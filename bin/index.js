/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js-compile/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js-compile/examples/AdvancedCard.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/AdvancedCard.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const RenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class AdvancedCard extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.rotatetxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.brush = new Graphics_1.Graphics();
            this.brush.beginFill(0xffffff);
            this.brush.drawCircle(0, 0, 50);
            this.brush.endFill();
            const background = new Sprite_1.Sprite(this.grasstxt);
            this.stage.addChild(background);
            background.width = this.sizew;
            background.height = this.sizeh;
            const imageToReveal = new Sprite_1.Sprite(this.rotatetxt);
            this.stage.addChild(imageToReveal);
            imageToReveal.width = this.sizew;
            imageToReveal.height = this.sizeh;
            this.renderTexture = RenderTexture_1.RenderTexture.create(this.sizew, this.sizeh);
            const renderTextureSprite = new Sprite_1.Sprite(this.renderTexture);
            this.stage.addChild(renderTextureSprite);
            imageToReveal.mask = renderTextureSprite;
            this.stage.interactive = true;
            this.dragging = false;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.pointerDown);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.pointerUp);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.pointerMove);
            this.exampleReady();
        };
        this.pointerMove = (event) => {
            if (this.dragging) {
                this.brush.position.copyFrom(event.data.global);
                this.app.renderer.render(this.brush, this.renderTexture, false, null, false);
            }
        };
        this.pointerDown = (event) => {
            this.dragging = true;
            this.pointerMove(event);
        };
        this.pointerUp = (event) => {
            this.dragging = false;
        };
        this.handleGrassLoaded = (event) => {
            this.grasstxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.stage.removeEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.pointerDown);
        this.stage.removeEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.pointerUp);
        this.stage.removeEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.pointerMove);
        this.brush.destroy(null);
        this.grasstxt.destroy(null);
    }
}
exports.AdvancedCard = AdvancedCard;


/***/ }),

/***/ "./js-compile/examples/AdvancedSlots.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/AdvancedSlots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const TextStyle_1 = __webpack_require__(/*! ../raw-pixi-ts/TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class AdvancedSlots extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleEggLoaded = (event) => {
            this.eggTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleFlowerLoaded);
            this.loader.load();
        };
        this.handleFlowerLoaded = (event) => {
            this.flowerTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/helmlok.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleHelmLoaded);
            this.loader.load();
        };
        this.handleHelmLoaded = (event) => {
            this.helmTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/skully.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleSkullLoaded);
            this.loader.load();
        };
        this.handleSkullLoaded = (event) => {
            this.skullTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const REEL_WIDTH = 160;
            this.SYMBOL_SIZE = 150;
            this.slotTextures = [
                this.eggTxt,
                this.flowerTxt,
                this.helmTxt,
                this.skullTxt,
            ];
            this.reels = [];
            const reelContainer = new Container_1.Container();
            for (let i = 0; i < 5; i++) {
                const rc = new Container_1.Container();
                rc.x = i * REEL_WIDTH;
                reelContainer.addChild(rc);
                const reel = {
                    container: rc,
                    symbols: [],
                    position: 0,
                    previousPosition: 0,
                    blur: new BlurFilter_1.BlurFilter(),
                };
                reel.blur.blurX = 0;
                reel.blur.blurY = 0;
                rc.filters = [reel.blur];
                for (let j = 0; j < 4; j++) {
                    const symbol = new Sprite_1.Sprite(this.slotTextures[Math.floor(Math.random() * this.slotTextures.length)]);
                    symbol.y = j * this.SYMBOL_SIZE;
                    symbol.scale.x = symbol.scale.y = Math.min(this.SYMBOL_SIZE / symbol.width, this.SYMBOL_SIZE / symbol.height);
                    symbol.x = Math.round((this.SYMBOL_SIZE - symbol.width) / 2);
                    reel.symbols.push(symbol);
                    rc.addChild(symbol);
                }
                this.reels.push(reel);
                this.stage.addChild(reelContainer);
                const margin = (this.sizeh - this.SYMBOL_SIZE * 3) / 2;
                reelContainer.y = margin;
                reelContainer.x = Math.round(this.sizew - REEL_WIDTH * 5);
                const top = new Graphics_1.Graphics();
                top.beginFill(0, 1);
                top.drawRect(0, 0, this.sizew, margin);
                const bottom = new Graphics_1.Graphics();
                bottom.beginFill(0, 1);
                bottom.drawRect(0, this.SYMBOL_SIZE * 3 + margin, this.sizew, margin);
                const style = new TextStyle_1.TextStyle({
                    fontFamily: 'Arial',
                    fontSize: 36,
                    fontStyle: 'italic',
                    fontWeight: 'bold',
                    fill: ['#ffffff', '#00ff99'],
                    stroke: '#4a1850',
                    strokeThickness: 5,
                    dropShadow: true,
                    dropShadowColor: '#000000',
                    dropShadowBlur: 4,
                    dropShadowAngle: Math.PI / 6,
                    dropShadowDistance: 6,
                    wordWrap: true,
                    wordWrapWidth: 440,
                });
                const playText = new Text_1.Text('Spin the wheels!', style);
                playText.x = Math.round((bottom.width - playText.width) / 2);
                playText.y = this.sizeh - margin + Math.round((margin - playText.height) / 2);
                bottom.addChild(playText);
                const headerText = new Text_1.Text('PIXI MONSTER SLOTS!', style);
                headerText.x = Math.round((top.width - headerText.width) / 2);
                headerText.y = Math.round((margin - headerText.height) / 2);
                top.addChild(headerText);
                this.stage.addChild(top);
                this.stage.addChild(bottom);
                bottom.interactive = true;
                bottom.buttonMode = true;
                bottom.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.startPlay);
                this.running = false;
            }
            this.app.ticker.add(this.runExample);
            this.app.ticker.add(this.tween);
            this.exampleReady();
        };
        this.startPlay = () => {
            if (this.running)
                return;
            this.running = true;
            for (let i = 0; i < this.reels.length; i++) {
                const r = this.reels[i];
                const extra = Math.floor(Math.random() * 3);
                const target = r.position + 10 + i * 5 + extra;
                const time = 2500 + i * 600 + extra * 600;
                this.tweenTo(r, 'position', target, time, this.backout(0.5), null, i === this.reels.length - 1 ? this.reelsComplete : null);
            }
        };
        this.reelsComplete = () => {
            this.running = false;
        };
        this.runExample = (delta) => {
            for (let i = 0; i < this.reels.length; i++) {
                const r = this.reels[i];
                r.blur.blurY = (r.position - r.previousPosition) * 8;
                r.previousPosition = r.position;
                for (let j = 0; j < r.symbols.length; j++) {
                    const s = r.symbols[j];
                    const prevy = s.y;
                    s.y = ((r.position + j) % r.symbols.length) * this.SYMBOL_SIZE - this.SYMBOL_SIZE;
                    if (s.y < 0 && prevy > this.SYMBOL_SIZE) {
                        s.texture = this.slotTextures[Math.floor(Math.random() * this.slotTextures.length)];
                        s.scale.x = s.scale.y = Math.min(this.SYMBOL_SIZE / s.texture.width, this.SYMBOL_SIZE / s.texture.height);
                        s.x = Math.round((this.SYMBOL_SIZE - s.width) / 2);
                    }
                }
            }
        };
        this.tween = (delta) => {
            const now = Date.now();
            const remove = [];
            for (let i = 0; i < this.tweening.length; i++) {
                const t = this.tweening[i];
                const phase = Math.min(1, (now - t.start) / t.time);
                t.object[t.property] = this.lerp(t.propertyBeginValue, t.target, t.easing(phase));
                if (t.change)
                    t.change(t);
                if (phase === 1) {
                    t.object[t.property] = t.target;
                    if (t.complete)
                        t.complete(t);
                    remove.push(t);
                }
            }
            for (let i = 0; i < remove.length; i++) {
                this.tweening.splice(this.tweening.indexOf(remove[i]), 1);
            }
        };
        this.tweening = [];
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/eggHead.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleEggLoaded);
        this.loader.load();
    }
    tweenTo(object, property, target, time, easing, onchange, oncomplete) {
        const tween = {
            object,
            property,
            propertyBeginValue: object[property],
            target,
            easing,
            time,
            change: onchange,
            complete: oncomplete,
            start: Date.now(),
        };
        this.tweening.push(tween);
        return tween;
    }
    lerp(a1, a2, t) {
        return a1 * (1 - t) + a2 * t;
    }
    backout(amount) {
        return t => (--t * t * ((amount + 1) * t + amount) + 1);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.app.ticker.remove(this.tween, null);
        this.eggTxt.destroy(null);
        this.flowerTxt.destroy(null);
        this.helmTxt.destroy(null);
        this.skullTxt.destroy(null);
        this.slotTextures = null;
        this.tweening = null;
    }
}
exports.AdvancedSlots = AdvancedSlots;


/***/ }),

/***/ "./js-compile/examples/AdvancedTrail.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/AdvancedTrail.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const BlendModesSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class AdvancedTrail extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.trailTexture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.historyX = [];
            this.historyY = [];
            this.historySize = 20;
            this.ropeSize = 100;
            this.points = [];
            for (let i = 0; i < this.historySize; i++) {
                this.historyX.push(0);
                this.historyY.push(0);
            }
            for (let i = 0; i < this.ropeSize; i++) {
                this.points.push(new Point_1.Point(0, 0));
            }
            const rope = new SimpleRope_1.SimpleRope(this.trailTexture, this.points);
            rope.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.ADD;
            this.stage.addChild(rope);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            const mouseposition = this.app.renderer.plugins.interaction.mouse.global;
            this.historyX.pop();
            this.historyX.unshift(mouseposition.x);
            this.historyY.pop();
            this.historyY.unshift(mouseposition.y);
            for (let i = 0; i < this.ropeSize; i++) {
                const p = this.points[i];
                const ix = this.cubicInterpolation(this.historyX, i / this.ropeSize * this.historySize);
                const iy = this.cubicInterpolation(this.historyY, i / this.ropeSize * this.historySize);
                p.x = ix;
                p.y = iy;
            }
        };
        this.backColor = 0x000378;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/trail.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    clipInput(k, arr) {
        if (k < 0)
            k = 0;
        if (k > arr.length - 1)
            k = arr.length - 1;
        return arr[k];
    }
    getTangent(k, factor, array) {
        return factor * (this.clipInput(k + 1, array) - this.clipInput(k - 1, array)) / 2;
    }
    cubicInterpolation(array, t, tangentFactor = 1) {
        const k = Math.floor(t);
        const m = [this.getTangent(k, tangentFactor, array), this.getTangent(k + 1, tangentFactor, array)];
        const p = [this.clipInput(k, array), this.clipInput(k + 1, array)];
        t -= k;
        const t2 = t * t;
        const t3 = t * t2;
        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
    }
    destructor() {
        super.destructor();
        this.points = null;
        this.historyY = null;
        this.historyX = null;
        this.app.ticker.remove(this.runExample, null);
        this.trailTexture.destroy(null);
    }
}
exports.AdvancedTrail = AdvancedTrail;


/***/ }),

/***/ "./js-compile/examples/AdvancedWarp.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/AdvancedWarp.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class AdvancedWarp extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.starTexture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.starAmount = 1000;
            this.cameraZ = 0;
            this.fov = 20;
            this.baseSpeed = 0.025;
            this.speed = 0;
            this.warpSpeed = 0;
            this.starStretch = 5;
            this.starBaseSize = 0.05;
            this.stars = [];
            for (let i = 0; i < this.starAmount; i++) {
                const star = {
                    sprite: new Sprite_1.Sprite(this.starTexture),
                    z: 0,
                    x: 0,
                    y: 0,
                };
                star.sprite.anchor.x = 0.5;
                star.sprite.anchor.y = 0.7;
                this.randomizeStar(star, true);
                this.stage.addChild(star.sprite);
                this.stars.push(star);
            }
            setInterval(() => {
                this.warpSpeed = this.warpSpeed > 0 ? 0 : 1;
            }, 5000);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.speed += (this.warpSpeed - this.speed) / 20;
            this.cameraZ += delta * 10 * (this.speed + this.baseSpeed);
            for (let i = 0; i < this.starAmount; i++) {
                const star = this.stars[i];
                if (star.z < this.cameraZ)
                    this.randomizeStar(star);
                const z = star.z - this.cameraZ;
                star.sprite.x = star.x * (this.fov / z) * this.sizew + this.sizew / 2;
                star.sprite.y = star.y * (this.fov / z) * this.sizew + this.sizeh / 2;
                const dxCenter = star.sprite.x - this.sizew / 2;
                const dyCenter = star.sprite.y - this.sizeh / 2;
                const distanceCenter = Math.sqrt(dxCenter * dxCenter + dyCenter + dyCenter);
                const distanceScale = Math.max(0, (2000 - z) / 2000);
                star.sprite.scale.x = distanceScale * this.starBaseSize;
                star.sprite.scale.y = distanceScale * this.starBaseSize + distanceScale * this.speed * this.starStretch * distanceCenter / this.sizew;
                star.sprite.rotation = Math.atan2(dyCenter, dxCenter) + Math.PI / 2;
            }
        };
        this.backColor = 0x000000;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/star.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    randomizeStar(star, initial = true) {
        star.z = initial ? Math.random() * 2000 : this.cameraZ + Math.random() * 1000 + 2000;
        const deg = Math.random() * Math.PI * 2;
        const distance = Math.random() * 50 + 1;
        star.x = Math.cos(deg) * distance;
        star.y = Math.sin(deg) * distance;
    }
    destructor() {
        super.destructor();
        this.stars = null;
        this.app.ticker.remove(this.runExample, null);
        this.starTexture.destroy(null);
    }
}
exports.AdvancedWarp = AdvancedWarp;


/***/ }),

/***/ "./js-compile/examples/BaseExample.js":
/*!********************************************!*\
  !*** ./js-compile/examples/BaseExample.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const EventDispatcher_1 = __webpack_require__(/*! ../raw-pixi-ts/EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class BaseExample extends EventDispatcher_1.EventDispatcher {
    constructor(app, width = 100, height = 100) {
        super();
        this.backColor = 0x969696;
        this.sizew = width;
        this.sizeh = height;
        this.app = app;
        this.stage = new Container_1.Container();
    }
    activateMask() {
        this.stageMask = new Graphics_1.Graphics();
        this.stageMask.beginFill(0);
        this.stageMask.drawRect(0, 0, this.sizew, this.sizeh);
        this.stage.mask = this.stageMask;
    }
    destructor() {
        this.stage.removeChildren();
        if (this.stageMask) {
            this.stageMask.destroy(null);
        }
    }
    exampleReady() {
        this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
    }
}
exports.BaseExample = BaseExample;


/***/ }),

/***/ "./js-compile/examples/BasicBlend.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/BasicBlend.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const BlendModesSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class BasicBlend extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(txt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleFlowerLoaded);
            this.loader.load();
        };
        this.handleFlowerLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.dudeArray = [];
            const totaldudes = 20;
            for (let i = 0; i < totaldudes; i++) {
                const dude = new ExtendedSprite(txt);
                dude.anchor.set(0.5);
                dude.scale.set(0.8 + Math.random() * 0.3);
                dude.x = Math.floor(Math.random() * this.sizew);
                dude.y = Math.floor(Math.random() * this.sizeh);
                dude.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.ADD;
                dude.direction = Math.random() * Math.PI * 2;
                dude.turningSpeed = Math.random() - 0.8;
                dude.speed = 2 + Math.random() * 2;
                this.dudeArray.push(dude);
                this.stage.addChild(dude);
            }
            const dudeBoundsPadding = 100;
            this.dudeBounds = new Rectangle_1.Rectangle(-dudeBoundsPadding, -dudeBoundsPadding, this.sizew + dudeBoundsPadding * 2, this.sizeh + dudeBoundsPadding * 2);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            for (let i = 0; i < this.dudeArray.length; i++) {
                const dude = this.dudeArray[i];
                dude.direction += dude.turningSpeed * 0.01;
                dude.x += Math.sin(dude.direction) * dude.speed;
                dude.y += Math.cos(dude.direction) * dude.speed;
                dude.rotation = -dude.direction - Math.PI / 2;
                if (dude.x < this.dudeBounds.x) {
                    dude.x += this.dudeBounds.width;
                }
                else if (dude.x > this.dudeBounds.x + this.dudeBounds.width) {
                    dude.x -= this.dudeBounds.width;
                }
                if (dude.y < this.dudeBounds.y) {
                    dude.y += this.dudeBounds.height;
                }
                else if (dude.y > this.dudeBounds.y + this.dudeBounds.height) {
                    dude.y -= this.dudeBounds.height;
                }
            }
        };
        this.backColor = 0xFFFFFF;
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/eggHead.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.dudeArray = null;
    }
}
exports.BasicBlend = BasicBlend;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/BasicContainer.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/BasicContainer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class BasicContainer extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            for (let i = 0; i < 25; i++) {
                const bunny = new Sprite_1.Sprite(txt);
                bunny.anchor.set(0.5);
                bunny.x = (i % 5) * 40;
                bunny.y = Math.floor(i / 5) * 40;
                this.container.addChild(bunny);
            }
            this.container.x = this.sizew / 2;
            this.container.y = this.sizeh / 2;
            this.container.pivot.x = this.container.width / 2;
            this.container.pivot.y = this.container.height / 2;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.container.rotation -= 0.01 * delta;
        };
        this.container = new Container_1.Container();
        this.stage.addChild(this.container);
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.container.destroy(null);
        this.container = null;
    }
}
exports.BasicContainer = BasicContainer;


/***/ }),

/***/ "./js-compile/examples/BasicParticles.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/BasicParticles.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ParticleContainer_1 = __webpack_require__(/*! ../raw-pixi-ts/ParticleContainer */ "./js-compile/raw-pixi-ts/ParticleContainer.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class BasicParticles extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const sprites = new ParticleContainer_1.ParticleContainer(10000, { scale: true, position: true, rotation: true, uvs: true, alpha: true, });
            this.stage.addChild(sprites);
            this.maggots = [];
            const totalSprites = 10000;
            for (let i = 0; i < totalSprites; i++) {
                const dude = new ExtendedSprite(txt);
                dude.tint = Math.random() * 0xE8D4CD;
                dude.anchor.set(0.5);
                dude.scale.set(0.8 + Math.random() * 0.3);
                dude.x = Math.random() * this.sizew;
                dude.y = Math.random() * this.sizeh;
                dude.tint = Math.random() * 0x808080;
                dude.direction = Math.random() * Math.PI * 2;
                dude.turningSpeed = Math.random() - 0.8;
                dude.speed = (2 + Math.random() * 2) * 0.2;
                dude.offset = Math.random() * 100;
                this.maggots.push(dude);
                sprites.addChild(dude);
            }
            const dudeBoundsPadding = 100;
            this.dudeBounds = new Rectangle_1.Rectangle(-dudeBoundsPadding, -dudeBoundsPadding, this.sizew + dudeBoundsPadding * 2, this.sizeh + dudeBoundsPadding * 2);
            this.tick = 0;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            for (let i = 0; i < this.maggots.length; i++) {
                const dude = this.maggots[i];
                dude.scale.y = 0.95 + Math.sin(this.tick + dude.offset) * 0.05;
                dude.direction += dude.turningSpeed * 0.01;
                dude.x += Math.sin(dude.direction) * (dude.speed * dude.scale.y);
                dude.y += Math.cos(dude.direction) * (dude.speed * dude.scale.y);
                dude.rotation = -dude.direction + Math.PI;
                if (dude.x < this.dudeBounds.x) {
                    dude.x += this.dudeBounds.width;
                }
                else if (dude.x > this.dudeBounds.x + this.dudeBounds.width) {
                    dude.x -= this.dudeBounds.width;
                }
                if (dude.y < this.dudeBounds.y) {
                    dude.y += this.dudeBounds.height;
                }
                else if (dude.y > this.dudeBounds.y + this.dudeBounds.height) {
                    dude.y -= this.dudeBounds.height;
                }
            }
            this.tick += 0.1;
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/maggot_tiny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.maggots = null;
    }
}
exports.BasicParticles = BasicParticles;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/BasicTinting.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/BasicTinting.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class BasicTinting extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.aliens = [];
            const totalDudes = 20;
            for (let i = 0; i < totalDudes; i++) {
                const dude = new ExtendedSprite(txt);
                dude.anchor.set(0.5);
                dude.scale.set(0.8 + Math.random() * 0.3);
                dude.x = Math.random() * this.sizew;
                dude.y = Math.random() * this.sizeh;
                dude.tint = Math.random() * 0xFFFFFF;
                dude.direction = Math.random() * Math.PI * 2;
                dude.turningSpeed = Math.random() - 0.8;
                dude.speed = 2 + Math.random() * 2;
                this.aliens.push(dude);
                this.stage.addChild(dude);
            }
            const dudeBoundsPadding = 100;
            this.dudeBounds = new Rectangle_1.Rectangle(-dudeBoundsPadding, -dudeBoundsPadding, this.sizew + dudeBoundsPadding * 2, this.sizeh + dudeBoundsPadding * 2);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            for (let i = 0; i < this.aliens.length; i++) {
                const dude = this.aliens[i];
                dude.direction += dude.turningSpeed * 0.01;
                dude.x += Math.sin(dude.direction) * dude.speed;
                dude.y += Math.cos(dude.direction) * dude.speed;
                dude.rotation = -dude.direction - Math.PI / 2;
                if (dude.x < this.dudeBounds.x) {
                    dude.x += this.dudeBounds.width;
                }
                else if (dude.x > this.dudeBounds.x + this.dudeBounds.width) {
                    dude.x -= this.dudeBounds.width;
                }
                if (dude.y < this.dudeBounds.y) {
                    dude.y += this.dudeBounds.height;
                }
                else if (dude.y > this.dudeBounds.y + this.dudeBounds.height) {
                    dude.y -= this.dudeBounds.height;
                }
            }
        };
        this.backColor = 0xFFF000;
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/eggHead.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.aliens = null;
    }
}
exports.BasicTinting = BasicTinting;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/FilterBlending.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/FilterBlending.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
class FilterBlending extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.backgroundtxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(this.backgroundtxt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            const shaderFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 mouse;
            uniform vec4 inputSize;
            uniform vec4 outputFrame;
            uniform float time;
            void main() {
            vec2 screenPos = vTextureCoord * inputSize.xy + outputFrame.xy;
            if (length(mouse - screenPos) < 25.0) {
                gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0) * 0.7; //yellow circle, alpha=0.7
            } else {
                gl_FragColor = vec4( sin(time), (mouse.xy - outputFrame.xy) / outputFrame.zw, 1.0) * 0.5; // blend with underlying image, alpha=0.5
            }
            }
            `;
            const container = new Container_1.Container();
            container.filterArea = new Rectangle_1.Rectangle(100, 100, this.sizew - 200, this.sizeh - 200);
            this.stage.addChild(container);
            this.filter = new Filter_1.Filter(null, shaderFrag, {
                mouse: new Point_1.Point()
            });
            container.filters = [this.filter];
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.filter.uniforms.mouse.copyFrom(this.app.renderer.plugins.interaction.mouse.global);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.backgroundtxt.destroy(null);
        this.backgroundtxt = null;
        this.filter.destroy();
        this.filter = null;
        this.app.ticker.remove(this.runExample, null);
    }
}
exports.FilterBlending = FilterBlending;


/***/ }),

/***/ "./js-compile/examples/FilterBlur.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/FilterBlur.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
class FilterBlur extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleMobyLoaded = (event) => {
            this.mobyTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const bg = new Sprite_1.Sprite(this.depthTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            this.stage.addChild(bg);
            const littleDudes = new Sprite_1.Sprite(this.dudesTxt);
            littleDudes.x = (this.sizew / 2) - 315;
            littleDudes.y = 200;
            this.stage.addChild(littleDudes);
            const littleRobot = new Sprite_1.Sprite(this.mobyTxt);
            littleRobot.x = (this.sizew / 2) - 200;
            littleRobot.y = 100;
            this.stage.addChild(littleRobot);
            this.blurFilter1 = new BlurFilter_1.BlurFilter();
            this.blurFilter2 = new BlurFilter_1.BlurFilter();
            littleDudes.filters = [this.blurFilter1];
            littleRobot.filters = [this.blurFilter2];
            this.count = 0;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.count += 0.005;
            const blurAmount = Math.cos(this.count);
            const blurAmount2 = Math.sin(this.count);
            this.blurFilter1.blur = 20 * (blurAmount);
            this.blurFilter2.blur = 20 * (blurAmount2);
        };
        this.handleDudesLoaded = (event) => {
            this.dudesTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/depth_blur_moby.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleMobyLoaded);
            this.loader.load();
        };
        this.handleDepthLoaded = (event) => {
            this.depthTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/depth_blur_dudes.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDudesLoaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/bg_depth_blur.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDepthLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.blurFilter1.destroy();
        this.blurFilter1 = null;
        this.blurFilter2.destroy();
        this.blurFilter2 = null;
        this.mobyTxt.destroy(null);
        this.mobyTxt = null;
        this.dudesTxt.destroy(null);
        this.dudesTxt = null;
        this.depthTxt.destroy(null);
        this.depthTxt = null;
    }
}
exports.FilterBlur = FilterBlur;


/***/ }),

/***/ "./js-compile/examples/FilterColor.js":
/*!********************************************!*\
  !*** ./js-compile/examples/FilterColor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const ColorMatrixFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/ColorMatrixFilter */ "./js-compile/raw-pixi-ts/ColorMatrixFilter.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class FilterColor extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePandaLoaded = (event) => {
            this.pandaTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bg = new Sprite_1.Sprite(this.rotateTxt);
            this.bg.anchor.set(0.5);
            this.bg.x = this.sizew / 2;
            this.bg.y = this.sizeh / 2;
            this.filter = new ColorMatrixFilter_1.ColorMatrixFilter();
            const container = new Container_1.Container();
            container.x = this.sizew / 2;
            container.y = this.sizeh / 2;
            this.bgFront = new Sprite_1.Sprite(this.scenerotateTxt);
            this.bgFront.anchor.set(0.5);
            container.addChild(this.bgFront);
            this.light2 = new Sprite_1.Sprite(this.lightrotate2Txt);
            this.light2.anchor.set(0.5);
            container.addChild(this.light2);
            this.light1 = new Sprite_1.Sprite(this.lightrotate1Txt);
            this.light1.anchor.set(0.5);
            container.addChild(this.light1);
            this.panda = new Sprite_1.Sprite(this.pandaTxt);
            this.panda.anchor.set(0.5);
            container.addChild(this.panda);
            this.stage.addChild(container);
            this.stage.filters = [this.filter];
            this.count = 0;
            this.enabled = true;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handlePointer);
            const help = new Text_1.Text('Click or tap to turn filters on / off.', {
                fontFamily: 'Arial',
                fontSize: 12,
                fontWeight: 'bold',
                fill: 'white',
            });
            help.y = this.sizeh - 25;
            help.x = 10;
            this.stage.addChild(help);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bg.rotation += 0.01;
            this.bgFront.rotation -= 0.01;
            this.light1.rotation += 0.02;
            this.light2.rotation += 0.01;
            this.panda.scale.x = 1 + Math.sin(this.count) * 0.04;
            this.panda.scale.y = 1 + Math.cos(this.count) * 0.04;
            this.count += 0.1;
            const { matrix } = this.filter;
            matrix[1] = Math.sin(this.count) * 3;
            matrix[2] = Math.cos(this.count);
            matrix[3] = Math.cos(this.count) * 1.5;
            matrix[4] = Math.sin(this.count / 3) * 2;
            matrix[5] = Math.sin(this.count / 2);
            matrix[6] = Math.sin(this.count / 4);
        };
        this.handlePointer = (event) => {
            this.enabled = !this.enabled;
            this.stage.filters = this.enabled ? [this.filter] : null;
        };
        this.handleLightRotate1Loaded = (event) => {
            this.lightrotate1Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_1.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate1Loaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.rotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleSceneRotateLoaded);
            this.loader.load();
        };
        this.handleSceneRotateLoaded = (event) => {
            this.scenerotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_2.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate2Loaded);
            this.loader.load();
        };
        this.handleLightRotate2Loaded = (event) => {
            this.lightrotate2Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/panda.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePandaLoaded);
            this.loader.load();
        };
        this.backColor = 0;
        this.activateMask();
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.bg.destroy(null);
        this.bg = null;
        this.bgFront.destroy(null);
        this.bgFront = null;
        this.light2.destroy(null);
        this.light2 = null;
        this.panda.destroy(null);
        this.panda = null;
        this.light1.destroy(null);
        this.light1 = null;
        this.filter.destroy();
        this.filter = null;
        this.app.ticker.remove(this.runExample, null);
        this.rotateTxt.destroy(null);
        this.rotateTxt = null;
        this.scenerotateTxt.destroy(null);
        this.scenerotateTxt = null;
        this.lightrotate2Txt.destroy(null);
        this.lightrotate2Txt = null;
        this.lightrotate1Txt.destroy(null);
        this.lightrotate1Txt = null;
        this.pandaTxt.destroy(null);
        this.pandaTxt = null;
    }
}
exports.FilterColor = FilterColor;


/***/ }),

/***/ "./js-compile/examples/FilterCrawlies.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/FilterCrawlies.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const DisplacementFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplacementFilter */ "./js-compile/raw-pixi-ts/DisplacementFilter.js");
class FilterCrawlies extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.grassTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.container = new Container_1.Container();
            this.stage.addChild(this.container);
            const padding = 100;
            this.bounds = new Rectangle_1.Rectangle(-padding, -padding, this.sizew + padding * 2, this.sizeh + padding * 2);
            for (let i = 0; i < 20; i++) {
                const maggot = new ExtendedSprite(this.maggotTxt);
                maggot.anchor.set(0.5);
                this.container.addChild(maggot);
                maggot.direction = Math.random() * Math.PI * 2;
                maggot.speed = 1;
                maggot.turnSpeed = Math.random() - 0.8;
                maggot.x = Math.random() * this.bounds.width;
                maggot.y = Math.random() * this.bounds.height;
                maggot.scale.set(1 + Math.random() * 0.3);
                maggot.original = new Point_1.Point();
                maggot.original.copyFrom(maggot.scale);
                this.maggots.push(maggot);
            }
            this.displacementSprite = new Sprite_1.Sprite(this.displacementTxt);
            const displacementFilter = new DisplacementFilter_1.DisplacementFilter(this.displacementSprite);
            this.stage.addChild(this.displacementSprite);
            this.container.filters = [displacementFilter];
            displacementFilter.scale.x = 110;
            displacementFilter.scale.y = 110;
            this.displacementSprite.anchor.set(0.5);
            this.ring = new Sprite_1.Sprite(this.ringTxt);
            this.ring.anchor.set(0.5);
            this.ring.visible = false;
            this.stage.addChild(this.ring);
            const bg = new Sprite_1.Sprite(this.grassTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            bg.alpha = 0.4;
            this.container.addChild(bg);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.MOUSE_MOVE, this.onPointerMove);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.TOUCH_MOVE, this.onPointerMove);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.handleMaggotLoaded = (event) => {
            this.maggotTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/bg_grass.jpg'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
            this.loader.load();
        };
        this.handleRingLoaded = (event) => {
            this.ringTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/maggot.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleMaggotLoaded);
            this.loader.load();
        };
        this.handleDisplacementLoaded = (event) => {
            this.displacementTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/ring.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRingLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.maggotTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/displace.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDisplacementLoaded);
            this.loader.load();
        };
        this.onPointerMove = (event) => {
            this.ring.visible = true;
            this.displacementSprite.position.set(event.data.global.x - 25, event.data.global.y);
            this.ring.position.copyFrom(this.displacementSprite.position);
        };
        this.runExample = (delta) => {
            this.count += 0.05;
            for (let i = 0; i < this.maggots.length; i++) {
                const maggot = this.maggots[i];
                maggot.direction += maggot.turnSpeed * 0.01;
                maggot.x += Math.sin(maggot.direction) * maggot.speed;
                maggot.y += Math.cos(maggot.direction) * maggot.speed;
                maggot.rotation = -maggot.direction - Math.PI / 2;
                maggot.scale.x = maggot.original.x + Math.sin(this.count) * 0.2;
                if (maggot.x < this.bounds.x) {
                    maggot.x += this.bounds.width;
                }
                else if (maggot.x > this.bounds.x + this.bounds.width) {
                    maggot.x -= this.bounds.width;
                }
                if (maggot.y < this.bounds.y) {
                    maggot.y += this.bounds.height;
                }
                else if (maggot.y > this.bounds.y + this.bounds.height) {
                    maggot.y -= this.bounds.height;
                }
            }
        };
        this.activateMask();
        this.count = 0;
        this.maggots = [];
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.maggotTxt.destroy(null);
        this.maggotTxt = null;
        this.displacementTxt.destroy(null);
        this.displacementTxt = null;
        this.ringTxt.destroy(null);
        this.ringTxt = null;
        this.grassTxt.destroy(null);
        this.grassTxt = null;
        this.maggots = null;
        this.ring.destroy(null);
        this.ring = null;
        this.app.ticker.remove(this.runExample, null);
        this.displacementSprite.destroy(null);
        this.displacementSprite = null;
        this.container.destroy(null);
        this.container = null;
    }
}
exports.FilterCrawlies = FilterCrawlies;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/FilterCustom.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/FilterCustom.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
class FilterCustom extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.grasstxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.background = new Sprite_1.Sprite(this.grasstxt);
            this.background.width = this.sizew;
            this.background.height = this.sizeh;
            this.stage.addChild(this.background);
            this.urlloader = new URLLoader_1.URLLoader();
            this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleFragLoaded);
            this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/pixi-filters/shader.frag"));
        };
        this.handleFragLoaded = (event) => {
            let fragdata = this.urlloader.data;
            this.filter = new Filter_1.Filter(null, fragdata, {
                customUniform: 0.0
            });
            this.background.filters = [this.filter];
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.filter.uniforms.customUniform += 0.04 * delta;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.grasstxt.destroy(null);
        this.grasstxt = null;
        this.background.destroy(null);
        this.background = null;
        this.filter.destroy();
        this.filter = null;
    }
}
exports.FilterCustom = FilterCustom;


/***/ }),

/***/ "./js-compile/examples/FilterFlag.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/FilterFlag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const DisplacementFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplacementFilter */ "./js-compile/raw-pixi-ts/DisplacementFilter.js");
class FilterFlag extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleDisplacementLoaded = (event) => {
            this.repeatTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const container = new Container_1.Container();
            this.stage.addChild(container);
            const flag = new Sprite_1.Sprite(this.flagTxt);
            container.addChild(flag);
            flag.x = 100;
            flag.y = 100;
            this.displacementSprite = new Sprite_1.Sprite(this.repeatTxt);
            this.displacementSprite.texture.baseTexture.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.REPEAT;
            const displacementFilter = new DisplacementFilter_1.DisplacementFilter(this.displacementSprite);
            displacementFilter.padding = 10;
            this.displacementSprite.position = flag.position;
            this.stage.addChild(this.displacementSprite);
            flag.filters = [displacementFilter];
            displacementFilter.scale.x = 30;
            displacementFilter.scale.y = 60;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.displacementSprite.x++;
            if (this.displacementSprite.x > this.displacementSprite.width) {
                this.displacementSprite.x = 0;
            }
        };
        this.handleRotateLoaded = (event) => {
            this.flagTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/displacement_map_repeat.jpg'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDisplacementLoaded);
            this.loader.load();
        };
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/flag.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.flagTxt.destroy(null);
        this.flagTxt = null;
        this.repeatTxt.destroy(null);
        this.repeatTxt = null;
        this.displacementSprite.destroy(null);
        this.displacementSprite = null;
        this.app.ticker.remove(this.runExample, null);
    }
}
exports.FilterFlag = FilterFlag;


/***/ }),

/***/ "./js-compile/examples/FilterShadow.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/FilterShadow.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
class FilterShadow extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (textures) => {
            this.stage.interactive = true;
            const frames = [];
            for (let i = 0; i < 30; i++) {
                const val = i < 10 ? `0${i}` : i;
                frames.push(textures[`rollSequence00${val}.png`]);
            }
            this.anim = new AnimatedSprite_1.AnimatedSprite(frames);
            this.anim.x = this.sizew / 2;
            this.anim.y = this.sizeh / 2;
            this.anim.anchor.set(0.5);
            this.anim.animationSpeed = 0.5;
            this.anim.play();
            this.stage.addChild(this.anim);
            this.filter = new Filter_1.Filter(FilterShadow.myVertex, FilterShadow.myFragment);
            this.filter.uniforms.shadowDirection = [0.1, 0.5];
            this.filter.uniforms.floorY = this.anim.height * 2;
            this.filter.padding = 200;
            this.anim.filters = [this.filter];
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.filter.uniforms.floorY = this.app.renderer.plugins.interaction.mouse.global.y;
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            let spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            spritesheet.parse(this.onAnimationParsed);
        };
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.json"));
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.txt.destroy(null);
        this.txt = null;
        this.anim.destroy(null);
        this.anim = null;
        this.filter.destroy();
        this.filter = null;
        this.jsondata = null;
    }
}
FilterShadow.myVertex = `
        attribute vec2 aVertexPosition;
        attribute vec2 aTextureCoord;
        uniform mat3 projectionMatrix;
        varying vec2 vTextureCoord;
        void main(void) {
            gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            vTextureCoord = aTextureCoord;
        }
    `;
FilterShadow.myFragment = `
        varying vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform vec4 inputSize;
        uniform vec4 outputFrame;
        uniform vec2 shadowDirection;
        uniform float floorY;
        void main(void) {
            //1. get the screen coordinate
            vec2 screenCoord = vTextureCoord * inputSize.xy + outputFrame.xy;
            //2. calculate Y shift of our dimension vector
            vec2 shadow;
            //shadow coordinate system is a bit skewed, but it has to be the same for screenCoord.y = floorY
            float paramY = (screenCoord.y - floorY) / shadowDirection.y;
            shadow.y = paramY + floorY;
            shadow.x = screenCoord.x + paramY * shadowDirection.x;
            vec2 bodyFilterCoord = (shadow - outputFrame.xy) * inputSize.zw; // same as / inputSize.xy
            vec4 originalColor = texture2D(uSampler, vTextureCoord);
            vec4 shadowColor = texture2D(uSampler, bodyFilterCoord);
            shadowColor.rgb = vec3(0.0);
            shadowColor.a *= 0.5;
            // normal blend mode coefficients (1, 1-src_alpha)
            // shadow is destination (backdrop), original is source
            gl_FragColor = originalColor + shadowColor * (1.0 - originalColor.a);
        }
    `;
exports.FilterShadow = FilterShadow;


/***/ }),

/***/ "./js-compile/examples/GraphicsAdvanced.js":
/*!*************************************************!*\
  !*** ./js-compile/examples/GraphicsAdvanced.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
class GraphicsAdvanced extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const sprite = new Sprite_1.Sprite(txt);
            const realPath = new Graphics_1.Graphics();
            realPath.lineStyle(2, 0xFFFFFF, 1);
            realPath.moveTo(0, 0);
            realPath.lineTo(100, 200);
            realPath.lineTo(200, 200);
            realPath.lineTo(240, 100);
            realPath.position.x = 50;
            realPath.position.y = 50;
            this.stage.addChild(realPath);
            const bezier = new Graphics_1.Graphics();
            bezier.lineStyle(5, 0xAA0000, 1);
            bezier.bezierCurveTo(100, 200, 200, 200, 240, 100);
            bezier.position.x = 50;
            bezier.position.y = 50;
            this.stage.addChild(bezier);
            const realPath2 = new Graphics_1.Graphics();
            realPath2.lineStyle(2, 0xFFFFFF, 1);
            realPath2.moveTo(0, 0);
            realPath2.lineTo(0, -100);
            realPath2.lineTo(150, 150);
            realPath2.lineTo(240, 100);
            realPath2.position.x = 320;
            realPath2.position.y = 150;
            this.stage.addChild(realPath2);
            const bezier2 = new Graphics_1.Graphics();
            bezier2.lineTextureStyle(10, sprite.texture);
            bezier2.bezierCurveTo(0, -100, 150, 150, 240, 100);
            bezier2.position.x = 320;
            bezier2.position.y = 150;
            this.stage.addChild(bezier2);
            const arc = new Graphics_1.Graphics();
            arc.lineStyle(5, 0xAA00BB, 1);
            arc.arc(600, 100, 50, Math.PI, 2 * Math.PI);
            this.stage.addChild(arc);
            const arc2 = new Graphics_1.Graphics();
            arc2.lineStyle(6, 0x3333DD, 1);
            arc2.arc(650, 270, 60, 2 * Math.PI, 3 * Math.PI / 2);
            this.stage.addChild(arc2);
            const arc3 = new Graphics_1.Graphics();
            arc3.lineTextureStyle(20, sprite.texture);
            arc3.arc(650, 420, 60, 2 * Math.PI, 2.5 * Math.PI / 2);
            this.stage.addChild(arc3);
            const rectAndHole = new Graphics_1.Graphics();
            rectAndHole.beginFill(0x00FF00);
            rectAndHole.drawRect(350, 350, 150, 150);
            rectAndHole.beginHole();
            rectAndHole.drawCircle(375, 375, 25);
            rectAndHole.drawCircle(425, 425, 25);
            rectAndHole.drawCircle(475, 475, 25);
            rectAndHole.endHole();
            rectAndHole.endFill();
            this.stage.addChild(rectAndHole);
            const beatifulRect = new Graphics_1.Graphics();
            beatifulRect.lineTextureStyle(20, sprite.texture);
            beatifulRect.beginFill(0xFF0000);
            beatifulRect.drawRect(80, 350, 150, 150);
            beatifulRect.endFill();
            this.stage.addChild(beatifulRect);
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
}
exports.GraphicsAdvanced = GraphicsAdvanced;


/***/ }),

/***/ "./js-compile/examples/GraphicsDynamic.js":
/*!************************************************!*\
  !*** ./js-compile/examples/GraphicsDynamic.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class GraphicsDynamic extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            this.thing.clear();
            this.thing.lineStyle(10, 0xff0000, 1);
            this.thing.beginFill(0xffFF00, 0.5);
            this.thing.moveTo(-120 + Math.sin(this.count) * 20, -100 + Math.cos(this.count) * 20);
            this.thing.lineTo(120 + Math.cos(this.count) * 20, -100 + Math.sin(this.count) * 20);
            this.thing.lineTo(120 + Math.sin(this.count) * 20, 100 + Math.cos(this.count) * 20);
            this.thing.lineTo(-120 + Math.cos(this.count) * 20, 100 + Math.sin(this.count) * 20);
            this.thing.lineTo(-120 + Math.sin(this.count) * 20, -100 + Math.cos(this.count) * 20);
            this.thing.rotation = this.count * 0.1;
        };
        this.onPointerDown = () => {
            this.graphics.lineStyle(Math.random() * 30, Math.random() * 0xFFFFFF, 1);
            this.graphics.moveTo(Math.random() * 800, Math.random() * 600);
            this.graphics.bezierCurveTo(Math.random() * 800, Math.random() * 600, Math.random() * 800, Math.random() * 600, Math.random() * 800, Math.random() * 600);
        };
        app.stage.interactive = true;
        this.graphics = new Graphics_1.Graphics();
        this.graphics.beginFill(0xFF3300);
        this.graphics.lineStyle(10, 0xffd900, 1);
        this.graphics.moveTo(50, 50);
        this.graphics.lineTo(250, 50);
        this.graphics.lineTo(100, 100);
        this.graphics.lineTo(250, 220);
        this.graphics.lineTo(50, 220);
        this.graphics.lineTo(50, 50);
        this.graphics.endFill();
        this.graphics.lineStyle(10, 0xFF0000, 0.8);
        this.graphics.beginFill(0xFF700B, 1);
        this.graphics.moveTo(210, 300);
        this.graphics.lineTo(450, 320);
        this.graphics.lineTo(570, 350);
        this.graphics.quadraticCurveTo(600, 0, 480, 100);
        this.graphics.lineTo(330, 120);
        this.graphics.lineTo(410, 200);
        this.graphics.lineTo(210, 300);
        this.graphics.endFill();
        this.graphics.lineStyle(2, 0x0000FF, 1);
        this.graphics.drawRect(50, 250, 100, 100);
        this.graphics.lineStyle(0);
        this.graphics.beginFill(0xFFFF0B, 0.5);
        this.graphics.drawCircle(470, 200, 100);
        this.graphics.endFill();
        this.graphics.lineStyle(20, 0x33FF00);
        this.graphics.moveTo(30, 30);
        this.graphics.lineTo(600, 300);
        this.stage.addChild(this.graphics);
        this.thing = new Graphics_1.Graphics();
        this.stage.addChild(this.thing);
        this.thing.x = 800 / 2;
        this.thing.y = 600 / 2;
        this.count = 0;
        app.ticker.add(this.runExample);
        this.stage.interactive = true;
        this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onPointerDown);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.graphics.destroy(null);
        this.graphics = null;
        this.thing.destroy(null);
        this.thing = null;
    }
}
exports.GraphicsDynamic = GraphicsDynamic;


/***/ }),

/***/ "./js-compile/examples/GraphicsSimple.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/GraphicsSimple.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
class GraphicsSimple extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.backColor = 0;
        const graphics = new Graphics_1.Graphics();
        graphics.beginFill(0xDE3249);
        graphics.drawRect(50, 50, 100, 100);
        graphics.endFill();
        graphics.lineStyle(2, 0xFEEB77, 1);
        graphics.beginFill(0x650A5A);
        graphics.drawRect(200, 50, 100, 100);
        graphics.endFill();
        graphics.lineStyle(10, 0xFFBD01, 1);
        graphics.beginFill(0xC34288);
        graphics.drawRect(350, 50, 100, 100);
        graphics.endFill();
        graphics.lineStyle(2, 0xFFFFFF, 1);
        graphics.beginFill(0xAA4F08);
        graphics.drawRect(530, 50, 140, 100);
        graphics.endFill();
        graphics.lineStyle(0); // draw a circle, set the lineStyle to zero so the circle doesn't have an outline
        graphics.beginFill(0xDE3249, 1);
        graphics.drawCircle(100, 250, 50);
        graphics.endFill();
        graphics.lineStyle(2, 0xFEEB77, 1);
        graphics.beginFill(0x650A5A, 1);
        graphics.drawCircle(250, 250, 50);
        graphics.endFill();
        graphics.lineStyle(10, 0xFFBD01, 1);
        graphics.beginFill(0xC34288, 1);
        graphics.drawCircle(400, 250, 50);
        graphics.endFill();
        graphics.lineStyle(2, 0xFFFFFF, 1);
        graphics.beginFill(0xAA4F08, 1);
        graphics.drawEllipse(600, 250, 80, 50);
        graphics.endFill();
        graphics.beginFill(0xFF3300);
        graphics.lineStyle(4, 0xffd900, 1);
        graphics.moveTo(50, 350);
        graphics.lineTo(250, 350);
        graphics.lineTo(100, 400);
        graphics.lineTo(50, 350);
        graphics.endFill();
        graphics.lineStyle(2, 0xFF00FF, 1);
        graphics.beginFill(0x650A5A, 0.25);
        graphics.drawRoundedRect(50, 440, 100, 100, 16);
        graphics.endFill();
        graphics.lineStyle(2, 0xFFFFFF);
        graphics.beginFill(0x35CC5A, 1);
        graphics.drawStar(360, 370, 5, 50);
        graphics.endFill();
        graphics.lineStyle(2, 0xFFFFFF);
        graphics.beginFill(0xFFCC5A, 1);
        graphics.drawStar(280, 510, 7, 50);
        graphics.endFill();
        graphics.lineStyle(4, 0xFFFFFF);
        graphics.beginFill(0x55335A, 1);
        graphics.drawStar(470, 450, 4, 50);
        graphics.endFill();
        const path = [600, 370, 700, 460, 780, 420, 730, 570, 590, 520];
        graphics.lineStyle(0);
        graphics.beginFill(0x3500FA, 1);
        graphics.drawPolygon(path);
        graphics.endFill();
        this.stage.addChild(graphics);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
}
exports.GraphicsSimple = GraphicsSimple;


/***/ }),

/***/ "./js-compile/examples/InteractionClick.js":
/*!*************************************************!*\
  !*** ./js-compile/examples/InteractionClick.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const DisplaySettings_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class InteractionClick extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            DisplaySettings_1.DisplaySettings.SCALE_MODE = WebGLSettings_1.WebGLSettings.SCALE_MODES.NEAREST;
            this.sprite = new Sprite_1.Sprite(txt);
            this.sprite.anchor.set(0.5);
            this.sprite.x = this.sizew / 2;
            this.sprite.y = this.sizeh / 2;
            this.sprite.interactive = true;
            this.sprite.buttonMode = true;
            this.sprite.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onClick);
            this.stage.addChild(this.sprite);
            this.exampleReady();
        };
        this.onClick = (event) => {
            this.sprite.scale.x *= 1.25;
            this.sprite.scale.y *= 1.25;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.sprite.destroy(null);
        this.sprite = null;
    }
}
exports.InteractionClick = InteractionClick;


/***/ }),

/***/ "./js-compile/examples/InteractionDragging.js":
/*!****************************************************!*\
  !*** ./js-compile/examples/InteractionDragging.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class InteractionDragging extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            let texture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            texture.baseTexture.scaleMode = WebGLSettings_1.WebGLSettings.SCALE_MODES.NEAREST;
            for (let i = 0; i < 10; i++) {
                this.createBunny(Math.floor(Math.random() * this.sizew), Math.floor(Math.random() * this.sizeh), texture);
            }
            this.exampleReady();
        };
        this.onDragStart = (event) => {
            let button = event.currentTarget;
            button.data = event.data;
            button.alpha = 0.5;
            button.dragging = true;
        };
        this.onDragEnd = (event) => {
            let button = event.currentTarget;
            button.alpha = 1;
            button.dragging = false;
            button.data = null;
        };
        this.onDragMove = (event) => {
            let button = event.currentTarget;
            if (button.dragging) {
                const newPosition = button.data.getLocalPosition(button.parent);
                button.x = newPosition.x;
                button.y = newPosition.y;
            }
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    createBunny(x, y, texture) {
        const bunny = new ExtendedSprite(texture);
        bunny.interactive = true;
        bunny.buttonMode = true;
        bunny.anchor.set(0.5);
        bunny.scale.set(3);
        bunny.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onDragStart);
        bunny.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.onDragEnd);
        bunny.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.onDragEnd);
        bunny.addEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.onDragMove);
        // For mouse-only events
        // .on('mousedown', onDragStart)
        // .on('mouseup', onDragEnd)
        // .on('mouseupoutside', onDragEnd)
        // .on('mousemove', onDragMove);
        // For touch-only events
        // .on('touchstart', onDragStart)
        // .on('touchend', onDragEnd)
        // .on('touchendoutside', onDragEnd)
        // .on('touchmove', onDragMove);
        bunny.x = x;
        bunny.y = y;
        this.stage.addChild(bunny);
    }
}
exports.InteractionDragging = InteractionDragging;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/InteractionIcon.js":
/*!************************************************!*\
  !*** ./js-compile/examples/InteractionIcon.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class InteractionIcon extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleButtonOverLoaded = (event) => {
            this.textureButtonOver = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const buttons = [];
            const buttonPositions = [
                175, 75,
                655, 75,
                410, 325,
                150, 465,
                685, 445,
            ];
            for (let i = 0; i < 5; i++) {
                const button = new ExtendedSprite(this.textureButton);
                button.anchor.set(0.5);
                button.x = buttonPositions[i * 2];
                button.y = buttonPositions[i * 2 + 1];
                button.interactive = true;
                button.buttonMode = true;
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onButtonDown);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.onButtonUp);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.onButtonUp);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_OVER, this.onButtonOver);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_OUT, this.onButtonOut);
                // button.on('mousedown', onButtonDown)
                // button.on('mouseup', onButtonUp)
                // button.on('mouseupoutside', onButtonUp)
                // button.on('mouseover', onButtonOver)
                // button.on('mouseout', onButtonOut)
                // Use touch-only events
                // .on('touchstart', onButtonDown)
                // .on('touchend', onButtonUp)
                // .on('touchendoutside', onButtonUp)
                this.stage.addChild(button);
                buttons.push(button);
            }
            buttons[0].scale.set(1.2);
            buttons[2].rotation = Math.PI / 10;
            buttons[3].scale.set(0.8);
            buttons[4].scale.set(0.8, 1.2);
            buttons[4].rotation = Math.PI;
            this.exampleReady();
        };
        this.onButtonDown = (event) => {
            let button = event.currentTarget;
            button.isdown = true;
            button.texture = this.textureButtonDown;
            button.alpha = 1;
        };
        this.onButtonUp = (event) => {
            let button = event.currentTarget;
            button.isdown = false;
            if (button.isOver) {
                button.texture = this.textureButtonOver;
            }
            else {
                button.texture = this.textureButton;
            }
        };
        this.onButtonOver = (event) => {
            let button = event.currentTarget;
            button.isOver = true;
            if (button.isdown) {
                return;
            }
            button.texture = this.textureButtonOver;
            this.app.renderer.view.style.cursor = "url('examples/assets/bunny.png'), pointer";
        };
        this.onButtonOut = (event) => {
            let button = event.currentTarget;
            button.isOver = false;
            if (button.isdown) {
                return;
            }
            button.texture = this.textureButton;
            this.app.renderer.view.style.cursor = "url('examples/assets/bunny.png'), pointer";
        };
        this.handleButtonDownLoaded = (event) => {
            this.textureButtonDown = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button_over.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonOverLoaded);
            this.loader.load();
        };
        this.handleButtonLoaded = (event) => {
            this.textureButton = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button_down.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonDownLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(txt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonLoaded);
            this.loader.load();
        };
        const defaultIcon = "url('examples/assets/bunny.png'),auto;";
        const hoverIcon = "url('examples/assets/bunny_saturated.png'),auto;";
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_button.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.textureButton.destroy(null);
        this.textureButton = null;
        this.textureButtonOver.destroy(null);
        this.textureButtonOver = null;
        this.textureButtonDown.destroy(null);
        this.textureButtonDown = null;
    }
}
exports.InteractionIcon = InteractionIcon;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/InteractionInteractivity.js":
/*!*********************************************************!*\
  !*** ./js-compile/examples/InteractionInteractivity.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class InteractionInteractivity extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleButtonOverLoaded = (event) => {
            this.textureButtonOver = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const buttons = [];
            const buttonPositions = [
                175, 75,
                655, 75,
                410, 325,
                150, 465,
                685, 445,
            ];
            for (let i = 0; i < 5; i++) {
                const button = new ExtendedSprite(this.textureButton);
                button.buttonMode = true;
                button.anchor.set(0.5);
                button.x = buttonPositions[i * 2];
                button.y = buttonPositions[i * 2 + 1];
                button.interactive = true;
                button.buttonMode = true;
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onButtonDown);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.onButtonUp);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.onButtonUp);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_OVER, this.onButtonOver);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_OUT, this.onButtonOut);
                // button.on('mousedown', onButtonDown)
                // button.on('mouseup', onButtonUp)
                // button.on('mouseupoutside', onButtonUp)
                // button.on('mouseover', onButtonOver)
                // button.on('mouseout', onButtonOut)
                // Use touch-only events
                // .on('touchstart', onButtonDown)
                // .on('touchend', onButtonUp)
                // .on('touchendoutside', onButtonUp)
                this.stage.addChild(button);
                buttons.push(button);
            }
            buttons[0].scale.set(1.2);
            buttons[2].rotation = Math.PI / 10;
            buttons[3].scale.set(0.8);
            buttons[4].scale.set(0.8, 1.2);
            buttons[4].rotation = Math.PI;
            this.exampleReady();
        };
        this.onButtonDown = (event) => {
            let button = event.currentTarget;
            button.isdown = true;
            button.texture = this.textureButtonDown;
            button.alpha = 1;
        };
        this.onButtonUp = (event) => {
            let button = event.currentTarget;
            button.isdown = false;
            if (button.isOver) {
                button.texture = this.textureButtonOver;
            }
            else {
                button.texture = this.textureButton;
            }
        };
        this.onButtonOver = (event) => {
            let button = event.currentTarget;
            button.isOver = true;
            if (button.isdown) {
                return;
            }
            button.texture = this.textureButtonOver;
        };
        this.onButtonOut = (event) => {
            let button = event.currentTarget;
            button.isOver = false;
            if (button.isdown) {
                return;
            }
            button.texture = this.textureButton;
        };
        this.handleButtonDownLoaded = (event) => {
            this.textureButtonDown = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button_over.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonOverLoaded);
            this.loader.load();
        };
        this.handleButtonLoaded = (event) => {
            this.textureButton = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button_down.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonDownLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(txt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonLoaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_button.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.textureButton.destroy(null);
        this.textureButton = null;
        this.textureButtonOver.destroy(null);
        this.textureButtonOver = null;
        this.textureButtonDown.destroy(null);
        this.textureButtonDown = null;
    }
}
exports.InteractionInteractivity = InteractionInteractivity;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/MaskFilter.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MaskFilter.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class MaskFilter extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.flagTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const radius = 100;
            const blurSize = 32;
            const background = new Sprite_1.Sprite(this.flagTxt);
            this.stage.addChild(background);
            background.width = this.sizew;
            background.height = this.sizeh;
            const circle = new Graphics_1.Graphics()
                .beginFill(0xFF0000)
                .drawCircle(radius + blurSize, radius + blurSize, radius)
                .endFill();
            circle.filters = [new BlurFilter_1.BlurFilter(blurSize)];
            const bounds = new Rectangle_1.Rectangle(0, 0, (radius + blurSize) * 2, (radius + blurSize) * 2);
            const texture = this.app.renderer.generateTexture(circle, WebGLSettings_1.WebGLSettings.SCALE_MODES.NEAREST, 1, bounds);
            this.focus = new Sprite_1.Sprite(texture);
            this.stage.addChild(this.focus);
            background.mask = this.focus;
            this.stage.interactive = true;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.MOUSE_MOVE, this.pointerMove);
            this.exampleReady();
        };
        this.pointerMove = (event) => {
            this.focus.position.x = event.data.global.x - this.focus.width / 2;
            this.focus.position.y = event.data.global.y - this.focus.height / 2;
        };
        this.backColor = 0;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.flagTxt.destroy(null);
        this.flagTxt = null;
        this.focus.destroy(null);
        this.focus = null;
    }
}
exports.MaskFilter = MaskFilter;


/***/ }),

/***/ "./js-compile/examples/MaskGraphics.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MaskGraphics.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
class MaskGraphics extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePandaLoaded = (event) => {
            this.pandaTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bg = new Sprite_1.Sprite(this.rotateTxt);
            this.bg.anchor.set(0.5);
            this.bg.x = this.sizew / 2;
            this.bg.y = this.sizeh / 2;
            this.stage.addChild(this.bg);
            this.container = new Container_1.Container();
            this.container.x = this.sizew / 2;
            this.container.y = this.sizeh / 2;
            this.bgFront = new Sprite_1.Sprite(this.scenerotateTxt);
            this.bgFront.anchor.set(0.5);
            this.light2 = new Sprite_1.Sprite(this.lightrotate2Txt);
            this.light2.anchor.set(0.5);
            this.light1 = new Sprite_1.Sprite(this.lightrotate1Txt);
            this.light1.anchor.set(0.5);
            this.panda = new Sprite_1.Sprite(this.pandaTxt);
            this.panda.anchor.set(0.5);
            this.container.addChild(this.bgFront);
            this.container.addChild(this.light2);
            this.container.addChild(this.light1);
            this.container.addChild(this.panda);
            this.stage.addChild(this.container);
            this.thing = new Graphics_1.Graphics();
            this.stage.addChild(this.thing);
            this.thing.x = this.sizew / 2;
            this.thing.y = this.sizeh / 2;
            this.thing.lineStyle(0);
            this.container.mask = this.thing;
            this.count = 0;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handleStageTap);
            const help = new Text_1.Text('Click or tap to turn masking on / off.', {
                fontFamily: 'Arial',
                fontSize: 12,
                fontWeight: 'bold',
                fill: 'white',
            });
            help.y = this.app.screen.height - 35;
            help.x = 15;
            this.stage.addChild(help);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bg.rotation += 0.01;
            this.bgFront.rotation -= 0.01;
            this.light1.rotation += 0.02;
            this.light2.rotation += 0.01;
            this.panda.scale.x = 1 + Math.sin(this.count) * 0.04;
            this.panda.scale.y = 1 + Math.cos(this.count) * 0.04;
            this.count += 0.1;
            this.thing.clear();
            this.thing.beginFill(0x8bc5ff, 0.4);
            this.thing.moveTo(-120 + Math.sin(this.count) * 20, -100 + Math.cos(this.count) * 20);
            this.thing.lineTo(120 + Math.cos(this.count) * 20, -100 + Math.sin(this.count) * 20);
            this.thing.lineTo(120 + Math.sin(this.count) * 20, 100 + Math.cos(this.count) * 20);
            this.thing.lineTo(-120 + Math.cos(this.count) * 20, 100 + Math.sin(this.count) * 20);
            this.thing.rotation = this.count * 0.1;
        };
        this.handleStageTap = (event) => {
            if (!this.container.mask) {
                this.container.mask = this.thing;
            }
            else {
                this.container.mask = null;
            }
        };
        this.handleLightRotate1Loaded = (event) => {
            this.lightrotate1Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_1.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate1Loaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.rotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleSceneRotateLoaded);
            this.loader.load();
        };
        this.handleSceneRotateLoaded = (event) => {
            this.scenerotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_2.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate2Loaded);
            this.loader.load();
        };
        this.handleLightRotate2Loaded = (event) => {
            this.lightrotate2Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/panda.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePandaLoaded);
            this.loader.load();
        };
        this.backColor = 0;
        this.activateMask();
        app.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.panda.destroy(null);
        this.panda = null;
        this.rotateTxt.destroy(null);
        this.rotateTxt = null;
        this.scenerotateTxt.destroy(null);
        this.scenerotateTxt = null;
        this.lightrotate2Txt.destroy(null);
        this.lightrotate2Txt = null;
        this.lightrotate1Txt.destroy(null);
        this.lightrotate1Txt = null;
        this.pandaTxt.destroy(null);
        this.pandaTxt = null;
        this.container.destroy(null);
        this.container = null;
        this.thing.destroy(null);
        this.thing = null;
        this.bg.destroy(null);
        this.bg = null;
        this.bgFront.destroy(null);
        this.bgFront = null;
        this.light2.destroy(null);
        this.light2 = null;
        this.light1.destroy(null);
        this.light1 = null;
    }
}
exports.MaskGraphics = MaskGraphics;


/***/ }),

/***/ "./js-compile/examples/MaskSprite.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MaskSprite.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
class MaskSprite extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleFlowerLoaded = (event) => {
            this.flowerTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.app.stage.interactive = true;
            const bg = new Sprite_1.Sprite(this.planeTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            this.stage.addChild(bg);
            const cells = new Sprite_1.Sprite(this.cellTxt);
            cells.scale.set(1.5);
            this.mask = new Sprite_1.Sprite(this.flowerTxt);
            this.mask.anchor.set(0.5);
            this.mask.x = 310;
            this.mask.y = 190;
            cells.mask = this.mask;
            this.stage.addChild(this.mask);
            this.stage.addChild(cells);
            this.target = new Point_1.Point();
            this.reset();
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.mask.x += (this.target.x - this.mask.x) * 0.1;
            this.mask.y += (this.target.y - this.mask.y) * 0.1;
            if (Math.abs(this.mask.x - this.target.x) < 1) {
                this.reset();
            }
        };
        this.handleCellLoaded = (event) => {
            this.cellTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleFlowerLoaded);
            this.loader.load();
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/cells.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleCellLoaded);
            this.loader.load();
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_plane.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    reset() {
        this.target.x = Math.floor(Math.random() * 550);
        this.target.y = Math.floor(Math.random() * 300);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.mask.destroy(null);
        this.mask = null;
        this.planeTxt.destroy(null);
        this.planeTxt = null;
        this.cellTxt.destroy(null);
        this.cellTxt = null;
        this.flowerTxt.destroy(null);
        this.flowerTxt = null;
    }
}
exports.MaskSprite = MaskSprite;


/***/ }),

/***/ "./js-compile/examples/MeshAdvanced.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshAdvanced.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
class MeshAdvanced extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            for (let i = 0; i < this.points.length; i++) {
                this.points[i].y = Math.sin((i * 0.5) + this.count) * 30;
                this.points[i].x = i * this.ropeLength + Math.cos((i * 0.3) + this.count) * 20;
            }
            this.renderPoints();
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.count = 0;
            this.ropeLength = 30;
            this.points = [];
            for (let i = 0; i < 25; i++) {
                this.points.push(new Point_1.Point(i * this.ropeLength, 0));
            }
            const strip = new SimpleRope_1.SimpleRope(this.planeTxt, this.points);
            strip.x = 20;
            strip.y = 300;
            this.stage.addChild(strip);
            this.g = new Graphics_1.Graphics();
            this.g.x = strip.x;
            this.g.y = strip.y;
            this.stage.addChild(this.g);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/snake.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    renderPoints() {
        this.g.clear();
        this.g.lineStyle(2, 0xffc2c2);
        this.g.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) {
            this.g.lineTo(this.points[i].x, this.points[i].y);
        }
        for (let i = 1; i < this.points.length; i++) {
            this.g.beginFill(0xff0022);
            this.g.drawCircle(this.points[i].x, this.points[i].y, 10);
            this.g.endFill();
        }
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.planeTxt.destroy(null);
        this.planeTxt = null;
        this.g.destroy(null);
        this.g = null;
        this.points = null;
    }
}
exports.MeshAdvanced = MeshAdvanced;


/***/ }),

/***/ "./js-compile/examples/MeshBasic.js":
/*!******************************************!*\
  !*** ./js-compile/examples/MeshBasic.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
class MeshBasic extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            for (let i = 0; i < this.points.length; i++) {
                this.points[i].y = Math.sin((i * 0.5) + this.count) * 30;
                this.points[i].x = i * this.ropeLength + Math.cos((i * 0.3) + this.count) * 20;
            }
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.count = 0;
            this.ropeLength = 918 / 20;
            this.points = [];
            for (let i = 0; i < 20; i++) {
                this.points.push(new Point_1.Point(i * this.ropeLength, 0));
            }
            const strip = new SimpleRope_1.SimpleRope(this.planeTxt, this.points);
            strip.x = -459;
            const snakeContainer = new Container_1.Container();
            snakeContainer.x = 400;
            snakeContainer.y = 300;
            snakeContainer.scale.set(800 / 1100);
            this.stage.addChild(snakeContainer);
            snakeContainer.addChild(strip);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/snake.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.planeTxt.destroy(null);
        this.planeTxt = null;
        this.points = null;
    }
}
exports.MeshBasic = MeshBasic;


/***/ }),

/***/ "./js-compile/examples/MeshColoredTriangle.js":
/*!****************************************************!*\
  !*** ./js-compile/examples/MeshColoredTriangle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshColoredTriangle extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        const geometry = new Geometry_1.Geometry();
        geometry.addAttribute('aVertexPosition', // the attribute name
        [-100, -50,
            100, -50,
            0.0, 100.0], // x, y
        2); // the size of the attribute
        geometry.addAttribute('aColor', // the attribute name
        [1, 0, 0,
            0, 1, 0,
            0, 0, 1], // r, g, b
        3); // the size of the attribute
        let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec3 aColor;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec3 vColor;    
            void main() {    
                vColor = aColor;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
        let fx = `precision mediump float;
            varying vec3 vColor;    
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }    
            `;
        let program = new Program_1.Program(vx, fx);
        const shader = new Shader_1.Shader(program, null);
        this.triangle = new Mesh_1.Mesh(geometry, shader);
        this.triangle.position.set(400, 300);
        this.triangle.scale.set(2);
        this.stage.addChild(this.triangle);
        this.app.ticker.add(this.runExample);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.triangle.destroy(null);
        this.triangle = null;
    }
}
exports.MeshColoredTriangle = MeshColoredTriangle;


/***/ }),

/***/ "./js-compile/examples/MeshGeometry.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshGeometry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
class MeshGeometry extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleTxt3Loaded = (event) => {
            this.txt3 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100], // x, y
            2); // the size of the attribute    
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1], // u, v
            2); // the size of the attribute    
            const program = Program_1.Program.from(`    
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`, `precision mediump float;    
            varying vec2 vUvs;    
            uniform sampler2D uSamplerTexture;    
            void main() {    
                gl_FragColor = texture2D(uSamplerTexture, vUvs);
            }    
        `);
            this.triangle = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt1,
            }));
            this.triangle2 = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt2,
            }));
            this.triangle3 = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt3,
            }));
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.triangle2.position.set(200, 100);
            this.triangle3.position.set(500, 400);
            this.triangle3.scale.set(3);
            this.stage.addChild(this.triangle3);
            this.stage.addChild(this.triangle2);
            this.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle2.rotation -= 0.01;
            this.triangle3.rotation -= 0.005;
        };
        this.handleTxt2Loaded = (event) => {
            this.txt2 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_displacement.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt3Loaded);
            this.loader.load();
        };
        this.handleTxt1Loaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt2Loaded);
            this.loader.load();
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt1Loaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.txt1.destroy(null);
        this.txt1 = null;
        this.triangle3.destroy(null);
        this.triangle3 = null;
        this.triangle2.destroy(null);
        this.triangle2 = null;
        this.triangle.destroy(null);
        this.triangle = null;
        this.txt3.destroy(null);
        this.txt3 = null;
        this.txt2.destroy(null);
        this.txt2 = null;
    }
}
exports.MeshGeometry = MeshGeometry;


/***/ }),

/***/ "./js-compile/examples/MeshShader.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MeshShader.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshShader extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleTxt1Loaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100]); // x, y
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1]); // u, v
            let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            varying vec2 vUvs;
            void main() {
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
            let fx = `precision mediump float;
            varying vec2 vUvs;
            uniform sampler2D uSampler2;
            void main() {
                gl_FragColor = texture2D(uSampler2, vUvs);
            }        
            `;
            let program = new Program_1.Program(vx, fx);
            const shader = new Shader_1.Shader(program, { uSampler2: this.txt1 });
            let vx2 = `
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
            let fx2 = `precision mediump float;
            varying vec2 vUvs;    
            uniform sampler2D uSampler2;    
            void main() {    
                gl_FragColor = texture2D(uSampler2, vUvs);
                gl_FragColor.r += (abs(sin(gl_FragCoord.x * 0.06)) * 0.5) * 2.;
                gl_FragColor.g += (abs(cos(gl_FragCoord.y * 0.06)) * 0.5) * 2.;
            }    
            `;
            let program2 = new Program_1.Program(vx2, fx2);
            const shader2 = new Shader_1.Shader(program2, { uSampler2: this.txt1 });
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle2 = new Mesh_1.Mesh(geometry, shader2);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.triangle2.position.set(500, 400);
            this.triangle2.scale.set(3);
            this.stage.addChild(this.triangle2);
            this.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle2.rotation -= 0.005;
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt1Loaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.txt1.destroy(null);
        this.txt1 = null;
        this.triangle.destroy(null);
        this.triangle = null;
        this.triangle2.destroy(null);
        this.triangle2 = null;
    }
}
exports.MeshShader = MeshShader;


/***/ }),

/***/ "./js-compile/examples/MeshTextured.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshTextured.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshTextured extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100], // x, y
            2); // the size of the attribute
            geometry.addAttribute('aColor', // the attribute name
            [1, 0, 0,
                0, 1, 0,
                0, 0, 1], // r, g, b
            3); // the size of the attribute
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1], // u, v
            2); // the size of the attribute
            const vertexSrc = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec3 aColor;
            attribute vec2 aUvs;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            varying vec2 vUvs;
            varying vec3 vColor;
            void main() {
                vUvs = aUvs;
                vColor = aColor;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
            const fragmentSrc = `
            precision mediump float;
            varying vec3 vColor;
            varying vec2 vUvs;
            uniform sampler2D uSampler2;
            void main() {
                gl_FragColor = texture2D(uSampler2, vUvs) * vec4(vColor, 1.0);
            }`;
            const uniforms = { uSampler2: this.planeTxt };
            let program = new Program_1.Program(vertexSrc, fragmentSrc);
            const shader = new Shader_1.Shader(program, uniforms);
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.triangle.destroy(null);
        this.triangle = null;
        this.planeTxt.destroy(null);
        this.planeTxt = null;
    }
}
exports.MeshTextured = MeshTextured;


/***/ }),

/***/ "./js-compile/examples/MeshTriangle.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshTriangle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshTriangle extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        const geometry = new Geometry_1.Geometry();
        geometry.addAttribute('aVertexPosition', [-100, -50, 100, -50, 0, 100]);
        let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            void main() {
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
        let fx = `precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `;
        let program = new Program_1.Program(vx, fx);
        const shader = new Shader_1.Shader(program, null);
        this.triangle = new Mesh_1.Mesh(geometry, shader);
        this.triangle.position.set(400, 300);
        this.stage.addChild(this.triangle);
        this.app.ticker.add(this.runExample);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.triangle.destroy(null);
        this.triangle = null;
    }
}
exports.MeshTriangle = MeshTriangle;


/***/ }),

/***/ "./js-compile/examples/MeshUniforms.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshUniforms.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
class MeshUniforms extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100,
                -100, 100], // x, y
            2); // the size of the attribute
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1,
                0, 1], // u, v
            2); // the size of the attribute
            geometry.addIndex([0, 1, 2, 0, 2, 3]);
            const vertexSrc = `
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
            const fragmentSrc = `    
            precision mediump float;    
            varying vec2 vUvs;    
            uniform sampler2D uSampler2;
            uniform float time;    
            void main() {    
                gl_FragColor = texture2D(uSampler2, vUvs + sin( (time + (vUvs.x) * 14.) ) * 0.1 );
            }`;
            const uniforms = {
                uSampler2: this.planeTxt,
                time: 0,
            };
            let program = new Program_1.Program(vertexSrc, fragmentSrc);
            const shader = new Shader_1.Shader(program, uniforms);
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle.shader.uniforms.time += 0.1;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.planeTxt.destroy(null);
        this.planeTxt = null;
        this.triangle.destroy(null);
        this.triangle = null;
    }
}
exports.MeshUniforms = MeshUniforms;


/***/ }),

/***/ "./js-compile/examples/SpriteBasic.js":
/*!********************************************!*\
  !*** ./js-compile/examples/SpriteBasic.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class SpriteBasic extends BaseExample_1.BaseExample {
    constructor(app, width = 100, height = 100) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            let texture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bunny = new Sprite_1.Sprite(texture);
            this.bunny.anchor.set(0.5);
            this.bunny.x = this.sizew / 2;
            this.bunny.y = this.sizeh / 2;
            this.stage.addChild(this.bunny);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bunny.rotation += 0.1 * delta;
        };
        this.backColor = 0xFFF000;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.bunny.destroy(null);
    }
}
exports.SpriteBasic = SpriteBasic;


/***/ }),

/***/ "./js-compile/examples/SpriteExplosion.js":
/*!************************************************!*\
  !*** ./js-compile/examples/SpriteExplosion.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
class SpriteExplosion extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (textures) => {
            const explosionTextures = [];
            let i;
            for (i = 0; i < 26; i++) {
                const texture = textures[`Explosion_Sequence_A ${i + 1}.png`];
                explosionTextures.push(texture);
            }
            for (i = 0; i < 50; i++) {
                const explosion = new AnimatedSprite_1.AnimatedSprite(explosionTextures);
                explosion.x = Math.random() * this.sizew;
                explosion.y = Math.random() * this.sizeh;
                explosion.anchor.set(0.5);
                explosion.rotation = Math.random() * Math.PI;
                explosion.scale.set(0.75 + Math.random() * 0.5);
                explosion.gotoAndPlay(Math.random() * 27);
                this.stage.addChild(explosion);
            }
            this.exampleReady();
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/mc.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            let spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            spritesheet.parse(this.onAnimationParsed);
        };
        this.backColor = 0x000000;
        this.activateMask();
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/mc.json"));
    }
    destructor() {
        super.destructor();
        this.txt.destroy(null);
        this.txt = null;
        this.jsondata = null;
    }
}
exports.SpriteExplosion = SpriteExplosion;


/***/ }),

/***/ "./js-compile/examples/SpriteSpeed.js":
/*!********************************************!*\
  !*** ./js-compile/examples/SpriteSpeed.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
class SpriteSpeed extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (loadedtextures) => {
            const textures = [];
            let i;
            for (i = 0; i < 10; i++) {
                const framekey = `0123456789 ${i}.ase`;
                const texture = loadedtextures[framekey];
                const time = this.spritesheet.data.frames[framekey].duration;
                textures.push({ texture, time });
            }
            const scaling = 4;
            const slow = new AnimatedSprite_1.AnimatedSprite(textures);
            slow.anchor.set(0.5);
            slow.scale.set(scaling);
            slow.animationSpeed = 0.5;
            slow.x = (this.sizew - slow.width) / 2;
            slow.y = this.sizeh / 2;
            slow.play();
            this.app.stage.addChild(slow);
            const fast = new AnimatedSprite_1.AnimatedSprite(textures);
            fast.anchor.set(0.5);
            fast.scale.set(scaling);
            fast.x = (this.sizew + fast.width) / 2;
            fast.y = this.sizeh / 2;
            fast.play();
            this.stage.addChild(fast);
            // this.app.ticker.add(this.runExample)
            this.exampleReady();
        };
        this.runExample = (delta) => {
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/0123456789.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            this.spritesheet.parse(this.onAnimationParsed);
        };
        this.backColor = 0x57AACC;
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/0123456789.json"));
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.spritesheet.destroy(null);
        this.spritesheet = null;
        this.txt.destroy(null);
        this.txt = null;
        this.anim.destroy(null);
        this.anim = null;
    }
}
exports.SpriteSpeed = SpriteSpeed;


/***/ }),

/***/ "./js-compile/examples/SpriteSwap.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/SpriteSwap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class SpriteSwap extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/eggHead.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotate2Loaded);
            this.loader.load();
        };
        this.handleRotate2Loaded = (event) => {
            this.txt2 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.dude = new Sprite_1.Sprite(this.txt1);
            this.dude.anchor.set(0.5);
            this.dude.x = this.sizew / 2;
            this.dude.y = this.sizeh / 2;
            this.stage.addChild(this.dude);
            this.dude.interactive = true;
            this.dude.buttonMode = true;
            this.dude.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleDown);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.handleDown = (event) => {
            this.bol = !this.bol;
            if (this.bol) {
                this.dude.texture = this.txt2;
            }
            else {
                this.dude.texture = this.txt1;
            }
        };
        this.runExample = (delta) => {
            this.dude.rotation += 0.1;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.dude.destroy(null);
        this.dude = null;
        this.txt1.destroy(null);
        this.txt1 = null;
        this.txt2.destroy(null);
        this.txt2 = null;
    }
}
exports.SpriteSwap = SpriteSwap;


/***/ }),

/***/ "./js-compile/examples/SpriteTiling.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/SpriteTiling.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const TilingSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/TilingSprite */ "./js-compile/raw-pixi-ts/TilingSprite.js");
class SpriteTiling extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.tilingSprite = new TilingSprite_1.TilingSprite(this.txt1, this.sizew, this.sizeh);
            this.stage.addChild(this.tilingSprite);
            this.count = 0;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.count += 0.005;
            this.tilingSprite.tileScale.x = 2 + Math.sin(this.count);
            this.tilingSprite.tileScale.y = 2 + Math.cos(this.count);
            this.tilingSprite.tilePosition.x += 1;
            this.tilingSprite.tilePosition.y += 1;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/p2.jpeg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.tilingSprite.destroy(null);
        this.tilingSprite = null;
        this.txt1.destroy(null);
        this.txt1 = null;
    }
}
exports.SpriteTiling = SpriteTiling;


/***/ }),

/***/ "./js-compile/examples/SpriteVideo.js":
/*!********************************************!*\
  !*** ./js-compile/examples/SpriteVideo.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class SpriteVideo extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onPlayVideo = (event) => {
            this.button.destroy(null);
            this.video.play();
            const texture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.video));
            const videoSprite = new Sprite_1.Sprite(texture);
            videoSprite.width = this.sizew;
            videoSprite.height = this.sizeh;
            this.stage.addChild(videoSprite);
        };
        this.button = new Graphics_1.Graphics()
            .beginFill(0x0, 0.5)
            .drawRoundedRect(0, 0, 100, 100, 10)
            .endFill()
            .beginFill(0xffffff)
            .moveTo(36, 30)
            .lineTo(36, 70)
            .lineTo(70, 50);
        this.button.x = (this.sizew - this.button.width) / 2;
        this.button.y = (this.sizeh - this.button.height) / 2;
        this.button.interactive = true;
        this.button.buttonMode = true;
        this.stage.addChild(this.button);
        this.video = document.createElement("video");
        this.video['type'] = "video/mp4";
        this.video.src = "examples/assets/video.mp4";
        this.video.addEventListener('canplay', () => {
            this.button.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.onPlayVideo);
            this.exampleReady();
        });
    }
    destructor() {
        super.destructor();
        this.video = null;
    }
}
exports.SpriteVideo = SpriteVideo;


/***/ }),

/***/ "./js-compile/examples/Spritejet.js":
/*!******************************************!*\
  !*** ./js-compile/examples/Spritejet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
class Spritejet extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (textures) => {
            const frames = [];
            for (let i = 0; i < 30; i++) {
                const val = i < 10 ? `0${i}` : i;
                frames.push(textures[`rollSequence00${val}.png`]);
            }
            this.anim = new AnimatedSprite_1.AnimatedSprite(frames);
            this.anim.x = this.sizew / 2;
            this.anim.y = this.sizeh / 2;
            this.anim.anchor.set(0.5);
            this.anim.animationSpeed = 0.5;
            this.anim.play();
            this.stage.addChild(this.anim);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.anim.rotation += 0.01;
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            let spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            spritesheet.parse(this.onAnimationParsed);
        };
        this.backColor = 0x969696;
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.json"));
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.anim.destroy(null);
        this.anim = null;
        this.txt.destroy(null);
        this.txt = null;
        this.jsondata = null;
    }
}
exports.Spritejet = Spritejet;


/***/ }),

/***/ "./js-compile/examples/TextBase.js":
/*!*****************************************!*\
  !*** ./js-compile/examples/TextBase.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const TextStyle_1 = __webpack_require__(/*! ../raw-pixi-ts/TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
class TextBase extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        const basicText = new Text_1.Text('Basic text in pixi');
        basicText.x = 50;
        basicText.y = 100;
        this.stage.addChild(basicText);
        const style = new TextStyle_1.TextStyle({
            fontFamily: 'Arial',
            fontSize: 36,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: ['#ffffff', '#00ff99'],
            stroke: '#4a1850',
            strokeThickness: 5,
            dropShadow: true,
            dropShadowColor: '#000000',
            dropShadowBlur: 4,
            dropShadowAngle: Math.PI / 6,
            dropShadowDistance: 6,
            wordWrap: true,
            wordWrapWidth: 440,
        });
        const richText = new Text_1.Text('Rich text with a lot of options and across multiple lines', style);
        richText.x = 50;
        richText.y = 250;
        this.stage.addChild(richText);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
}
exports.TextBase = TextBase;


/***/ }),

/***/ "./js-compile/examples/TextBitmap.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/TextBitmap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const FontManager_1 = __webpack_require__(/*! ../raw-pixi-ts/FontManager */ "./js-compile/raw-pixi-ts/FontManager.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BitmapText_1 = __webpack_require__(/*! ../raw-pixi-ts/BitmapText */ "./js-compile/raw-pixi-ts/BitmapText.js");
class TextBitmap extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleFontLoaded = (event) => {
            const bitmapFontText = new BitmapText_1.BitmapText('bitmap fonts are supported!\nWoo yay!');
            bitmapFontText.fontSize = 55;
            bitmapFontText.font = "Desyrel";
            bitmapFontText.align = 'left';
            bitmapFontText.x = 50;
            bitmapFontText.y = 200;
            this.stage.addChild(bitmapFontText);
            this.exampleReady();
        };
        let loader = FontManager_1.FontManager.loadBitmapFont("examples/assets/bitmap-font/desyrel.xml");
        loader.addEventListener(Event_1.Event.COMPLETE, this.handleFontLoaded);
    }
}
exports.TextBitmap = TextBitmap;


/***/ }),

/***/ "./js-compile/examples/TextWebFont.js":
/*!********************************************!*\
  !*** ./js-compile/examples/TextWebFont.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const FontManager_1 = __webpack_require__(/*! ../raw-pixi-ts/FontManager */ "./js-compile/raw-pixi-ts/FontManager.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
class TextWebFont extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleWebFontLoaded = () => {
            const textSample = new Text_1.Text('Pixi.js text using the\ncustom "Snippet" Webfont', {
                fontFamily: 'Snippet',
                fontSize: 50,
                fill: 'white',
                align: 'left',
            });
            textSample.position.set(50, 200);
            this.stage.addChild(textSample);
            this.exampleReady();
        };
        FontManager_1.FontManager.onWebFontloaded = this.handleWebFontLoaded;
        FontManager_1.FontManager.WebFontConfig = {
            google: {
                families: ['Snippet', 'Arvo:700italic', 'Podkova:700'],
            }
        };
    }
}
exports.TextWebFont = TextWebFont;


/***/ }),

/***/ "./js-compile/examples/TextureAdvanced.js":
/*!************************************************!*\
  !*** ./js-compile/examples/TextureAdvanced.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const RenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class TextureAdvanced extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            for (let i = 0; i < this.items.length; i++) {
                const item = this.items[i];
                item.rotation += 0.1;
            }
            this.count += 0.01;
            const temp = this.renderTexture;
            this.renderTexture = this.renderTexture2;
            this.renderTexture2 = temp;
            this.outputSprite.texture = this.renderTexture;
            this.stuffContainer.rotation -= 0.01;
            this.outputSprite.scale.set(1 + Math.sin(this.count) * 0.2);
            this.app.renderer.render(this.stage, this.renderTexture2, false);
        };
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.fruits.push(txt);
            this.loadAssets();
        };
        this.renderTexture = RenderTexture_1.RenderTexture.create(this.sizew, this.sizeh);
        this.renderTexture2 = RenderTexture_1.RenderTexture.create(this.sizew, this.sizeh);
        const currentTexture = this.renderTexture;
        this.outputSprite = new Sprite_1.Sprite(currentTexture);
        this.outputSprite.x = 400;
        this.outputSprite.y = 300;
        this.outputSprite.anchor.set(0.5);
        this.stage.addChild(this.outputSprite);
        this.stuffContainer = new Container_1.Container();
        this.stuffContainer.x = 400;
        this.stuffContainer.y = 300;
        this.stage.addChild(this.stuffContainer);
        this.fruitslinks = [
            'examples/assets/rt_object_01.png',
            'examples/assets/rt_object_02.png',
            'examples/assets/rt_object_03.png',
            'examples/assets/rt_object_04.png',
            'examples/assets/rt_object_05.png',
            'examples/assets/rt_object_06.png',
            'examples/assets/rt_object_07.png',
            'examples/assets/rt_object_08.png',
        ];
        this.fruits = [];
        this.loadAssets();
    }
    init() {
        this.items = [];
        for (let i = 0; i < 20; i++) {
            const item = new Sprite_1.Sprite(this.fruits[i % this.fruits.length]);
            item.x = Math.random() * 400 - 200;
            item.y = Math.random() * 400 - 200;
            item.anchor.set(0.5);
            this.stuffContainer.addChild(item);
            this.items.push(item);
        }
        this.count = 0;
        this.app.ticker.add(this.runExample);
        this.exampleReady();
    }
    loadAssets() {
        if (!this.fruitslinks.length) {
            this.init();
            return;
        }
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest(this.fruitslinks.pop()));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.stuffContainer.destroy(null);
        this.stuffContainer = null;
        this.outputSprite.destroy(null);
        this.outputSprite = null;
        this.items = null;
        this.fruitslinks = null;
        this.fruits = null;
    }
}
exports.TextureAdvanced = TextureAdvanced;


/***/ }),

/***/ "./js-compile/examples/TextureGradientBasic.js":
/*!*****************************************************!*\
  !*** ./js-compile/examples/TextureGradientBasic.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class TextureGradientBasic extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        const gradTexture = this.createGradTexture();
        const sprite = new Sprite_1.Sprite(gradTexture);
        sprite.position.set(100, 100);
        sprite.rotation = Math.PI / 8;
        sprite.width = 500;
        sprite.height = 50;
        this.stage.addChild(sprite);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
    createGradTexture() {
        const quality = 256;
        const canvas = document.createElement('canvas');
        canvas.width = quality;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        const grd = ctx.createLinearGradient(0, 0, quality, 0);
        grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
        grd.addColorStop(0.3, 'cyan');
        grd.addColorStop(0.7, 'red');
        grd.addColorStop(1, 'green');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, quality, 1);
        return Texture_1.Texture.from(canvas);
    }
}
exports.TextureGradientBasic = TextureGradientBasic;


/***/ }),

/***/ "./js-compile/examples/TextureGradientResource.js":
/*!********************************************************!*\
  !*** ./js-compile/examples/TextureGradientResource.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Resource_1 = __webpack_require__(/*! ../raw-pixi-ts/Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class TextureGradientResource extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        const gradBaseTexture = new BaseTexture_1.BaseTexture(new GradientResource());
        gradBaseTexture.setSize(500, 50);
        const gradTexture = new Texture_1.Texture(gradBaseTexture);
        const sprite = new Sprite_1.Sprite(gradTexture);
        sprite.position.set(100, 100);
        sprite.rotation = Math.PI / 8;
        this.stage.addChild(sprite);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
}
exports.TextureGradientResource = TextureGradientResource;
class GradientResource extends Resource_1.Resource {
    constructor() {
        super(256, 100);
        this.canUpload = true;
    }
    upload(renderer, baseTexture, glTexture) {
        const { width } = this; // default size or from baseTexture?
        const { height } = this; // your choice.
        const canvas = document.createElement('canvas');
        this.source = canvas;
        this.source.width = width;
        this.source.height = height;
        const ctx = this.source.getContext('2d');
        const grd = ctx.createLinearGradient(0, 0, width, 0);
        grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
        grd.addColorStop(0.3, 'cyan');
        grd.addColorStop(0.7, 'red');
        grd.addColorStop(1, 'green');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);
        glTexture.width = width;
        glTexture.height = height;
        const { gl } = renderer;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, this.source);
        return true;
    }
}


/***/ }),

/***/ "./js-compile/examples/TextureRender.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/TextureRender.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const BaseRenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseRenderTexture */ "./js-compile/raw-pixi-ts/BaseRenderTexture.js");
const RenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
class TextureRender extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.container = new Container_1.Container();
            this.stage.addChild(this.container);
            for (let i = 0; i < 25; i++) {
                const bunny = new Sprite_1.Sprite(txt);
                bunny.x = (i % 5) * 30;
                bunny.y = Math.floor(i / 5) * 30;
                bunny.rotation = Math.random() * (Math.PI * 2);
                this.container.addChild(bunny);
            }
            const brt = new BaseRenderTexture_1.BaseRenderTexture(300, 300, WebGLSettings_1.WebGLSettings.SCALE_MODES.LINEAR, 1);
            this.rt = new RenderTexture_1.RenderTexture(brt);
            const sprite = new Sprite_1.Sprite(this.rt);
            sprite.x = 450;
            sprite.y = 60;
            this.stage.addChild(sprite);
            this.container.x = 100;
            this.container.y = 60;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.app.renderer.render(this.container, this.rt);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.container.destroy(null);
        this.container = null;
        this.rt.destroy(null);
        this.rt = null;
    }
}
exports.TextureRender = TextureRender;


/***/ }),

/***/ "./js-compile/examples/TextureRotate.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/TextureRotate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const GroupD8_1 = __webpack_require__(/*! ../raw-pixi-ts/GroupD8 */ "./js-compile/raw-pixi-ts/GroupD8.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
class TextureRotate extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const textures = [txt];
            const D8 = GroupD8_1.GroupD8;
            for (let rotate = 1; rotate < 16; rotate++) {
                const h = D8.isVertical(rotate) ? txt.frame.width : txt.frame.height;
                const w = D8.isVertical(rotate) ? txt.frame.height : txt.frame.width;
                const { frame } = txt;
                const crop = new Rectangle_1.Rectangle(txt.frame.x, txt.frame.y, w, h);
                const trim = crop;
                let rotatedTexture;
                if (rotate % 2 === 0) {
                    rotatedTexture = new Texture_1.Texture(txt.baseTexture, frame, crop, trim, rotate);
                }
                else {
                    rotatedTexture = new Texture_1.Texture(txt.baseTexture, frame, crop, trim, rotate - 1);
                    rotatedTexture.rotate++;
                }
                textures.push(rotatedTexture);
            }
            const offsetX = this.sizew / 16 | 0;
            const offsetY = this.sizeh / 8 | 0;
            const gridW = this.sizew / 4 | 0;
            const gridH = this.sizeh / 5 | 0;
            for (let i = 0; i < 16; i++) {
                const dude = new Sprite_1.Sprite(textures[i < 8 ? i * 2 : (i - 8) * 2 + 1]);
                dude.scale.x = 0.5;
                dude.scale.y = 0.5;
                dude.x = offsetX + gridW * (i % 4);
                dude.y = offsetY + gridH * (i / 4 | 0);
                this.stage.addChild(dude);
                const text = new Text_1.Text(`rotate = ${dude.texture.rotate}`, {
                    fontFamily: 'Courier New', fontSize: '12px', fill: 'white', align: 'left',
                });
                text.x = dude.x;
                text.y = dude.y - 20;
                this.stage.addChild(text);
            }
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
}
exports.TextureRotate = TextureRotate;


/***/ }),

/***/ "./js-compile/examples/controls/ExampleDisplay.js":
/*!********************************************************!*\
  !*** ./js-compile/examples/controls/ExampleDisplay.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const ExampleList_1 = __webpack_require__(/*! ./ExampleList */ "./js-compile/examples/controls/ExampleList.js");
const AdvancedCard_1 = __webpack_require__(/*! ../AdvancedCard */ "./js-compile/examples/AdvancedCard.js");
const AdvancedSlots_1 = __webpack_require__(/*! ../AdvancedSlots */ "./js-compile/examples/AdvancedSlots.js");
const AdvancedTrail_1 = __webpack_require__(/*! ../AdvancedTrail */ "./js-compile/examples/AdvancedTrail.js");
const AdvancedWarp_1 = __webpack_require__(/*! ../AdvancedWarp */ "./js-compile/examples/AdvancedWarp.js");
const BasicBlend_1 = __webpack_require__(/*! ../BasicBlend */ "./js-compile/examples/BasicBlend.js");
const InteractionIcon_1 = __webpack_require__(/*! ../InteractionIcon */ "./js-compile/examples/InteractionIcon.js");
const SpriteVideo_1 = __webpack_require__(/*! ../SpriteVideo */ "./js-compile/examples/SpriteVideo.js");
const TextureRotate_1 = __webpack_require__(/*! ../TextureRotate */ "./js-compile/examples/TextureRotate.js");
const BasicContainer_1 = __webpack_require__(/*! ../BasicContainer */ "./js-compile/examples/BasicContainer.js");
const BasicTinting_1 = __webpack_require__(/*! ../BasicTinting */ "./js-compile/examples/BasicTinting.js");
const BasicParticles_1 = __webpack_require__(/*! ../BasicParticles */ "./js-compile/examples/BasicParticles.js");
const GraphicsSimple_1 = __webpack_require__(/*! ../GraphicsSimple */ "./js-compile/examples/GraphicsSimple.js");
const GraphicsAdvanced_1 = __webpack_require__(/*! ../GraphicsAdvanced */ "./js-compile/examples/GraphicsAdvanced.js");
const GraphicsDynamic_1 = __webpack_require__(/*! ../GraphicsDynamic */ "./js-compile/examples/GraphicsDynamic.js");
const TextureRender_1 = __webpack_require__(/*! ../TextureRender */ "./js-compile/examples/TextureRender.js");
const TextureAdvanced_1 = __webpack_require__(/*! ../TextureAdvanced */ "./js-compile/examples/TextureAdvanced.js");
const TextureGradientBasic_1 = __webpack_require__(/*! ../TextureGradientBasic */ "./js-compile/examples/TextureGradientBasic.js");
const TextureGradientResource_1 = __webpack_require__(/*! ../TextureGradientResource */ "./js-compile/examples/TextureGradientResource.js");
const TextBase_1 = __webpack_require__(/*! ../TextBase */ "./js-compile/examples/TextBase.js");
const TextBitmap_1 = __webpack_require__(/*! ../TextBitmap */ "./js-compile/examples/TextBitmap.js");
const TextWebFont_1 = __webpack_require__(/*! ../TextWebFont */ "./js-compile/examples/TextWebFont.js");
const MaskGraphics_1 = __webpack_require__(/*! ../MaskGraphics */ "./js-compile/examples/MaskGraphics.js");
const MaskSprite_1 = __webpack_require__(/*! ../MaskSprite */ "./js-compile/examples/MaskSprite.js");
const FilterBlur_1 = __webpack_require__(/*! ../FilterBlur */ "./js-compile/examples/FilterBlur.js");
const FilterColor_1 = __webpack_require__(/*! ../FilterColor */ "./js-compile/examples/FilterColor.js");
const FilterCrawlies_1 = __webpack_require__(/*! ../FilterCrawlies */ "./js-compile/examples/FilterCrawlies.js");
const FilterFlag_1 = __webpack_require__(/*! ../FilterFlag */ "./js-compile/examples/FilterFlag.js");
const MaskFilter_1 = __webpack_require__(/*! ../MaskFilter */ "./js-compile/examples/MaskFilter.js");
const InteractionClick_1 = __webpack_require__(/*! ../InteractionClick */ "./js-compile/examples/InteractionClick.js");
const InteractionInteractivity_1 = __webpack_require__(/*! ../InteractionInteractivity */ "./js-compile/examples/InteractionInteractivity.js");
const InteractionDragging_1 = __webpack_require__(/*! ../InteractionDragging */ "./js-compile/examples/InteractionDragging.js");
const SpriteBasic_1 = __webpack_require__(/*! ../SpriteBasic */ "./js-compile/examples/SpriteBasic.js");
const SpriteSwap_1 = __webpack_require__(/*! ../SpriteSwap */ "./js-compile/examples/SpriteSwap.js");
const SpriteTiling_1 = __webpack_require__(/*! ../SpriteTiling */ "./js-compile/examples/SpriteTiling.js");
const SpriteExplosion_1 = __webpack_require__(/*! ../SpriteExplosion */ "./js-compile/examples/SpriteExplosion.js");
const Spritejet_1 = __webpack_require__(/*! ../Spritejet */ "./js-compile/examples/Spritejet.js");
const SpriteSpeed_1 = __webpack_require__(/*! ../SpriteSpeed */ "./js-compile/examples/SpriteSpeed.js");
const FilterBlending_1 = __webpack_require__(/*! ../FilterBlending */ "./js-compile/examples/FilterBlending.js");
const FilterCustom_1 = __webpack_require__(/*! ../FilterCustom */ "./js-compile/examples/FilterCustom.js");
const FilterShadow_1 = __webpack_require__(/*! ../FilterShadow */ "./js-compile/examples/FilterShadow.js");
const MeshBasic_1 = __webpack_require__(/*! ../MeshBasic */ "./js-compile/examples/MeshBasic.js");
const MeshAdvanced_1 = __webpack_require__(/*! ../MeshAdvanced */ "./js-compile/examples/MeshAdvanced.js");
const MeshTriangle_1 = __webpack_require__(/*! ../MeshTriangle */ "./js-compile/examples/MeshTriangle.js");
const MeshColoredTriangle_1 = __webpack_require__(/*! ../MeshColoredTriangle */ "./js-compile/examples/MeshColoredTriangle.js");
const MeshTextured_1 = __webpack_require__(/*! ../MeshTextured */ "./js-compile/examples/MeshTextured.js");
const MeshUniforms_1 = __webpack_require__(/*! ../MeshUniforms */ "./js-compile/examples/MeshUniforms.js");
const MeshGeometry_1 = __webpack_require__(/*! ../MeshGeometry */ "./js-compile/examples/MeshGeometry.js");
const MeshShader_1 = __webpack_require__(/*! ../MeshShader */ "./js-compile/examples/MeshShader.js");
const Event_1 = __webpack_require__(/*! ../../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class ExampleDisplay extends Container_1.Container {
    constructor(app, displayWidth, displayheight) {
        super();
        this.handleExampleRequest = (event) => {
            this.setExample(this.list.selectedClass);
        };
        this.handleComplete = (event) => {
            this.list.addEventListener(Event_1.Event.CHANGE, this.handleExampleRequest);
        };
        let controlSize = 200;
        this.app = app;
        this.background = new Graphics_1.Graphics();
        this.refreshBackground(0x969696);
        app.stage.addChild(this.background);
        this.stageLayer = new Container_1.Container();
        app.stage.addChild(this.stageLayer);
        this.list = new ExampleList_1.ExampleList(controlSize, displayheight);
        this.list.x = displayWidth - controlSize;
        displayWidth = displayWidth - controlSize;
        app.stage.addChild(this.list);
        this.controlLayer = new Container_1.Container();
        app.stage.addChild(this.controlLayer);
        this.framesize = 5;
        this.exampleWidth = displayWidth; //(displayWidth - controlSize) - (this.framesize / 2)
        this.exampleheight = displayheight - (this.framesize / 2);
        this.frame = new Graphics_1.Graphics();
        this.frame.beginFill(0x000FFF);
        this.frame.drawRect(0, 0, this.framesize, displayheight);
        this.frame.drawRect(displayWidth - this.framesize, 0, 5, displayheight);
        this.frame.drawRect(this.framesize, 0, displayWidth - (this.framesize * 2), this.framesize);
        this.frame.drawRect(this.framesize, displayheight - this.framesize, displayWidth - (this.framesize * 2), this.framesize);
        this.controlLayer.addChild(this.frame);
        this.list.addExample("Sprite Basic", SpriteBasic_1.SpriteBasic);
        this.list.addExample("Sprite Reveal", AdvancedCard_1.AdvancedCard);
        this.list.addExample("Sprite Slots", AdvancedSlots_1.AdvancedSlots);
        this.list.addExample("Sprite Trail", AdvancedTrail_1.AdvancedTrail);
        this.list.addExample("Sprite Warp", AdvancedWarp_1.AdvancedWarp);
        this.list.addExample("Sprite Blend", BasicBlend_1.BasicBlend);
        this.list.addExample("Sprite Tinting", BasicTinting_1.BasicTinting);
        this.list.addExample("Sprite Video", SpriteVideo_1.SpriteVideo);
        this.list.addExample("Sprite Tiling", SpriteTiling_1.SpriteTiling);
        this.list.addExample("Sprite Animation", SpriteExplosion_1.SpriteExplosion);
        this.list.addExample("Sprite Animation 2", Spritejet_1.Spritejet);
        this.list.addExample("Sprite Animation 3", SpriteSpeed_1.SpriteSpeed);
        this.list.addExample("Graphics Basic", GraphicsSimple_1.GraphicsSimple);
        this.list.addExample("Graphics Advanced", GraphicsAdvanced_1.GraphicsAdvanced);
        this.list.addExample("Graphics Dynamic", GraphicsDynamic_1.GraphicsDynamic);
        this.list.addExample("Container", BasicContainer_1.BasicContainer);
        this.list.addExample("Mask Graphics", MaskGraphics_1.MaskGraphics);
        this.list.addExample("Mask Sprite", MaskSprite_1.MaskSprite);
        this.list.addExample("Particles", BasicParticles_1.BasicParticles);
        this.list.addExample("Text", TextBase_1.TextBase);
        this.list.addExample("Text Bitmap", TextBitmap_1.TextBitmap);
        this.list.addExample("Text WebFont", TextWebFont_1.TextWebFont);
        this.list.addExample("Interaction", InteractionInteractivity_1.InteractionInteractivity);
        this.list.addExample("Interaction Click", InteractionClick_1.InteractionClick);
        this.list.addExample("Interaction Drag", InteractionDragging_1.InteractionDragging);
        this.list.addExample("Interaction Icon", InteractionIcon_1.InteractionIcon);
        this.list.addExample("texture Swap", SpriteSwap_1.SpriteSwap);
        this.list.addExample("Texture Advanced", TextureAdvanced_1.TextureAdvanced);
        this.list.addExample("Texture Gradient", TextureGradientBasic_1.TextureGradientBasic);
        this.list.addExample("Texture Gradient 2", TextureGradientResource_1.TextureGradientResource);
        this.list.addExample("Texture Rotate", TextureRotate_1.TextureRotate);
        this.list.addExample("Texture Render", TextureRender_1.TextureRender);
        this.list.addExample("Filter Blur", FilterBlur_1.FilterBlur);
        this.list.addExample("Filter ColorMatrix", FilterColor_1.FilterColor);
        this.list.addExample("Filter Displacement", FilterCrawlies_1.FilterCrawlies);
        this.list.addExample("Filter Displacement 2", FilterFlag_1.FilterFlag);
        this.list.addExample("Filter Blur 2", MaskFilter_1.MaskFilter);
        this.list.addExample("Filter Blending", FilterBlending_1.FilterBlending);
        this.list.addExample("Filter Custom", FilterCustom_1.FilterCustom);
        this.list.addExample("Filter Shadow", FilterShadow_1.FilterShadow);
        this.list.addExample("Mesh Basic", MeshBasic_1.MeshBasic);
        this.list.addExample("Mesh Triangle", MeshTriangle_1.MeshTriangle);
        this.list.addExample("Mesh Triangle 2", MeshColoredTriangle_1.MeshColoredTriangle);
        this.list.addExample("Mesh Texture", MeshTextured_1.MeshTextured);
        this.list.addExample("Mesh Advanced", MeshAdvanced_1.MeshAdvanced);
        this.list.addExample("Mesh Uniforms", MeshUniforms_1.MeshUniforms);
        this.list.addExample("Mesh Geometry", MeshGeometry_1.MeshGeometry);
        this.list.addExample("Mesh Shader", MeshShader_1.MeshShader);
        this.setExample(SpriteBasic_1.SpriteBasic);
    }
    setExample(keyclass) {
        this.list.removeEventListener(Event_1.Event.CHANGE, this.handleExampleRequest);
        if (this.currentExample) {
            this.currentExample.destructor();
        }
        this.currentExample = new keyclass(this.app, this.exampleWidth, this.exampleheight);
        this.currentExample.addEventListener(Event_1.Event.COMPLETE, this.handleComplete);
        // this.currentExample.stage.x = this.currentExample.stage.y = this.framesize;
        this.stageLayer.removeChildren();
        this.stageLayer.addChild(this.currentExample.stage);
        this.refreshBackground(this.currentExample.backColor);
    }
    refreshBackground(color) {
        this.background.clear();
        this.background.beginFill(color);
        this.background.drawRect(0, 0, this.exampleWidth, this.exampleheight);
    }
}
exports.ExampleDisplay = ExampleDisplay;


/***/ }),

/***/ "./js-compile/examples/controls/ExampleList.js":
/*!*****************************************************!*\
  !*** ./js-compile/examples/controls/ExampleList.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Button_1 = __webpack_require__(/*! ../../fl-package/Button */ "./js-compile/fl-package/Button.js");
const Graphics_1 = __webpack_require__(/*! ../../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Event_1 = __webpack_require__(/*! ../../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class ExampleList extends Container_1.Container {
    constructor(displayWidth, displayheight) {
        super();
        this.handleScrollChange = (event) => {
            this.listContainer.y = this.scroll.targetPosition;
        };
        this.handleButtonTap = (event) => {
            this._selectedClass = this.classReference[event.currentTarget.name];
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.CHANGE));
        };
        this.buttons = [];
        this.classReference = {};
        this.itemGap = 2;
        this.sideGap = 2;
        this.listContainer = new Container_1.Container();
        this.addChild(this.listContainer);
        this.listmask = new Graphics_1.Graphics();
        this.listmask.beginFill(0);
        this.listmask.drawRect(0, 0, displayWidth, displayheight);
        this.listContainer.mask = this.listmask;
        this.addChild(this.listmask);
        let gr = new Graphics_1.Graphics();
        gr.beginFill(0xAAA0AA);
        gr.drawRect(0, 0, 25, displayheight);
        this.addChild(gr);
        gr.x = displayWidth - 25;
        this.buttonWidth = displayWidth - 25 - (this.sideGap * 2);
        this.buttonheight = 40;
        this.scroll = new ScrollBar();
        this.addChild(this.scroll);
        this.scroll.x = displayWidth - 25;
        this.scroll.scrollArea = displayheight;
        this.scroll.addEventListener(Event_1.Event.CHANGE, this.handleScrollChange);
    }
    get selectedClass() {
        return this._selectedClass;
    }
    addExample(keyname, keyclass) {
        let button = new Button_1.Button(keyname, this.buttonWidth, this.buttonheight);
        button.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handleButtonTap);
        this.buttons.push(button);
        button.name = keyname;
        button.x = this.sideGap;
        this.listContainer.addChild(button);
        this.classReference[keyname] = keyclass;
        this.refreshList();
    }
    refreshList() {
        let start = this.itemGap;
        for (let button of this.buttons) {
            button.y = start;
            start += button.height + this.itemGap;
        }
        this.scroll.scrollDistance = start;
    }
}
exports.ExampleList = ExampleList;
class ScrollBar extends Container_1.Container {
    constructor() {
        super();
        this.handleHandleUp = (event) => {
            this.dragging = false;
            this.eventData = null;
        };
        this.handleHandleMove = (event) => {
            if (this.eventData) {
                const newPosition = this.eventData.getLocalPosition(this._handle.parent);
                this._handle.y = newPosition.y - (this._handle.height / 2);
                if (this._handle.y > this._scrollArea) {
                    this._handle.y = this._scrollArea;
                }
                else if (this._handle.y < 0) {
                    this._handle.y = 0;
                }
                this.areaPercent = this._handle.y / this._scrollArea;
                this._targetPosition = (this._scrollDistance - this._visibleArea) * this.areaPercent * -1;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.CHANGE));
            }
        };
        this.handleHandleDown = (event) => {
            this.dragging = true;
            this.eventData = event.data;
        };
        this._handle = new Graphics_1.Graphics();
        this._handle.beginFill(0x636363);
        this._handle.drawRect(0, 0, 25, 25);
        this.addChild(this._handle);
        this._handle.buttonMode = this._handle.interactive = true;
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleHandleDown);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.handleHandleUp);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.handleHandleUp);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.handleHandleMove);
    }
    get targetPosition() {
        return this._targetPosition;
    }
    set scrollDistance(value) {
        this._scrollDistance = value;
    }
    set scrollArea(value) {
        this._scrollArea = value - 25;
        this._visibleArea = value;
    }
}


/***/ }),

/***/ "./js-compile/fl-package/Button.js":
/*!*****************************************!*\
  !*** ./js-compile/fl-package/Button.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const TextStyle_1 = __webpack_require__(/*! ../raw-pixi-ts/TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
class Button extends Container_1.Container {
    constructor(caption, buttonWidth = 150, buttonheight = 40) {
        super();
        this.handleOut = (event) => {
            this.buttongraphic.visible = true;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = false;
        };
        this.handleOver = (event) => {
            this.buttongraphic.visible = false;
            this.buttonovergraphic.visible = true;
            this.buttondowngraphic.visible = false;
        };
        this.handleUp = (event) => {
            this.buttongraphic.visible = true;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = false;
        };
        this.handleDown = (event) => {
            this.buttongraphic.visible = false;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = true;
        };
        this.interactive = true;
        this.buttongraphic = new Graphics_1.Graphics();
        this.buttongraphic.beginFill(0x969696);
        this.buttongraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttongraphic);
        this.buttonovergraphic = new Graphics_1.Graphics();
        this.buttonovergraphic.beginFill(0xB9B9B9);
        this.buttonovergraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttonovergraphic);
        this.buttonovergraphic.visible = false;
        this.buttondowngraphic = new Graphics_1.Graphics();
        this.buttondowngraphic.beginFill(0x636363);
        this.buttondowngraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttondowngraphic);
        this.buttondowngraphic.visible = false;
        let style = new TextStyle_1.TextStyle({});
        style.fontSize = 16;
        style.align = "center";
        style.fontFamily = "Arial";
        this.label = new Text_1.Text(caption, style);
        this.label.interactive = false;
        this.label.y = (buttonheight - (this.label.height)) / 2;
        this.label.x = (buttonWidth / 2 - this.label.width / 2);
        this.addChild(this.label);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleDown);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_OVER, this.handleOver);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.handleUp);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_OUT, this.handleOut);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.handleOut);
    }
}
exports.Button = Button;


/***/ }),

/***/ "./js-compile/index.js":
/*!*****************************!*\
  !*** ./js-compile/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Application_1 = __webpack_require__(/*! ./raw-pixi-ts/Application */ "./js-compile/raw-pixi-ts/Application.js");
const StageOptions_1 = __webpack_require__(/*! ./raw-pixi-ts/StageOptions */ "./js-compile/raw-pixi-ts/StageOptions.js");
const ExampleDisplay_1 = __webpack_require__(/*! ./examples/controls/ExampleDisplay */ "./js-compile/examples/controls/ExampleDisplay.js");
window.addEventListener("load", () => {
    var options = new StageOptions_1.StageOptions();
    options.width = 1000;
    options.height = 600;
    options.autoResize = false;
    options.backgroundColor = 0x00000000;
    options.clearBeforeRender = true;
    options.resolution = 1;
    options.autoStart = true;
    options.transparent = true;
    options.antialias = true;
    options.view = document.getElementById("fakecanvas");
    var app = new Application_1.Application(options);
    let display = new ExampleDisplay_1.ExampleDisplay(app, 1024, 768);
    app.stage.addChild(display);
    // create a view class with frame
    // create a control class with buttons
    // each button click change content of class frame
    // let button:Button = new Button("Test", 200, 40);
    // app.stage.addChild(button);
    // button.x = 800;
    // let example:BasicCache = new BasicCache(app); NOT WORKING
    // let example:InteractionIcon = new InteractionIcon(app);
    // let example:SpriteVideo = new SpriteVideo(app);
    // let example:AdvancedSlots = new AdvancedSlots(app); 
    // let example:TextureRotate = new TextureRotate(app); 
    // let example:BasicContainer = new BasicContainer(app);
    // let example:BasicBackground = new BasicBackground(app);
    // let example:BasicTinting = new BasicTinting(app);    
    // let example:BasicParticles = new BasicParticles(app);
    // let example:BasicBlend = new BasicBlend(app);    
    // let example:GraphicsSimple = new GraphicsSimple(app);
    // let example:GraphicsAdvanced = new GraphicsAdvanced(app);
    // let example:GraphicsDynamic = new GraphicsDynamic(app);
    // let example:TextureRender = new TextureRender(app);
    // let example:TextureAdvanced = new TextureAdvanced(app);
    // let example:TextureGradientBasic = new TextureGradientBasic(app);
    // let example:TextureGradientResource = new TextureGradientResource(app);
    // let example:TextBase = new TextBase(app);
    // let example:TextBitmap = new TextBitmap(app); 
    // let example:TextWebFont = new TextWebFont(app); 
    // let example:MaskGraphics = new MaskGraphics(app);
    // let example:MaskSprite = new MaskSprite(app);
    // let example:FilterBlur = new FilterBlur(app);
    // let example:FilterColor = new FilterColor(app);
    // let example:FilterCrawlies = new FilterCrawlies(app);
    // let example:FilterFlag = new FilterFlag(app);
    // let example:MaskFilter = new MaskFilter(app);
    // let example:InteractionClick = new InteractionClick(app);
    // let example:InteractionInteractivity = new InteractionInteractivity(app);
    // let example:InteractionDragging = new InteractionDragging(app); 
    // let example:SpriteBasic = new SpriteBasic(app);  
    // let example:SpriteSwap = new SpriteSwap(app);    
    // let example:SpriteTiling = new SpriteTiling(app);    
    // let example:SpriteExplosion = new SpriteExplosion(app);
    // let example:Spritejet = new Spritejet(app); 
    // let example:SpriteSpeed = new SpriteSpeed(app); 
    // let example:AdvancedCard = new AdvancedCard(app); 
    // let example:AdvancedTrail = new AdvancedTrail(app); 
    // let example:AdvancedWarp = new AdvancedWarp(app); 
    // let example:FilterBlending = new FilterBlending(app); 
    // let example:FilterCustom = new FilterCustom(app); 
    // let example:FilterShadow = new FilterShadow(app); 
    // let example:MeshBasic = new MeshBasic(app);
    // let example:MeshAdvanced = new MeshAdvanced(app);
    // let example:MeshTriangle = new MeshTriangle(app);
    // let example:MeshColoredTriangle = new MeshColoredTriangle(app);
    // let example:MeshTextured = new MeshTextured(app);
    // let example:MeshUniforms = new MeshUniforms(app);
    // let example:MeshGeometry = new MeshGeometry(app);
    // let example:MeshShader = new MeshShader(app);
});


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AbstractRenderer.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AbstractRenderer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class AbstractRenderer extends EventDispatcher_1.EventDispatcher {
    constructor(system, options) {
        super();
        if (options.roundPixels) {
            DisplaySettings_1.DisplaySettings.ROUND_PIXELS = options.roundPixels;
        }
        this.options = options;
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.UNKNOWN;
        this.screen = new Rectangle_1.Rectangle(0, 0, options.width, options.height);
        this.view = options.view || document.createElement('canvas');
        this.resolution = options.resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.transparent = options.transparent;
        this.autoDensity = options.autoDensity || options.autoResize || false;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.clearBeforeRender = options.clearBeforeRender;
        this._backgroundColor = 0x000000;
        this._backgroundColorRgba = [0, 0, 0, 0];
        this._backgroundColorString = '#000000';
        this.backgroundColor = options.backgroundColor || this._backgroundColor;
        this._tempDisplayObjectParent = new Container_1.Container();
        this._lastObjectRendered = this._tempDisplayObjectParent;
        this.blendModes = 0;
    }
    resize(screenWidth, screenHeight) {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;
        if (this.autoDensity) {
            this.view.style.width = screenWidth + "px";
            this.view.style.height = screenHeight + "px";
        }
    }
    ;
    get width() {
        return this.view.width;
    }
    ;
    get height() {
        return this.view.height;
    }
    ;
    generateTexture(displayObject, scaleMode, resolution, region) {
        region = region || displayObject.getLocalBounds();
        if (region.width === 0) {
            region.width = 1;
        }
        if (region.height === 0) {
            region.height = 1;
        }
        var renderTexture = RenderTexture_1.RenderTexture.create(region.width | 0, region.height | 0, scaleMode, resolution);
        AbstractRenderer.tempMatrix.tx = -region.x;
        AbstractRenderer.tempMatrix.ty = -region.y;
        this.render(displayObject, renderTexture, false, AbstractRenderer.tempMatrix, !!displayObject.parent);
        return renderTexture;
    }
    ;
    render(displayObject, renderTexture, b, m, parent) {
    }
    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     */
    destroy(removeView) {
        // for (var o in this.plugins)
        // {
        //     this.plugins[o].destroy();
        //     this.plugins[o] = null;
        // }
        if (removeView && this.view.parentNode) {
            this.view.parentNode.removeChild(this.view);
        }
        // this.plugins = null;
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.UNKNOWN;
        this.view = null;
        this.screen = null;
        this.resolution = 0;
        this.transparent = false;
        this.autoDensity = false;
        this.blendModes = null;
        this.options = null;
        this.preserveDrawingBuffer = false;
        this.clearBeforeRender = false;
        this._backgroundColor = 0;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._tempDisplayObjectParent = null;
        this._lastObjectRendered = null;
    }
    ;
    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     */
    get backgroundColor() {
        return this._backgroundColor;
    }
    ;
    set backgroundColor(value) {
        this._backgroundColor = value;
        this._backgroundColorString = MathSettings_1.MathSettings.hex2string(value);
        ColorSettings_1.ColorSettings.hex2rgb(value, this._backgroundColorRgba);
    }
    ;
}
AbstractRenderer.tempMatrix = new Matrix_1.Matrix();
exports.AbstractRenderer = AbstractRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AccessibilityManager.js":
/*!********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AccessibilityManager.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// import { settings } from './settings';
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class AccessibilityManager {
    constructor(renderer) {
        /**
                 * @type {?HTMLElement}
                 * @private
                 */
        this._hookDiv = null;
        // if (settings.isMobile_min.tablet || settings.isMobile_min.phone)
        // {
        this.createTouchHook();
        // }
        // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.
        var div = document.createElement('div');
        div.style.width = AccessibilityManager.DIV_TOUCH_SIZE + "px";
        div.style.height = AccessibilityManager.DIV_TOUCH_SIZE + "px";
        div.style.position = 'absolute';
        div.style.top = AccessibilityManager.DIV_TOUCH_POS_X + "px";
        div.style.left = AccessibilityManager.DIV_TOUCH_POS_Y + "px";
        div.style.zIndex = AccessibilityManager.DIV_TOUCH_ZINDEX.toString();
        /**
         * This is the dom element that will sit over the PixiJS element. This is where the div overlays will go.
         *
         * @type {HTMLElement}
         * @private
         */
        this.div = div;
        /**
         * A simple pool for storing divs.
         *
         * @type {*}
         * @private
         */
        this.pool = [];
        /**
         * This is a tick used to check if an object is no longer being rendered.
         *
         * @type {Number}
         * @private
         */
        this.renderId = 0;
        /**
         * Setting this to true will visually show the divs.
         *
         * @type {boolean}
         */
        this.debug = false;
        /**
         * The renderer this accessibility manager works for.
         *
         * @member {PIXI.AbstractRenderer}
         */
        this.renderer = renderer;
        /**
         * The array of currently active accessible items.
         *
         * @member {Array<*>}
         * @private
         */
        this.children = [];
        /**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */
        this._onKeyDown = this._onKeyDown.bind(this);
        /**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */
        this._onMouseMove = this._onMouseMove.bind(this);
        /**
         * A flag
         * @type {boolean}
         * @readonly
         */
        this.isActive = false;
        /**
         * A flag
         * @type {boolean}
         * @readonly
         */
        this.isMobileAccessibility = false;
        // let listen for tab.. once pressed we can fire up and show the accessibility layer
        window.addEventListener('keydown', this._onKeyDown, false);
    }
    /**
     * Creates the touch hooks.
     *
     * @private
     */
    createTouchHook() {
        var this$1 = this;
        var hookDiv = document.createElement('button');
        hookDiv.style.width = AccessibilityManager.DIV_HOOK_SIZE + "px";
        hookDiv.style.height = AccessibilityManager.DIV_HOOK_SIZE + "px";
        hookDiv.style.position = 'absolute';
        hookDiv.style.top = AccessibilityManager.DIV_HOOK_POS_X + "px";
        hookDiv.style.left = AccessibilityManager.DIV_HOOK_POS_Y + "px";
        hookDiv.style.zIndex = AccessibilityManager.DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = '#FF0000';
        hookDiv.title = 'HOOK DIV';
        hookDiv.addEventListener('focus', function () {
            this$1.isMobileAccessibility = true;
            this$1.activate();
            this$1.destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
    }
    ;
    /**
     * Destroys the touch hooks.
     *
     * @private
     */
    destroyTouchHook() {
        if (!this._hookDiv) {
            return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
    }
    ;
    /**
     * Activating will cause the Accessibility layer to be shown.
     * This is called when a user presses the tab key.
     *
     * @private
     */
    activate() {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        window.document.addEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown, false);
        this.renderer.on('postrender', this.update, this);
        if (this.renderer.view.parentNode) {
            this.renderer.view.parentNode.appendChild(this.div);
        }
    }
    ;
    /**
     * Deactivating will cause the Accessibility layer to be hidden.
     * This is called when a user moves the mouse.
     *
     * @private
     */
    deactivate() {
        if (!this.isActive || this.isMobileAccessibility) {
            return;
        }
        this.isActive = false;
        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.addEventListener('keydown', this._onKeyDown, false);
        this.renderer.off('postrender', this.update);
        if (this.div.parentNode) {
            this.div.parentNode.removeChild(this.div);
        }
    }
    ;
    /**
     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
     *
     * @private
     * @param {PIXI.Container} displayObject - The DisplayObject to check.
     */
    updateAccessibleObjects(displayObject) {
        if (!displayObject.visible) {
            return;
        }
        if (displayObject.accessible && displayObject.interactive) {
            if (!displayObject._accessibleActive) {
                this.addChild(displayObject);
            }
            displayObject.renderId = this.renderId;
        }
        var children = displayObject.children;
        for (var i = 0; i < children.length; i++) {
            this.updateAccessibleObjects(children[i]);
        }
    }
    ;
    /**
     * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
     *
     * @private
     */
    update() {
        if (!this.renderer.renderingToScreen) {
            return;
        }
        // update children...
        this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var rect = this.renderer.view.getBoundingClientRect();
        var sx = rect.width / this.renderer.width;
        var sy = rect.height / this.renderer.height;
        var div = this.div;
        div.style.left = (rect.left) + "px";
        div.style.top = (rect.top) + "px";
        div.style.width = (this.renderer.width) + "px";
        div.style.height = (this.renderer.height) + "px";
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (child.renderId !== this.renderId) {
                child._accessibleActive = false;
                UtilsSettings_1.UtilsSettings.removeItems(this.children, i, 1);
                this.div.removeChild(child._accessibleDiv);
                this.pool.push(child._accessibleDiv);
                child._accessibleDiv = null;
                i--;
                if (this.children.length === 0) {
                    this.deactivate();
                }
            }
            else {
                // map div to display..
                div = child._accessibleDiv;
                var hitArea = child.hitArea;
                var wt = child.worldTransform;
                if (child.hitArea) {
                    div.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + "px";
                    div.style.top = ((wt.ty + (hitArea.y * wt.d)) * sy) + "px";
                    div.style.width = (hitArea.width * wt.a * sx) + "px";
                    div.style.height = (hitArea.height * wt.d * sy) + "px";
                }
                else {
                    hitArea = child.getBounds();
                    this.capHitArea(hitArea);
                    div.style.left = (hitArea.x * sx) + "px";
                    div.style.top = (hitArea.y * sy) + "px";
                    div.style.width = (hitArea.width * sx) + "px";
                    div.style.height = (hitArea.height * sy) + "px";
                    // update button titles and hints if they exist and they've changed
                    if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                        div.title = child.accessibleTitle;
                    }
                    if (div.getAttribute('aria-label') !== child.accessibleHint
                        && child.accessibleHint !== null) {
                        div.setAttribute('aria-label', child.accessibleHint);
                    }
                }
            }
        }
        // increment the render id..
        this.renderId++;
    }
    ;
    /**
     * Adjust the hit area based on the bounds of a display object
     *
     * @param {Rectangle} hitArea - Bounds of the child
     */
    capHitArea(hitArea) {
        if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
        }
        if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
        }
        if (hitArea.x + hitArea.width > this.renderer.width) {
            hitArea.width = this.renderer.width - hitArea.x;
        }
        if (hitArea.y + hitArea.height > this.renderer.height) {
            hitArea.height = this.renderer.height - hitArea.y;
        }
    }
    ;
    /**
     * Adds a DisplayObject to the accessibility manager
     *
     * @private
     * @param {DisplayObject} displayObject - The child to make accessible.
     */
    addChild(displayObject) {
        //this.activate();
        var div = this.pool.pop();
        if (!div) {
            div = document.createElement('button');
            div.style.width = AccessibilityManager.DIV_TOUCH_SIZE + "px";
            div.style.height = AccessibilityManager.DIV_TOUCH_SIZE + "px";
            div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
            div.style.position = 'absolute';
            div.style.zIndex = AccessibilityManager.DIV_TOUCH_ZINDEX;
            div.style.borderStyle = 'none';
            // ARIA attributes ensure that button title and hint updates are announced properly
            if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.
                div.setAttribute('aria-live', 'off');
            }
            else {
                div.setAttribute('aria-live', 'polite');
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
                // FireFox needs this to announce only the new button name
                div.setAttribute('aria-relevant', 'additions');
            }
            else {
                // required by IE, other browsers don't much care
                div.setAttribute('aria-relevant', 'text');
            }
            div.addEventListener('click', this._onClick.bind(this));
            div.addEventListener('focus', this._onFocus.bind(this));
            div.addEventListener('focusout', this._onFocusOut.bind(this));
        }
        if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
            div.title = displayObject.accessibleTitle;
        }
        else if (!displayObject.accessibleHint
            || displayObject.accessibleHint === null) {
            div.title = "displayObject " + (displayObject.tabIndex);
        }
        if (displayObject.accessibleHint
            && displayObject.accessibleHint !== null) {
            div.setAttribute('aria-label', displayObject.accessibleHint);
        }
        //
        displayObject._accessibleActive = true;
        displayObject._accessibleDiv = div;
        div.displayObject = displayObject;
        this.children.push(displayObject);
        this.div.appendChild(displayObject._accessibleDiv);
        displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
    }
    ;
    /**
     * Maps the div button press to pixi's  (click)
     *
     * @private
     * @param {MouseEvent} e - The click event.
     */
    _onClick(e) {
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
    }
    ;
    /**
     * Maps the div focus events to pixi's  (mouseover)
     *
     * @private
     * @param {FocusEvent} e - The focus event.
     */
    _onFocus(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'assertive');
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
    }
    ;
    /**
     * Maps the div focus events to pixi's  (mouseout)
     *
     * @private
     * @param {FocusEvent} e - The focusout event.
     */
    _onFocusOut(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'polite');
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
    }
    ;
    /**
     * Is called when a key is pressed
     *
     * @private
     * @param {KeyboardEvent} e - The keydown event.
     */
    _onKeyDown(e) {
        if (e.keyCode !== AccessibilityManager.KEY_CODE_TAB) {
            return;
        }
        this.activate();
    }
    ;
    /**
     * Is called when the mouse moves across the renderer element
     *
     * @private
     * @param {MouseEvent} e - The mouse event.
     */
    _onMouseMove(e) {
        if (e.movementX === 0 && e.movementY === 0) {
            return;
        }
        this.deactivate();
    }
    ;
    /**
     * Destroys the accessibility manager
     *
     */
    destroy() {
        this.destroyTouchHook();
        this.div = null;
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].div = null;
        }
        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown);
        this.pool = null;
        this.children = null;
        this.renderer = null;
    }
    ;
}
AccessibilityManager.DIV_HOOK_SIZE = 1;
AccessibilityManager.DIV_HOOK_POS_X = -1000;
AccessibilityManager.DIV_HOOK_POS_Y = -1000;
AccessibilityManager.DIV_HOOK_ZINDEX = 2;
AccessibilityManager.KEY_CODE_TAB = 9;
AccessibilityManager.DIV_TOUCH_SIZE = 100;
AccessibilityManager.DIV_TOUCH_POS_X = 0;
AccessibilityManager.DIV_TOUCH_POS_Y = 0;
AccessibilityManager.DIV_TOUCH_ZINDEX = 2;
exports.AccessibilityManager = AccessibilityManager;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AnimatedSprite.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AnimatedSprite.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
class AnimatedSprite extends Sprite_1.Sprite {
    constructor(textures, autoUpdate = true) {
        super(textures[0] instanceof Texture_1.Texture ? textures[0] : textures[0].texture);
        /**
         * @type {PIXI.Texture[]}
         * @private
         */
        this._textures = null;
        /**
         * @type {number[]}
         * @private
         */
        this._durations = null;
        this.textures = textures;
        /**
         * `true` uses PIXI.Ticker.shared to auto update animation time.
         * @type {boolean}
         * @default true
         * @private
         */
        this._autoUpdate = autoUpdate !== false;
        /**
         * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.
         *
         * @member {number}
         * @default 1
         */
        this.animationSpeed = 1;
        /**
         * Whether or not the animate sprite repeats after playing.
         *
         * @member {boolean}
         * @default true
         */
        this.loop = true;
        /**
         * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.
         *
         * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.
         * Changing anchor for each frame allows to pin sprite origin to certain moving feature
         * of the frame (e.g. left foot).
         *
         * Note: Enabling this will override any previously set `anchor` on each frame change.
         *
         * @member {boolean}
         * @default false
         */
        this.updateAnchor = false;
        /**
         * Function to call when a AnimatedSprite finishes playing.
         *
         * @member {Function}
         */
        this.onComplete = null;
        /**
         * Function to call when a AnimatedSprite changes which texture is being rendered.
         *
         * @member {Function}
         */
        this.onFrameChange = null;
        /**
         * Function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again.
         *
         * @member {Function}
         */
        this.onLoop = null;
        /**
         * Elapsed time since animation has been started, used internally to display current texture.
         *
         * @member {number}
         * @private
         */
        this._currentTime = 0;
        /**
         * Indicates if the AnimatedSprite is currently playing.
         *
         * @member {boolean}
         * @readonly
         */
        this.playing = false;
    }
    /**
     * Stops the AnimatedSprite.
     *
     */
    stop() {
        if (!this.playing) {
            return;
        }
        this.playing = false;
        if (this._autoUpdate) {
            Ticker_1.Ticker.shared.remove(this.update, this);
        }
    }
    ;
    /**
     * Plays the AnimatedSprite.
     *
     */
    play() {
        if (this.playing) {
            return;
        }
        this.playing = true;
        if (this._autoUpdate) {
            Ticker_1.Ticker.shared.add(this.update, this, Ticker_1.Ticker.UPDATE_PRIORITY.HIGH);
        }
    }
    ;
    /**
     * Stops the AnimatedSprite and goes to a specific frame.
     *
     * @param {number} frameNumber - Frame index to stop at.
     */
    gotoAndStop(frameNumber) {
        this.stop();
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
    }
    ;
    /**
     * Goes to a specific frame and begins playing the AnimatedSprite.
     *
     * @param {number} frameNumber - Frame index to start at.
     */
    gotoAndPlay(frameNumber) {
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
        this.play();
    }
    ;
    /**
     * Updates the object transform for rendering.
     *
     * @private
     * @param {number} deltaTime - Time since last tick.
     */
    update(deltaTime) {
        var elapsed = this.animationSpeed * deltaTime;
        var previousFrame = this.currentFrame;
        if (this._durations !== null) {
            var lag = this._currentTime % 1 * this._durations[this.currentFrame];
            lag += elapsed / 60 * 1000;
            while (lag < 0) {
                this._currentTime--;
                lag += this._durations[this.currentFrame];
            }
            var sign = Math.sign(this.animationSpeed * deltaTime);
            this._currentTime = Math.floor(this._currentTime);
            while (lag >= this._durations[this.currentFrame]) {
                lag -= this._durations[this.currentFrame] * sign;
                this._currentTime += sign;
            }
            this._currentTime += lag / this._durations[this.currentFrame];
        }
        else {
            this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
            this.gotoAndStop(0);
            if (this.onComplete) {
                this.onComplete();
            }
        }
        else if (this._currentTime >= this._textures.length && !this.loop) {
            this.gotoAndStop(this._textures.length - 1);
            if (this.onComplete) {
                this.onComplete();
            }
        }
        else if (previousFrame !== this.currentFrame) {
            if (this.loop && this.onLoop) {
                if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
                    this.onLoop();
                }
                else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
                    this.onLoop();
                }
            }
            this.updateTexture();
        }
    }
    ;
    /**
     * Updates the displayed texture to match the current frame index.
     *
     * @private
     */
    updateTexture() {
        this._texture = this._textures[this.currentFrame];
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this.cachedTint = 0xFFFFFF;
        this.uvs = this._texture._uvs.uvsFloat32;
        if (this.updateAnchor) {
            this._anchor.copy(this._texture.defaultAnchor);
        }
        if (this.onFrameChange) {
            this.onFrameChange(this.currentFrame);
        }
    }
    ;
    /**
     * Stops the AnimatedSprite and destroys it.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value.
     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.
     */
    destroy(options) {
        this.stop();
        Sprite_1.Sprite.prototype.destroy.call(this, options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
    }
    ;
    /**
     * A short hand way of creating a movieclip from an array of frame ids.
     *
     * @static
     * @param {string[]} frames - The array of frames ids the movieclip will use as its texture frames.
     * @return {AnimatedSprite} The new animated sprite with the specified frames.
     */
    static fromFrames(frames) {
        var textures = [];
        for (var i = 0; i < frames.length; ++i) {
            textures.push(Texture_1.Texture.from(frames[i]));
        }
        return new AnimatedSprite(textures);
    }
    ;
    /**
     * A short hand way of creating a movieclip from an array of image ids.
     *
     * @static
     * @param {string[]} images - The array of image urls the movieclip will use as its texture frames.
     * @return {AnimatedSprite} The new animate sprite with the specified images as frames.
     */
    static fromImages(images) {
        var textures = [];
        for (var i = 0; i < images.length; ++i) {
            textures.push(Texture_1.Texture.from(images[i]));
        }
        return new AnimatedSprite(textures);
    }
    ;
    /**
     * The total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     *
     * @readonly
     * @member {number}
     * @default 0
     */
    get totalFrames() {
        return this._textures.length;
    }
    ;
    /**
     * The array of textures used for this AnimatedSprite.
     *
     * @member {PIXI.Texture[]}
     */
    get textures() {
        return this._textures;
    }
    ;
    set textures(value) {
        if (value[0] instanceof Texture_1.Texture) {
            this._textures = value;
            this._durations = null;
        }
        else {
            this._textures = [];
            this._durations = [];
            for (var i = 0; i < value.length; i++) {
                this._textures.push(value[i].texture);
                this._durations.push(value[i].time);
            }
        }
        this.gotoAndStop(0);
        this.updateTexture();
    }
    ;
    /**
    * The AnimatedSprites current frame index.
    *
    * @member {number}
    * @readonly
    */
    get currentFrame() {
        var currentFrame = Math.floor(this._currentTime) % this._textures.length;
        if (currentFrame < 0) {
            currentFrame += this._textures.length;
        }
        return currentFrame;
    }
    ;
}
exports.AnimatedSprite = AnimatedSprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Application.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Application.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./js-compile/raw-pixi-ts/Renderer.js");
const StageOptions_1 = __webpack_require__(/*! ./StageOptions */ "./js-compile/raw-pixi-ts/StageOptions.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./js-compile/raw-pixi-ts/AccessibilityManager.js");
const Extract_1 = __webpack_require__(/*! ./Extract */ "./js-compile/raw-pixi-ts/Extract.js");
const InteractionManager_1 = __webpack_require__(/*! ./InteractionManager */ "./js-compile/raw-pixi-ts/InteractionManager.js");
const ParticleRenderer_1 = __webpack_require__(/*! ./ParticleRenderer */ "./js-compile/raw-pixi-ts/ParticleRenderer.js");
const Prepare_1 = __webpack_require__(/*! ./Prepare */ "./js-compile/raw-pixi-ts/Prepare.js");
const BatchRenderer_1 = __webpack_require__(/*! ./BatchRenderer */ "./js-compile/raw-pixi-ts/BatchRenderer.js");
const TilingSpriteRenderer_1 = __webpack_require__(/*! ./TilingSpriteRenderer */ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js");
class Application {
    constructor(options = null) {
        this.resize = () => {
            if (this._resizeTo) {
                if (this._resizeTo === window) {
                    this.renderer.resize(window.innerWidth, window.innerHeight);
                }
                else {
                    this.renderer.resize(this._resizeTo['clientWidth'], this._resizeTo['clientHeight']);
                }
            }
        };
        if (!options) {
            options = new StageOptions_1.StageOptions();
        }
        Renderer_1.Renderer.registerPlugin('accessibility', AccessibilityManager_1.AccessibilityManager);
        Renderer_1.Renderer.registerPlugin('extract', Extract_1.Extract);
        Renderer_1.Renderer.registerPlugin('interaction', InteractionManager_1.InteractionManager);
        Renderer_1.Renderer.registerPlugin('particle', ParticleRenderer_1.ParticleRenderer);
        Renderer_1.Renderer.registerPlugin('prepare', Prepare_1.Prepare);
        Renderer_1.Renderer.registerPlugin('batch', BatchRenderer_1.BatchRenderer);
        Renderer_1.Renderer.registerPlugin('tilingSprite', TilingSpriteRenderer_1.TilingSpriteRenderer);
        // this.loader = /*options.sharedLoader ? Loader.shared : */new Loader();
        this.renderer = new Renderer_1.Renderer(options); //Application.autoDetectRenderer(options);
        this._stage = new Container_1.Container();
        this.ticker = options.sharedTicker ? Ticker_1.Ticker.shared : new Ticker_1.Ticker();
        this.resizeTo = window;
        // DisplayObject.mixin(interactiveTarget);
        if (options.autoStart) {
            this.start();
        }
    }
    get ticker() {
        return this._ticker;
    }
    set ticker(ticker) {
        if (this._ticker) {
            this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
            ticker.add(this.render, this, Ticker_1.Ticker.UPDATE_PRIORITY.LOW);
        }
    }
    start() {
        this._ticker.start();
    }
    ;
    stop() {
        this._ticker.stop();
    }
    ;
    get resizeTo() {
        return this._resizeTo;
    }
    set resizeTo(value) {
        window.removeEventListener('resize', this.resize);
        this._resizeTo = value;
        if (value) {
            window.addEventListener('resize', this.resize);
            this.resize();
        }
    }
    render() {
        this.renderer.render(this._stage);
    }
    ;
    get stage() {
        return this._stage;
    }
    get view() {
        return this.renderer.view;
    }
    ;
    get screen() {
        return this.renderer.screen;
    }
    ;
    destroy(options = null) {
        this._stage.destroy(options);
        this._stage = null;
        this.renderer.destroy(options);
        this.renderer = null;
        this._options = null;
        // if (this.loader)
        // {
        //     this.loader.destroy();
        //     this.loader = null;
        // }
    }
    ;
}
exports.Application = Application;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ArcUtils.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/ArcUtils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class ArcUtils {
    constructor() {
    }
    static curveTo(x1, y1, x2, y2, radius, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs((a1 * b2) - (b1 * a2));
        if (mm < 1.0e-8 || radius === 0) {
            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                points.push(x1, y1);
            }
            return null;
        }
        var dd = (a1 * a1) + (b1 * b1);
        var cc = (a2 * a2) + (b2 * b2);
        var tt = (a1 * a2) + (b1 * b2);
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = (k1 * b2) + (k2 * b1);
        var cy = (k1 * a2) + (k2 * a1);
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        return {
            cx: (cx + x1),
            cy: (cy + y1),
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            anticlockwise: (b1 * a2 > b2 * a1),
        };
    }
    ;
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @private
     * @param {number} startX - Start x location of arc
     * @param {number} startY - Start y location of arc
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} anticlockwise - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @param {number} n - Number of segments
     * @param {number[]} points - Collection of points to add to
     */
    static arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points) {
        var sweep = endAngle - startAngle;
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / MathSettings_1.MathSettings.PI_2) * 40);
        var theta = (sweep) / (n * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = n - 1;
        var remainder = (segMinus % 1) / segMinus;
        for (var i = 0; i <= segMinus; ++i) {
            var real = i + (remainder * i);
            var angle = ((theta) + startAngle + (theta2 * real));
            var c = Math.cos(angle);
            var s = -Math.sin(angle);
            points.push((((cTheta * c) + (sTheta * s)) * radius) + cx, (((cTheta * -s) + (sTheta * c)) * radius) + cy);
        }
    }
    ;
}
exports.ArcUtils = ArcUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ArrayResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ArrayResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ResourceSettings_1 = __webpack_require__(/*! ./ResourceSettings */ "./js-compile/raw-pixi-ts/ResourceSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ArrayResource extends Resource_1.Resource {
    constructor(source, options) {
        options = options || {};
        var urls;
        var length = source;
        if (Array.isArray(source)) {
            urls = source;
            length = source.length;
        }
        super(options.width, options.height);
        /**
         * Collection of resources.
         * @member {Array<PIXI.BaseTexture>}
         * @readonly
         */
        this.items = [];
        /**
         * Dirty IDs for each part
         * @member {Array<number>}
         * @readonly
         */
        this.itemDirtyIds = [];
        for (var i = 0; i < length; i++) {
            var partTexture = new BaseTexture_1.BaseTexture();
            this.items.push(partTexture);
            this.itemDirtyIds.push(-1);
        }
        /**
         * Number of elements in array
         *
         * @member {number}
         * @readonly
         */
        this.length = length;
        /**
         * Promise when loading
         * @member {Promise}
         * @private
         * @default null
         */
        this._load = null;
        if (urls) {
            for (var i$1 = 0; i$1 < length; i$1++) {
                this.addResourceAt(ResourceSettings_1.ResourceSettings.autoDetectResource(urls[i$1], options), i$1);
            }
        }
    }
    /**
     * Destroy this BaseImageResource
     * @override
     */
    dispose() {
        for (var i = 0, len = this.length; i < len; i++) {
            this.items[i].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
    }
    ;
    /**
     * Set a resource by ID
     *
     * @param {PIXI.resources.Resource} resource
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.resources.ArrayResource} Instance for chaining
     */
    addResourceAt(resource, index) {
        var baseTexture = this.items[index];
        if (!baseTexture) {
            throw new Error(("Index " + index + " is out of bounds"));
        }
        // Inherit the first resource dimensions
        if (resource.valid && !this.valid) {
            this.resize(resource.width, resource.height);
        }
        this.items[index].setResource(resource);
        return this;
    }
    ;
    /**
     * Set the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    bind(baseTexture) {
        super.bind(baseTexture);
        baseTexture.target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_2D_ARRAY;
        for (var i = 0; i < this.length; i++) {
            this.items[i].on('update', baseTexture.update, baseTexture);
        }
    }
    ;
    /**
     * Unset the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    unbind(baseTexture) {
        super.unbind(baseTexture);
        for (var i = 0; i < this.length; i++) {
            this.items[i].off('update', baseTexture.update, baseTexture);
        }
    }
    ;
    /**
     * Load all the resources simultaneously
     * @override
     * @return {Promise<void>} When load is resolved
     */
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        var resources = this.items.map(function (item) { return item.resource; });
        // TODO: also implement load part-by-part strategy
        var promises = resources.map(function (item) { return item.load(); });
        this._load = Promise.all(promises)
            .then(function () {
            var ref = resources[0];
            var width = ref.width;
            var height = ref.height;
            this$1.resize(width, height);
            return Promise.resolve(this$1);
        });
        return this._load;
    }
    ;
    /**
     * Upload the resources to the GPU.
     * @param {PIXI.Renderer} renderer
     * @param {PIXI.BaseTexture} texture
     * @param {PIXI.GLTexture} glTexture
     * @returns {boolean} whether texture was uploaded
     */
    upload(renderer, texture, glTexture) {
        var ref = this;
        var length = ref.length;
        var itemDirtyIds = ref.itemDirtyIds;
        var items = ref.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
            gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
        }
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (itemDirtyIds[i] < item.dirtyId) {
                itemDirtyIds[i] = item.dirtyId;
                if (item.valid) {
                    gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, // xoffset
                    0, // yoffset
                    i, // zoffset
                    item.resource.width, item.resource.height, 1, texture.format, texture.type, item.resource.source);
                }
            }
        }
        return true;
    }
    ;
}
exports.ArrayResource = ArrayResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Attribute.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Attribute.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = __webpack_require__(/*! .//Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Attribute {
    constructor(buffer, size, normalized = false, type = 5126, stride = undefined, start = undefined, instance = undefined) {
        this.buffer = buffer;
        this.size = size;
        this.normalized = normalized;
        this.type = type;
        this._stride = stride;
        this.start = start;
        this.instance = instance;
    }
    ;
    set stride(value) {
        Logger_1.trace("set to " + value);
        this._stride = value;
    }
    get stride() {
        return this._stride;
    }
    destroy(options = null) {
        this.buffer = null;
    }
    ;
}
exports.Attribute = Attribute;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseImageResource.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseImageResource.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class BaseImageResource extends Resource_1.Resource {
    constructor(source) {
        super(source.width, source.height);
        this.source = source;
    }
    /**
     * Set cross origin based detecting the url and the crossorigin
     * @protected
     * @param {HTMLElement} element - Element to apply crossOrigin
     * @param {string} url - URL to check
     * @param {boolean|string} [crossorigin=true] - Cross origin value to use
     */
    static crossOrigin(element, url, crossorigin) {
        if (crossorigin === undefined && url.indexOf('data:') !== 0) {
            element.crossOrigin = NetworkSettings_1.NetworkSettings.determineCrossOrigin(url);
        }
        else if (crossorigin !== false) {
            element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';
        }
    }
    ;
    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} [source] (optional)
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture, source = null) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        source = source || this.source;
        Logger_1.trace("update upload " + baseTexture.type);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
            // trace("update upload " + glTexture.width + ":" + glTexture.height)
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else {
            glTexture.width = width;
            glTexture.height = height;
            Logger_1.trace("first upload " + width + ":" + height);
            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
    }
    ;
    /**
     * Destroy this BaseImageResource
     * @override
     * @param {PIXI.BaseTexture} [fromTexture] Optional base texture
     * @return {boolean} Destroy was successful
     */
    dispose() {
        this.source = null;
    }
    ;
}
exports.BaseImageResource = BaseImageResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BasePrepare.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BasePrepare.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const Text_1 = __webpack_require__(/*! ./Text */ "./js-compile/raw-pixi-ts/Text.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const TextMetrics_1 = __webpack_require__(/*! ./TextMetrics */ "./js-compile/raw-pixi-ts/TextMetrics.js");
const CountLimiter_1 = __webpack_require__(/*! ./CountLimiter */ "./js-compile/raw-pixi-ts/CountLimiter.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class BasePrepare //extends Renderer
 {
    constructor(renderer) {
        // super(null);
        /**
         * The limiter to be used to control how quickly items are prepared.
         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}
         */
        this.limiter = new CountLimiter_1.CountLimiter(WebGLSettings_1.WebGLSettings.UPLOADS_PER_FRAME);
        /**
         * Reference to the renderer.
         * @type {PIXI.AbstractRenderer}
         * @protected
         */
        this.renderer = renderer;
        /**
         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass
         * to upload hooks. That different parameter is stored here.
         * @type {PIXI.prepare.CanvasPrepare|PIXI.Renderer}
         * @protected
         */
        this.uploadHookHelper = renderer;
        /**
         * Collection of items to uploads at once.
         * @type {Array<*>}
         * @private
         */
        this.queue = [];
        /**
         * Collection of additional hooks for finding assets.
         * @type {Array<Function>}
         * @private
         */
        this.addHooks = [];
        /**
         * Collection of additional hooks for processing assets.
         * @type {Array<Function>}
         * @private
         */
        this.uploadHooks = [];
        /**
         * Callback to call after completed.
         * @type {Array<Function>}
         * @private
         */
        this.completes = [];
        /**
         * If prepare is ticking (running).
         * @type {boolean}
         * @private
         */
        this.ticking = false;
        /**
         * 'bound' call for prepareItems().
         * @type {Function}
         * @private
         */
        this.delayedTick = function () {
            // unlikely, but in case we were destroyed between tick() and delayedTick()
            if (!this.queue) {
                return;
            }
            this.prepareItems();
        };
        // hooks to find the correct texture
        this.registerFindHook(BasePrepare.findText);
        this.registerFindHook(BasePrepare.findTextStyle);
        this.registerFindHook(BasePrepare.findMultipleBaseTextures);
        this.registerFindHook(BasePrepare.findBaseTexture);
        this.registerFindHook(BasePrepare.findTexture);
        // upload hooks
        this.registerUploadHook(BasePrepare.drawText);
        this.registerUploadHook(BasePrepare.calculateTextStyle);
    }
    /**
     * Upload all the textures and graphics to the GPU.
     *
     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -
     *    Either the container or display object to search for items to upload, the items to upload themselves,
     *    or the callback function, if items have been added using `prepare.add`.
     * @param {Function} [done] - Optional callback when all queued uploads have completed
     */
    upload(item, done) {
        if (typeof item === 'function') {
            done = item;
            item = null;
        }
        // If a display object, search for items
        // that we could upload
        if (item) {
            this.add(item);
        }
        // Get the items for upload from the display
        if (this.queue.length) {
            if (done) {
                this.completes.push(done);
            }
            if (!this.ticking) {
                this.ticking = true;
                Ticker_1.Ticker.system.addOnce(this.tick, this, Ticker_1.Ticker.UPDATE_PRIORITY.UTILITY);
            }
        }
        else if (done) {
            done();
        }
    }
    ;
    /**
     * Handle tick update
     *
     * @private
     */
    tick() {
        setTimeout(this.delayedTick, 0);
    }
    ;
    /**
     * Actually prepare items. This is handled outside of the tick because it will take a while
     * and we do NOT want to block the current animation frame from rendering.
     *
     * @private
     */
    prepareItems() {
        this.limiter.beginFrame();
        // Upload the graphics
        while (this.queue.length && this.limiter.allowedToUpload()) {
            var item = this.queue[0];
            var uploaded = false;
            if (item && !item._destroyed) {
                for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
                    if (this.uploadHooks[i](this.uploadHookHelper, item)) {
                        this.queue.shift();
                        uploaded = true;
                        break;
                    }
                }
            }
            if (!uploaded) {
                this.queue.shift();
            }
        }
        // We're finished
        if (!this.queue.length) {
            this.ticking = false;
            var completes = this.completes.slice(0);
            this.completes.length = 0;
            for (var i$1 = 0, len$1 = completes.length; i$1 < len$1; i$1++) {
                completes[i$1]();
            }
        }
        else {
            // if we are not finished, on the next rAF do this again
            Ticker_1.Ticker.system.addOnce(this.tick, this, Ticker_1.Ticker.UPDATE_PRIORITY.UTILITY);
        }
    }
    ;
    /**
     * Adds hooks for finding items.
     *
     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
     *      function must return `true` if it was able to add item to the queue.
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    registerFindHook(addHook) {
        if (addHook) {
            this.addHooks.push(addHook);
        }
        return this;
    }
    ;
    /**
     * Adds hooks for uploading items.
     *
     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
     *      function must return `true` if it was able to handle upload of item.
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    registerUploadHook(uploadHook) {
        if (uploadHook) {
            this.uploadHooks.push(uploadHook);
        }
        return this;
    }
    ;
    /**
     * Manually add an item to the uploading queue.
     *
     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
     *    add to the queue
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    add(item) {
        // Add additional hooks for finding elements on special
        // types of objects that
        for (var i = 0, len = this.addHooks.length; i < len; i++) {
            if (this.addHooks[i](item, this.queue)) {
                break;
            }
        }
        // Get children recursively
        if (item instanceof Container_1.Container) {
            for (var i$1 = item.children.length - 1; i$1 >= 0; i$1--) {
                this.add(item.children[i$1]);
            }
        }
        return this;
    }
    ;
    /**
     * Destroys the plugin, don't use after this.
     *
     */
    destroy() {
        if (this.ticking) {
            Ticker_1.Ticker.system.remove(this.tick, this);
        }
        this.ticking = false;
        this.addHooks = null;
        this.uploadHooks = null;
        this.renderer = null;
        this.completes = null;
        this.queue = null;
        this.limiter = null;
        this.uploadHookHelper = null;
    }
    ;
    /**
 * Built-in hook to find Text objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Text object was found.
 */
    static findText(item, queue) {
        if (item instanceof Text_1.Text) {
            // push the text style to prepare it - this can be really expensive
            if (queue.indexOf(item.style) === -1) {
                queue.push(item.style);
            }
            // also push the text object so that we can render it (to canvas/texture) if needed
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            // also push the Text's texture for upload to GPU
            var texture = item._texture.baseTexture;
            if (queue.indexOf(texture) === -1) {
                queue.push(texture);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find TextStyle objects.
 *
 * @private
 * @param {PIXI.TextStyle} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.TextStyle object was found.
 */
    static findTextStyle(item, queue) {
        if (item instanceof TextStyle_1.TextStyle) {
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find multiple textures from objects like AnimatedSprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findMultipleBaseTextures(item, queue) {
        var result = false;
        // Objects with multiple textures
        if (item && item._textures && item._textures.length) {
            for (var i = 0; i < item._textures.length; i++) {
                if (item._textures[i] instanceof Texture_1.Texture) {
                    var baseTexture = item._textures[i].baseTexture;
                    if (queue.indexOf(baseTexture) === -1) {
                        queue.push(baseTexture);
                        result = true;
                    }
                }
            }
        }
        return result;
    }
    /**
 * Built-in hook to find BaseTextures from Sprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findBaseTexture(item, queue) {
        // Objects with textures, like Sprites/Text
        if (item instanceof BaseTexture_1.BaseTexture) {
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find textures from objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findTexture(item, queue) {
        if (item._texture && item._texture instanceof Texture_1.Texture) {
            var texture = item._texture.baseTexture;
            if (queue.indexOf(texture) === -1) {
                queue.push(texture);
            }
            return true;
        }
        return false;
    }
    /**
     * Built-in hook to draw PIXI.Text to its texture.
     *
     * @private
     * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
     * @param {PIXI.DisplayObject} item - Item to check
     * @return {boolean} If item was uploaded.
     */
    static drawText(helper, item) {
        if (item instanceof Text_1.Text) {
            // updating text will return early if it is not dirty
            item.updateText(true);
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to calculate a text style for a PIXI.Text object.
 *
 * @private
 * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
    static calculateTextStyle(helper, item) {
        if (item instanceof TextStyle_1.TextStyle) {
            var font = item.toFontString();
            TextMetrics_1.TextMetrics.measureFont(font);
            return true;
        }
        return false;
    }
}
exports.BasePrepare = BasePrepare;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseRenderTexture.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseRenderTexture.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Framebuffer_1 = __webpack_require__(/*! ./Framebuffer */ "./js-compile/raw-pixi-ts/Framebuffer.js");
class BaseRenderTexture extends BaseTexture_1.BaseTexture {
    constructor(options, arg1 = null, arg2 = null, arg4 = null) {
        super(null, options);
        if (typeof options === 'number') {
            /* eslint-disable prefer-rest-params */
            // Backward compatibility of signature
            var width$1 = arguments[0];
            var height$1 = arguments[1];
            var scaleMode = arguments[2];
            var resolution = arguments[3];
            options = { width: width$1, height: height$1, scaleMode: scaleMode, resolution: resolution };
            /* eslint-enable prefer-rest-params */
        }
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;
        // Set defaults
        this.mipmap = false;
        this.width = Math.ceil(width) || 100;
        this.height = Math.ceil(height) || 100;
        this.valid = true;
        /**
         * A reference to the canvas render target (we only need one as this can be shared across renderers)
         *
         * @protected
         * @member {object}
         */
        this._canvasRenderTarget = null;
        this.clearColor = [0, 0, 0, 0];
        this.framebuffer = new Framebuffer_1.Framebuffer(this.width * this.resolution, this.height * this.resolution)
            .addColorTexture(0, this)
            .enableStencil();
        // TODO - could this be added the systems?
        /**
         * The data structure for the stencil masks.
         *
         * @member {PIXI.Graphics[]}
         */
        this.stencilMaskStack = [];
        /**
         * The data structure for the filters.
         *
         * @member {PIXI.Graphics[]}
         */
        this.filterStack = [{}];
    }
    /**
     * Resizes the BaseRenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     */
    resize(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        this.framebuffer.resize(width * this.resolution, height * this.resolution);
    }
    ;
    /**
     * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    dispose() {
        this.framebuffer.dispose();
        super.dispose();
    }
    ;
    /**
     * Destroys this texture.
     *
     */
    destroy() {
        super.destroy();
        this.framebuffer = null;
        this.renderer = null;
    }
    ;
}
exports.BaseRenderTexture = BaseRenderTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseTexture.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseTexture.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const ResourceSettings_1 = __webpack_require__(/*! ./ResourceSettings */ "./js-compile/raw-pixi-ts/ResourceSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class BaseTexture extends EventDispatcher_1.EventDispatcher {
    constructor(resource = null, options = null) {
        super();
        this.handleResize = (event) => {
            this.setRealSize(this.resource.width, this.resource.height);
        };
        this.handleUpdate = (event) => {
            this.update();
        };
        options = options || {};
        var premultiplyAlpha = options.premultiplyAlpha;
        var mipmap = options.mipmap;
        var scaleMode = options.scaleMode;
        var width = options.width;
        var height = options.height;
        var wrapMode = options.wrapMode;
        var format = options.format;
        var type = options.type;
        var target = options.target;
        var resolution = options.resolution;
        var resourceOptions = options.resourceOptions;
        // Convert the resource to a Resource object
        if (resource && resource instanceof ImageBitmap) {
        }
        else if (resource && !(resource instanceof Resource_1.Resource)) {
            resource = ResourceSettings_1.ResourceSettings.autoDetectResource(resource, resourceOptions);
            Logger_1.reveal(resource);
            resource.internal = true;
        }
        /**
         * The width of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.width = width || 0;
        /**
         * The height of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.height = height || 0;
        /**
         * The resolution / device pixel ratio of the texture
         *
         * @member {number}
         * @default PIXI.settings.RESOLUTION
         */
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        /**
         * Mipmap mode of the texture, affects downscaled images
         *
         * @member {PIXI.MIPMAP_MODES}
         * @default PIXI.settings.MIPMAP_TEXTURES
         */
        this.mipmap = mipmap !== undefined ? mipmap : WebGLSettings_1.WebGLSettings.MIPMAP_TEXTURES;
        /**
         * How the texture wraps
         * @member {number}
         */
        this.wrapMode = wrapMode || WebGLSettings_1.WebGLSettings.WRAP_MODE;
        /**
         * The scale mode to apply when scaling this texture
         *
         * @member {PIXI.SCALE_MODES}
         * @default PIXI.settings.SCALE_MODE
         */
        this.scaleMode = scaleMode !== undefined ? scaleMode : DisplaySettings_1.DisplaySettings.SCALE_MODE;
        /**
         * The pixel format of the texture
         *
         * @member {PIXI.FORMATS}
         * @default PIXI.FORMATS.RGBA
         */
        this.format = format || WebGLSettings_1.WebGLSettings.FORMATS.RGBA;
        /**
         * The type of resource data
         *
         * @member {PIXI.TYPES}
         * @default PIXI.TYPES.UNSIGNED_BYTE
         */
        this.type = type || WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE;
        /**
         * The target type
         *
         * @member {PIXI.TARGETS}
         * @default PIXI.TARGETS.TEXTURE_2D
         */
        this.target = target || WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_2D;
        /**
         * Set to true to enable pre-multiplied alpha
         *
         * @member {boolean}
         * @default true
         */
        this.premultiplyAlpha = premultiplyAlpha !== false;
        /**
         * Global unique identifier for this BaseTexture
         *
         * @member {string}
         * @protected
         */
        this.uid = MathSettings_1.MathSettings.uid();
        /**
         * Used by automatic texture Garbage Collection, stores last GC tick when it was bound
         *
         * @member {number}
         * @protected
         */
        this.touched = 0;
        /**
         * Whether or not the texture is a power of two, try to use power of two textures as much
         * as you can
         *
         * @readonly
         * @member {boolean}
         * @default false
         */
        this.isPowerOfTwo = false;
        this._refreshPOT();
        /**
         * The map of render context textures where this is bound
         *
         * @member {Object}
         * @private
         */
        this._glTextures = {};
        /**
         * Used by TextureSystem to only update texture to the GPU when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyId = 0;
        /**
         * Used by TextureSystem to only update texture style when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyStyleId = 0;
        /**
         * Currently default cache ID.
         *
         * @member {string}
         */
        this.cacheId = null;
        /**
         * Generally speaking means when resource is loaded.
         * @readonly
         * @member {boolean}
         */
        this.valid = width > 0 && height > 0;
        /**
         * The collection of alternative cache ids, since some BaseTextures
         * can have more than one ID, short name and longer full URL
         *
         * @member {Array<string>}
         * @readonly
         */
        this.textureCacheIds = [];
        /**
         * Flag if BaseTexture has been destroyed.
         *
         * @member {boolean}
         * @readonly
         */
        this.destroyed = false;
        /**
         * The resource used by this BaseTexture, there can only
         * be one resource per BaseTexture, but textures can share
         * resources.
         *
         * @member {PIXI.resources.Resource}
         * @readonly
         */
        this.resource = null;
        /**
         * Number of the texture batch, used by multi-texture renderers
         *
         * @member {number}
         */
        this._batchEnabled = 0;
        /**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */
        /**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */
        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */
        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */
        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#update
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
         */
        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#dispose
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
         */
        // Set the resource
        this.setResource(resource);
    }
    /**
     * Pixel width of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    get realWidth() {
        return this.width * this.resolution;
    }
    ;
    /**
     * Pixel height of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    get realHeight() {
        return this.height * this.resolution;
    }
    ;
    /**
     * Changes style options of BaseTexture
     *
     * @param {PIXI.SCALE_MODES} [scaleMode] - Pixi scalemode
     * @param {PIXI.MIPMAP_MODES} [mipmap] - enable mipmaps
     * @returns {BaseTexture} this
     */
    BsetStyle(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== undefined && scaleMode !== this.scaleMode) {
            this.scaleMode = scaleMode;
            dirty = true;
        }
        if (mipmap !== undefined && mipmap !== this.mipmap) {
            this.mipmap = mipmap;
            dirty = true;
        }
        if (dirty) {
            this.dirtyStyleId++;
        }
        return this;
    }
    ;
    /**
     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
     *
     * @param {number} width Visual width
     * @param {number} height Visual height
     * @param {number} [resolution] Optionally set resolution
     * @returns {BaseTexture} this
     */
    setSize(width, height, resolution = null) {
        this.resolution = resolution || this.resolution;
        this.width = width;
        this.height = height;
        this._refreshPOT();
        this.update();
        return this;
    }
    ;
    /**
     * Sets real size of baseTexture, preserves current resolution.
     *
     * @param {number} realWidth Full rendered width
     * @param {number} realHeight Full rendered height
     * @param {number} [resolution] Optionally set resolution
     * @returns {BaseTexture} this
     */
    setRealSize(realWidth, realHeight, resolution = null) {
        this.resolution = resolution || this.resolution;
        this.width = realWidth / this.resolution;
        this.height = realHeight / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
    }
    ;
    /**
     * Refresh check for isPowerOfTwo texture based on size
     *
     * @private
     */
    _refreshPOT() {
        this.isPowerOfTwo = MathSettings_1.MathSettings.isPow2(this.realWidth) && MathSettings_1.MathSettings.isPow2(this.realHeight);
    }
    ;
    /**
     * Changes resolution
     *
     * @param {number} [resolution] res
     * @returns {BaseTexture} this
     */
    setResolution(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
            return this;
        }
        this.resolution = resolution;
        if (this.valid) {
            this.width = this.width * oldResolution / resolution;
            this.height = this.height * oldResolution / resolution;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update');
        }
        this._refreshPOT();
        return this;
    }
    ;
    /**
     * Sets the resource if it wasn't set. Throws error if resource already present
     *
     * @param {PIXI.resources.Resource} resource - that is managing this BaseTexture
     * @returns {BaseTexture} this
     */
    setResource(resource) {
        if (this.resource === resource) {
            return this;
        }
        if (this.resource) {
            throw new Error('Resource can be set only once');
        }
        this.resource = resource;
        if (resource instanceof ImageBitmap) {
            this.setRealSize(this.resource.width, this.resource.height);
            this.handleUpdate(null);
        }
        else {
            resource.addEventListener("update", this.handleUpdate);
            resource.addEventListener("setRealSize", this.handleResize);
            this.setRealSize(this.resource.width, this.resource.height);
        }
        // resource.bind(this);
        return this;
    }
    ;
    /**
     * Invalidates the object. Texture becomes valid if width and height are greater than zero.
     */
    update() {
        if (!this.valid) {
            if (this.width > 0 && this.height > 0) {
                this.valid = true;
                this.dispatchEvent(Event_1.Event.getEvent("loaded"));
                this.dispatchEvent(Event_1.Event.getEvent("update"));
                // this.emit('loaded', this);
                // this.emit('update', this);
            }
        }
        else {
            this.dirtyId++;
            this.dirtyStyleId++;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update', this);
        }
    }
    ;
    /**
     * Destroys this base texture.
     * The method stops if resource doesn't want this texture to be destroyed.
     * Removes texture from all caches.
     */
    destroy() {
        // remove and destroy the resource
        if (this.resource) {
            this.resource.unbind(this);
            // only destroy resourced created internally
            if (this.resource.internal) {
                this.resource.destroy();
            }
            this.resource = null;
        }
        if (this.cacheId) {
            delete CacheSettings_1.CacheSettings.BaseTextureCache[this.cacheId];
            delete CacheSettings_1.CacheSettings.TextureCache[this.cacheId];
            this.cacheId = null;
        }
        // finally let the WebGL renderer know..
        this.dispose();
        BaseTexture.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
    }
    ;
    /**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    dispose() {
        this.dispatchEvent(Event_1.Event.getEvent("dispose"));
        // this.emit('dispose', this);
    }
    ;
    /**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element. If the
     * source is an image url or an image element and not in the base texture
     * cache, it will be created and loaded.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|SVGElement|HTMLVideoElement} source - The
     *        source to create base texture from.
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @returns {PIXI.BaseTexture} The new base texture.
     */
    static from(source, options) {
        var cacheId = null;
        if (typeof source === 'string') {
            cacheId = source;
        }
        else {
            if (!source._pixiId) {
                source._pixiId = "pixiid_" + (MathSettings_1.MathSettings.uid());
            }
            cacheId = source._pixiId;
        }
        var baseTexture = CacheSettings_1.CacheSettings.BaseTextureCache[cacheId];
        if (!baseTexture) {
            baseTexture = new BaseTexture(source, options);
            baseTexture.cacheId = cacheId;
            BaseTexture.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
    }
    ;
    /**
     * Create a new BaseTexture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.BaseTexture} The resulting new BaseTexture
     */
    static fromBuffer(buffer, width, height, options) {
        buffer = buffer || new Float32Array(width * height * 4);
        var resource = new BufferResource_1.BufferResource(buffer, { width: width, height: height });
        var type = buffer instanceof Float32Array ? WebGLSettings_1.WebGLSettings.TYPES.FLOAT : WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE;
        return new BaseTexture(resource, Object.assign(WebGLSettings_1.WebGLSettings.defaultBufferOptions, options || { width: width, height: height, type: type }));
    }
    ;
    /**
     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
     * @param {string} id - The id that the BaseTexture will be stored against.
     */
    static addToCache(baseTexture, id) {
        if (id) {
            if (baseTexture.textureCacheIds.indexOf(id) === -1) {
                baseTexture.textureCacheIds.push(id);
            }
            if (CacheSettings_1.CacheSettings.BaseTextureCache[id]) {
                // eslint-disable-next-line no-console
                console.warn(("BaseTexture added to the cache with an id [" + id + "] that already had an entry"));
            }
            CacheSettings_1.CacheSettings.BaseTextureCache[id] = baseTexture;
        }
    }
    ;
    /**
     * Remove a BaseTexture from the global BaseTextureCache.
     *
     * @static
     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
     */
    static removeFromCache(baseTexture) {
        if (typeof baseTexture === 'string') {
            var baseTextureFromCache = CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture];
            if (baseTextureFromCache) {
                var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
                if (index > -1) {
                    baseTextureFromCache.textureCacheIds.splice(index, 1);
                }
                delete CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture];
                return baseTextureFromCache;
            }
        }
        else if (baseTexture && baseTexture.textureCacheIds) {
            for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
                delete CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture.textureCacheIds[i]];
            }
            baseTexture.textureCacheIds.length = 0;
            return baseTexture;
        }
        return null;
    }
    ;
}
/**
 * Global number of the texture batch, used by multi-texture renderers
 *
 * @static
 * @member {number} new texture batch number
 */
BaseTexture._globalBatch = 0;
exports.BaseTexture = BaseTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchBuffer.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchBuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BatchBuffer {
    constructor(size) {
        this.vertices = new ArrayBuffer(size);
        /**
         * View on the vertices as a Float32Array for positions
         *
         * @member {Float32Array}
         */
        this.float32View = new Float32Array(this.vertices);
        /**
         * View on the vertices as a Uint32Array for uvs
         *
         * @member {Float32Array}
         */
        this.uint32View = new Uint32Array(this.vertices);
    }
    destroy() {
        this.vertices = null;
        this.float32View = null;
        this.uint32View = null;
    }
    ;
}
exports.BatchBuffer = BatchBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchDrawCall.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchDrawCall.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BatchDrawCall {
    constructor() {
        this.textures = [];
        this.ids = [];
        this.blend = 0;
        this.textureCount = 0;
        this.start = 0;
        this.size = 0;
        this.type = 4;
    }
    ;
}
exports.BatchDrawCall = BatchDrawCall;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchGeometry.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchGeometry.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class BatchGeometry extends Geometry_1.Geometry {
    constructor(_static = false) {
        super();
        /**
         * Buffer used for position, color, texture IDs
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._buffer = new Buffer_1.Buffer(null, _static, false);
        /**
         * Index buffer data
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._indexBuffer = new Buffer_1.Buffer(null, _static, true);
        this.addAttribute('aVertexPosition', this._buffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aTextureCoord', this._buffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aColor', this._buffer, 4, true, WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE)
            .addAttribute('aTextureId', this._buffer, 1, true, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addIndex(this._indexBuffer);
    }
}
exports.BatchGeometry = BatchGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchRenderer.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchRenderer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const BatchGeometry_1 = __webpack_require__(/*! ./BatchGeometry */ "./js-compile/raw-pixi-ts/BatchGeometry.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const BatchDrawCall_1 = __webpack_require__(/*! ./BatchDrawCall */ "./js-compile/raw-pixi-ts/BatchDrawCall.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const BatchBuffer_1 = __webpack_require__(/*! ./BatchBuffer */ "./js-compile/raw-pixi-ts/BatchBuffer.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BatchRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        /**
         * Called before the renderer starts rendering.
         *
         */
        this.onPrerender = (event) => {
            this.vertexCount = 0;
        };
        /**
         * Number of values sent in the vertex buffer.
         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5
         *
         * @member {number}
         */
        this.vertSize = 6;
        /**
         * The size of the vertex information in bytes.
         *
         * @member {number}
         */
        this.vertByteSize = this.vertSize * 4;
        /**
         * The number of images in the SpriteRenderer before it flushes.
         *
         * @member {number}
         */
        this.size = 2000 * 4; // settings.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
        this.currentSize = 0;
        this.currentIndexSize = 0;
        // the total number of bytes in our batch
        // let numVerts = this.size * 4 * this.vertByteSize;
        this.attributeBuffers = {};
        this.aBuffers = {};
        this.iBuffers = {};
        //     this.defualtSpriteIndexBuffer = new Buffer(createIndicesForQuads(this.size), true, true);
        /**
         * Holds the defualt indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         */
        // const indicies = createIndicesForQuads(this.size);
        //  this.defaultQuadIndexBuffer = new Buffer(indicies, true, true);
        this.onlySprites = false;
        /**
         * The default shaders that is used if a sprite doesn't have a more specific one.
         * there is a shader for each number of textures that can be rendered.
         * These shaders will also be generated on the fly as required.
         * @member {PIXI.Shader[]}
         */
        this.shader = null;
        this.currentIndex = 0;
        this.groups = [];
        for (var k = 0; k < this.size / 4; k++) {
            this.groups[k] = new BatchDrawCall_1.BatchDrawCall();
        }
        this.elements = [];
        this.vaos = [];
        this.vaoMax = 2;
        this.vertexCount = 0;
        this.renderer.addEventListener("prerender", this.onPrerender);
        // this.renderer.on('prerender', this.onPrerender, this);
        this.state = State_1.State.for2d();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        var gl = this.renderer.gl;
        if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
            this.MAX_TEXTURES = 1;
        }
        else {
            // step 1: first check max textures the GPU can handle.
            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), WebGLSettings_1.WebGLSettings.SPRITE_MAX_TEXTURES);
            // step 2: check the maximum number of if statements the shader can have too..
            this.MAX_TEXTURES = WebGLSettings_1.WebGLSettings.checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
        }
        // generate generateMultiTextureProgram, may be a better move?
        this.shader = WebGLSettings_1.WebGLSettings.generateMultiTextureShader(gl, this.MAX_TEXTURES);
        // we use the second shader as the first one depending on your browser may omit aTextureId
        // as it is not used by the shader so is optimized out.
        for (var i = 0; i < this.vaoMax; i++) {
            /* eslint-disable max-len */
            this.vaos[i] = new BatchGeometry_1.BatchGeometry();
        }
    }
    ;
    /**
     * Renders the sprite object.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
     */
    render(element) {
        // trace("rendering element: " + element._texture.valid)
        if (!element._texture.valid) {
            return;
        }
        if (this.currentSize + (element.vertexData.length / 2) > this.size) {
            this.flush();
        }
        this.elements[this.currentIndex++] = element;
        this.currentSize += element.vertexData.length / 2;
        // trace("currentSize: " + this.currentSize)
        this.currentIndexSize += element.indices.length;
    }
    ;
    getIndexBuffer(size) {
        // 12 indices is enough for 2 quads
        var roundedP2 = MathSettings_1.MathSettings.nextPow2(Math.ceil(size / 12));
        var roundedSizeIndex = MathSettings_1.MathSettings.log2(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this.iBuffers.length <= roundedSizeIndex) {
            this.iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this.iBuffers[roundedSizeIndex];
        if (!buffer) {
            this.iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
    }
    ;
    getAttributeBuffer(size) {
        // 8 vertices is enough for 2 quads
        var roundedP2 = MathSettings_1.MathSettings.nextPow2(Math.ceil(size / 8));
        var roundedSizeIndex = MathSettings_1.MathSettings.log2(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this.aBuffers.length <= roundedSizeIndex) {
            this.iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this.aBuffers[roundedSize];
        if (!buffer) {
            this.aBuffers[roundedSize] = buffer = new BatchBuffer_1.BatchBuffer(roundedSize * this.vertByteSize);
        }
        return buffer;
    }
    ;
    /**
     * Renders the content and empties the current batch.
     *
     */
    flush() {
        // trace("BatchRender flush " + this.currentSize)
        if (this.currentSize === 0) {
            return;
        }
        var gl = this.renderer.gl;
        var MAX_TEXTURES = this.MAX_TEXTURES;
        var buffer = this.getAttributeBuffer(this.currentSize);
        // reveal(buffer);
        var indexBuffer = this.getIndexBuffer(this.currentIndexSize);
        // reveal(indexBuffer);
        var elements = this.elements;
        var groups = this.groups;
        var float32View = buffer.float32View;
        // reveal(float32View);
        var uint32View = buffer.uint32View;
        // reveal(uint32View);
        var touch = this.renderer.textureGC.count;
        var index = 0;
        var indexCount = 0;
        var nextTexture;
        var currentTexture;
        var groupCount = 0;
        var textureCount = 0;
        var currentGroup = groups[0];
        // reveal(currentGroup);
        var blendMode = -1; // premultiplyBlendMode[elements[0]._texture.baseTexture.premultiplyAlpha ? 0 : ][elements[0].blendMode];
        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.blend = blendMode;
        var TICK = ++BaseTexture_1.BaseTexture._globalBatch;
        var i;
        for (i = 0; i < this.currentIndex; ++i) {
            // upload the sprite elements...
            // they have all ready been calculated so we just need to push them into the buffer.
            var sprite = elements[i];
            elements[i] = null;
            nextTexture = sprite._texture.baseTexture;
            // reveal(nextTexture);
            var spriteBlendMode = BlendModesSettings_1.BlendModesSettings.premultiplyBlendMode[nextTexture.premultiplyAlpha ? 1 : 0][sprite.blendMode];
            if (blendMode !== spriteBlendMode) {
                blendMode = spriteBlendMode;
                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }
            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;
                if (nextTexture._batchEnabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;
                        textureCount = 0;
                        currentGroup.size = indexCount - currentGroup.start;
                        currentGroup = groups[groupCount++];
                        currentGroup.textureCount = 0;
                        currentGroup.blend = blendMode;
                        currentGroup.start = indexCount;
                    }
                    nextTexture.touched = touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    // reveal(currentGroup);
                    // reveal(nextTexture);
                    textureCount++;
                }
            }
            this.packGeometry(sprite, float32View, uint32View, indexBuffer, index, indexCount); // argb, nextTexture._id, float32View, uint32View, indexBuffer, index, indexCount);
            // HERE 
            // push a graphics..
            index += (sprite.vertexData.length / 2) * this.vertSize;
            indexCount += sprite.indices.length;
        }
        BaseTexture_1.BaseTexture._globalBatch = TICK;
        currentGroup.size = indexCount - currentGroup.start;
        //        this.indexBuffer.update();
        if (!WebGLSettings_1.WebGLSettings.CAN_UPLOAD_SAME_BUFFER) {
            // this is still needed for IOS performance..
            // it really does not like uploading to the same buffer in a single frame!
            if (this.vaoMax <= this.vertexCount) {
                this.vaoMax++;
                /* eslint-disable max-len */
                this.vaos[this.vertexCount] = new BatchGeometry_1.BatchGeometry();
            }
            this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0);
            this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0);
            //   this.vertexBuffers[this.vertexCount].update(buffer.vertices, 0);
            this.renderer.geometry.bind(this.vaos[this.vertexCount]);
            this.renderer.geometry.updateBuffers();
            this.vertexCount++;
        }
        else {
            // lets use the faster option, always use buffer number 0
            this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0);
            this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0);
            //   if (true)// this.spriteOnly)
            // {
            // this.vaos[this.vertexCount].indexBuffer = this.defualtSpriteIndexBuffer;
            // this.vaos[this.vertexCount].buffers[1] = this.defualtSpriteIndexBuffer;
            // }
            // this.vaos[0].attributes.aColor.stride = 24
            // this.vaos[0].attributes.aColor.start = 16
            // NOT SET
            // this.vaos[0].attributes.aTextureCoord.stride = 24
            // this.vaos[0].attributes.aTextureCoord.start = 8
            // NOT SET
            // this.vaos[0].attributes.aVertexPosition.stride = 24
            // NOT SET
            this.renderer.geometry.updateBuffers();
            //    
        }
        //   this.renderer.state.set(this.state);
        var textureSystem = this.renderer.texture;
        var stateSystem = this.renderer.state;
        // e.log(groupCount);
        // / render the groups..
        //    trace("groupcount: " + groupCount)
        // trace("BatchRenderer count: " + groupCount)
        for (i = 0; i < groupCount; i++) {
            var group = groups[i];
            var groupTextureCount = group.textureCount;
            for (var j = 0; j < groupTextureCount; j++) {
                // trace("possible textureSystem bind call (BathRenderer)")
                // trace("binding: " + group.textures[j] + " to " + j)
                textureSystem.bind(group.textures[j], j);
                group.textures[j] = null;
            }
            // this.state.blendMode = group.blend;
            // this.state.blend = true;
            // this.renderer.state.setState(this.state);
            // set the blend mode..
            stateSystem.setBlendMode(group.blend);
            gl.drawElements(group.type, group.size, gl.UNSIGNED_SHORT, group.start * 2);
        }
        // reset elements for the next flush
        this.currentIndex = 0;
        this.currentSize = 0;
        this.currentIndexSize = 0;
    }
    ;
    packGeometry(element, float32View, uint32View, indexBuffer, index, indexCount) {
        var p = index / this.vertSize; // float32View.length / 6 / 2;
        var uvs = element.uvs;
        var indicies = element.indices; // geometry.getIndex().data;// indicies;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._id;
        var alpha = Math.min(element.worldAlpha, 1.0);
        var argb = alpha < 1.0 && element._texture.baseTexture.premultiplyAlpha ? ColorSettings_1.ColorSettings.premultiplyTint(element._tintRGB, alpha)
            : element._tintRGB + (alpha * 255 << 24);
        // lets not worry about tint! for now..
        for (var i = 0; i < vertexData.length; i += 2) {
            float32View[index++] = vertexData[i];
            float32View[index++] = vertexData[i + 1];
            float32View[index++] = uvs[i];
            float32View[index++] = uvs[i + 1];
            uint32View[index++] = argb;
            float32View[index++] = textureId;
        }
        for (var i$1 = 0; i$1 < indicies.length; i$1++) {
            indexBuffer[indexCount++] = p + indicies[i$1];
        }
    }
    ;
    /**
     * Starts a new sprite batch.
     */
    start() {
        this.renderer.state.setState(this.state);
        this.renderer.shader.bind(this.shader);
        if (WebGLSettings_1.WebGLSettings.CAN_UPLOAD_SAME_BUFFER) {
            // bind buffer #0, we don't need others
            this.renderer.geometry.bind(this.vaos[this.vertexCount]);
        }
    }
    ;
    /**
     * Stops and flushes the current batch.
     *
     */
    stop() {
        this.flush();
    }
    ;
    /**
     * Destroys the SpriteRenderer.
     *
     */
    destroy() {
        for (var i = 0; i < this.vaoMax; i++) {
            // if (this.vertexBuffers[i])
            // {
            //     this.vertexBuffers[i].destroy();
            // }
            if (this.vaos[i]) {
                this.vaos[i].destroy(null);
            }
        }
        if (this.indexBuffer) {
            this.indexBuffer.destroy();
        }
        this.renderer.removeEventListener('prerender', this.onPrerender);
        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }
        // this.vertexBuffers = null;
        this.vaos = null;
        this.indexBuffer = null;
        this.indices = null;
        this.sprites = null;
        // for (let i = 0; i < this.buffers.length; ++i)
        // {
        //     this.buffers[i].destroy();
        // }
        super.destroy();
    }
    ;
}
exports.BatchRenderer = BatchRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchSystem.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
class BatchSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.emptyRenderer = new ObjectRenderer_1.ObjectRenderer(renderer);
        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.currentRenderer = this.emptyRenderer;
    }
    /**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */
    setObjectRenderer(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
            return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
    }
    ;
    /**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     */
    flush() {
        this.setObjectRenderer(this.emptyRenderer);
    }
    ;
    /**
     * Reset the system to an empty renderer
     */
    reset() {
        this.setObjectRenderer(this.emptyRenderer);
    }
    ;
}
exports.BatchSystem = BatchSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BezierUtils.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BezierUtils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class BezierUtils {
    constructor() {
    }
    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n = 10;
        var result = 0.0;
        var t = 0.0;
        var t2 = 0.0;
        var t3 = 0.0;
        var nt = 0.0;
        var nt2 = 0.0;
        var nt3 = 0.0;
        var x = 0.0;
        var y = 0.0;
        var dx = 0.0;
        var dy = 0.0;
        var prevX = fromX;
        var prevY = fromY;
        for (var i = 1; i <= n; ++i) {
            t = i / n;
            t2 = t * t;
            t3 = t2 * t;
            nt = (1.0 - t);
            nt2 = nt * nt;
            nt3 = nt2 * nt;
            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);
            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);
            dx = prevX - x;
            dy = prevY - y;
            prevX = x;
            prevY = y;
            result += Math.sqrt((dx * dx) + (dy * dy));
        }
        return result;
    }
    ;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Path array to push points into
     */
    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        points.length -= 2;
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
        points.push(fromX, fromY);
        for (var i = 1, j = 0; i <= n; ++i) {
            j = i / n;
            dt = (1 - j);
            dt2 = dt * dt;
            dt3 = dt2 * dt;
            t2 = j * j;
            t3 = t2 * j;
            points.push((dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX), (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY));
        }
    }
    ;
}
exports.BezierUtils = BezierUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BitmapText.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BitmapText.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
const FontManager_1 = __webpack_require__(/*! ./FontManager */ "./js-compile/raw-pixi-ts/FontManager.js");
class BitmapText extends Container_1.Container {
    constructor(text) {
        super();
        this.hasFont = false;
        this.bitmapfont = null;
        this._textWidth = 0;
        this._textHeight = 0;
        this._glyphs = [];
        this._font = new BitmapFontTracker();
        this._font.align = "left";
        this._font.size = 16;
        this._font.tint = 0xFFFFFF;
        this.font = null;
        this._text = text;
        this._maxWidth = 0;
        this._maxLineHeight = 0;
        this._letterSpacing = 0;
        this._anchor = new ObservablePoint_1.ObservablePoint(function () { this.dirty = true; }, this, 0, 0);
        this.dirty = false;
        this.roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
        this.updateText();
    }
    get font() {
        return this._font.name;
    }
    ;
    set font(value) {
        if (!value) {
            return;
        }
        if (value == this._font.name) {
            return;
        }
        this._font.name = value;
        this.dirty = true;
    }
    ;
    render(renderer) {
        if (!this.bitmapfont) {
            this.bitmapfont = FontManager_1.FontManager.getBitmapFont(this._font.name);
            return;
        }
        if (this.bitmapfont && !this.hasFont) {
            this.hasFont = true;
            this.dirty = true;
            return;
        }
        super.render(renderer);
    }
    updateText() {
        if (!this.bitmapfont) {
            this.bitmapfont = FontManager_1.FontManager.getBitmapFont(this._font.name);
            return;
        }
        let scale = this._font.fontSize / this.bitmapfont.size;
        if (scale <= 0) {
            scale = 1;
        }
        let pos = new Point_1.Point();
        let chars = [];
        let lineWidths = [];
        let text = this._text.replace(/(?:\r\n|\r)/g, '\n') || ' ';
        let textLength = text.length;
        let maxWidth = this._maxWidth * this.bitmapfont.size / this._font.size;
        let prevCharCode = null;
        let lastLineWidth = 0;
        let maxLineWidth = 0;
        let line = 0;
        let lastBreakPos = -1;
        let lastBreakWidth = 0;
        let spacesRemoved = 0;
        let maxLineHeight = 0;
        for (let i = 0; i < textLength; i++) {
            let charCode = text.charCodeAt(i);
            let char = text.charAt(i);
            if ((/(?:\s)/).test(char)) {
                lastBreakPos = i;
                lastBreakWidth = lastLineWidth;
            }
            if (char === '\r' || char === '\n') {
                lineWidths.push(lastLineWidth);
                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
                ++line;
                ++spacesRemoved;
                pos.x = 0;
                pos.y += this.bitmapfont.lineHeight;
                prevCharCode = null;
                continue;
            }
            let charData = this.bitmapfont.chars[charCode];
            if (!charData) {
                continue;
            }
            if (prevCharCode && charData.kerning[prevCharCode]) {
                pos.x += charData.kerning[prevCharCode];
            }
            let glipthdata = new DataGlipth();
            glipthdata.texture = charData.texture;
            glipthdata.line = line;
            glipthdata.charCode = charCode;
            glipthdata.position = new Point_1.Point(pos.x + charData.xOffset + (this._letterSpacing / 2), pos.y + charData.yOffset);
            chars.push(glipthdata);
            pos.x += charData.xAdvance + this._letterSpacing;
            lastLineWidth = pos.x;
            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));
            prevCharCode = charCode;
            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
                ++spacesRemoved;
                UtilsSettings_1.UtilsSettings.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
                i = lastBreakPos;
                lastBreakPos = -1;
                lineWidths.push(lastBreakWidth);
                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
                line++;
                pos.x = 0;
                pos.y += this.bitmapfont.lineHeight;
                prevCharCode = null;
            }
        }
        let lastChar = text.charAt(text.length - 1);
        if (lastChar !== '\r' && lastChar !== '\n') {
            if ((/(?:\s)/).test(lastChar)) {
                lastLineWidth = lastBreakWidth;
            }
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        }
        let lineAlignOffsets = [];
        for (let i$1 = 0; i$1 <= line; i$1++) {
            let alignOffset = 0;
            if (this._font.align === 'right') {
                alignOffset = maxLineWidth - lineWidths[i$1];
            }
            else if (this._font.align === 'center') {
                alignOffset = (maxLineWidth - lineWidths[i$1]) / 2;
            }
            lineAlignOffsets.push(alignOffset);
        }
        let lenChars = chars.length;
        let tint = this.tint;
        for (let i$2 = 0; i$2 < lenChars; i$2++) {
            let c = this._glyphs[i$2];
            if (c) {
                c.texture = chars[i$2].texture;
            }
            else {
                c = new Sprite_1.Sprite(chars[i$2].texture);
                c.roundPixels = this.roundPixels;
                this._glyphs.push(c);
                this.addChild(c);
            }
            c.position.x = (chars[i$2].position.x + lineAlignOffsets[chars[i$2].line]) * scale;
            c.position.y = chars[i$2].position.y * scale;
            c.scale.x = c.scale.y = scale;
            c.tint = tint;
        }
        for (let i$3 = lenChars; i$3 < this._glyphs.length; ++i$3) {
            this.removeChild(this._glyphs[i$3]);
        }
        this._textWidth = maxLineWidth * scale;
        this._textHeight = (pos.y + this.bitmapfont.lineHeight) * scale;
        if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            for (let i$4 = 0; i$4 < lenChars; i$4++) {
                this._glyphs[i$4].x -= this._textWidth * this.anchor.x;
                this._glyphs[i$4].y -= this._textHeight * this.anchor.y;
            }
        }
        this._maxLineHeight = maxLineHeight * scale;
    }
    ;
    updateTransform() {
        super.updateTransform();
        this.validate();
    }
    ;
    getLocalBounds() {
        this.validate();
        return super.getLocalBounds();
    }
    ;
    validate() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
    }
    ;
    get fontSize() {
        return this._font.fontSize;
    }
    ;
    set fontSize(value) {
        this._font.fontSize = value;
        this.dirty = true;
    }
    ;
    get tint() {
        return this._font.tint;
    }
    ;
    set tint(value) {
        this._font.tint = value;
        this.dirty = true;
    }
    ;
    get align() {
        return this._font.align;
    }
    ;
    set align(value) {
        this._font.align = value || 'left';
        this.dirty = true;
    }
    ;
    get anchor() {
        return this._anchor;
    }
    ;
    set anchor(value) {
        this._anchor.copyFrom(value);
    }
    ;
    get text() {
        return this._text;
    }
    ;
    set text(text) {
        if (this._text === text) {
            return;
        }
        this._text = text;
        this.dirty = true;
    }
    ;
    get maxWidth() {
        return this._maxWidth;
    }
    ;
    set maxWidth(value) {
        if (this._maxWidth === value) {
            return;
        }
        this._maxWidth = value;
        this.dirty = true;
    }
    ;
    get maxLineHeight() {
        this.validate();
        return this._maxLineHeight;
    }
    ;
    get textWidth() {
        this.validate();
        return this._textWidth;
    }
    ;
    get letterSpacing() {
        return this._letterSpacing;
    }
    ;
    set letterSpacing(value) {
        if (this._letterSpacing !== value) {
            this._letterSpacing = value;
            this.dirty = true;
        }
    }
    ;
    get textHeight() {
        this.validate();
        return this._textHeight;
    }
    ;
}
exports.BitmapText = BitmapText;
class BitmapFontTracker extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super(...arguments);
        this.fontSize = 16;
    }
}
class DataGlipth {
}
class FontMap {
}
class FontCharacterData {
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlendModesSettings.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlendModesSettings.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BlendModesSettings {
    /**
* Corrects PixiJS blend, takes premultiplied alpha into account
*
* @memberof PIXI.utils
* @function mapPremultipliedBlendModes
* @private
* @param {Array<number[]>} [array] - The array to output into.
* @return {Array<number[]>} Mapped modes.
*/
    static mapPremultipliedBlendModes() {
        var pm = [];
        var npm = [];
        for (var i = 0; i < 32; i++) {
            pm[i] = i;
            npm[i] = i;
        }
        pm[BlendModesSettings.BLEND_MODES.NORMAL_NPM] = BlendModesSettings.BLEND_MODES.NORMAL;
        pm[BlendModesSettings.BLEND_MODES.ADD_NPM] = BlendModesSettings.BLEND_MODES.ADD;
        pm[BlendModesSettings.BLEND_MODES.SCREEN_NPM] = BlendModesSettings.BLEND_MODES.SCREEN;
        npm[BlendModesSettings.BLEND_MODES.NORMAL] = BlendModesSettings.BLEND_MODES.NORMAL_NPM;
        npm[BlendModesSettings.BLEND_MODES.ADD] = BlendModesSettings.BLEND_MODES.ADD_NPM;
        npm[BlendModesSettings.BLEND_MODES.SCREEN] = BlendModesSettings.BLEND_MODES.SCREEN_NPM;
        var array = [];
        array.push(npm);
        array.push(pm);
        return array;
    }
    /**
* changes blendMode according to texture format
*
* @memberof PIXI.utils
* @function correctBlendMode
* @param {number} blendMode supposed blend mode
* @param {boolean} premultiplied  whether source is premultiplied
* @returns {number} true blend mode for this texture
*/
    static correctBlendMode(blendMode, premultiplied) {
        return BlendModesSettings.premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
    }
    /**
* Maps gl blend combinations to WebGL.
*
* @memberof PIXI
* @function mapWebGLBlendModesToPixi
* @private
* @param {WebGLRenderingContext} gl - The rendering context.
* @param {number[][]} [array=[]] - The array to output into.
* @return {number[][]} Mapped modes.
*/
    static mapWebGLBlendModesToPixi(gl, array = []) {
        // TODO - premultiply alpha would be different.
        // add a boolean for that!
        array[BlendModesSettings.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.NONE] = [0, 0];
        // not-premultiplied blend modes
        array[BlendModesSettings.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.DST_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        // composite operations
        array[BlendModesSettings.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
        array[BlendModesSettings.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
        array[BlendModesSettings.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
        array[BlendModesSettings.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
        // SUBTRACT from flash
        array[BlendModesSettings.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
        return array;
    }
}
/**
* Various blend modes supported by PIXI.
*
* IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
* Anything else will silently act like NORMAL.
*
* @memberof PIXI
* @name BLEND_MODES
* @enum {number}
* @property {number} NORMAL
* @property {number} ADD
* @property {number} MULTIPLY
* @property {number} SCREEN
* @property {number} OVERLAY
* @property {number} DARKEN
* @property {number} LIGHTEN
* @property {number} COLOR_DODGE
* @property {number} COLOR_BURN
* @property {number} HARD_LIGHT
* @property {number} SOFT_LIGHT
* @property {number} DIFFERENCE
* @property {number} EXCLUSION
* @property {number} HUE
* @property {number} SATURATION
* @property {number} COLOR
* @property {number} LUMINOSITY
* @property {number} NORMAL_NPM
* @property {number} ADD_NPM
* @property {number} SCREEN_NPM
* @property {number} NONE
* @property {number} SRC_IN
* @property {number} SRC_OUT
* @property {number} SRC_ATOP
* @property {number} DST_OVER
* @property {number} DST_IN
* @property {number} DST_OUT
* @property {number} DST_ATOP
* @property {number} SUBTRACT
* @property {number} SRC_OVER
* @property {number} ERASE
*/
BlendModesSettings.BLEND_MODES = {
    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16,
    NORMAL_NPM: 17,
    ADD_NPM: 18,
    SCREEN_NPM: 19,
    NONE: 20,
    SRC_OVER: 0,
    SRC_IN: 21,
    SRC_OUT: 22,
    SRC_ATOP: 23,
    DST_OVER: 24,
    DST_IN: 25,
    DST_OUT: 26,
    DST_ATOP: 27,
    ERASE: 26,
    SUBTRACT: 28,
};
/**
* maps premultiply flag and blendMode to adjusted blendMode
* @memberof PIXI.utils
* @const premultiplyBlendMode
* @type {Array<number[]>}
*/
BlendModesSettings.premultiplyBlendMode = BlendModesSettings.mapPremultipliedBlendModes();
exports.BlendModesSettings = BlendModesSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlurFilter.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlurFilter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const BlurFilterPass_1 = __webpack_require__(/*! ./BlurFilterPass */ "./js-compile/raw-pixi-ts/BlurFilterPass.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BlurFilter extends Filter_1.Filter {
    constructor(strength = 1, quality = 1, resolution = 1, kernelSize = 5) {
        super();
        this.blurXFilter = new BlurFilterPass_1.BlurFilterPass(true, strength, quality, resolution, kernelSize);
        this.blurYFilter = new BlurFilterPass_1.BlurFilterPass(false, strength, quality, resolution, kernelSize);
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.quality = quality || 4;
        this.blur = strength || 8;
        this.repeatEdgePixels = false;
    }
    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    apply(filterManager, input, output, clear) {
        var xStrength = Math.abs(this.blurXFilter.strength);
        var yStrength = Math.abs(this.blurYFilter.strength);
        if (xStrength && yStrength) {
            var renderTarget = filterManager.getFilterTexture();
            this.blurXFilter.apply(filterManager, input, renderTarget, true);
            this.blurYFilter.apply(filterManager, renderTarget, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
        else if (yStrength) {
            this.blurYFilter.apply(filterManager, input, output, clear);
        }
        else {
            this.blurXFilter.apply(filterManager, input, output, clear);
        }
    }
    ;
    updatePadding() {
        if (this._repeatEdgePixels) {
            this.padding = 0;
        }
        else {
            this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
    }
    ;
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @default 2
     */
    get blur() {
        return this.blurXFilter.blur;
    }
    ;
    set blur(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    get quality() {
        return this.blurXFilter.quality;
    }
    ;
    set quality(value) {
        this.blurXFilter.quality = this.blurYFilter.quality = value;
    }
    ;
    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @default 2
     */
    get blurX() {
        return this.blurXFilter.blur;
    }
    ;
    set blurX(value) {
        this.blurXFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @default 2
     */
    get blurY() {
        return this.blurYFilter.blur;
    }
    ;
    set blurY(value) {
        this.blurYFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get blendMode() {
        return this.blurYFilter.blendMode;
    }
    ;
    set blendMode(value) {
        this.blurYFilter.blendMode = value;
    }
    ;
    /**
     * If set to true the edge of the target will be clamped
     *
     * @member {bool}
     * @default false
     */
    get repeatEdgePixels() {
        return this._repeatEdgePixels;
    }
    ;
    set repeatEdgePixels(value) {
        this._repeatEdgePixels = value;
        this.updatePadding();
    }
    ;
}
exports.BlurFilter = BlurFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlurFilterPass.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlurFilterPass.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BlurFilterPass extends Filter_1.Filter {
    constructor(horizontal, strength, quality, resolution, kernelSize) {
        kernelSize = kernelSize || 5;
        var vertSrc = BlurFilterPass.generateBlurVertSource(kernelSize, horizontal);
        var fragSrc = BlurFilterPass.generateBlurFragSource(kernelSize);
        super(vertSrc, fragSrc);
        this.horizontal = horizontal;
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this._quality = 0;
        this.quality = quality || 4;
        this.blur = strength || 8;
    }
    static generateBlurFragSource(kernelSize) {
        var kernel = BlurFilterPass.GAUSSIAN_VALUES[kernelSize];
        var halfLength = kernel.length;
        var fragSource = BlurFilterPass.fragTemplate$2;
        var blurLoop = '';
        var template = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;';
        var value;
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i.toString());
            value = i;
            if (i >= halfLength) {
                value = kernelSize - i - 1;
            }
            blur = blur.replace('%value%', kernel[value]);
            blurLoop += blur;
            blurLoop += '\n';
        }
        fragSource = fragSource.replace('%blur%', blurLoop);
        fragSource = fragSource.replace('%size%', kernelSize);
        return fragSource;
    }
    static generateBlurVertSource(kernelSize, x) {
        var halfLength = Math.ceil(kernelSize / 2);
        var vertSource = BlurFilterPass.vertTemplate;
        var blurLoop = '';
        var template;
        // let value;
        if (x) {
            template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);';
        }
        else {
            template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);';
        }
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i);
            // value = i;
            // if(i >= halfLength)
            // {
            //     value = kernelSize - i - 1;
            // }
            blur = blur.replace('%sampleIndex%', ((i - (halfLength - 1)) + ".0"));
            blurLoop += blur;
            blurLoop += '\n';
        }
        vertSource = vertSource.replace('%blur%', blurLoop);
        vertSource = vertSource.replace('%size%', kernelSize);
        return vertSource;
    }
    apply(filterManager, input, output, clear) {
        if (output) {
            if (this.horizontal) {
                this.uniforms.strength = (1 / output.width) * (output.width / input.width);
            }
            else {
                this.uniforms.strength = (1 / output.height) * (output.height / input.height);
            }
        }
        else {
            if (this.horizontal) // eslint-disable-line
             {
                this.uniforms.strength = (1 / filterManager.renderer.width) * (filterManager.renderer.width / input.width);
            }
            else {
                this.uniforms.strength = (1 / filterManager.renderer.height) * (filterManager.renderer.height / input.height); // eslint-disable-line
            }
        }
        // screen space!
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;
        if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clear);
        }
        else {
            var renderTarget = filterManager.getFilterTexture();
            var renderer = filterManager.renderer;
            var flip = input;
            var flop = renderTarget;
            this.state.blend = false;
            filterManager.applyFilter(this, flip, flop, false);
            for (var i = 1; i < this.passes - 1; i++) {
                renderer.renderTexture.bind(flip, flip.filterFrame);
                this.uniforms.uSampler = flop;
                var temp = flop;
                flop = flip;
                flip = temp;
                renderer.shader.bind(this);
                renderer.geometry.draw(5);
            }
            this.state.blend = true;
            filterManager.applyFilter(this, flop, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
    }
    ;
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @default 16
     */
    get blur() {
        return this.strength;
    }
    ;
    set blur(value) {
        this.padding = 1 + (Math.abs(value) * 2);
        this.strength = value;
    }
    ;
    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quaility bluring but the lower the performance.
     *
     * @member {number}
     * @default 4
     */
    get quality() {
        return this._quality;
    }
    ;
    set quality(value) {
        this._quality = value;
        this.passes = value;
    }
    ;
}
BlurFilterPass.GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448],
};
BlurFilterPass.vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n    \n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n    \n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n    \n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
BlurFilterPass.fragTemplate$2 = [
    'varying vec2 vBlurTexCoords[%size%];',
    'uniform sampler2D uSampler;',
    'void main(void)',
    '{',
    '    gl_FragColor = vec4(0.0);',
    '    %blur%',
    '}'
].join('\n');
exports.BlurFilterPass = BlurFilterPass;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Bounds.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Bounds.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class Bounds {
    constructor() {
        /**
         * @member {number}
         * @default 0
         */
        this.minX = Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.minY = Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.maxX = -Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.maxY = -Infinity;
        this.rect = null;
    }
    /**
 * Checks if bounds are empty.
 *
 * @return {boolean} True if empty.
 */
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
    }
    ;
    /**
     * Clears the bounds and resets.
     *
     */
    clear() {
        this.updateID++;
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
    }
    ;
    /**
 * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
 * It is not guaranteed that it will return tempRect
 *
 * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
 * @returns {PIXI.Rectangle} A rectangle of the bounds
 */
    getRectangle(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
            return Rectangle_1.Rectangle.EMPTY;
        }
        rect = rect || new Rectangle_1.Rectangle(0, 0, 1, 1);
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
    }
    ;
    /**
     * This function should be inlined when its possible.
     *
     * @param {PIXI.Point} point - The point to add.
     */
    addPoint(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
    }
    ;
    /**
     * Adds a quad, not transformed
     *
     * @param {Float32Array} vertices - The verts to add.
     */
    addQuad(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = vertices[0];
        var y = vertices[1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[2];
        y = vertices[3];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[4];
        y = vertices[5];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[6];
        y = vertices[7];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds sprite frame, transformed.
     *
     * @param {PIXI.Transform} transform - TODO
     * @param {number} x0 - TODO
     * @param {number} y0 - TODO
     * @param {number} x1 - TODO
     * @param {number} y1 - TODO
     */
    addFrame(transform, x0, y0, x1, y1) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = (a * x0) + (c * y0) + tx;
        var y = (b * x0) + (d * y0) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x1) + (c * y0) + tx;
        y = (b * x1) + (d * y0) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x0) + (c * y1) + tx;
        y = (b * x0) + (d * y1) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x1) + (c * y1) + tx;
        y = (b * x1) + (d * y1) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds screen vertices from array
     *
     * @param {Float32Array} vertexData - calculated vertices
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */
    addVertexData(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
            var x = vertexData[i];
            var y = vertexData[i + 1];
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Add an array of mesh vertices
     *
     * @param {PIXI.Transform} transform - mesh transform
     * @param {Float32Array} vertices - mesh coordinates in array
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */
    addVertices(transform, vertices, beginOffset, endOffset) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
            var rawX = vertices[i];
            var rawY = vertices[i + 1];
            var x = (a * rawX) + (c * rawY) + tx;
            var y = (d * rawY) + (b * rawX) + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds other Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     */
    addBounds(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    }
    ;
    /**
     * Adds other Bounds, masked with Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Bounds} mask - TODO
     */
    addBoundsMask(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    }
    ;
    /**
     * Adds other Bounds, masked with Rectangle
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Rectangle} area - TODO
     */
    addBoundsArea(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);
        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    }
    ;
}
exports.Bounds = Bounds;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Buffer.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Buffer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Buffer {
    constructor(data = null, _static = false, index = null) {
        if (_static === void 0) {
            _static = true;
        }
        if (index === void 0) {
            index = false;
        }
        /**
         * The data in the buffer, as a typed array
         *
         * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
         */
        this.data = data || new Float32Array(1);
        /**
         * A map of renderer IDs to webgl buffer
         *
         * @private
         * @member {object<number, GLBuffer>}
         */
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index;
        this.static = _static;
        this.id = Buffer.UID++;
        this.disposeRunner = new Runner_1.Runner('disposeBuffer', 2);
        // this.disposeRunner = new Runner('disposeBuffer', 2);
    }
    // TODO could explore flagging only a partial upload?
    /**
     * flags this buffer as requiring an upload to the GPU
     */
    update(data) {
        this.data = data || this.data;
        this._updateID++;
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        this.disposeRunner.run(this, false);
        // this.disposeRunner.run(this, false);
    }
    ;
    /**
     * Destroys the buffer
     */
    destroy() {
        this.dispose();
        this.data = null;
    }
    ;
    /**
     * Helper function that creates a buffer based on an array or TypedArray
     *
     * @static
     * @param {ArrayBufferView | number[]} data the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
     * @return {PIXI.Buffer} A new Buffer based on the data provided.
     */
    static from(data) {
        if (data instanceof Array) {
            data = new Float32Array(data);
        }
        return new Buffer(data);
    }
    ;
}
Buffer.UID = 0;
exports.Buffer = Buffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BufferResource.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BufferResource.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
class BufferResource extends Resource_1.Resource {
    constructor(source, options) {
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;
        if (!width || !height) {
            throw new Error('BufferResource width or height invalid');
        }
        super(width, height);
        /**
         * Source array
         * Cannot be ClampedUint8Array because it cant be uploaded to WebGL
         *
         * @member {Float32Array|Uint8Array|Uint32Array}
         */
        this.data = source;
    }
    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture glTexture
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
            gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        }
        else {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;
            var internalFormat = baseTexture.format;
            // guess sized format by type and format
            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
            if (renderer.context.webGLVersion === 2
                && baseTexture.type === renderer.gl.FLOAT
                && baseTexture.format === renderer.gl.RGBA) {
                internalFormat = renderer.gl.RGBA32F;
            }
            gl.texImage2D(baseTexture.target, 0, internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
    }
    ;
    /**
     * Destroy and don't use after this
     * @override
     */
    dispose() {
        this.data = null;
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @return {boolean} `true` if <canvas>
     */
    static test(source) {
        return source instanceof Float32Array
            || source instanceof Uint8Array
            || source instanceof Uint32Array;
    }
    ;
}
exports.BufferResource = BufferResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CacheSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CacheSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CacheSettings {
    static clearTextureCache() {
        var key;
        for (key in CacheSettings.TextureCache) {
            delete CacheSettings.TextureCache[key];
        }
        for (key in CacheSettings.BaseTextureCache) {
            delete CacheSettings.BaseTextureCache[key];
        }
    }
    static destroyTextureCache() {
        var key;
        for (key in CacheSettings.TextureCache) {
            CacheSettings.TextureCache[key].destroy();
        }
        for (key in CacheSettings.BaseTextureCache) {
            CacheSettings.BaseTextureCache[key].destroy();
        }
    }
}
CacheSettings.ProgramCache = {};
CacheSettings.nameCache = {};
CacheSettings.programCache = {};
CacheSettings.TextureCache = {};
CacheSettings.BaseTextureCache = {};
CacheSettings.defaultGroupCache = {};
exports.CacheSettings = CacheSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasRenderTarget.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasRenderTarget.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class CanvasRenderTarget {
    constructor(width, height, resolution) {
        /**
                 * The Canvas object that belongs to this CanvasRenderTarget.
                 *
                 * @member {HTMLCanvasElement}
                 */
        this.canvas = document.createElement('canvas');
        /**
         * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
         *
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.resize(width, height);
    }
    /**
     * Clears the canvas that was created by the CanvasRenderTarget class.
     *
     * @private
     */
    clear() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    ;
    /**
     * Resizes the canvas to the specified width and height.
     *
     * @param {number} width - the new width of the canvas
     * @param {number} height - the new height of the canvas
     */
    resize(width, height) {
        this.canvas.width = width * this.resolution;
        this.canvas.height = height * this.resolution;
    }
    ;
    /**
     * Destroys this canvas.
     *
     */
    destroy() {
        this.context = null;
        this.canvas = null;
    }
    ;
    /**
     * The width of the canvas buffer in pixels.
     *
     * @member {number}
     */
    get width() {
        return this.canvas.width;
    }
    ;
    set width(val) {
        this.canvas.width = val;
    }
    ;
    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     */
    get height() {
        return this.canvas.height;
    }
    ;
    set height(val) {
        this.canvas.height = val;
    }
    ;
}
exports.CanvasRenderTarget = CanvasRenderTarget;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasResource.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasResource.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
class CanvasResource extends BaseImageResource_1.BaseImageResource {
    constructor(source) {
        super(source);
    }
    static test(source) {
        return (source instanceof HTMLCanvasElement);
    }
    ;
}
exports.CanvasResource = CanvasResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasSettings.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasSettings.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CanvasSettings {
    /**
* Trim transparent borders from a canvas
*
* @memberof PIXI.utils
* @function trimCanvas
* @param {HTMLCanvasElement} canvas - the canvas to trim
* @returns {object} Trim data
*/
    static trimCanvas(canvas) {
        // https://gist.github.com/remy/784508
        var width = canvas.width;
        var height = canvas.height;
        var context = canvas.getContext('2d');
        var imageData = context.getImageData(0, 0, width, height);
        var pixels = imageData.data;
        var len = pixels.length;
        var bound = {
            top: null,
            left: null,
            right: null,
            bottom: null,
        };
        var data = null;
        var i;
        var x;
        var y;
        for (i = 0; i < len; i += 4) {
            if (pixels[i + 3] !== 0) {
                x = (i / 4) % width;
                y = ~~((i / 4) / width);
                if (bound.top === null) {
                    bound.top = y;
                }
                if (bound.left === null) {
                    bound.left = x;
                }
                else if (x < bound.left) {
                    bound.left = x;
                }
                if (bound.right === null) {
                    bound.right = x + 1;
                }
                else if (bound.right < x) {
                    bound.right = x + 1;
                }
                if (bound.bottom === null) {
                    bound.bottom = y;
                }
                else if (bound.bottom < y) {
                    bound.bottom = y;
                }
            }
        }
        if (bound.top !== null) {
            width = bound.right - bound.left;
            height = bound.bottom - bound.top + 1;
            data = context.getImageData(bound.left, bound.top, width, height);
        }
        return {
            height: height,
            width: width,
            data: data,
        };
    }
}
exports.CanvasSettings = CanvasSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Circle.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Circle.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Circle {
    constructor(x = 0, y = 0, radius = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (radius === void 0) {
            radius = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.radius = radius;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.CIRC
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.CIRC;
    }
    /**
     * Creates a clone of this Circle instance
     *
     * @return {PIXI.Circle} a copy of the Circle
     */
    clone() {
        return new Circle(this.x, this.y, this.radius);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */
    contains(x, y) {
        if (this.radius <= 0) {
            return false;
        }
        var r2 = this.radius * this.radius;
        var dx = (this.x - x);
        var dy = (this.y - y);
        dx *= dx;
        dy *= dy;
        return (dx + dy <= r2);
    }
    ;
    /**
    * Returns the framing rectangle of the circle as a Rectangle object
    *
    * @return {PIXI.Rectangle} the framing rectangle
    */
    getBounds() {
        return new Rectangle_1.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
    ;
}
exports.Circle = Circle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CleanUpSettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CleanUpSettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CleanUpSettings {
}
CleanUpSettings.defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true,
};
exports.CleanUpSettings = CleanUpSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ColorMatrixFilter.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ColorMatrixFilter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class ColorMatrixFilter extends Filter_1.Filter {
    constructor() {
        var uniforms = {
            m: new Float32Array([1, 0, 0, 0, 0,
                0, 1, 0, 0, 0,
                0, 0, 1, 0, 0,
                0, 0, 0, 1, 0]),
            uAlpha: 1,
        };
        super(settings_1.settings.defaultFilterVertex, ColorMatrixFilter.fragment$4, uniforms);
        this.alpha = 1;
    }
    /**
     * Transforms current matrix and set the new one
     *
     * @param {number[]} matrix - 5x4 matrix
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    _loadMatrix(matrix, multiply) {
        if (multiply === void 0) {
            multiply = false;
        }
        var newMatrix = matrix;
        if (multiply) {
            this._multiply(newMatrix, this.uniforms.m, matrix);
            newMatrix = this._colorMatrix(newMatrix);
        }
        // set the new matrix
        this.uniforms.m = newMatrix;
    }
    ;
    /**
     * Multiplies two mat5's
     *
     * @private
     * @param {number[]} out - 5x4 matrix the receiving matrix
     * @param {number[]} a - 5x4 matrix the first operand
     * @param {number[]} b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */
    _multiply(out, a, b) {
        // Red Channel
        out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
        out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
        out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
        out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
        out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]) + a[4];
        // Green Channel
        out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
        out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
        out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
        out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
        out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]) + a[9];
        // Blue Channel
        out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
        out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
        out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
        out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
        out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]) + a[14];
        // Alpha Channel
        out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
        out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
        out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
        out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
        out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]) + a[19];
        return out;
    }
    ;
    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     *
     * @private
     * @param {number[]} matrix - 5x4 matrix
     * @return {number[]} 5x4 matrix with all values between 0-1
     */
    _colorMatrix(matrix) {
        // Create a Float32 Array and normalize the offset component to 0-1
        var m = new Float32Array(matrix);
        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;
        return m;
    }
    ;
    /**
     * Adjusts brightness
     *
     * @param {number} b - value of the brigthness (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    brightness(b, multiply) {
        var matrix = [
            b, 0, 0, 0, 0,
            0, b, 0, 0, 0,
            0, 0, b, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the matrices in grey scales
     *
     * @param {number} scale - value of the grey (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    greyscale(scale, multiply) {
        var matrix = [
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the black and white matrice.
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    blackAndWhite(multiply) {
        var matrix = [
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the hue property of the color
     *
     * @param {number} rotation - in degrees
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    hue(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;
        /* a good approximation for hue rotation
            This matrix is far better than the versions with magic luminance constants
            formerly used here, but also used in the starling framework (flash) and known from this
            old part of the internet: quasimondo.com/archives/000565.php

            This new matrix is based on rgb cube rotation in space. Look here for a more descriptive
            implementation as a shader not a general matrix:
            https://github.com/evanw/glfx.js/blob/58841c23919bd59787effc0333a4897b43835412/src/filters/adjust/huesaturation.js

            This is the source for the code:
            see http://stackoverflow.com/questions/8507885/shift-hue-of-an-rgb-color/8510751#8510751
            */
        var w = 1 / 3;
        var sqrW = sqrt(w); // weight is
        var a00 = cosR + ((1.0 - cosR) * w);
        var a01 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a02 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a10 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a11 = cosR + (w * (1.0 - cosR));
        var a12 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a20 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a21 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a22 = cosR + (w * (1.0 - cosR));
        var matrix = [
            a00, a01, a02, 0, 0,
            a10, a11, a12, 0, 0,
            a20, a21, a22, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     *
     * @param {number} amount - value of the contrast (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    contrast(amount, multiply) {
        var v = (amount || 0) + 1;
        var o = -0.5 * (v - 1);
        var matrix = [
            v, 0, 0, 0, o,
            0, v, 0, 0, o,
            0, 0, v, 0, o,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     *
     * @param {number} amount - The saturation amount (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    saturate(amount, multiply = null) {
        if (amount === void 0) {
            amount = 0;
        }
        var x = (amount * 2 / 3) + 1;
        var y = ((x - 1) * -0.5);
        var matrix = [
            x, y, y, 0, 0,
            y, x, y, 0, 0,
            y, y, x, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Desaturate image (remove color)
     *
     * Call the saturate function
     *
     */
    desaturate() {
        this.saturate(-1);
    }
    ;
    /**
     * Negative image (inverse of classic rgb matrix)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    negative(multiply) {
        var matrix = [
            -1, 0, 0, 1, 0,
            0, -1, 0, 1, 0,
            0, 0, -1, 1, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Sepia image
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    sepia(multiply) {
        var matrix = [
            0.393, 0.7689999, 0.18899999, 0, 0,
            0.349, 0.6859999, 0.16799999, 0, 0,
            0.272, 0.5339999, 0.13099999, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    technicolor(multiply) {
        var matrix = [
            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
            -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,
            -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Polaroid filter
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    polaroid(multiply) {
        var matrix = [
            1.438, -0.062, -0.062, 0, 0,
            -0.122, 1.378, -0.122, 0, 0,
            -0.016, -0.016, 1.483, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Filter who transforms : Red -> Blue and Blue -> Red
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    toBGR(multiply) {
        var matrix = [
            0, 0, 1, 0, 0,
            0, 1, 0, 0, 0,
            1, 0, 0, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    kodachrome(multiply) {
        var matrix = [
            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
            -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
            -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    browni(multiply) {
        var matrix = [
            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
            -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,
            0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Vintage filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    vintage(multiply) {
        var matrix = [
            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
            0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,
            0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     *
     * @param {number} desaturation - Tone values.
     * @param {number} toned - Tone values.
     * @param {string} lightColor - Tone values, example: `0xFFE580`
     * @param {string} darkColor - Tone values, example: `0xFFE580`
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    colorTone(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 0xFFE580;
        darkColor = darkColor || 0x338000;
        var lR = ((lightColor >> 16) & 0xFF) / 255;
        var lG = ((lightColor >> 8) & 0xFF) / 255;
        var lB = (lightColor & 0xFF) / 255;
        var dR = ((darkColor >> 16) & 0xFF) / 255;
        var dG = ((darkColor >> 8) & 0xFF) / 255;
        var dB = (darkColor & 0xFF) / 255;
        var matrix = [
            0.3, 0.59, 0.11, 0, 0,
            lR, lG, lB, desaturation, 0,
            dR, dG, dB, toned, 0,
            lR - dR, lG - dG, lB - dB, 0, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Night effect
     *
     * @param {number} intensity - The intensity of the night effect.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    night(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [
            intensity * (-2.0), -intensity, 0, 0, 0,
            -intensity, 0, intensity, 0, 0,
            0, intensity, intensity * 2.0, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new indepent one
     *
     * @param {number} amount - how much the predator feels his future victim
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    predator(amount, multiply) {
        var matrix = [
            // row 1
            11.224130630493164 * amount,
            -4.794486999511719 * amount,
            -2.8746118545532227 * amount,
            0 * amount,
            0.40342438220977783 * amount,
            // row 2
            -3.6330697536468506 * amount,
            9.193157196044922 * amount,
            -2.951810836791992 * amount,
            0 * amount,
            -1.316135048866272 * amount,
            // row 3
            -3.2184197902679443 * amount,
            -4.2375030517578125 * amount,
            7.476448059082031 * amount,
            0 * amount,
            0.8044459223747253 * amount,
            // row 4
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * LSD effect
     *
     * Multiply the current matrix
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    lsd(multiply) {
        var matrix = [
            2, -0.4, 0.5, 0, 0,
            -0.5, 2, -0.4, 0, 0,
            -0.4, -0.5, 3, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Erase the current matrix by setting the default one
     *
     */
    reset() {
        var matrix = [
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, false);
    }
    ;
    /**
     * The matrix of the color matrix filter
     *
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    get matrix() {
        return this.uniforms.m;
    }
    ;
    set matrix(value) {
        this.uniforms.m = value;
    }
    ;
    /**
     * The opacity value to use when mixing the original and resultant colors.
     *
     * When the value is 0, the original color is used without modification.
     * When the value is 1, the result color is used.
     * When in the range (0, 1) the color is interpolated between the original and result by this amount.
     *
     * @member {number}
     * @default 1
     */
    get alpha() {
        return this.uniforms.uAlpha;
    }
    ;
    set alpha(value) {
        this.uniforms.uAlpha = value;
    }
    ;
}
/*!
* @pixi/filter-color-matrix - v5.0.0-rc.3
* Compiled Wed, 10 Apr 2019 01:21:15 UTC
*
* @pixi/filter-color-matrix is licensed under the MIT License.
* http://www.opensource.org/licenses/mit-license
*/
ColorMatrixFilter.fragment$4 = "varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform float m[20];\r\nuniform float uAlpha;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 c = texture2D(uSampler, vTextureCoord);\r\n\r\n    if (uAlpha == 0.0) {\r\n        gl_FragColor = c;\r\n        return;\r\n    }\r\n\r\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\r\n    if (c.a > 0.0) {\r\n      c.rgb /= c.a;\r\n    }\r\n\r\n    vec4 result;\r\n\r\n    result.r = (m[0] * c.r);\r\n        result.r += (m[1] * c.g);\r\n        result.r += (m[2] * c.b);\r\n        result.r += (m[3] * c.a);\r\n        result.r += m[4];\r\n\r\n    result.g = (m[5] * c.r);\r\n        result.g += (m[6] * c.g);\r\n        result.g += (m[7] * c.b);\r\n        result.g += (m[8] * c.a);\r\n        result.g += m[9];\r\n\r\n    result.b = (m[10] * c.r);\r\n       result.b += (m[11] * c.g);\r\n       result.b += (m[12] * c.b);\r\n       result.b += (m[13] * c.a);\r\n       result.b += m[14];\r\n\r\n    result.a = (m[15] * c.r);\r\n       result.a += (m[16] * c.g);\r\n       result.a += (m[17] * c.b);\r\n       result.a += (m[18] * c.a);\r\n       result.a += m[19];\r\n\r\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\r\n\r\n    // Premultiply alpha again.\r\n    rgb *= result.a;\r\n\r\n    gl_FragColor = vec4(rgb, result.a);\r\n}\r\n";
exports.ColorMatrixFilter = ColorMatrixFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ColorSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ColorSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class ColorSettings {
    static premultiplyTint(tint, alpha) {
        if (alpha === 1.0) {
            return (alpha * 255 << 24) + tint;
        }
        if (alpha === 0.0) {
            return 0;
        }
        var R = ((tint >> 16) & 0xFF);
        var G = ((tint >> 8) & 0xFF);
        var B = (tint & 0xFF);
        R = ((R * alpha) + 0.5) | 0;
        G = ((G * alpha) + 0.5) | 0;
        B = ((B * alpha) + 0.5) | 0;
        return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
    }
    static premultiplyTintToRgba(tint, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        out[0] = ((tint >> 16) & 0xFF) / 255.0;
        out[1] = ((tint >> 8) & 0xFF) / 255.0;
        out[2] = (tint & 0xFF) / 255.0;
        if (premultiply || premultiply === undefined) {
            out[0] *= alpha;
            out[1] *= alpha;
            out[2] *= alpha;
        }
        out[3] = alpha;
        return out;
    }
    static getSingleColor(color) {
        if (typeof color === 'number') {
            return MathSettings_1.MathSettings.hex2string(color);
        }
        else if (typeof color === 'string') {
            if (color.indexOf('0x') === 0) {
                color = color.replace('0x', '#');
            }
        }
        return color;
    }
    static getColor(color) {
        if (!Array.isArray(color)) {
            return ColorSettings.getSingleColor(color);
        }
        else {
            for (var i = 0; i < color.length; ++i) {
                color[i] = ColorSettings.getSingleColor(color[i]);
            }
            return color;
        }
    }
    static premultiplyRgba(rgb, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        if (premultiply || premultiply === undefined) {
            out[0] = rgb[0] * alpha;
            out[1] = rgb[1] * alpha;
            out[2] = rgb[2] * alpha;
        }
        else {
            out[0] = rgb[0];
            out[1] = rgb[1];
            out[2] = rgb[2];
        }
        out[3] = alpha;
        return out;
    }
    /**
* Converts a hexadecimal color number to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
*
* @example
* PIXI.utils.hex2rgb(0xffffff); // returns [1, 1, 1]
* @memberof PIXI.utils
* @function hex2rgb
* @param {number} hex - The hexadecimal number to convert
* @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
* @return {number[]} An array representing the [R, G, B] of the color where all values are floats.
*/
    static hex2rgb(hex, out = null) {
        out = out || [];
        out[0] = ((hex >> 16) & 0xFF) / 255;
        out[1] = ((hex >> 8) & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;
        return out;
    }
    /**
* Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.
*
* @example
* PIXI.utils.rgb2hex([1, 1, 1]); // returns 0xffffff
* @memberof PIXI.utils
* @function rgb2hex
* @param {number[]} rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.
* @return {number} Number in hexadecimal.
*/
    static rgb2hex(rgb) {
        return (((rgb[0] * 255) << 16) + ((rgb[1] * 255) << 8) + (rgb[2] * 255 | 0));
    }
}
exports.ColorSettings = ColorSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Container.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Container.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DisplayObject_1 = __webpack_require__(/*! ./DisplayObject */ "./js-compile/raw-pixi-ts/DisplayObject.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class Container extends DisplayObject_1.DisplayObject {
    constructor() {
        super();
        this.containerUpdateTransform = this.updateTransform;
        /**
         * The array of children of this container.
         *
         * @member {PIXI.DisplayObject[]}
         * @readonly
         */
        this.children = [];
        /**
         * If set to true, the container will sort its children by zIndex value
         * when updateTransform() is called, or manually if sortChildren() is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as @link https://github.com/pixijs/pixi-display
         *
         * Also be aware of that this may not work nicely with the addChildAt() function,
         * as the zIndex sorting may cause the child to automatically sorted to another position.
         *
         * @see PIXI.settings.SORTABLE_CHILDREN
         *
         * @member {boolean}
         */
        this.sortableChildren = DisplaySettings_1.DisplaySettings.SORTABLE_CHILDREN;
        /**
         * Should children be sorted by zIndex at the next updateTransform call.
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         *
         * @member {boolean}
         */
        this.sortDirty = false;
        /**
         * Fired when a DisplayObject is added to this Container.
         *
         * @event PIXI.Container#childAdded
         * @param {PIXI.DisplayObject} child - The child added to the Container.
         * @param {PIXI.Container} container - The container that added the child.
         * @param {number} index - The children's index of the added child.
         */
        /**
         * Fired when a DisplayObject is removed from this Container.
         *
         * @event PIXI.DisplayObject#removedFrom
         * @param {PIXI.DisplayObject} child - The child removed from the Container.
         * @param {PIXI.Container} container - The container that removed removed the child.
         * @param {number} index - The former children's index of the removed child
         */
    }
    /**
 * Returns the display object in the container.
 *
 * @method getChildByName
 * @memberof PIXI.Container#
 * @param {string} name - Instance name.
 * @return {PIXI.DisplayObject} The child with the specified name.
 */
    getChildByName(name) {
        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].name === name) {
                return this.children[i];
            }
        }
        return null;
    }
    ;
    /**
     * Overridable method that can be used by Container subclasses whenever the children array is modified
     *
     * @protected
     */
    onChildrenChange(options) {
        /* empty */
    }
    ;
    /**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
     * @return {PIXI.DisplayObject} The first child that was added.
     */
    addChild(child) {
        var arguments$1 = arguments;
        var argumentsLength = arguments.length;
        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.addChild(arguments$1[i]);
            }
        }
        else {
            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place
            if (child.parent) {
                child.parent.removeChild(child);
            }
            child.parent = this;
            this.sortDirty = true;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            this.children.push(child);
            // ensure bounds will be recalculated
            this._boundsID++;
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            this.dispatchEvent(Event_1.Event.getEvent("childAdded"));
            // this.emit('childAdded', child, this, this.children.length - 1);
            child.dispatchEvent(Event_1.Event.getEvent("added"));
            // child.emit('added', this);
        }
        return child;
    }
    ;
    /**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
     *
     * @param {PIXI.DisplayObject} child - The child to add
     * @param {number} index - The index to place the child in
     * @return {PIXI.DisplayObject} The child that was added.
     */
    addChildAt(child, index) {
        if (index < 0 || index > this.children.length) {
            throw new Error((child + "addChildAt: The index " + index + " supplied is out of bounds " + (this.children.length)));
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        // ensure child transform will be recalculated
        child.transform._parentID = -1;
        this.children.splice(index, 0, child);
        // ensure bounds will be recalculated
        this._boundsID++;
        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        // child.emit('added', this);
        this.dispatchEvent(Event_1.Event.getEvent("childAdded"));
        // this.emit('childAdded', child, this, index);
        return child;
    }
    ;
    /**
     * Swaps the position of 2 Display Objects within this container.
     *
     * @param {PIXI.DisplayObject} child - First display object to swap
     * @param {PIXI.DisplayObject} child2 - Second display object to swap
     */
    swapChildren(child, child2) {
        if (child === child2) {
            return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
    }
    ;
    /**
     * Returns the index position of a child DisplayObject instance
     *
     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
     * @return {number} The index position of the child display object to identify
     */
    getChildIndex(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
            throw new Error('The supplied DisplayObject must be a child of the caller');
        }
        return index;
    }
    ;
    /**
     * Changes the position of an existing child in the display object container
     *
     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
     * @param {number} index - The resulting index number for the child display object
     */
    setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(("The index " + index + " supplied is out of bounds " + (this.children.length)));
        }
        var currentIndex = this.getChildIndex(child);
        UtilsSettings_1.UtilsSettings.removeItems(this.children, currentIndex, 1); // remove from old position
        this.children.splice(index, 0, child); // add at new position
        this.onChildrenChange(index);
    }
    ;
    /**
     * Returns the child at the specified index
     *
     * @param {number} index - The index to get the child at
     * @return {PIXI.DisplayObject} The child at the given index, if any.
     */
    getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(("getChildAt: Index (" + index + ") does not exist."));
        }
        return this.children[index];
    }
    ;
    /**
     * Removes one or more children from the container.
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
     * @return {PIXI.DisplayObject} The first child that was removed.
     */
    removeChild(child) {
        var arguments$1 = arguments;
        var argumentsLength = arguments.length;
        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.removeChild(arguments$1[i]);
            }
        }
        else {
            var index = this.children.indexOf(child);
            if (index === -1) {
                return null;
            }
            child.parent = null;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            UtilsSettings_1.UtilsSettings.removeItems(this.children, index, 1);
            // ensure bounds will be recalculated
            this._boundsID++;
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            // child.emit('removed', this);
            this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
            // this.emit('childRemoved', child, this, index);
        }
        return child;
    }
    ;
    /**
     * Removes a child from the specified index position.
     *
     * @param {number} index - The index to get the child from
     * @return {PIXI.DisplayObject} The child that was removed.
     */
    removeChildAt(index) {
        var child = this.getChildAt(index);
        // ensure child transform will be recalculated..
        child.parent = null;
        child.transform._parentID = -1;
        UtilsSettings_1.UtilsSettings.removeItems(this.children, index, 1);
        // ensure bounds will be recalculated
        this._boundsID++;
        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        // child.emit('removed', this);
        this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
        // this.emit('childRemoved', child, this, index);
        return child;
    }
    ;
    /**
     * Removes all children from this container that are within the begin and end indexes.
     *
     * @param {number} [beginIndex=0] - The beginning position.
     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
     * @returns {DisplayObject[]} List of removed children
     */
    removeChildren(beginIndex = 0, endIndex = Infinity) {
        if (beginIndex === void 0) {
            beginIndex = 0;
        }
        var begin = beginIndex;
        var end = typeof endIndex === 'number' ? endIndex : this.children.length;
        var range = end - begin;
        var removed;
        if (range > 0 && range <= end) {
            removed = this.children.splice(begin, range);
            for (var i = 0; i < removed.length; ++i) {
                removed[i].parent = null;
                if (removed[i].transform) {
                    removed[i].transform._parentID = -1;
                }
            }
            this._boundsID++;
            this.onChildrenChange(beginIndex);
            for (var i$1 = 0; i$1 < removed.length; ++i$1) {
                // removed[i$1].emit('removed', this);
                this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
                // this.emit('childRemoved', removed[i$1], this, i$1);
            }
            return removed;
        }
        else if (range === 0 && this.children.length === 0) {
            return [];
        }
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    }
    ;
    /**
     * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.
     */
    sortChildren() {
        var sortRequired = false;
        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            child._lastSortedIndex = i;
            if (!sortRequired && child.zIndex !== 0) {
                sortRequired = true;
            }
        }
        if (sortRequired && this.children.length > 1) {
            this.children.sort(Container.sortChildren);
        }
        this.sortDirty = false;
    }
    ;
    /**
     * Updates the transform on all children of this container for rendering
     */
    updateTransform() {
        if (this.sortableChildren && this.sortDirty) {
            this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        // TODO: check render flags, how to process stuff here
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            if (child.visible) {
                child.updateTransform();
            }
        }
    }
    ;
    /**
     * Recalculates the bounds of the container.
     *
     */
    calculateBounds() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (!child.visible || !child.renderable) {
                continue;
            }
            child.calculateBounds();
            // TODO: filter+mask, need to mask both somehow
            if (child._mask) {
                child._mask.calculateBounds();
                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
            }
            else if (child.filterArea) {
                this._bounds.addBoundsArea(child._bounds, child.filterArea);
            }
            else {
                this._bounds.addBounds(child._bounds);
            }
        }
        this._lastBoundsID = this._boundsID;
    }
    ;
    /**
     * Recalculates the bounds of the object. Override this to
     * calculate the bounds of the specific object (not including children).
     *
     * @protected
     */
    _calculateBounds() {
        // FILL IN//
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer) {
        // if the object is not visible or the alpha is 0 then no need to render this element
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        // do a quick check to see if this element has a mask or a filter.
        if (this._mask || this.filters) {
            this.renderAdvanced(renderer);
        }
        else {
            this._render(renderer);
            // simple render children!
            for (var i = 0, j = this.children.length; i < j; ++i) {
                this.children[i].render(renderer);
            }
        }
    }
    ;
    /**
     * Render the object using the WebGL renderer and advanced features.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    renderAdvanced(renderer) {
        renderer.batch.flush();
        var filters = this.filters;
        var mask = this._mask;
        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (filters) {
            if (!this._enabledFilters) {
                this._enabledFilters = [];
            }
            this._enabledFilters.length = 0;
            for (var i = 0; i < filters.length; i++) {
                if (filters[i].enabled) {
                    this._enabledFilters.push(filters[i]);
                }
            }
            if (this._enabledFilters.length) {
                renderer.filter.push(this, this._enabledFilters);
            }
        }
        if (mask) {
            renderer.mask.push(this, this._mask);
        }
        // add this object to the batch, only rendered if it has a texture.
        this._render(renderer);
        // now loop through the children and make sure they get rendered
        for (var i$1 = 0, j = this.children.length; i$1 < j; i$1++) {
            this.children[i$1].render(renderer);
        }
        renderer.batch.flush();
        if (mask) {
            renderer.mask.pop(this, this._mask);
        }
        if (filters && this._enabledFilters && this._enabledFilters.length) {
            renderer.filter.pop();
        }
    }
    ;
    /**
     * To be overridden by the subclasses.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        // this is where content itself gets rendered...
    }
    ;
    /**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.sortDirty = false;
        var destroyChildren = typeof options === 'boolean' ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
            for (var i = 0; i < oldChildren.length; ++i) {
                oldChildren[i].destroy(options);
            }
        }
    }
    ;
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return this.scale.x * this.getLocalBounds().width;
    }
    ;
    set width(value) {
        var width = this.getLocalBounds().width;
        if (width !== 0) {
            this.scale.x = value / width;
        }
        else {
            this.scale.x = 1;
        }
        this._width = value;
    }
    ;
    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return this.scale.y * this.getLocalBounds().height;
    }
    ;
    set height(value) {
        var height = this.getLocalBounds().height;
        if (height !== 0) {
            this.scale.y = value / height;
        }
        else {
            this.scale.y = 1;
        }
        this._height = value;
    }
    ;
    static sortChildren(a, b) {
        if (a.zIndex === b.zIndex) {
            return a._lastSortedIndex - b._lastSortedIndex;
        }
        return a.zIndex - b.zIndex;
    }
}
exports.Container = Container;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ContextSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ContextSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class ContextSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Either 1 or 2 to reflect the WebGL version being used
         * @member {number}
         * @readonly
         */
        this.webGLVersion = 1;
        /**
         * Extensions being used
         * @member {object}
         * @readonly
         * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension
         * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension
         * @property {OES_texture_float} floatTexture - WebGL v1 extension
         * @property {WEBGL_lose_context} loseContext - WebGL v1 extension
         * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension
         */
        this.extensions = {};
        // Bind functions
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        renderer.view.addEventListener('webglcontextlost', this.handleContextLost, false);
        renderer.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);
    }
    /**
     * `true` if the context is lost
     * @member {boolean}
     * @readonly
     */
    get isLost() {
        return (!this.gl || this.gl.isContextLost());
    }
    ;
    /**
     * Handle the context change event
     * @param {WebGLRenderingContext} gl new webgl context
     */
    contextChange(gl) {
        this.gl = gl;
        // restore a context if it was previously lost
        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
            gl.getExtension('WEBGL_lose_context').restoreContext();
        }
    }
    ;
    /**
     * Initialize the context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - WebGL context
     */
    initFromContext(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = ContextSystem.CONTEXT_UID++;
        // this.dispatchEvent(Event.getEvent("contextchange"))
        this.renderer.runners.contextChange.run(gl);
    }
    ;
    /**
     * Initialize from context options
     *
     * @protected
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
     * @param {object} options - context attributes
     */
    initFromOptions(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
    }
    ;
    /**
     * Helper class to create a WebGL Context
     *
     * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
     * @param options {object} An options object that gets passed in to the canvas element containing the context attributes
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
     * @return {WebGLRenderingContext} the WebGL context
     */
    createContext(canvas, options) {
        var gl;
        if (DisplaySettings_1.DisplaySettings.PREFER_ENV >= DisplaySettings_1.DisplaySettings.ENV.WEBGL2) {
            gl = canvas.getContext('webgl2', options);
        }
        if (gl) {
            this.webGLVersion = 2;
        }
        else {
            this.webGLVersion = 1;
            gl = canvas.getContext('webgl', options)
                || canvas.getContext('experimental-webgl', options);
            if (!gl) {
                // fail, not able to get a context
                throw new Error('This browser does not support WebGL. Try using the canvas renderer');
            }
        }
        this.gl = gl;
        this.getExtensions();
        return gl;
    }
    ;
    /**
     * Auto-populate the extensions
     *
     * @protected
     */
    getExtensions() {
        // time to set up default extensions that Pixi uses.
        var ref = this;
        var gl = ref.gl;
        if (this.webGLVersion === 1) {
            Object.assign(this.extensions, {
                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),
                depthTexture: gl.getExtension('WEBKIT_WEBGL_depth_texture'),
                floatTexture: gl.getExtension('OES_texture_float'),
                loseContext: gl.getExtension('WEBGL_lose_context'),
                vertexArrayObject: gl.getExtension('OES_vertex_array_object')
                    || gl.getExtension('MOZ_OES_vertex_array_object')
                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),
            });
        }
        // we don't use any specific WebGL 2 ones yet!
    }
    ;
    /**
     * Handles a lost webgl context
     *
     * @protected
     * @param {WebGLContextEvent} event - The context lost event.
     */
    handleContextLost(event) {
        event.preventDefault();
    }
    ;
    /**
     * Handles a restored webgl context
     *
     * @protected
     */
    handleContextRestored() {
        this.renderer.runners.contextChange.run(this.gl);
    }
    ;
    destroy() {
        var view = this.renderer.view;
        // remove listeners
        view.removeEventListener('webglcontextlost', this.handleContextLost);
        view.removeEventListener('webglcontextrestored', this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
            this.extensions.loseContext.loseContext();
        }
    }
    ;
    /**
     * Handle the post-render runner event
     *
     * @protected
     */
    postrender() {
        this.gl.flush();
    }
    ;
    /**
     * Validate context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - Render context
     */
    validateContext(gl) {
        var attributes = gl.getContextAttributes();
        // this is going to be fairly simple for now.. but at least we have room to grow!
        if (!attributes.stencil) {
            /* eslint-disable max-len */
            /* eslint-disable no-console */
            console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
            /* eslint-enable no-console */
            /* eslint-enable max-len */
        }
    }
    ;
}
ContextSystem.CONTEXT_UID = 0;
exports.ContextSystem = ContextSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CountLimiter.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CountLimiter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CountLimiter {
    constructor(maxItemsPerFrame) {
        /**
             * The maximum number of items that can be prepared each frame.
             * @type {number}
             * @private
             */
        this.maxItemsPerFrame = maxItemsPerFrame;
        /**
         * The number of items that can be prepared in the current frame.
         * @type {number}
         * @private
         */
        this.itemsLeft = 0;
    }
    /**
     * Resets any counting properties to start fresh on a new frame.
     */
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame;
    }
    ;
    /**
     * Checks to see if another item can be uploaded. This should only be called once per item.
     * @return {boolean} If the item is allowed to be uploaded.
     */
    allowedToUpload() {
        return this.itemsLeft-- > 0;
    }
    ;
}
exports.CountLimiter = CountLimiter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CubeResource.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CubeResource.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ArrayResource_1 = __webpack_require__(/*! ./ArrayResource */ "./js-compile/raw-pixi-ts/ArrayResource.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class CubeResource extends ArrayResource_1.ArrayResource {
    constructor(source, options) {
        super(source, options);
        options = options || {};
        if (this.length !== CubeResource.SIDES) {
            throw new Error(("Invalid length. Got " + (this.length) + ", expected 6"));
        }
        for (var i = 0; i < CubeResource.SIDES; i++) {
            this.items[i].target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
        }
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * Add binding
     *
     * @override
     * @param {PIXI.BaseTexture} baseTexture - parent base texture
     */
    bind(baseTexture) {
        super.bind(baseTexture);
        baseTexture.target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_CUBE_MAP;
    }
    ;
    /**
     * Upload the resource
     *
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i = 0; i < CubeResource.SIDES; i++) {
            var side = this.items[i];
            if (dirty[i] < side.dirtyId) {
                dirty[i] = side.dirtyId;
                if (side.valid) {
                    side.resource.upload(renderer, side, glTexture);
                }
            }
        }
        return true;
    }
    ;
}
/**
* Number of texture sides to store for CubeResources
*
* @name PIXI.resources.CubeResource.SIDES
* @static
* @member {number}
* @default 6
*/
CubeResource.SIDES = 6;
exports.CubeResource = CubeResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DepthResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DepthResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
class DepthResource extends BufferResource_1.BufferResource {
    constructor(source, options) {
        super(source, options);
    }
    upload(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
            gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        }
        else {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;
            gl.texImage2D(baseTexture.target, 0, gl.DEPTH_COMPONENT16, // Needed for depth to render properly in webgl2.0
            baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
    }
    ;
}
exports.DepthResource = DepthResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplacementFilter.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplacementFilter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
class DisplacementFilter extends Filter_1.Filter {
    constructor(sprite, scale = 1) {
        var maskMatrix = new Matrix_1.Matrix();
        sprite.renderable = false;
        super(DisplacementFilter.vertex$4, DisplacementFilter.fragment$5, { mapSampler: sprite._texture, filterMatrix: maskMatrix, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]), });
        this.maskSprite = sprite;
        this.maskMatrix = maskMatrix;
        if (scale === null || scale === undefined) {
            scale = 20;
        }
        /**
         * scaleX, scaleY for displacements
         * @member {PIXI.Point}
         */
        this.scale = new Point_1.Point(scale, scale);
    }
    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    apply(filterManager, input, output) {
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;
        // Extract rotation from world transform
        var wt = this.maskSprite.transform.worldTransform;
        var lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));
        var lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));
        if (lenX !== 0 && lenY !== 0) {
            this.uniforms.rotation[0] = wt.a / lenX;
            this.uniforms.rotation[1] = wt.b / lenX;
            this.uniforms.rotation[2] = wt.c / lenY;
            this.uniforms.rotation[3] = wt.d / lenY;
        }
        // draw the filter...
        filterManager.applyFilter(this, input, output);
    }
    ;
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     */
    get map() {
        return this.uniforms.mapSampler;
    }
    ;
    set map(value) {
        this.uniforms.mapSampler = value;
    }
    ;
}
DisplacementFilter.fragment$5 = "varying vec2 vFilterCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec2 scale;\r\nuniform mat2 rotation;\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mapSampler;\r\n\r\nuniform highp vec4 inputSize;\r\nuniform vec4 inputClamp;\r\n\r\nvoid main(void)\r\n{\r\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\r\n\r\n  map -= 0.5;\r\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\r\n\r\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\r\n}\r\n";
DisplacementFilter.vertex$4 = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 filterMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vFilterCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tgl_Position = filterVertexPosition();\r\n\tvTextureCoord = filterTextureCoord();\r\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\r\n}\r\n";
exports.DisplacementFilter = DisplacementFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplayObject.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplayObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Bounds_1 = __webpack_require__(/*! ./Bounds */ "./js-compile/raw-pixi-ts/Bounds.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./js-compile/raw-pixi-ts/Transform.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class DisplayObject extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        /*!
 * @pixi/mixin-get-child-by-name - v5.0.0-rc.3
 * Compiled Wed, 10 Apr 2019 01:21:15 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
        /**
         * The instance name of the object.
         *
         * @memberof PIXI.DisplayObject#
         * @member {string} name
         */
        this.name = null;
        /**
         *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
         *   shadow div with attributes set
         *
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         */
        this.accessible = false;
        /**
         * Sets the title attribute of the shadow div
         * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
         *
         * @member {?string}
         * @memberof PIXI.DisplayObject#
         */
        this.accessibleTitle = null;
        /**
         * Sets the aria-label attribute of the shadow div
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        this.accessibleHint = null;
        /**
         * @member {number}
         * @memberof PIXI.DisplayObject#
         * @private
         * @todo Needs docs.
         */
        this.tabIndex = 0;
        /**
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         * @todo Needs docs.
         */
        this._accessibleActive = false;
        /**
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         * @todo Needs docs.
         */
        this._accessibleDiv = false;
        /**
        * Enable interaction events for the DisplayObject. Touch, pointer and mouse
        * events will not be emitted unless `interactive` is set to `true`.
        *
        * @example
        * const sprite = new PIXI.Sprite(texture);
        * sprite.interactive = true;
        * sprite.on('tap', (event) => {
        *    //handle event
        * });
        * @member {boolean}
        * @memberof PIXI.DisplayObject#
        */
        this.interactive = false;
        /**
         * Determines if the children to the displayObject can be clicked/touched
         * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
         *
         * @member {boolean}
         * @memberof PIXI.Container#
         */
        this.interactiveChildren = true;
        /**
         * Interaction shape. Children will be hit first, then this shape will be checked.
         * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);
         * @member {PIXI.Rectangle|PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.RoundedRectangle}
         * @memberof PIXI.DisplayObject#
         */
        this.hitArea = null;
        /**
         * This defines what cursor mode is used when the mouse cursor
         * is hovered over the displayObject.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.cursor = 'wait';
         * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        this.cursor = null;
        /**
         * Map of all tracked pointers, by identifier. Use trackedPointers to access.
         *
         * @private
         * @type {Map<number, InteractionTrackingData>}
         */
        this._trackedPointers = undefined;
        this._cacheAsBitmap = false;
        this._cacheData = false;
        // performance increase to avoid using call.. (10x faster)
        this.displayObjectUpdateTransform = this.updateTransform;
        this.tempDisplayObjectParent = null;
        // TODO: need to create Transform from factory
        /**
         * World transform and local transform of this object.
         * This will become read-only later, please do not assign anything there unless you know what are you doing.
         *
         * @member {PIXI.Transform}
         */
        this.transform = new Transform_1.Transform();
        /**
         * The opacity of the object.
         *
         * @member {number}
         */
        this.alpha = 1;
        /**
         * The visibility of the object. If false the object will not be drawn, and
         * the updateTransform function will not be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.
         *
         * @member {boolean}
         */
        this.visible = true;
        /**
         * Can this object be rendered, if false the object will not be drawn but the updateTransform
         * methods will still be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds manually.
         *
         * @member {boolean}
         */
        this.renderable = true;
        /**
         * The display object container that contains this display object.
         *
         * @member {PIXI.Container}
         * @readonly
         */
        this.parent = null;
        /**
         * The multiplied alpha of the displayObject.
         *
         * @member {number}
         * @readonly
         */
        this.worldAlpha = 1;
        /**
         * Which index in the children array the display component was before the previous zIndex sort.
         * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.
         *
         * @member {number}
         * @protected
         */
        this._lastSortedIndex = 0;
        /**
         * The zIndex of the displayObject.
         * A higher value will mean it will be rendered on top of other displayObjects within the same container.
         *
         * @member {number}
         * @protected
         */
        this._zIndex = 0;
        /**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         *
         * @member {?PIXI.Rectangle}
         */
        this.filterArea = null;
        /**
         * Sets the filters for the displayObject.
         * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         *
         * @member {?PIXI.Filter[]}
         */
        this.filters = null;
        this._enabledFilters = null;
        /**
         * The bounds object, this is used to calculate and store the bounds of the displayObject.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds_1.Bounds();
        this._boundsID = 0;
        this._lastBoundsID = -1;
        this._boundsRect = null;
        this._localBoundsRect = null;
        /**
         * The original, cached mask of the object.
         *
         * @member {PIXI.Graphics|PIXI.Sprite}
         * @protected
         */
        this._mask = null;
        /**
         * Fired when this DisplayObject is added to a Container.
         *
         * @event PIXI.DisplayObject#added
         * @param {PIXI.Container} container - The container added to.
         */
        /**
         * Fired when this DisplayObject is removed from a Container.
         *
         * @event PIXI.DisplayObject#removed
         * @param {PIXI.Container} container - The container removed from.
         */
        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @protected
         */
        this._destroyed = false;
        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = false;
    }
    /**
 * Internal set of all active pointers, by identifier
 *
 * @member {Map<number, InteractionTrackingData>}
 * @memberof PIXI.DisplayObject#
 * @private
 */
    get trackedPointers() {
        if (this._trackedPointers === undefined) {
            this._trackedPointers = {};
        }
        return this._trackedPointers;
    }
    /*!
 * @pixi/mixin-get-global-position - v5.0.0-rc.3
 * Compiled Wed, 10 Apr 2019 01:21:15 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
    /**
     * Returns the global position of the displayObject. Does not depend on object scale, rotation and pivot.
     *
     * @method getGlobalPosition
     * @memberof PIXI.DisplayObject#
     * @param {Point} point - The point to write the global value to. If null a new point will be returned
     * @param {boolean} skipUpdate - Setting to true will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @return {Point} The updated point.
     */
    getGlobalPosition(point, skipUpdate) {
        if (point === void 0) {
            point = new Point_1.Point();
        }
        if (skipUpdate === void 0) {
            skipUpdate = false;
        }
        if (this.parent) {
            this.parent.toGlobal(this.position, point, skipUpdate);
        }
        else {
            point.x = this.position.x;
            point.y = this.position.y;
        }
        return point;
    }
    ;
    /**
 * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
 * Setting this changes the 'cursor' property to `'pointer'`.
 *
 * @example
 * const sprite = new PIXI.Sprite(texture);
 * sprite.interactive = true;
 * sprite.buttonMode = true;
 * @member {boolean}
 * @memberof PIXI.DisplayObject#
 */
    get buttonMode() {
        return this.cursor === 'pointer';
    }
    set buttonMode(value) {
        if (value) {
            this.cursor = 'pointer';
        }
        else if (this.cursor === 'pointer') {
            this.cursor = null;
        }
    }
    /**
     * @protected
     * @member {PIXI.DisplayObject}
     */
    static mixin(source) {
        // in ES8/ES2017, this would be really easy:
        // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        // get all the enumerable property keys
        var keys = Object.keys(source);
        // loop through properties
        for (var i = 0; i < keys.length; ++i) {
            var propertyName = keys[i];
            // Set the property using the property descriptor - this works for accessors and normal value properties
            Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
    }
    ;
    get _tempDisplayObjectParent() {
        if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new DisplayObject();
        }
        return this.tempDisplayObjectParent;
    }
    ;
    /**
     * Updates the object transform for rendering.
     *
     * TODO - Optimization pass!
     */
    updateTransform() {
        this.transform.updateTransform(this.parent.transform);
        // multiply the alphas..
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this._bounds.updateID++;
    }
    ;
    /**
     * Recursively updates transform of all objects from the root to this one
     * internal function for toLocal()
     */
    _recursivePostUpdateTransform() {
        if (this.parent) {
            this.parent._recursivePostUpdateTransform();
            this.transform.updateTransform(this.parent.transform);
        }
        else {
            this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
    }
    ;
    /**
     * Retrieves the bounds of the displayObject as a rectangle object.
     *
     * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    getBounds(skipUpdate = true, rect = null) {
        if (!skipUpdate) {
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.updateTransform();
                this.parent = null;
            }
            else {
                this._recursivePostUpdateTransform();
                this.updateTransform();
            }
        }
        if (this._boundsID !== this._lastBoundsID) {
            this.calculateBounds();
        }
        if (!rect) {
            if (!this._boundsRect) {
                this._boundsRect = new Rectangle_1.Rectangle();
            }
            rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
    }
    ;
    calculateBounds() {
    }
    /**
     * Retrieves the local bounds of the displayObject as a rectangle object.
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    getLocalBounds(rect = null) {
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        if (!rect) {
            if (!this._localBoundsRect) {
                this._localBoundsRect = new Rectangle_1.Rectangle();
            }
            rect = this._localBoundsRect;
        }
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        return bounds;
    }
    ;
    /**
     * Calculates the global position of the display object.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
     * @return {PIXI.IPoint} A point object representing the position of this object.
     */
    toGlobal(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
            skipUpdate = false;
        }
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        // don't need to update the lot
        return this.worldTransform.apply(position, point);
    }
    ;
    /**
     * Calculates the local position of the display object relative to another point.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
     * @return {PIXI.IPoint} A point object representing the position of this object
     */
    toLocal(position, from, point, skipUpdate) {
        if (from) {
            position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        // simply apply the matrix..
        return this.worldTransform.applyInverse(position, point);
    }
    ;
    /**
     * Renders the object using the WebGL renderer.
     *
     * @param {PIXI.Renderer} renderer - The renderer.
     */
    render(renderer) {
        // OVERWRITE;
    }
    ;
    /**
     * Set the parent Container of this DisplayObject.
     *
     * @param {PIXI.Container} container - The Container to add this DisplayObject to.
     * @return {PIXI.Container} The Container that this DisplayObject was added to.
     */
    setParent(container) {
        if (!container || !container.addChild) {
            throw new Error('setParent: Argument must be a Container');
        }
        container.addChild(this);
        return container;
    }
    ;
    /**
     * Convenience function to set the position, scale, skew and pivot at once.
     *
     * @param {number} [x=0] - The X position
     * @param {number} [y=0] - The Y position
     * @param {number} [scaleX=1] - The X scale value
     * @param {number} [scaleY=1] - The Y scale value
     * @param {number} [rotation=0] - The rotation
     * @param {number} [skewX=0] - The X skew value
     * @param {number} [skewY=0] - The Y skew value
     * @param {number} [pivotX=0] - The X pivot value
     * @param {number} [pivotY=0] - The Y pivot value
     * @return {PIXI.DisplayObject} The DisplayObject instance
     */
    setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (scaleX === void 0) {
            scaleX = 1;
        }
        if (scaleY === void 0) {
            scaleY = 1;
        }
        if (rotation === void 0) {
            rotation = 0;
        }
        if (skewX === void 0) {
            skewX = 0;
        }
        if (skewY === void 0) {
            skewY = 0;
        }
        if (pivotX === void 0) {
            pivotX = 0;
        }
        if (pivotY === void 0) {
            pivotY = 0;
        }
        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
    }
    ;
    /**
     * Base destroy method for generic display objects. This will automatically
     * remove the display object from its parent Container as well as remove
     * all current event listeners and internal references. Do not use a DisplayObject
     * after calling `destroy()`.
     *
     */
    destroy(options = null) {
        // this.removeAllListeners();
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;
        this.filterArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this._destroyed = true;
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     *
     * @member {number}
     */
    get x() {
        return this.position.x;
    }
    ;
    set x(value) {
        this.transform.position.x = value;
    }
    ;
    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     * An alias to position.y
     *
     * @member {number}
     */
    get y() {
        return this.position.y;
    }
    ;
    set y(value) {
        this.transform.position.y = value;
    }
    ;
    /**
     * Current transform of the object based on world (parent) factors.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    get worldTransform() {
        return this.transform.worldTransform;
    }
    ;
    /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    get localTransform() {
        return this.transform.localTransform;
    }
    ;
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get position() {
        return this.transform.position;
    }
    ;
    set position(value) {
        this.transform.position.copyFrom(value);
    }
    ;
    /**
     * The scale factor of the object.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get scale() {
        return this.transform.scale;
    }
    ;
    set scale(value) {
        this.transform.scale.copyFrom(value);
    }
    ;
    /**
     * The pivot point of the displayObject that it rotates around.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get pivot() {
        return this.transform.pivot;
    }
    ;
    set pivot(value) {
        this.transform.pivot.copyFrom(value);
    }
    ;
    /**
     * The skew factor for the object in radians.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.ObservablePoint}
     */
    get skew() {
        return this.transform.skew;
    }
    ;
    set skew(value) {
        this.transform.skew.copyFrom(value);
    }
    ;
    /**
     * The rotation of the object in radians.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    get rotation() {
        return this.transform.rotation;
    }
    ;
    set rotation(value) {
        this.transform.rotation = value;
    }
    ;
    /**
     * The angle of the object in degrees.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    get angle() {
        return this.transform.rotation * MathSettings_1.MathSettings.RAD_TO_DEG;
    }
    ;
    set angle(value) {
        this.transform.rotation = value * MathSettings_1.MathSettings.DEG_TO_RAD;
    }
    ;
    /**
     * The zIndex of the displayObject.
     * If a container has the sortableChildren property set to true, children will be automatically
     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
     * and thus rendered on top of other displayObjects within the same container.
     *
     * @member {number}
     */
    get zIndex() {
        return this._zIndex;
    }
    ;
    set zIndex(value) {
        this._zIndex = value;
        if (this.parent) {
            this.parent.sortDirty = true;
        }
    }
    ;
    /**
     * Indicates if the object is globally visible.
     *
     * @member {boolean}
     * @readonly
     */
    get worldVisible() {
        var item = this;
        do {
            if (!item.visible) {
                return false;
            }
            item = item.parent;
        } while (item);
        return true;
    }
    ;
    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
     * utilities shape clipping. To remove a mask, set this property to `null`.
     *
     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
     * @example
     * const graphics = new PIXI.Graphics();
     * graphics.beginFill(0xFF3300);
     * graphics.drawRect(50, 250, 100, 100);
     * graphics.endFill();
     *
     * const sprite = new PIXI.Sprite(texture);
     * sprite.mask = graphics;
     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
     *
     * @member {PIXI.Graphics|PIXI.Sprite}
     */
    get mask() {
        return this._mask;
    }
    ;
    set mask(value) {
        if (this._mask) {
            this._mask.renderable = true;
            this._mask.isMask = false;
        }
        this._mask = value;
        if (this._mask) {
            this._mask.renderable = false;
            this._mask.isMask = true;
        }
    }
    ;
    /**
             * Set this to true if you want this display object to be cached as a bitmap.
             * This basically takes a snap shot of the display object as it is at that moment. It can
             * provide a performance benefit for complex static displayObjects.
             * To remove simply set this property to `false`
             *
             * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
             * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
             *
             * @member {boolean}
             * @memberof PIXI.DisplayObject#
             */
    get cacheAsBitmap() {
        return this._cacheAsBitmap;
    }
    set cacheAsBitmap(value) {
        if (this._cacheAsBitmap === value) {
            return;
        }
        this._cacheAsBitmap = value;
        var data;
        if (value) {
            if (!this._cacheData) {
                this._cacheData = new CacheData();
            }
            data = this._cacheData;
            data.originalRender = this.render;
            data.originalRenderCanvas = this.renderCanvas;
            data.originalUpdateTransform = this.updateTransform;
            data.originalCalculateBounds = this.calculateBounds;
            data.originalGetLocalBounds = this.getLocalBounds;
            data.originalDestroy = this.destroy;
            data.originalContainsPoint = this.containsPoint;
            data.originalMask = this._mask;
            data.originalFilterArea = this.filterArea;
            this.render = this._renderCached;
            this.renderCanvas = this._renderCachedCanvas;
            this.destroy = this._cacheAsBitmapDestroy;
        }
        else {
            data = this._cacheData;
            if (data.sprite) {
                this._destroyCachedDisplayObject();
            }
            this.render = data.originalRender;
            this.renderCanvas = data.originalRenderCanvas;
            this.calculateBounds = data.originalCalculateBounds;
            this.getLocalBounds = data.originalGetLocalBounds;
            this.destroy = data.originalDestroy;
            this.updateTransform = data.originalUpdateTransform;
            this.containsPoint = data.originalContainsPoint;
            this._mask = data.originalMask;
            this.filterArea = data.originalFilterArea;
        }
    }
    containsPoint(point) {
        return false;
    }
    /**
     * Renders a cached version of the sprite with WebGL
     *
     * @private
     * @function _renderCached
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _renderCached(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        this._initCachedDisplayObject(renderer);
        this._cacheData.sprite.transform._worldID = this.transform._worldID;
        this._cacheData.sprite.worldAlpha = this.worldAlpha;
        this._cacheData.sprite._render(renderer);
    }
    /**
     * Prepares the WebGL renderer to cache the sprite
     *
     * @private
     * @function _initCachedDisplayObject
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _initCachedDisplayObject(renderer) {
        if (this._cacheData && this._cacheData.sprite) {
            return;
        }
        // make sure alpha is set to 1 otherwise it will get rendered as invisible!
        var cacheAlpha = this.alpha;
        this.alpha = 1;
        // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
        renderer.batch.flush();
        // this.filters= [];
        // next we find the dimensions of the untransformed object
        // this function also calls updatetransform on all its children as part of the measuring.
        // This means we don't need to update the transform again in this function
        // TODO pass an object to clone too? saves having to create a new one each time!
        var bounds = this.getLocalBounds().clone();
        // add some padding!
        if (this.filters) {
            var padding = this.filters[0].padding;
            bounds.pad(padding);
        }
        bounds.ceil(DisplaySettings_1.DisplaySettings.RESOLUTION);
        // for now we cache the current renderTarget that the WebGL renderer is currently using.
        // this could be more elegant..
        var cachedRenderTarget = renderer._activeRenderTarget;
        // We also store the filter stack - I will definitely look to change how this works a little later down the line.
        // const stack = renderer.filterManager.filterStack;
        // this renderTexture will be used to store the cached DisplayObject
        var renderTexture = RenderTexture_1.RenderTexture.create(bounds.width, bounds.height);
        var textureCacheId = "cacheAsBitmap_" + (MathSettings_1.MathSettings.uid());
        this._cacheData.textureCacheId = textureCacheId;
        BaseTexture_1.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
        Texture_1.Texture.addToCache(renderTexture, textureCacheId);
        // need to set //
        var m = DisplayObject._tempMatrix;
        m.tx = -bounds.x;
        m.ty = -bounds.y;
        // reset
        this.transform.worldTransform.identity();
        // set all properties to there original so we can render to a texture
        this.render = this._cacheData.originalRender;
        renderer.render(this, renderTexture, true, m, true);
        // now restore the state be setting the new properties
        renderer.renderTexture.bind(cachedRenderTarget);
        // renderer.filterManager.filterStack = stack;
        this.render = this._renderCached;
        // the rest is the same as for Canvas
        this.updateTransform = this.displayObjectUpdateTransform;
        this.calculateBounds = this._calculateCachedBounds;
        this.getLocalBounds = this._getCachedLocalBounds;
        this._mask = null;
        this.filterArea = null;
        // create our cached sprite
        var cachedSprite; // = new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform;
        cachedSprite.anchor.x = -(bounds.x / bounds.width);
        cachedSprite.anchor.y = -(bounds.y / bounds.height);
        cachedSprite.alpha = cacheAlpha;
        cachedSprite._bounds = this._bounds;
        this._cacheData.sprite = cachedSprite;
        this.transform._parentID = -1;
        // restore the transform of the cached sprite to avoid the nasty flicker..
        if (!this.parent) {
            this.parent = renderer._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
        }
        else {
            this.updateTransform();
        }
        // map the hit test..
        this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    }
    ;
    /**
 * Renders a cached version of the sprite with canvas
 *
 * @private
 * @function _renderCachedCanvas
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Renderer} renderer - the WebGL renderer
 */
    _renderCachedCanvas(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        this._initCachedDisplayObjectCanvas(renderer);
        this._cacheData.sprite.worldAlpha = this.worldAlpha;
        this._cacheData.sprite._renderCanvas(renderer);
    }
    ;
    // TODO this can be the same as the WebGL version.. will need to do a little tweaking first though..
    /**
     * Prepares the Canvas renderer to cache the sprite
     *
     * @private
     * @function _initCachedDisplayObjectCanvas
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _initCachedDisplayObjectCanvas(renderer) {
        if (this._cacheData && this._cacheData.sprite) {
            return;
        }
        // get bounds actually transforms the object for us already!
        var bounds = this.getLocalBounds();
        var cacheAlpha = this.alpha;
        this.alpha = 1;
        var cachedRenderTarget = renderer.context;
        bounds.ceil(DisplaySettings_1.DisplaySettings.RESOLUTION);
        var renderTexture = RenderTexture_1.RenderTexture.create(bounds.width, bounds.height);
        var textureCacheId = "cacheAsBitmap_" + (MathSettings_1.MathSettings.uid());
        this._cacheData.textureCacheId = textureCacheId;
        BaseTexture_1.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
        Texture_1.Texture.addToCache(renderTexture, textureCacheId);
        // need to set //
        var m = DisplayObject._tempMatrix;
        this.transform.localTransform.copyTo(m);
        m.invert();
        m.tx -= bounds.x;
        m.ty -= bounds.y;
        // m.append(this.transform.worldTransform.)
        // set all properties to there original so we can render to a texture
        this.renderCanvas = this._cacheData.originalRenderCanvas;
        // renderTexture.render(this, m, true);
        renderer.render(this, renderTexture, true, m, false);
        // now restore the state be setting the new properties
        renderer.context = cachedRenderTarget;
        this.renderCanvas = this._renderCachedCanvas;
        // the rest is the same as for WebGL
        this.updateTransform = this.displayObjectUpdateTransform;
        this.calculateBounds = this._calculateCachedBounds;
        this.getLocalBounds = this._getCachedLocalBounds;
        this._mask = null;
        this.filterArea = null;
        // create our cached sprite
        var cachedSprite; //= new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform;
        cachedSprite.anchor.x = -(bounds.x / bounds.width);
        cachedSprite.anchor.y = -(bounds.y / bounds.height);
        cachedSprite.alpha = cacheAlpha;
        cachedSprite._bounds = this._bounds;
        this._cacheData.sprite = cachedSprite;
        this.transform._parentID = -1;
        // restore the transform of the cached sprite to avoid the nasty flicker..
        if (!this.parent) {
            this.parent = renderer._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
        }
        else {
            this.updateTransform();
        }
        // map the hit test..
        this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    }
    ;
    renderCanvas(renderer) {
    }
    /**
     * Calculates the bounds of the cached sprite
     *
     * @private
     */
    _calculateCachedBounds() {
        this._bounds.clear();
        this._cacheData.sprite.transform._worldID = this.transform._worldID;
        this._cacheData.sprite._calculateBounds();
        this._lastBoundsID = this._boundsID;
    }
    ;
    /**
     * Gets the bounds of the cached sprite.
     *
     * @private
     * @return {Rectangle} The local bounds.
     */
    _getCachedLocalBounds() {
        return this._cacheData.sprite.getLocalBounds();
    }
    ;
    /**
     * Destroys the cached sprite.
     *
     * @private
     */
    _destroyCachedDisplayObject() {
        this._cacheData.sprite._texture.destroy(true);
        this._cacheData.sprite = null;
        BaseTexture_1.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
        Texture_1.Texture.removeFromCache(this._cacheData.textureCacheId);
        this._cacheData.textureCacheId = null;
    }
    ;
    /**
 * Destroys the cached object.
 *
 * @private
 * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
 *  have been set to that value.
 *  Used when destroying containers, see the Container.destroy method.
 */
    _cacheAsBitmapDestroy(options) {
        this.cacheAsBitmap = false;
        this.destroy(options);
    }
    ;
}
DisplayObject._tempMatrix = new Matrix_1.Matrix();
exports.DisplayObject = DisplayObject;
// figured theres no point adding ALL the extra variables to prototype.
// this model can hold the information needed. This can also be generated on demand as
// most objects are not cached as bitmaps.
/**
 * @class
 * @ignore
 */
class CacheData {
    constructor() {
        this.textureCacheId = null;
        this.originalRender = null;
        this.originalRenderCanvas = null;
        this.originalCalculateBounds = null;
        this.originalGetLocalBounds = null;
        this.originalUpdateTransform = null;
        this.originalHitTest = null;
        this.originalDestroy = null;
        this.originalMask = null;
        this.originalFilterArea = null;
        this.sprite = null;
    }
}
;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplaySettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplaySettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DisplaySettings {
}
DisplaySettings.SORTABLE_CHILDREN = false;
DisplaySettings.CREATE_IMAGE_BITMAP = true;
DisplaySettings.RENDERER_TYPE = {
    UNKNOWN: 0,
    WEBGL: 1,
    CANVAS: 2,
};
DisplaySettings.ENV = {
    WEBGL_LEGACY: 0,
    WEBGL: 1,
    WEBGL2: 2,
};
DisplaySettings.RESOLUTION = 1;
DisplaySettings.SCALE_MODE = 1;
DisplaySettings.ROUND_PIXELS = false;
DisplaySettings.PREFER_ENV = DisplaySettings.ENV.WEBGL;
exports.DisplaySettings = DisplaySettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DrawModeSettings.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DrawModeSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DrawModeSettings {
}
/**
* Various webgl draw modes. These can be used to specify which GL drawMode to use
* under certain situations and renderers.
*
* @memberof PIXI
* @static
* @name DRAW_MODES
* @enum {number}
* @property {number} POINTS
* @property {number} LINES
* @property {number} LINE_LOOP
* @property {number} LINE_STRIP
* @property {number} TRIANGLES
* @property {number} TRIANGLE_STRIP
* @property {number} TRIANGLE_FAN
*/
DrawModeSettings.DRAW_MODES = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
};
exports.DrawModeSettings = DrawModeSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Ellipse.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Ellipse.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Ellipse {
    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (halfWidth === void 0) {
            halfWidth = 0;
        }
        if (halfHeight === void 0) {
            halfHeight = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.width = halfWidth;
        /**
         * @member {number}
         * @default 0
         */
        this.height = halfHeight;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.ELIP
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.ELIP;
    }
    /**
     * Creates a clone of this Ellipse instance
     *
     * @return {PIXI.Ellipse} a copy of the ellipse
     */
    clone() {
        return new Ellipse(this.x, this.y, this.width, this.height);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        // normalize the coords to an ellipse with center 0,0
        var normx = ((x - this.x) / this.width);
        var normy = ((y - this.y) / this.height);
        normx *= normx;
        normy *= normy;
        return (normx + normy <= 1);
    }
    ;
    /**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {PIXI.Rectangle} the framing rectangle
     */
    getBounds() {
        return new Rectangle_1.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
    ;
}
exports.Ellipse = Ellipse;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Event.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Event.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Event extends FlashBaseObject_1.FlashBaseObject {
    constructor(type, bubble = true, cancelable = true) {
        super();
        this.reset(type, bubble, cancelable);
    }
    get currentTarget() {
        return this._currentTarget;
    }
    setCurrentTarget(value) {
        this._currentTarget = value;
    }
    get type() {
        return this._type;
    }
    get cancelable() {
        return this._cancelable;
    }
    get bubbles() {
        return this._bubbles;
    }
    get eventPhase() {
        return this._eventPhase;
    }
    clone() {
        return Event.getEvent(this._type, this._bubbles, this._cancelable);
    }
    reset(type, bubble = true, cancelable = true) {
        this._type = type;
        this._bubbles = bubble;
        this._cancelable = cancelable;
    }
    static getEvent(type, bubble = true, cancelable = true) {
        if (Event.EventCache.length) {
            let te = Event.EventCache[Event.EventCache.length - 1];
            Event.EventCache.length -= 1;
            te.reset(type, bubble, cancelable);
            return te;
        }
        return new Event(type, bubble, cancelable);
    }
    destructor() {
        this._currentTarget = null;
        let index = Event.EventCache.indexOf(this);
        if (index < 0) {
            Event.EventCache.push(this);
        }
    }
    get isDisposable() {
        return true;
    }
    stopPropagation() {
    }
    stopImmediatePropagation() {
    }
    preventDefault() {
    }
}
Event.ADDED_TO_STAGE = "addedToStage";
Event.ADDED = "added";
Event.ENTER_FRAME = "enterFrame";
Event.EXIT_FRAME = "exitFrame";
Event.FRAME_CONSTRUCTED = "frameConstructed";
Event.REMOVED = "removed";
Event.REMOVED_FROM_STAGE = "removedFromStage";
Event.RENDER = "render";
Event.COMPLETE = "complete";
Event.INIT = "init";
Event.OPEN = "open";
Event.UNLOAD = "unload";
Event.CLEAR = "clear";
Event.SOUND_COMPLETE = "soundComplete";
Event.SOUND_STARTED = "soundStarted";
Event.ACTIVATE = "activate";
Event.DEACTIVATE = "desactivate";
Event.RESIZE = "resize";
Event.CHANGE = "change";
Event.EventCache = [];
exports.Event = Event;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/EventDispatcher.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/EventDispatcher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class EventDispatcher extends FlashBaseObject_1.FlashBaseObject {
    constructor(target = null) {
        super();
        this.registeredListeners = {};
    }
    removeListeners() {
        for (var i in this.registeredListeners) {
            var methods = this.registeredListeners[i];
            while (methods.length) {
                let ms = methods.shift();
                ms.destructor();
            }
            delete this.registeredListeners[i];
        }
        this.registeredListeners = {};
    }
    destructor() {
        super.destructor();
        this.removeListeners();
    }
    willTrigger(type) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                return true;
            }
            return false;
        }
        return false;
    }
    removeEventListener(type, listener, useCapture = false) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                for (var i = 0; i < methods.length; i++) {
                    if (methods[i].objectFunction == listener) {
                        methods[i].destructor();
                        methods.splice(i, 1);
                    }
                }
            }
            if (!methods.length) {
                delete this.registeredListeners[type];
            }
        }
    }
    hasEventListener(type) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                return true;
            }
            return false;
        }
        return false;
    }
    dispatchEvent(event) {
        if (this.registeredListeners[event.type] != null) {
            event.setCurrentTarget(this);
            var methods = this.registeredListeners[event.type];
            if (methods && methods.length) {
                let methodcopy = methods.concat();
                methodcopy = methodcopy.sort(this.getMethodPriority);
                while (methodcopy.length) {
                    var method = methodcopy.shift();
                    if (method.eventType != event.type) {
                        continue;
                    }
                    if (method) {
                        this.trigger(method, event);
                    }
                }
            }
        }
        if (event.isDisposable) {
            event.destructor();
        }
        return false;
    }
    addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false, scope = null) {
        if (this.isRegistered(type, listener)) {
            return;
        }
        if (!this.registeredListeners[type]) {
            this.registeredListeners[type] = [];
        }
        var methods = this.registeredListeners[type];
        var methodScope = MethodScope.getMethodScope();
        methodScope.eventType = type;
        methodScope.parentDispatcher = this;
        methodScope.objectFunction = listener;
        methodScope.scope = scope;
        methodScope.priority = priority;
        methods.push(methodScope);
    }
    trigger(method, event) {
        if (method.objectFunction) {
            method.objectFunction.call(method.scope, event);
        }
    }
    getMethodPriority(method1, method2) {
        if (method1.priority > method2.priority) {
            return 1;
        }
        return -1;
    }
    isRegistered(type, listener) {
        if (!this.registeredListeners[type]) {
            return false;
        }
        var methods = this.registeredListeners[type];
        for (var i = 0; i < methods.length; i++) {
            if (methods[i].objectFunction == listener) {
                return true;
            }
        }
        return false;
    }
}
exports.EventDispatcher = EventDispatcher;
class MethodScope extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.reset();
    }
    reset() {
        this.objectFunction = null;
        this.scope = null;
        this.parentDispatcher = null;
        this.priority = 0;
        this.eventType = null;
    }
    static getMethodScope() {
        if (MethodScope.MethodScopeCache.length) {
            let te = MethodScope.MethodScopeCache[MethodScope.MethodScopeCache.length - 1];
            MethodScope.MethodScopeCache.length -= 1;
            te.reset();
            return te;
        }
        return new MethodScope();
    }
    destructor() {
        this.objectFunction = null;
        this.scope = null;
        this.parentDispatcher = null;
        let index = MethodScope.MethodScopeCache.indexOf(this);
        if (index < 0) {
            MethodScope.MethodScopeCache.unshift(this);
        }
    }
}
MethodScope.MethodScopeCache = [];


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Extract.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Extract.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const CanvasRenderTarget_1 = __webpack_require__(/*! ./CanvasRenderTarget */ "./js-compile/raw-pixi-ts/CanvasRenderTarget.js");
class Extract {
    constructor(renderer) {
        this.renderer = renderer;
        /**
         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
         *
         * @member {PIXI.extract.Extract} extract
         * @memberof PIXI.Renderer#
         * @see PIXI.extract.Extract
         */
        renderer.extract = this;
    }
    /**
     * Will return a HTML Image of the target
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLImageElement} HTML Image of the target
     */
    image(target) {
        var image = new Image();
        image.src = this.base64(target);
        return image;
    }
    ;
    /**
     * Will return a a base64 encoded string of this target. It works by calling
     *  `Extract.getCanvas` and then running toDataURL on that.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {string} A base64 encoded string of the texture.
     */
    base64(target) {
        return this.canvas(target).toDataURL();
    }
    ;
    /**
     * Creates a Canvas element, renders this target to it and then returns it.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
     */
    canvas(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var flipY = false;
        var renderTexture;
        var generated = false;
        if (target) {
            if (target instanceof RenderTexture_1.RenderTexture) {
                renderTexture = target;
            }
            else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }
        if (renderTexture) {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            flipY = false;
            renderer.renderTexture.bind(renderTexture);
        }
        else {
            resolution = this.renderer.resolution;
            flipY = true;
            frame = Extract.TEMP_RECT;
            frame.width = this.renderer.width;
            frame.height = this.renderer.height;
            renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var canvasBuffer = new CanvasRenderTarget_1.CanvasRenderTarget(width, height, 1);
        var webglPixels = new Uint8Array(Extract.BYTES_PER_PIXEL * width * height);
        // read pixels to the array
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        // add the pixels to the canvas
        var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
        canvasData.data.set(webglPixels);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        // pulling pixels
        if (flipY) {
            canvasBuffer.context.scale(1, -1);
            canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);
        }
        if (generated) {
            renderTexture.destroy(true);
        }
        // send the canvas back..
        return canvasBuffer.canvas;
    }
    ;
    /**
     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
     * order, with integer values between 0 and 255 (included).
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
     */
    pixels(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var renderTexture;
        var generated = false;
        if (target) {
            if (target instanceof RenderTexture_1.RenderTexture) {
                renderTexture = target;
            }
            else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }
        if (renderTexture) {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            // bind the buffer
            renderer.renderTexture.bind(renderTexture);
        }
        else {
            resolution = renderer.resolution;
            frame = Extract.TEMP_RECT;
            frame.width = renderer.width;
            frame.height = renderer.height;
            renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var webglPixels = new Uint8Array(Extract.BYTES_PER_PIXEL * width * height);
        // read pixels to the array
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        if (generated) {
            renderTexture.destroy(true);
        }
        return webglPixels;
    }
    ;
    /**
     * Destroys the extract
     *
     */
    destroy() {
        this.renderer.extract = null;
        this.renderer = null;
    }
    ;
}
Extract.TEMP_RECT = new Rectangle_1.Rectangle();
Extract.BYTES_PER_PIXEL = 4;
exports.Extract = Extract;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FillStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FillStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class FillStyle extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.reset();
    }
    /**
     * Clones the object
     *
     * @return {PIXI.FillStyle}
     */
    clone() {
        var obj = new FillStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
    }
    ;
    /**
     * Reset
     */
    reset() {
        /**
         * The hex color value used when coloring the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        this.color = 0xFFFFFF;
        /**
         * The alpha value used when filling the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        this.alpha = 1;
        /**
         * The texture to be used for the fill.
         *
         * @member {string}
         * @default 0
         */
        this.texture = Texture_1.Texture.WHITE;
        /**
         * The transform aplpied to the texture.
         *
         * @member {string}
         * @default 0
         */
        this.matrix = null;
        /**
         * If the current fill is visible.
         *
         * @member {boolean}
         * @default false
         */
        this.visible = false;
    }
    ;
    /**
     * Destroy and don't use after this
     */
    destroy() {
        this.texture = null;
        this.matrix = null;
    }
    ;
}
exports.FillStyle = FillStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Filter.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Filter.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
class Filter extends Shader_1.Shader {
    constructor(vertexSrc = null, fragmentSrc = null, uniforms = null) {
        var program = Program_1.Program.from(vertexSrc || Filter.defaultVertexSrc, fragmentSrc || Filter.defaultFragmentSrc);
        super(program, uniforms);
        /**
         * The padding of the filter. Some filters require extra space to breath such as a blur.
         * Increasing this will add extra width and height to the bounds of the object that the
         * filter is applied to.
         *
         * @member {number}
         */
        this.padding = 0;
        /**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         *
         * @member {number}
         */
        this.resolution = settings_1.settings.FILTER_RESOLUTION;
        /**
         * If enabled is true the filter is applied, if false it will not.
         *
         * @member {boolean}
         */
        this.enabled = true;
        /**
         * If enabled, PixiJS will fit the filter area into boundaries for better performance.
         * Switch it off if it does not work for specific shader.
         *
         * @member {boolean}
         */
        this.autoFit = true;
        /**
         * Legacy filters use position and uvs from attributes
         * @member {boolean}
         * @readonly
         */
        this.legacy = !!this.program.attributeData.aTextureCoord;
        /**
         * The WebGL state the filter requires to render
         * @member {PIXI.State}
         */
        this.state = new State_1.State();
    }
    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     * @param {object} [currentState] - It's current state of filter.
     *        There are some useful properties in the currentState :
     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
     */
    apply(filterManager, input, output, clear, currentState, derp) {
        // do as you please!
        filterManager.applyFilter(this, input, output, clear, currentState, derp);
        // or just do a regular render..
    }
    ;
    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    /**
     * The default vertex shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    static get defaultVertexSrc() {
        return Filter.defaultVertex$1;
    }
    ;
    /**
     * The default fragment shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    static get defaultFragmentSrc() {
        return Filter.defaultFragment$1;
    }
    ;
}
/**
 * Used for caching shader IDs
 *
 * @static
 * @type {object}
 * @protected
 */
Filter.SOURCE_KEY_MAP = {};
Filter.defaultVertex$1 = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n}\r\n";
Filter.defaultFragment$1 = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n}\r\n";
exports.Filter = Filter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FilterState.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FilterState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class FilterState {
    constructor() {
        this.renderTexture = null;
        /**
         * Target of the filters
         * We store for case when custom filter wants to know the element it was applied on
         * @member {PIXI.DisplayObject}
         * @private
         */
        this.target = null;
        /**
         * Compatibility with PixiJS v4 filters
         * @member {boolean}
         * @default false
         * @private
         */
        this.legacy = false;
        /**
         * Resolution of filters
         * @member {number}
         * @default 1
         * @private
         */
        this.resolution = 1;
        // next three fields are created only for root
        // re-assigned for everything else
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @private
         */
        this.sourceFrame = new Rectangle_1.Rectangle();
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @private
         */
        this.destinationFrame = new Rectangle_1.Rectangle();
        /**
         * Collection of filters
         * @member {PIXI.Filter[]}
         * @private
         */
        this.filters = [];
    }
    /**
     * clears the state
     * @private
     */
    clear() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
    }
    ;
}
exports.FilterState = FilterState;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FilterSystem.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FilterSystem.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Quad_1 = __webpack_require__(/*! ./Quad */ "./js-compile/raw-pixi-ts/Quad.js");
const QuadUv_1 = __webpack_require__(/*! ./QuadUv */ "./js-compile/raw-pixi-ts/QuadUv.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const FilterState_1 = __webpack_require__(/*! ./FilterState */ "./js-compile/raw-pixi-ts/FilterState.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class FilterSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * List of filters for the FilterSystem
         * @member {Object[]}
         * @readonly
         */
        this.defaultFilterStack = [{}];
        /**
         * stores a bunch of PO2 textures used for filtering
         * @member {Object}
         */
        this.texturePool = {};
        /**
         * a pool for storing filter states, save us creating new ones each tick
         * @member {Object[]}
         */
        this.statePool = [];
        /**
         * A very simple geometry used when drawing a filter effect to the screen
         * @member {PIXI.Quad}
         */
        this.quad = new Quad_1.Quad();
        /**
         * Quad UVs
         * @member {PIXI.QuadUv}
         */
        this.quadUv = new QuadUv_1.QuadUv();
        /**
         * Temporary rect for maths
         * @type {PIXI.Rectangle}
         */
        this.tempRect = new Rectangle_1.Rectangle();
        /**
         * Active state
         * @member {object}
         */
        this.activeState = {};
        /**
         * This uniform group is attached to filter uniforms when used
         * @member {PIXI.UniformGroup}
         * @property {PIXI.Rectangle} outputFrame
         * @property {Float32Array} inputSize
         * @property {Float32Array} inputPixel
         * @property {Float32Array} inputClamp
         * @property {Number} resolution
         * @property {Float32Array} filterArea
         * @property {Fload32Array} filterClamp
         */
        this.globalUniforms = new UniformGroup_1.UniformGroup({
            outputFrame: this.tempRect,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            // legacy variables
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4),
        }, true);
        this._pixelsWidth = renderer.view.width;
        this._pixelsHeight = renderer.view.height;
    }
    /**
     * Adds a new filter to the System.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */
    push(target, filters) {
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState_1.FilterState();
        var resolution = filters[0].resolution;
        var padding = filters[0].padding;
        var autoFit = filters[0].autoFit;
        var legacy = filters[0].legacy;
        for (var i = 1; i < filters.length; i++) {
            var filter = filters[i];
            // lets use the lowest resolution..
            resolution = Math.min(resolution, filter.resolution);
            // and the largest amount of padding!
            padding = Math.max(padding, filter.padding);
            // only auto fit if all filters are autofit
            autoFit = autoFit || filter.autoFit;
            legacy = legacy || filter.legacy;
        }
        if (filterStack.length === 1) {
            this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        if (autoFit) {
            state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
        }
        // round to whole number based on resolution
        state.sourceFrame.ceil(resolution);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
        state.filters = filters;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        renderer.renderTexture.bind(state.renderTexture, state.sourceFrame); // /, state.destinationFrame);
        renderer.renderTexture.clear();
    }
    ;
    /**
     * Pops off the filter and applies it.
     *
     */
    pop() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1.0 / inputSize[0];
        inputSize[3] = 1.0 / inputSize[1];
        inputPixel[0] = inputSize[0] * state.resolution;
        inputPixel[1] = inputSize[1] * state.resolution;
        inputPixel[2] = 1.0 / inputPixel[0];
        inputPixel[3] = 1.0 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);
        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);
        // only update the rect if its legacy..
        if (state.legacy) {
            var filterArea = globalUniforms.filterArea;
            filterArea[0] = state.destinationFrame.width;
            filterArea[1] = state.destinationFrame.height;
            filterArea[2] = state.sourceFrame.x;
            filterArea[3] = state.sourceFrame.y;
            globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        if (filters.length === 1) {
            filters[0].apply(this, state.renderTexture, lastState.renderTexture, false, state);
            this.returnFilterTexture(state.renderTexture);
        }
        else {
            var flip = state.renderTexture;
            var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
            flop.filterFrame = flip.filterFrame;
            var i = 0;
            for (i = 0; i < filters.length - 1; ++i) {
                filters[i].apply(this, flip, flop, true, state);
                var t = flip;
                flip = flop;
                flop = t;
            }
            filters[i].apply(this, flip, lastState.renderTexture, false, state);
            this.returnFilterTexture(flip);
            this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
    }
    ;
    /**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */
    applyFilter(filter, input, output, clear) {
        var renderer = this.renderer;
        renderer.renderTexture.bind(output, output ? output.filterFrame : null);
        if (clear) {
            // gl.disable(gl.SCISSOR_TEST);
            renderer.renderTexture.clear();
            // gl.enable(gl.SCISSOR_TEST);
        }
        // set the uniforms..
        filter.uniforms.uSampler = input;
        filter.uniforms.filterGlobals = this.globalUniforms;
        // TODO make it so that the order of this does not matter..
        // because it does at the moment cos of global uniforms.
        // they need to get resynced
        renderer.state.setState(filter.state);
        renderer.shader.bind(filter);
        if (filter.legacy) {
            this.quadUv.map(input._frame, input.filterFrame);
            renderer.geometry.bind(this.quadUv);
            renderer.geometry.draw(DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES);
        }
        else {
            renderer.geometry.bind(this.quad);
            renderer.geometry.draw(DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLE_STRIP);
        }
    }
    ;
    /**
     * Calculates the mapped matrix.
     *
     * TODO playing around here.. this is temporary - (will end up in the shader)
     * this returns a matrix that will normalize map filter cords in the filter to screen space
     *
     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    calculateScreenSpaceMatrix(outputMatrix) {
        var currentState = this.activeState;
        return FilterSystem.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.destinationFrame);
    }
    ;
    /**
     * This will map the filter coord so that a texture can be used based on the transform of a sprite
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    calculateSpriteMatrix(outputMatrix, sprite) {
        var currentState = this.activeState;
        return FilterSystem.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.destinationFrame, sprite);
    }
    ;
    /**
     * Destroys this Filter System.
     *
     * @param {boolean} [contextLost=false] context was lost, do not free shaders
     *
     */
    destroy(contextLost) {
        if (contextLost === void 0) {
            contextLost = false;
        }
        if (!contextLost) {
            this.emptyPool();
        }
        else {
            this.texturePool = {};
        }
    }
    ;
    /**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * TODO move to a separate class could be on renderer?
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture in real pixels.
     * @param {number} minHeight - The minimum height of the render texture in real pixels.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */
    getOptimalFilterTexture(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
            resolution = 1;
        }
        var key = FilterSystem.screenKey;
        minWidth *= resolution;
        minHeight *= resolution;
        if (minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
            minWidth = MathSettings_1.MathSettings.nextPow2(minWidth);
            minHeight = MathSettings_1.MathSettings.nextPow2(minHeight);
            key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);
        }
        if (!this.texturePool[key]) {
            this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
            // temporary bypass cache..
            // internally - this will cause a texture to be bound..
            renderTexture = RenderTexture_1.RenderTexture.create({
                width: minWidth / resolution,
                height: minHeight / resolution,
                resolution: resolution,
            });
        }
        renderTexture.filterPoolKey = key;
        return renderTexture;
    }
    ;
    /**
     * Gets extra render texture to use inside current filter
     *
     * @param {number} resolution resolution of the renderTexture
     * @returns {PIXI.RenderTexture}
     */
    getFilterTexture(resolution) {
        var rt = this.activeState.renderTexture;
        var filterTexture = this.getOptimalFilterTexture(rt.width, rt.height, resolution || rt.baseTexture.resolution);
        filterTexture.filterFrame = rt.filterFrame;
        return filterTexture;
    }
    ;
    /**
     * Frees a render texture back into the pool.
     *
     * @param {PIXI.RenderTexture} renderTexture - The renderTarget to free
     */
    returnFilterTexture(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
    }
    ;
    /**
     * Empties the texture pool.
     *
     */
    emptyPool() {
        for (var i in this.texturePool) {
            var textures = this.texturePool[i];
            if (textures) {
                for (var j = 0; j < textures.length; j++) {
                    textures[j].destroy(true);
                }
            }
        }
        this.texturePool = {};
    }
    ;
    resize() {
        var textures = this.texturePool[FilterSystem.screenKey];
        if (textures) {
            for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
            }
        }
        this.texturePool[FilterSystem.screenKey] = [];
        this._pixelsWidth = this.renderer.view.width;
        this._pixelsHeight = this.renderer.view.height;
    }
    ;
    // this will map the filter coord so that a texture can be used based on the transform of a sprite
    static calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);
        var worldTransform = sprite.worldTransform.copyTo(Matrix_1.Matrix.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
    }
    /**
 * Calculates the mapped matrix
 * @param {PIXI.Matrix} outputMatrix matrix that will normalize map filter cords in the filter to screen space
 * @param {PIXI.Rectangle} filterArea filter area
 * @param {PIXI.Rectangle} textureSize texture size
 * @returns {PIXI.Matrix} same as outputMatrix
 * @private
 */
    static calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
        // TODO unwrap?
        var mappedMatrix = outputMatrix.identity();
        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
        mappedMatrix.scale(textureSize.width, textureSize.height);
        return mappedMatrix;
    }
}
FilterSystem.screenKey = 'screen';
exports.FilterSystem = FilterSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FlashBaseObject.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FlashBaseObject.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class FlashBaseObject {
    constructor() {
        FlashBaseObject.nameCount++;
        this._name = "instance-" + this.className + "-" + FlashBaseObject.nameCount;
        this._instanceName = "instance-" + this.className + "-" + FlashBaseObject.nameCount;
        this._hasChanged = true;
        this._className = this.constructor['name'];
    }
    get className() {
        return this.constructor['name'];
    }
    destructor() {
    }
    get hasChanged() {
        return this._hasChanged;
    }
    set hasChanged(value) {
        this._hasChanged = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get instanceName() {
        return this._instanceName;
    }
}
FlashBaseObject.nameCount = 0;
exports.FlashBaseObject = FlashBaseObject;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FontManager.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FontManager.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ./URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const URLLoader_1 = __webpack_require__(/*! ./URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const IOErrorEvent_1 = __webpack_require__(/*! ./IOErrorEvent */ "./js-compile/raw-pixi-ts/IOErrorEvent.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const URLRequestMethod_1 = __webpack_require__(/*! ./URLRequestMethod */ "./js-compile/raw-pixi-ts/URLRequestMethod.js");
const XMLParser_1 = __webpack_require__(/*! ./XMLParser */ "./js-compile/raw-pixi-ts/XMLParser.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ResourceLoader_1 = __webpack_require__(/*! ./ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
class FontManager {
    constructor() {
    }
    static set WebFontConfig(value) {
        let config = {
            active() {
                FontManager.webFontActive();
            }
        };
        for (let key in value) {
            config[key] = value[key];
        }
        window['WebFontConfig'] = config;
        FontManager.loadWebFont();
    }
    static getBitmapFont(name) {
        if (FontManager.bitmapfonts[name] != undefined) {
            return FontManager.bitmapfonts[name];
        }
        return null;
    }
    static addBitmapFont(data) {
        FontManager.bitmapfonts[data.font] = data;
    }
    static loadBitmapFont(path) {
        let loader = new BitmapFontLoader();
        FontManager.fontLoaders[loader.instanceName] = loader;
        loader.loadFont(path);
        return loader;
    }
    static parseBitmapFontData(xml, base) {
        let pageid;
        let pagepath;
        let data = new BitmapFont();
        data.texture = base;
        let info = xml.getElementsByTagName('info')[0];
        let common = xml.getElementsByTagName('common')[0];
        let pages = xml.getElementsByTagName('page')[0];
        let res = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(pages.getAttribute('file'), DisplaySettings_1.DisplaySettings.RESOLUTION);
        data.font = info.getAttribute('face');
        data.size = parseInt(info.getAttribute('size'), 10);
        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res;
        data.chars = {};
        pageid = pages.getAttribute('id');
        pagepath = pages.getAttribute('file');
        data.texturePath = pagepath;
        let letters = Array.from(xml.getElementsByTagName('char'));
        for (let i$1 = 0; i$1 < letters.length; i$1++) {
            let letter = letters[i$1];
            let charCode = parseInt(letter.getAttribute('id'), 10);
            let page = parseInt(letter.getAttribute('page')) || 0;
            let textureRect = new Rectangle_1.Rectangle((parseInt(letter.getAttribute('x'), 10) / res) + (base.frame.x / res), (parseInt(letter.getAttribute('y'), 10) / res) + (base.frame.y / res), parseInt(letter.getAttribute('width'), 10) / res, parseInt(letter.getAttribute('height'), 10) / res);
            let fontchar = new FontCharacterData();
            fontchar.xOffset = parseInt(letter.getAttribute('xoffset'), 10) / res;
            fontchar.yOffset = parseInt(letter.getAttribute('yoffset'), 10) / res;
            fontchar.xAdvance = parseInt(letter.getAttribute('xadvance'), 10) / res;
            fontchar.kerning = {};
            fontchar.texture = new Texture_1.Texture(base.baseTexture, textureRect);
            fontchar.page = page;
            data.chars[charCode] = fontchar;
        }
        let kernings = Array.from(xml.getElementsByTagName('kerning'));
        for (let i$2 = 0; i$2 < kernings.length; i$2++) {
            let kerning = kernings[i$2];
            let first = parseInt(kerning.getAttribute('first'), 10) / res;
            let second = parseInt(kerning.getAttribute('second'), 10) / res;
            let amount = parseInt(kerning.getAttribute('amount'), 10) / res;
            if (data.chars[second]) {
                data.chars[second].kerning[first] = amount;
            }
        }
        return data;
    }
}
FontManager.fontLoaders = {};
FontManager.bitmapfonts = {};
FontManager.webFontActive = () => {
    if (FontManager.onWebFontloaded) {
        FontManager.onWebFontloaded();
    }
};
FontManager.loadWebFont = () => {
    const wf = document.createElement('script');
    wf.src = `${document.location.protocol === 'https:' ? 'https' : 'http'}://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js`;
    wf.type = 'text/javascript';
    wf.async = 'true';
    const s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
};
exports.FontManager = FontManager;
class BitmapFont {
}
exports.BitmapFont = BitmapFont;
class BitmapFontLoader extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        this.handleFontXMLComplete = (event) => {
            this.fontxml = XMLParser_1.XMLParser.parse(this.urlloader.data);
            let pages = this.fontxml.getElementsByTagName('page')[0];
            let pagepath = pages.getAttribute('file');
            this.textureloader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest(this.rootpath + pagepath));
            this.textureloader.addEventListener(Event_1.Event.COMPLETE, this.handletextureLoaded);
            this.textureloader.load();
        };
        this.handletextureLoaded = (event) => {
            let b = new BaseTexture_1.BaseTexture(this.textureloader.imageData);
            let t = new Texture_1.Texture(b);
            this.fontdata = FontManager.parseBitmapFontData(this.fontxml, t);
            FontManager.addBitmapFont(this.fontdata);
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
        };
        this.handleFontLoadError = (event) => {
            this.dispatchEvent(event);
        };
    }
    loadFont(path) {
        let request = new URLRequest_1.URLRequest(path);
        if (path.indexOf("/") >= 0) {
            let pathparts = path.split("/");
            pathparts.pop();
            this.rootpath = pathparts.join("/") + "/";
        }
        else {
            this.rootpath = "";
        }
        request.method = URLRequestMethod_1.URLRequestMethod.POST;
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleFontXMLComplete);
        this.urlloader.addEventListener(IOErrorEvent_1.IOErrorEvent.IO_ERROR, this.handleFontLoadError);
        this.urlloader.load(request);
    }
}
class FontCharacterData {
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Framebuffer.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Framebuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const DepthResource_1 = __webpack_require__(/*! ./DepthResource */ "./js-compile/raw-pixi-ts/DepthResource.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Framebuffer {
    constructor(width, height) {
        this.width = Math.ceil(width || 100);
        this.height = Math.ceil(height || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new Runner_1.Runner('disposeFramebuffer', 2);
        // this.disposeRunner = new Runner('disposeFramebuffer', 2);
    }
    /**
     * Reference to the colorTexture.
     *
     * @member {PIXI.Texture[]}
     * @readonly
     */
    get colorTexture() {
        return this.colorTextures[0];
    }
    ;
    /**
     * Add texture to the colorTexture array
     *
     * @param {number} [index=0] - Index of the array to add the texture to
     * @param {PIXI.Texture} [texture] - Texture to add to the array
     */
    addColorTexture(index, texture) {
        if (index === void 0) {
            index = 0;
        }
        // TODO add some validation to the texture - same width / height etc?
        this.colorTextures[index] = texture || new BaseTexture_1.BaseTexture(null, { scaleMode: 0,
            resolution: 1,
            mipmap: false,
            width: this.width,
            height: this.height }); // || new Texture();
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Add a depth texture to the frame buffer
     *
     * @param {PIXI.Texture} [texture] - Texture to add
     */
    addDepthTexture(texture) {
        /* eslint-disable max-len */
        this.depthTexture = texture || new BaseTexture_1.BaseTexture(new DepthResource_1.DepthResource(null, { width: this.width, height: this.height }), { scaleMode: 0,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: false,
            format: WebGLSettings_1.WebGLSettings.FORMATS.DEPTH_COMPONENT,
            type: WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_SHORT }); // UNSIGNED_SHORT;
        /* eslint-disable max-len */
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Enable depth on the frame buffer
     */
    enableDepth() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Enable stencil on the frame buffer
     */
    enableStencil() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Resize the frame buffer
     *
     * @param {number} width - Width of the frame buffer to resize to
     * @param {number} height - Height of the frame buffer to resize to
     */
    resize(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        if (width === this.width && height === this.height) {
            return;
        }
        this.width = width;
        this.height = height;
        this.dirtyId++;
        this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
            var texture = this.colorTextures[i];
            var resolution = texture.resolution;
            // take into acount the fact the texture may have a different resolution..
            texture.setSize(width / resolution, height / resolution);
        }
        if (this.depthTexture) {
            var resolution$1 = this.depthTexture.resolution;
            this.depthTexture.setSize(width / resolution$1, height / resolution$1);
        }
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        // this.disposeRunner.run(this, false);
        this.disposeRunner.run(this, false);
    }
    ;
}
exports.Framebuffer = Framebuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FramebufferSystem.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FramebufferSystem.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Framebuffer_1 = __webpack_require__(/*! ./Framebuffer */ "./js-compile/raw-pixi-ts/Framebuffer.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class FramebufferSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * A list of managed framebuffers
         * @member {PIXI.Framebuffer[]}
         * @readonly
         */
        this.managedFramebuffers = [];
        /**
         * Framebuffer value that shows that we don't know what is bound
         * @member {Framebuffer}
         * @readonly
         */
        this.unknownFramebuffer = new Framebuffer_1.Framebuffer(10, 10);
        this.viewport = new Rectangle_1.Rectangle();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange(gl) {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle_1.Rectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        // webgl2
        if (this.renderer.context.webGLVersion === 1) {
            // webgl 1!
            var nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
            var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
                nativeDrawBuffersExtension = null;
                nativeDepthTextureExtension = null;
            }
            if (nativeDrawBuffersExtension) {
                gl.drawBuffers = function (activeTextures) { return nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures); };
            }
            else {
                this.hasMRT = false;
                gl.drawBuffers = function () {
                    // empty
                };
            }
            if (!nativeDepthTextureExtension) {
                this.writeDepthTexture = false;
            }
        }
    }
    ;
    /**
         * Bind a framebuffer
         *
         * @param {PIXI.Framebuffer} framebuffer
         * @param {PIXI.Rectangle} [frame] frame, default is framebuffer size
         */
    bind(framebuffer = null, frame = null) {
        var ref = this;
        var gl = ref.gl;
        if (framebuffer) {
            // TODO caching layer!
            var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
            if (this.current !== framebuffer) {
                this.current = framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            }
            // make sure all textures are unbound..
            // now check for updates...
            if (fbo.dirtyId !== framebuffer.dirtyId) {
                fbo.dirtyId = framebuffer.dirtyId;
                if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
                    fbo.dirtyFormat = framebuffer.dirtyFormat;
                    this.updateFramebuffer(framebuffer);
                }
                else if (fbo.dirtySize !== framebuffer.dirtySize) {
                    fbo.dirtySize = framebuffer.dirtySize;
                    this.resizeFramebuffer(framebuffer);
                }
            }
            for (var i = 0; i < framebuffer.colorTextures.length; i++) {
                if (framebuffer.colorTextures[i].texturePart) {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i].texture);
                }
                else {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i]);
                }
            }
            if (framebuffer.depthTexture) {
                this.renderer.texture.unbind(framebuffer.depthTexture);
            }
            if (frame) {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else {
                this.setViewport(0, 0, framebuffer.width, framebuffer.height);
            }
        }
        else {
            if (this.current) {
                this.current = null;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            if (frame) {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else {
                this.setViewport(0, 0, this.renderer.width, this.renderer.height);
            }
        }
    }
    ;
    /**
     * Set the WebGLRenderingContext's viewport.
     *
     * @param {Number} x - X position of viewport
     * @param {Number} y - Y position of viewport
     * @param {Number} width - Width of viewport
     * @param {Number} height - Height of viewport
     */
    setViewport(x, y, width, height) {
        var v = this.viewport;
        if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
            v.x = x;
            v.y = y;
            v.width = width;
            v.height = height;
            this.gl.viewport(x, y, width, height);
        }
    }
    ;
    /**
     * Get the size of the current width and height. Returns object with `width` and `height` values.
     *
     * @member {object}
     * @readonly
     */
    get size() {
        if (this.current) {
            // TODO store temp
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }
        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    }
    ;
    /**
     * Clear the color of the context
     *
     * @param {Number} r - Red value from 0 to 1
     * @param {Number} g - Green value from 0 to 1
     * @param {Number} b - Blue value from 0 to 1
     * @param {Number} a - Alpha value from 0 to 1
     */
    clear(r = 0, g = 0, b = 0, a = 1) {
        var ref = this;
        var gl = ref.gl;
        // TODO clear color can be set only one right?
        gl.clearColor(r, g, b, a);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    ;
    /**
 * Initialize framebuffer
 *
 * @protected
 * @param {PIXI.Framebuffer} framebuffer
 */
    initFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        // TODO - make this a class?
        var fbo = {
            framebuffer: gl.createFramebuffer(),
            stencil: null,
            dirtyId: 0,
            dirtyFormat: 0,
            dirtySize: 0,
        };
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
    }
    ;
    /**
     * Resize the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    resizeFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.stencil) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        var colorTextures = framebuffer.colorTextures;
        for (var i = 0; i < colorTextures.length; i++) {
            this.renderer.texture.bind(colorTextures[i], 0);
        }
        if (framebuffer.depthTexture) {
            this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
    }
    ;
    /**
     * Update the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    updateFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        // bind the color texture
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
            count = Math.min(count, 1);
        }
        var activeTextures = [];
        for (var i = 0; i < count; i++) {
            var texture = framebuffer.colorTextures[i];
            if (texture.texturePart) {
                this.renderer.texture.bind(texture.texture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_CUBE_MAP_NEGATIVE_X + texture.side, texture.texture._glTextures[this.CONTEXT_UID].texture, 0);
            }
            else {
                this.renderer.texture.bind(texture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, texture._glTextures[this.CONTEXT_UID].texture, 0);
            }
            activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
        if (activeTextures.length > 1) {
            gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
            var writeDepthTexture = this.writeDepthTexture;
            if (writeDepthTexture) {
                var depthTexture = framebuffer.depthTexture;
                this.renderer.texture.bind(depthTexture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
            }
        }
        if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
            fbo.stencil = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            // TODO.. this is depth AND stencil?
            if (!framebuffer.depthTexture) { // you can't have both, so one should take priority if enabled
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
            }
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
            // fbo.enableStencil();
        }
    }
    ;
    /**
     * Disposes framebuffer
     * @param {PIXI.Framebuffer} framebuffer framebuffer that has to be disposed of
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    disposeFramebuffer(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
            return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index = this.managedFramebuffers.indexOf(framebuffer);
        if (index >= 0) {
            this.managedFramebuffers.splice(index, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
            gl.deleteFramebuffer(fbo.framebuffer);
            if (fbo.stencil) {
                gl.deleteRenderbuffer(fbo.stencil);
            }
        }
    }
    ;
    /**
     * Disposes all framebuffers, but not textures bound to them
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    disposeAll(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i = 0; i < list.count; i++) {
            this.disposeFramebuffer(list[i], contextLost);
        }
    }
    ;
    /**
     * resets framebuffer stored state, binds screen framebuffer
     *
     * should be called before renderTexture reset()
     */
    reset() {
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle_1.Rectangle();
    }
    ;
}
exports.FramebufferSystem = FramebufferSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLBuffer.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLBuffer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLBuffer {
    constructor(buffer) {
        this.buffer = buffer;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
    }
}
exports.GLBuffer = GLBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLProgram.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLProgram.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLProgram {
    constructor(program, uniformData) {
        /**
                 * The shader program
                 *
                 * @member {WebGLProgram}
                 */
        this.program = program;
        /**
         * holds the uniform data which contains uniform locations
         * and current uniform values used for caching and preventing unneeded GPU commands
         * @member {Object}
         */
        this.uniformData = uniformData;
        /**
         * uniformGroups holds the various upload functions for the shader. Each uniform group
         * and program have a unique upload function generated.
         * @member {Object}
         */
        this.uniformGroups = {};
    }
    /**
     * Destroys this program
     */
    destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.program = null;
    }
    ;
}
exports.GLProgram = GLProgram;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLTexture.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLTexture.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLTexture {
    constructor(texture) {
        /**
                 * The WebGL texture
                 * @member {WebGLTexture}
                 */
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        /**
         * Texture contents dirty flag
         * @member {number}
         */
        this.dirtyId = -1;
        /**
         * Texture style dirty flag
         * @member {number}
         */
        this.dirtyStyleId = -1;
        /**
         * Whether mip levels has to be generated
         * @member {boolean}
         */
        this.mipmap = false;
        /**
         * WrapMode copied from baseTexture
         * @member {number}
         */
        this.wrapMode = 33071;
    }
}
exports.GLTexture = GLTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Geometry.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Geometry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Attribute_1 = __webpack_require__(/*! ./Attribute */ "./js-compile/raw-pixi-ts/Attribute.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Geometry {
    constructor(buffers = [], attributes = {}) {
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        /**
         * A map of renderer IDs to webgl VAOs
         *
         * @protected
         * @type {object}
         */
        this.glVertexArrayObjects = {};
        this.id = Geometry.UID$1++;
        this.instanced = false;
        this.instanceCount = 1;
        this._size = null;
        this.disposeRunner = new Runner_1.Runner('disposeGeometry', 2);
        // this.disposeRunner = new Runner('disposeGeometry', 2);
        /**
         * Count of existing (not destroyed) meshes that reference this geometry
         * @member {boolean}
         */
        this.refCount = 0;
    }
    /**
    *
    * Adds an attribute to the geometry
    *
    * @param {String} id - the name of the attribute (matching up to a shader)
    * @param {PIXI.Buffer} [buffer] the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
    * @param {Number} [size=0] the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
    * @param {Boolean} [normalized=false] should the data be normalized.
    * @param {Number} [type=PIXI.TYPES.FLOAT] what type of number is the attribute. Check {PIXI.TYPES} to see the ones available
    * @param {Number} [stride=0] How far apart (in floats) the start of each value is. (used for interleaving data)
    * @param {Number} [start=0] How far into the array to start reading values (used for interleaving data)
    *
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */
    addAttribute(id, buffer, size = null, normalized = false, type = null, stride = undefined, start = undefined, instance = undefined) {
        if (!buffer) {
            throw new Error('You must pass a buffer when creating an attribute');
        }
        // check if this is a buffer!
        if (!buffer.data) {
            // its an array!
            if (buffer instanceof Array) {
                buffer = new Float32Array(buffer);
            }
            buffer = new Buffer_1.Buffer(buffer);
        }
        var ids = id.split('|');
        if (ids.length > 1) {
            for (var i = 0; i < ids.length; i++) {
                this.addAttribute(ids[i], buffer, size, normalized, type);
            }
            return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
            this.buffers.push(buffer);
            bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id] = new Attribute_1.Attribute(bufferIndex, size, normalized, type, stride, start, instance);
        // assuming that if there is instanced data then this will be drawn with instancing!
        this.instanced = this.instanced || instance;
        return this;
    }
    ;
    /**
     * returns the requested attribute
     *
     * @param {String} id  the name of the attribute required
     * @return {PIXI.Attribute} the attribute requested.
     */
    getAttribute(id) {
        return this.buffers[this.attributes[id].buffer];
    }
    ;
    /**
    *
    * Adds an index buffer to the geometry
    * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.
    *
    * @param {PIXI.Buffer} [buffer] the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */
    addIndex(buffer) {
        if (!buffer.data) {
            // its an array!
            if (buffer instanceof Array) {
                buffer = new Uint16Array(buffer);
            }
            buffer = new Buffer_1.Buffer(buffer);
        }
        buffer.index = true;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
            this.buffers.push(buffer);
        }
        return this;
    }
    ;
    /**
     * returns the index buffer
     *
     * @return {PIXI.Buffer} the index buffer.
     */
    getIndex() {
        return this.indexBuffer;
    }
    ;
    /**
     * this function modifies the structure so that all current attributes become interleaved into a single buffer
     * This can be useful if your model remains static as it offers a little performance boost
     *
     * @return {PIXI.Geometry} returns self, useful for chaining.
     */
    interleave() {
        // a simple check to see if buffers are already interleaved..
        if (this.buffers.length === 1 || (this.buffers.length === 2 && this.indexBuffer)) {
            return this;
        }
        // assume already that no buffers are interleaved
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer_1.Buffer();
        var i;
        for (i in this.attributes) {
            var attribute = this.attributes[i];
            var buffer = this.buffers[attribute.buffer];
            arrays.push(buffer.data);
            sizes.push((attribute.size * Geometry.byteSizeMap[attribute.type]) / 4);
            attribute.buffer = 0;
        }
        interleavedBuffer.data = Geometry.interleaveTypedArrays(arrays, sizes);
        for (i = 0; i < this.buffers.length; i++) {
            if (this.buffers[i] !== this.indexBuffer) {
                this.buffers[i].destroy();
            }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
            this.buffers.push(this.indexBuffer);
        }
        return this;
    }
    ;
    getSize() {
        for (var i in this.attributes) {
            var attribute = this.attributes[i];
            var buffer = this.buffers[attribute.buffer];
            return buffer.data.length / ((attribute.stride / 4) || attribute.size);
        }
        return 0;
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        // this.disposeRunner.run(this, false);
        this.disposeRunner.run(this, false);
    }
    ;
    /**
     * Destroys the geometry.
     */
    destroy(options = null) {
        this.dispose();
        this.buffers = null;
        this.indexBuffer.destroy();
        this.attributes = null;
    }
    ;
    /**
     * returns a clone of the geometry
     *
     * @returns {PIXI.Geometry} a new clone of this geometry
     */
    clone() {
        var geometry = new Geometry();
        for (var i = 0; i < this.buffers.length; i++) {
            geometry.buffers[i] = new Buffer_1.Buffer(this.buffers[i].data.slice());
        }
        for (var i$1 in this.attributes) {
            var attrib = this.attributes[i$1];
            geometry.attributes[i$1] = new Attribute_1.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
            geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
            geometry.indexBuffer.index = true;
        }
        return geometry;
    }
    ;
    /**
     * merges an array of geometries into a new single one
     * geometry attribute styles must match for this operation to work
     *
     * @param {PIXI.Geometry[]} geometries array of geometries to merge
     * @returns {PIXI.Geometry} shiny new geometry!
     */
    static merge(geometries) {
        // todo add a geometry check!
        // also a size check.. cant be too big!]
        var geometryOut = new Geometry();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        // pass one.. get sizes..
        for (var i = 0; i < geometries.length; i++) {
            geometry = geometries[i];
            for (var j = 0; j < geometry.buffers.length; j++) {
                sizes[j] = sizes[j] || 0;
                sizes[j] += geometry.buffers[j].data.length;
                offsets[j] = 0;
            }
        }
        // build the correct size arrays..
        for (var i$1 = 0; i$1 < geometry.buffers.length; i$1++) {
            // TODO types!
            arrays[i$1] = new Geometry.map$1[Geometry.getBufferType(geometry.buffers[i$1].data)](sizes[i$1]);
            geometryOut.buffers[i$1] = new Buffer_1.Buffer(arrays[i$1]);
        }
        // pass to set data..
        for (var i$2 = 0; i$2 < geometries.length; i$2++) {
            geometry = geometries[i$2];
            for (var j$1 = 0; j$1 < geometry.buffers.length; j$1++) {
                arrays[j$1].set(geometry.buffers[j$1].data, offsets[j$1]);
                offsets[j$1] += geometry.buffers[j$1].data.length;
            }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
            geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
            geometryOut.indexBuffer.index = true;
            var offset = 0;
            var stride = 0;
            var offset2 = 0;
            var bufferIndexToCount = 0;
            // get a buffer
            for (var i$3 = 0; i$3 < geometry.buffers.length; i$3++) {
                if (geometry.buffers[i$3] !== geometry.indexBuffer) {
                    bufferIndexToCount = i$3;
                    break;
                }
            }
            // figure out the stride of one buffer..
            for (var i$4 in geometry.attributes) {
                var attribute = geometry.attributes[i$4];
                if ((attribute.buffer | 0) === bufferIndexToCount) {
                    stride += ((attribute.size * Geometry.byteSizeMap[attribute.type]) / 4);
                }
            }
            // time to off set all indexes..
            for (var i$5 = 0; i$5 < geometries.length; i$5++) {
                var indexBufferData = geometries[i$5].indexBuffer.data;
                for (var j$2 = 0; j$2 < indexBufferData.length; j$2++) {
                    geometryOut.indexBuffer.data[j$2 + offset2] += offset;
                }
                offset += geometry.buffers[bufferIndexToCount].data.length / (stride);
                offset2 += indexBufferData.length;
            }
        }
        return geometryOut;
    }
    ;
    static getBufferType(array) {
        if (array.BYTES_PER_ELEMENT === 4) {
            if (array instanceof Float32Array) {
                return 'Float32Array';
            }
            else if (array instanceof Uint32Array) {
                return 'Uint32Array';
            }
            return 'Int32Array';
        }
        else if (array.BYTES_PER_ELEMENT === 2) {
            if (array instanceof Uint16Array) {
                return 'Uint16Array';
            }
        }
        else if (array.BYTES_PER_ELEMENT === 1) {
            if (array instanceof Uint8Array) {
                return 'Uint8Array';
            }
        }
        // TODO map out the rest of the array elements!
        return null;
    }
    static interleaveTypedArrays(arrays, sizes) {
        var outSize = 0;
        var stride = 0;
        var views = {};
        for (var i = 0; i < arrays.length; i++) {
            stride += sizes[i];
            outSize += arrays[i].length;
        }
        var buffer = new ArrayBuffer(outSize * 4);
        var out = null;
        var littleOffset = 0;
        for (var i$1 = 0; i$1 < arrays.length; i$1++) {
            var size = sizes[i$1];
            var array = arrays[i$1];
            var type = Geometry.getBufferType(array);
            if (!views[type]) {
                views[type] = new Geometry.map[type](buffer);
            }
            out = views[type];
            for (var j = 0; j < array.length; j++) {
                var indexStart = ((j / size | 0) * stride) + littleOffset;
                var index = j % size;
                out[indexStart + index] = array[j];
            }
            littleOffset += size;
        }
        return new Float32Array(buffer);
    }
}
/* eslint-disable object-shorthand */
Geometry.map = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
};
Geometry.UID$1 = 0;
/* eslint-disable object-shorthand */
Geometry.map$1 = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
    Uint16Array: Uint16Array,
};
Geometry.byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
exports.Geometry = Geometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GeometrySystem.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GeometrySystem.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const GLBuffer_1 = __webpack_require__(/*! ./GLBuffer */ "./js-compile/raw-pixi-ts/GLBuffer.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class GeometrySystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        this._activeGeometry = null;
        this._activeVao = null;
        /**
         * `true` if we has `*_vertex_array_object` extension
         * @member {boolean}
         * @readonly
         */
        this.hasVao = true;
        /**
         * `true` if has `ANGLE_instanced_arrays` extension
         * @member {boolean}
         * @readonly
         */
        this.hasInstance = true;
        /**
         * A cache of currently bound buffer,
         * contains only two members with keys ARRAY_BUFFER and ELEMENT_ARRAY_BUFFER
         * @member {Object.<number, PIXI.Buffer>}
         * @readonly
         */
        this.boundBuffers = {};
        /**
         * Cache for all geometries by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedGeometries = {};
        /**
         * Cache for all buffers by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedBuffers = {};
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        // webgl2
        if (!gl.createVertexArray) {
            // webgl 1!
            var nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
                nativeVaoExtension = null;
            }
            if (nativeVaoExtension) {
                gl.createVertexArray = function () { return nativeVaoExtension.createVertexArrayOES(); };
                gl.bindVertexArray = function (vao) { return nativeVaoExtension.bindVertexArrayOES(vao); };
                gl.deleteVertexArray = function (vao) { return nativeVaoExtension.deleteVertexArrayOES(vao); };
            }
            else {
                this.hasVao = false;
                gl.createVertexArray = function () {
                    // empty
                };
                gl.bindVertexArray = function () {
                    // empty
                };
                gl.deleteVertexArray = function () {
                    // empty
                };
            }
        }
        if (!gl.vertexAttribDivisor) {
            var instanceExt = gl.getExtension('ANGLE_instanced_arrays');
            if (instanceExt) {
                gl.vertexAttribDivisor = function (a, b) { return instanceExt.vertexAttribDivisorANGLE(a, b); };
                gl.drawElementsInstanced = function (a, b, c, d, e) { return instanceExt.drawElementsInstancedANGLE(a, b, c, d, e); };
                gl.drawArraysInstanced = function (a, b, c, d) { return instanceExt.drawArraysInstancedANGLE(a, b, c, d); };
            }
            else {
                this.hasInstance = false;
            }
        }
    }
    ;
    /**
     * Binds geometry so that is can be drawn. Creating a Vao if required
     * @protected
     * @param {PIXI.Geometry} geometry instance of geometry to bind
     * @param {PIXI.Shader} shader instance of shader to bind
     */
    bind(geometry, shader = null) {
        shader = shader || this.renderer.shader.shader;
        var ref = this;
        var gl = ref.gl;
        // not sure the best way to address this..
        // currently different shaders require different VAOs for the same geometry
        // Still mulling over the best way to solve this one..
        // will likely need to modify the shader attribute locations at run time!
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        if (!vaos) {
            this.managedGeometries[geometry.id] = geometry;
            // geometry.disposeRunner.add(this);
            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
            this._activeVao = vao;
            if (this.hasVao) {
                gl.bindVertexArray(vao);
            }
            else {
                this.activateVao(geometry, shader.program);
            }
        }
        // TODO - optimise later!
        // don't need to loop through if nothing changed!
        // maybe look to add an 'autoupdate' to geometry?
        this.updateBuffers();
    }
    ;
    /**
     * Reset and unbind any active VAO and geometry
     */
    reset() {
        this.unbind();
    }
    ;
    /**
     * Update buffers
     * @protected
     */
    updateBuffers() {
        var geometry = this._activeGeometry;
        var ref = this;
        var gl = ref.gl;
        // reveal(gl);
        for (var i = 0; i < geometry.buffers.length; i++) {
            var buffer = geometry.buffers[i];
            var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
            if (buffer._updateID !== glBuffer.updateID) {
                glBuffer.updateID = buffer._updateID;
                // TODO can cache this on buffer! maybe added a getter / setter?
                var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
                // TODO this could change if the VAO changes...
                // need to come up with a better way to cache..
                // if (this.boundBuffers[type] !== glBuffer)
                // {
                // this.boundBuffers[type] = glBuffer;
                gl.bindBuffer(type, glBuffer.buffer);
                // }
                this._boundBuffer = glBuffer;
                if (glBuffer.byteLength >= buffer.data.byteLength) {
                    // offset is always zero for now!
                    gl.bufferSubData(type, 0, buffer.data);
                }
                else {
                    var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
                    glBuffer.byteLength = buffer.data.byteLength;
                    gl.bufferData(type, buffer.data, drawType);
                }
            }
        }
    }
    ;
    /**
     * Check compability between a geometry and a program
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Program instance
     */
    checkCompatibility(geometry, program) {
        // geometry must have at least all the attributes that the shader requires.
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j in shaderAttributes) {
            if (!geometryAttributes[j]) {
                throw new Error(("shader and geometry incompatible, geometry missing the \"" + j + "\" attribute"));
            }
        }
    }
    ;
    /**
     * Takes a geometry and program and generates a unique signature for them.
     *
     * @param {PIXI.Geometry} geometry to get signature from
     * @param {PIXI.Program} program to test geometry against
     * @returns {String} Unique signature of the geometry and program
     * @protected
     */
    getSignature(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ['g', geometry.id];
        for (var i in attribs) {
            if (shaderAttributes[i]) {
                strings.push(i);
            }
        }
        return strings.join('-');
    }
    ;
    /**
     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
     * If vao is created, it is bound automatically.
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Instance of geometry to to generate Vao for
     * @param {PIXI.Program} program - Instance of program
     */
    initGeometryVao(geometry, program) {
        this.checkCompatibility(geometry, program);
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
            // this will give us easy access to the vao
            vaoObjectHash[program.id] = vao;
            return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j in buffers) {
            tempStride[j] = 0;
            tempStart[j] = 0;
        }
        for (var j$1 in attributes) {
            if (!attributes[j$1].size && program.attributeData[j$1]) {
                attributes[j$1].size = program.attributeData[j$1].size;
            }
            else if (!attributes[j$1].size) {
                console.warn(("PIXI Geometry attribute '" + j$1 + "' size cannot be determined (likely the bound shader does not have the attribute)")); // eslint-disable-line
            }
            tempStride[attributes[j$1].buffer] += attributes[j$1].size * GeometrySystem.byteSizeMap$1[attributes[j$1].type];
        }
        for (var j$2 in attributes) {
            var attribute = attributes[j$2];
            var attribSize = attribute.size;
            if (attribute.stride === undefined) {
                if (tempStride[attribute.buffer] === attribSize * GeometrySystem.byteSizeMap$1[attribute.type]) {
                    attribute.stride = 0;
                }
                else {
                    attribute.stride = tempStride[attribute.buffer];
                }
            }
            if (attribute.start === undefined) {
                attribute.start = tempStart[attribute.buffer];
                tempStart[attribute.buffer] += attribSize * GeometrySystem.byteSizeMap$1[attribute.type];
            }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        // first update - and create the buffers!
        // only create a gl buffer if it actually gets
        for (var i = 0; i < buffers.length; i++) {
            var buffer = buffers[i];
            if (!buffer._glBuffers[CONTEXT_UID]) {
                buffer._glBuffers[CONTEXT_UID] = new GLBuffer_1.GLBuffer(gl.createBuffer());
                this.managedBuffers[buffer.id] = buffer;
                // buffer.disposeRunner.add(this);
            }
            buffer._glBuffers[CONTEXT_UID].refCount++;
        }
        // TODO - maybe make this a data object?
        // lets wait to see if we need to first!
        this.activateVao(geometry, program);
        this._activeVao = vao;
        // add it to the cache!
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
    }
    ;
    /**
     * Disposes buffer
     * @param {PIXI.Buffer} buffer buffer with data
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    disposeBuffer(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
            return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        // buffer.disposeRunner.remove(this);
        if (!glBuffer) {
            return;
        }
        if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
    }
    ;
    /**
     * Disposes geometry
     * @param {PIXI.Geometry} geometry Geometry with buffers. Only VAO will be disposed
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    disposeGeometry(geometry, contextLost) {
        if (!this.managedGeometries[geometry.id]) {
            return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
            return;
        }
        for (var i = 0; i < buffers.length; i++) {
            var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
                this.disposeBuffer(buffers[i], contextLost);
            }
        }
        if (!contextLost) {
            for (var vaoId in vaos) {
                // delete only signatures, everything else are copies
                if (vaoId[0] === 'g') {
                    var vao = vaos[vaoId];
                    if (this._activeVao === vao) {
                        this.unbind();
                    }
                    gl.deleteVertexArray(vao);
                }
            }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
    ;
    /**
     * dispose all WebGL resources of all managed geometries and buffers
     * @param {boolean} [contextLost=false] If context was lost, we suppress `gl.delete` calls
     */
    disposeAll(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i = 0; i < all.length; i++) {
            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
        }
        all = Object.keys(this.managedBuffers);
        for (var i$1 = 0; i$1 < all.length; i$1++) {
            this.disposeBuffer(this.managedBuffers[all[i$1]], contextLost);
        }
    }
    ;
    /**
     * Activate vertex array object
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Shader program instance
     */
    activateVao(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
            // first update the index buffer if we have one..
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
        }
        var lastBuffer = null;
        // add a new one!
        for (var j in attributes) {
            var attribute = attributes[j];
            var buffer = buffers[attribute.buffer];
            var glBuffer = buffer._glBuffers[CONTEXT_UID];
            if (program.attributeData[j]) {
                if (lastBuffer !== glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
                    lastBuffer = glBuffer;
                }
                var location = program.attributeData[j].location;
                // TODO introduce state again
                // we can optimise this for older devices that have no VAOs
                gl.enableVertexAttribArray(location);
                gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
                if (attribute.instance) {
                    // TODO calculate instance count based of this...
                    if (this.hasInstance) {
                        gl.vertexAttribDivisor(location, 1);
                    }
                    else {
                        throw new Error('geometry error, GPU Instancing is not supported on this device');
                    }
                }
            }
        }
    }
    ;
    /**
     * Draw the geometry
     *
     * @param {Number} type - the type primitive to render
     * @param {Number} [size] - the number of elements to be rendered
     * @param {Number} [start] - Starting index
     * @param {Number} [instanceCount] - the number of instances of the set of elements to execute
     */
    draw(type, size = -1, start = 0, instanceCount = 1) {
        var ref = this;
        var gl = ref.gl;
        var geometry = this._activeGeometry;
        // TODO.. this should not change so maybe cache the function?
        if (size < 0) {
            size = geometry.indexBuffer.data.length;
        }
        if (geometry.indexBuffer) {
            if (geometry.instanced) {
                /* eslint-disable max-len */
                gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2, instanceCount || 1);
                /* eslint-enable max-len */
            }
            else {
                gl.drawElements(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2);
            }
        }
        else if (geometry.instanced) {
            // TODO need a better way to calculate size..
            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
        }
        else {
            gl.drawArrays(type, start, size || geometry.getSize());
        }
        return this;
    }
    ;
    /**
     * Unbind/reset everything
     * @protected
     */
    unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
    }
    ;
}
GeometrySystem.byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
exports.GeometrySystem = GeometrySystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Graphics.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Graphics.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const FillStyle_1 = __webpack_require__(/*! ./FillStyle */ "./js-compile/raw-pixi-ts/FillStyle.js");
// import { settings } from "./settings";
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const Ellipse_1 = __webpack_require__(/*! ./Ellipse */ "./js-compile/raw-pixi-ts/Ellipse.js");
const Circle_1 = __webpack_require__(/*! ./Circle */ "./js-compile/raw-pixi-ts/Circle.js");
const RoundedRectangle_1 = __webpack_require__(/*! ./RoundedRectangle */ "./js-compile/raw-pixi-ts/RoundedRectangle.js");
const ArcUtils_1 = __webpack_require__(/*! ./ArcUtils */ "./js-compile/raw-pixi-ts/ArcUtils.js");
const BezierUtils_1 = __webpack_require__(/*! ./BezierUtils */ "./js-compile/raw-pixi-ts/BezierUtils.js");
const QuadraticUtils_1 = __webpack_require__(/*! ./QuadraticUtils */ "./js-compile/raw-pixi-ts/QuadraticUtils.js");
const LineStyle_1 = __webpack_require__(/*! ./LineStyle */ "./js-compile/raw-pixi-ts/LineStyle.js");
const GraphicsGeometry_1 = __webpack_require__(/*! ./GraphicsGeometry */ "./js-compile/raw-pixi-ts/GraphicsGeometry.js");
const Star_1 = __webpack_require__(/*! ./Star */ "./js-compile/raw-pixi-ts/Star.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class Graphics extends Container_1.Container {
    constructor(geometry = null) {
        super();
        if (geometry === void 0) {
            geometry = null;
        }
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
         * @member {PIXI.GraphicsGeometry}
         * @readonly
         */
        this.geometry = geometry || new GraphicsGeometry_1.GraphicsGeometry();
        this.geometry.refCount++;
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Graphics objects.
         * @member {PIXI.Shader}
         */
        this.shader = null;
        /**
         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = State_1.State.for2d();
        /**
         * Current fill style
         *
         * @member {PIXI.FillStyle}
         * @protected
         */
        this._fillStyle = new FillStyle_1.FillStyle();
        /**
         * Current line style
         *
         * @member {PIXI.LineStyle}
         * @protected
         */
        this._lineStyle = new LineStyle_1.LineStyle();
        /**
         * Current shape transform matrix.
         *
         * @member {PIXI.Matrix}
         * @protected
         */
        this._matrix = null;
        /**
         * Current hole mode is enabled.
         *
         * @member {boolean}
         * @default false
         * @protected
         */
        this._holeMode = false;
        /**
         * Current path
         *
         * @member {PIXI.Polygon}
         * @protected
         */
        this.currentPath = null;
        /**
         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
         * This is useful if your graphics element does not change often, as it will speed up the rendering
         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
         * you are constantly redrawing the graphics element.
         *
         * @name cacheAsBitmap
         * @member {boolean}
         * @memberof PIXI.Graphics#
         * @default false
         */
        /**
         * A collections of batches! These can be drawn by the renderer batch system.
         *
         * @protected
         * @member {object[]}
         */
        this.batches = [];
        /**
         * Update dirty for limiting calculating tints for batches.
         *
         * @protected
         * @member {number}
         * @default -1
         */
        this.batchTint = -1;
        /**
         * Copy of the object vertex data.
         *
         * @protected
         * @member {Float32Array}
         */
        this.vertexData = null;
        this._transformID = -1;
        this.batchDirty = -1;
        // Set default
        this.tint = 0xFFFFFF;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
    }
    /**
     * Creates a new Graphics object with the same values as this one.
     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
     *
     * @return {PIXI.Graphics} A clone of the graphics object
     */
    clone() {
        this.finishPoly();
        return new Graphics(this.geometry);
    }
    ;
    /**
     * The blend mode to be applied to the graphic shape. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    /**
     * The tint applied to the graphic shape. This is a hex value. A value of
     * 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
    }
    ;
    /**
     * The current fill style.
     *
     * @member {PIXI.FillStyle}
     * @readonly
     */
    get fill() {
        return this._fillStyle;
    }
    ;
    /**
     * The current line style.
     *
     * @member {PIXI.LineStyle}
     * @readonly
     */
    get line() {
        return this._lineStyle;
    }
    ;
    /**
     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
     * method or the drawCircle() method.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {number} [alignment=1] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineStyle(width, color = 0, alpha = 1, alignment = 0.5, native = false) {
        if (width === void 0) {
            width = 0;
        }
        if (color === void 0) {
            color = 0;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (alignment === void 0) {
            alignment = 0.5;
        }
        if (native === void 0) {
            native = false;
        }
        this.lineTextureStyle(width, Texture_1.Texture.WHITE, color, alpha, null, alignment, native);
        return this;
    }
    ;
    /**
     * Like line style but support texture for line fill.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to use
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {PIXI.Matrix} [matrix=null] Texture matrix to transform texture
     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTextureStyle(width = 0, texture = Texture_1.Texture.WHITE, color = 0xFFFFFF, alpha = 1, matrix = null, alignment = 0.5, native = false) {
        if (width === void 0) {
            width = 0;
        }
        if (texture === void 0) {
            texture = Texture_1.Texture.WHITE;
        }
        if (color === void 0) {
            color = 0xFFFFFF;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (matrix === void 0) {
            matrix = null;
        }
        if (alignment === void 0) {
            alignment = 0.5;
        }
        if (native === void 0) {
            native = false;
        }
        if (this.currentPath) {
            this.startPoly();
        }
        var visible = width > 0 && alpha > 0;
        if (!visible) {
            this._lineStyle.reset();
        }
        else {
            if (matrix) {
                matrix = matrix.clone();
                matrix.invert();
            }
            Object.assign(this._lineStyle, {
                color: color,
                width: width,
                alpha: alpha,
                matrix: matrix,
                texture: texture,
                alignment: alignment,
                native: native,
                visible: visible,
            });
        }
        return this;
    }
    ;
    /**
     * Start a polygon object internally
     * @protected
     */
    startPoly() {
        if (this.currentPath) {
            var points = this.currentPath.points;
            var len = this.currentPath.points.length;
            if (len > 2) {
                this.drawShape(this.currentPath);
                this.currentPath = new Polygon_1.Polygon();
                this.currentPath.closeStroke = false;
                this.currentPath.points.push(points[len - 2], points[len - 1]);
            }
        }
        else {
            this.currentPath = new Polygon_1.Polygon();
            this.currentPath.closeStroke = false;
        }
    }
    ;
    /**
     * Finish the polygon object.
     * @protected
     */
    finishPoly() {
        if (this.currentPath) {
            if (this.currentPath.points.length > 2) {
                this.drawShape(this.currentPath);
                this.currentPath = null;
            }
            else {
                this.currentPath.points.length = 0;
            }
        }
    }
    ;
    /**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    moveTo(x, y) {
        this.startPoly();
        this.currentPath.points[0] = x;
        this.currentPath.points[1] = y;
        return this;
    }
    ;
    /**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTo(x, y) {
        if (!this.currentPath) {
            this.moveTo(0, 0);
        }
        // remove duplicates..
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        if (fromX !== x || fromY !== y) {
            points.push(x, y);
        }
        return this;
    }
    ;
    /**
     * Initialize the curve
     *
     * @protected
     * @param {number} [x=0]
     * @param {number} [y=0]
     */
    _initCurve(x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (this.currentPath) {
            if (this.currentPath.points.length === 0) {
                this.currentPath.points = [x, y];
            }
        }
        else {
            this.moveTo(x, y);
        }
    }
    ;
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    quadraticCurveTo(cpX, cpY, toX, toY) {
        this._initCurve();
        var points = this.currentPath.points;
        if (points.length === 0) {
            this.moveTo(0, 0);
        }
        QuadraticUtils_1.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
    }
    ;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils_1.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
    }
    ;
    /**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the beginning of the arc
     * @param {number} y1 - The y-coordinate of the beginning of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    arcTo(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        var points = this.currentPath.points;
        var result = ArcUtils_1.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result) {
            var cx = result.cx;
            var cy = result.cy;
            var radius$1 = result.radius;
            var startAngle = result.startAngle;
            var endAngle = result.endAngle;
            var anticlockwise = result.anticlockwise;
            this.arc(cx, cy, radius$1, startAngle, endAngle, anticlockwise);
        }
        return this;
    }
    ;
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
        if (anticlockwise === void 0) {
            anticlockwise = false;
        }
        if (startAngle === endAngle) {
            return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += MathSettings_1.MathSettings.PI_2;
        }
        else if (anticlockwise && startAngle <= endAngle) {
            startAngle += MathSettings_1.MathSettings.PI_2;
        }
        var sweep = endAngle - startAngle;
        if (sweep === 0) {
            return this;
        }
        var startX = cx + (Math.cos(startAngle) * radius);
        var startY = cy + (Math.sin(startAngle) * radius);
        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
        var points = this.currentPath ? this.currentPath.points : null;
        if (points) {
            // TODO: make a better fix.
            // We check how far our start is from the last existing point
            var xDiff = Math.abs(points[points.length - 2] - startX);
            var yDiff = Math.abs(points[points.length - 1] - startY);
            if (xDiff < 0.001 && yDiff < 0.001) {
                ;
            }
            else {
                points.push(startX, startY);
            }
        }
        else {
            this.moveTo(startX, startY);
            points = this.currentPath.points;
        }
        ArcUtils_1.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
    }
    ;
    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    beginFill(color = 0, alpha = 1) {
        return this.beginTextureFill(Texture_1.Texture.WHITE, color, alpha);
    }
    ;
    /**
     * Begin the texture fill
     *
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to fill
     * @param {number} [color=0xffffff] - Background to fill behind texture
     * @param {number} [alpha=1] - Alpha of fill
     * @param {PIXI.Matrix} [matrix=null] - Transform matrix
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    beginTextureFill(texture, color, alpha, matrix = null) {
        if (texture === void 0) {
            texture = Texture_1.Texture.WHITE;
        }
        if (color === void 0) {
            color = 0xFFFFFF;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (matrix === void 0) {
            matrix = null;
        }
        if (this.currentPath) {
            this.startPoly();
        }
        var visible = alpha > 0;
        if (!visible) {
            this._fillStyle.reset();
        }
        else {
            if (matrix) {
                matrix = matrix.clone();
                matrix.invert();
            }
            Object.assign(this._fillStyle, {
                color: color,
                alpha: alpha,
                texture: texture,
                matrix: matrix,
                visible: visible,
            });
        }
        return this;
    }
    ;
    /**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    endFill() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
    }
    ;
    /**
     * Draws a rectangle shape.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRect(x, y, width, height) {
        return this.drawShape(new Rectangle_1.Rectangle(x, y, width, height));
    }
    ;
    /**
     * Draw a rectangle shape with rounded/beveled corners.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRoundedRect(x, y, width, height, radius) {
        return this.drawShape(new RoundedRectangle_1.RoundedRectangle(x, y, width, height, radius));
    }
    ;
    /**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawCircle(x, y, radius) {
        return this.drawShape(new Circle_1.Circle(x, y, radius));
    }
    ;
    /**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawEllipse(x, y, width, height) {
        return this.drawShape(new Ellipse_1.Ellipse(x, y, width, height));
    }
    ;
    /**
     * Draws a polygon using the given path.
     *
     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawPolygon(path) {
        var arguments$1 = arguments;
        // prevents an argument assignment deopt
        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var points = path;
        var closeStroke = true; // !!this._fillStyle;
        // check if data has points..
        if (points.points) {
            closeStroke = points.closeStroke;
            points = points.points;
        }
        if (!Array.isArray(points)) {
            // prevents an argument leak deopt
            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            points = new Array(arguments.length);
            for (var i = 0; i < points.length; ++i) {
                points[i] = arguments$1[i]; // eslint-disable-line prefer-rest-params
            }
        }
        var shape = new Polygon_1.Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
    }
    ;
    /**
     * Draw any shape.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawShape(shape) {
        if (!this._holeMode) {
            this.geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        }
        else {
            this.geometry.drawHole(shape, this._matrix);
        }
        return this;
    }
    ;
    /**
     * Draw a star shape with an arbitrary number of points.
     *
     * @param {number} x - Center X position of the star
     * @param {number} y - Center Y position of the star
     * @param {number} points - The number of points of the star, must be > 1
     * @param {number} radius - The outer radius of the star
     * @param {number} [innerRadius] - The inner radius between points, default half `radius`
     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawStar(x, y, points, radius, innerRadius = 0, rotation = 0) {
        if (rotation === void 0) {
            rotation = 0;
        }
        return this.drawPolygon(new Star_1.Star(x, y, points, radius, innerRadius, rotation));
    }
    ;
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    clear() {
        this.geometry.clear();
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        this._spriteRect = null;
        return this;
    }
    ;
    /**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */
    isFastRect() {
        // will fix this!
        return false;
        // this.graphicsData.length === 1
        //  && this.graphicsData[0].shape.type === SHAPES.RECT
        // && !this.graphicsData[0].lineWidth;
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        this.finishPoly();
        var geometry = this.geometry;
        // batch part..
        // batch it!
        geometry.updateBatches();
        if (geometry.batchable) {
            if (this.batchDirty !== geometry.batchDirty) {
                this.batches = [];
                this.batchTint = -1;
                this._transformID = -1;
                this.batchDirty = geometry.batchDirty;
                this.vertexData = new Float32Array(geometry.points);
                var blendMode = this.blendMode;
                for (var i = 0; i < geometry.batches.length; i++) {
                    var gI = geometry.batches[i];
                    var color = gI.style.color;
                    //        + (alpha * 255 << 24);
                    var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
                    var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
                    var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
                    var batch = {
                        vertexData: vertexData,
                        blendMode: blendMode,
                        indices: indices,
                        uvs: uvs,
                        _batchRGB: ColorSettings_1.ColorSettings.hex2rgb(color),
                        _tintRGB: color,
                        _texture: gI.style.texture,
                        alpha: gI.style.alpha,
                        worldAlpha: 1
                    };
                    this.batches[i] = batch;
                }
            }
            renderer.batch.setObjectRenderer(renderer.plugins.batch);
            if (this.batches.length) {
                this.calculateVertices();
                this.calculateTints();
                for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
                    var batch$1 = this.batches[i$1];
                    batch$1.worldAlpha = this.worldAlpha * batch$1.alpha;
                    renderer.plugins.batch.render(batch$1);
                }
            }
        }
        else {
            // no batching...
            renderer.batch.flush();
            if (!this.shader) {
                // if there is no shader here, we can use the default shader.
                // and that only gets created if we actually need it..
                if (!Graphics.defaultShader) {
                    var sampleValues = new Int32Array(16);
                    for (var i$2 = 0; i$2 < 16; i$2++) {
                        sampleValues[i$2] = i$2;
                    }
                    var uniforms = {
                        tint: new Float32Array([1, 1, 1, 1]),
                        translationMatrix: new Matrix_1.Matrix(),
                        default: UniformGroup_1.UniformGroup.from({ uSamplers: sampleValues }, true),
                    };
                    // we can bbase default shader of the batch renderers program
                    var program = renderer.plugins.batch.shader.program;
                    Graphics.defaultShader = new Shader_1.Shader(program, uniforms);
                }
                this.shader = Graphics.defaultShader;
            }
            var uniforms$1 = this.shader.uniforms;
            // lets set the transfomr
            uniforms$1.translationMatrix = this.transform.worldTransform;
            var tint = this.tint;
            var wa = this.worldAlpha;
            // and then lets set the tint..
            uniforms$1.tint[0] = (((tint >> 16) & 0xFF) / 255) * wa;
            uniforms$1.tint[1] = (((tint >> 8) & 0xFF) / 255) * wa;
            uniforms$1.tint[2] = ((tint & 0xFF) / 255) * wa;
            uniforms$1.tint[3] = wa;
            // the first draw call, we can set the uniforms of the shader directly here.
            // this means that we can tack advantage of the sync function of pixi!
            // bind and sync uniforms..
            // there is a way to optimise this..
            renderer.shader.bind(this.shader);
            // then render it
            renderer.geometry.bind(geometry, this.shader);
            // set state..
            renderer.state.setState(this.state);
            // then render the rest of them...
            for (var i$3 = 0; i$3 < geometry.drawCalls.length; i$3++) {
                var drawCall = geometry.drawCalls[i$3];
                var groupTextureCount = drawCall.textureCount;
                for (var j = 0; j < groupTextureCount; j++) {
                    renderer.texture.bind(drawCall.textures[j], j);
                }
                // bind the geometry...
                renderer.geometry.draw(drawCall.type, drawCall.size, drawCall.start);
            }
        }
    }
    ;
    /**
     * Retrieves the bounds of the graphic shape as a rectangle object
     *
     * @protected
     */
    _calculateBounds() {
        this.finishPoly();
        var lb = this.geometry.bounds;
        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
    }
    ;
    /**
     * Tests if a point is inside this graphics object
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);
        return this.geometry.containsPoint(Graphics._TEMP_POINT);
    }
    ;
    /**
     * Recalcuate the tint by applying tin to batches using Graphics tint.
     * @protected
     */
    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this.tint;
            var tintRGB = ColorSettings_1.ColorSettings.hex2rgb(this.tint, Graphics.temp);
            for (var i = 0; i < this.batches.length; i++) {
                var batch = this.batches[i];
                var batchTint = batch._batchRGB;
                var r = (tintRGB[0] * batchTint[0]) * 255;
                var g = (tintRGB[1] * batchTint[1]) * 255;
                var b = (tintRGB[2] * batchTint[2]) * 255;
                // TODO Ivan, can this be done in one go?
                var color = (r << 16) + (g << 8) + (b | 0);
                batch._tintRGB = (color >> 16)
                    + (color & 0xff00)
                    + ((color & 0xff) << 16);
            }
        }
    }
    ;
    /**
     * If there's a transform update or a change to the shape of the
     * geometry, recaculate the vertices.
     * @protected
     */
    calculateVertices() {
        if (this._transformID === this.transform._worldID) {
            return;
        }
        this._transformID = this.transform._worldID;
        var wt = this.transform.worldTransform;
        // reveal(wt)
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var data = this.geometry.points; // batch.vertexDataOriginal;
        var vertexData = this.vertexData;
        var count = 0;
        for (var i = 0; i < data.length; i += 2) {
            var x = data[i];
            var y = data[i + 1];
            vertexData[count++] = (a * x) + (c * y) + tx;
            vertexData[count++] = (d * y) + (b * x) + ty;
        }
    }
    ;
    /**
     * Closes the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */
    closePath() {
        var currentPath = this.currentPath;
        if (currentPath) {
            // we don't need to add extra point in the end because buildLine will take care of that
            currentPath.closeStroke = true;
        }
        return this;
    }
    ;
    /**
     * Apply a matrix to the positional data.
     *
     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.
     * @return {PIXI.Graphics} Returns itself.
     */
    setMatrix(matrix) {
        this._matrix = matrix;
        return this;
    }
    ;
    /**
     * Begin adding holes to the last draw shape
     * IMPORTANT: holes must be fully inside a shape to work
     * Also weirdness ensues if holes overlap!
     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,
     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.
     * @return {PIXI.Graphics} Returns itself.
     */
    beginHole() {
        this.finishPoly();
        this._holeMode = true;
        return this;
    }
    ;
    /**
     * End adding holes to the last draw shape
     * @return {PIXI.Graphics} Returns itself.
     */
    endHole() {
        this.finishPoly();
        this._holeMode = false;
        return this;
    }
    ;
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
            this.geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this.geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        super.destroy(options);
    }
    ;
}
Graphics.temp = new Float32Array([1, 1, 1]);
Graphics.defaultShader = null;
/**
* Temporary point to use for containsPoint
*
* @static
* @private
* @member {PIXI.Point}
*/
Graphics._TEMP_POINT = new Point_1.Point();
exports.Graphics = Graphics;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GraphicsData.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GraphicsData.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GraphicsData {
    constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
        /**
         * The shape object to draw.
         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}
         */
        this.shape = shape;
        /**
         * The style of the line.
         * @member {PIXI.LineStyle}
         */
        this.lineStyle = lineStyle;
        /**
         * The style of the fill.
         * @member {PIXI.FillStyle}
         */
        this.fillStyle = fillStyle;
        /**
         * The transform matrix.
         * @member {PIXI.Matrix}
         */
        this.matrix = matrix;
        /**
         * The type of the shape, see the Const.Shapes file for all the existing types,
         * @member {number}
         */
        this.type = shape.type;
        /**
         * The collection of points.
         * @member {number[]}
         */
        this.points = [];
        /**
         * The collection of holes.
         * @member {PIXI.GraphicsData[]}
         */
        this.holes = [];
    }
    /**
     * Creates a new GraphicsData object with the same values as this one.
     *
     * @return {PIXI.GraphicsData} Cloned GraphicsData object
     */
    clone() {
        return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }
    ;
    /**
     * Destroys the Graphics data.
     */
    destroy() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
    }
    ;
}
exports.GraphicsData = GraphicsData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GraphicsGeometry.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GraphicsGeometry.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BatchGeometry_1 = __webpack_require__(/*! ./BatchGeometry */ "./js-compile/raw-pixi-ts/BatchGeometry.js");
const Bounds_1 = __webpack_require__(/*! ./Bounds */ "./js-compile/raw-pixi-ts/Bounds.js");
const GraphicsData_1 = __webpack_require__(/*! ./GraphicsData */ "./js-compile/raw-pixi-ts/GraphicsData.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const BatchDrawCall_1 = __webpack_require__(/*! ./BatchDrawCall */ "./js-compile/raw-pixi-ts/BatchDrawCall.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class BatchPart {
    constructor() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
    }
}
class GraphicsGeometry extends BatchGeometry_1.BatchGeometry {
    constructor() {
        super();
        /**
         * An array of points to draw
         *
         * @member {PIXI.Point[]}
         * @protected
         */
        this.points = [];
        /**
         * The collection of colors
         *
         * @member {number[]}
         * @protected
         */
        this.colors = [];
        /**
         * The UVs collection
         *
         * @member {number[]}
         * @protected
         */
        this.uvs = [];
        /**
         * The indices of the vertices
         *
         * @member {number[]}
         * @protected
         */
        this.indices = [];
        /**
         * Reference to the texture IDs.
         *
         * @member {number[]}
         * @protected
         */
        this.textureIds = [];
        /**
         * The collection of drawn shapes.
         *
         * @member {PIXI.GraphicsData[]}
         * @protected
         */
        this.graphicsData = [];
        /**
         * Used to detect if the graphics object has changed. If this is set to true then the graphics
         * object will be recalculated.
         *
         * @member {number}
         * @protected
         */
        this.dirty = 0;
        /**
         * Batches need to regenerated if the geometry is updated.
         *
         * @member {number}
         * @protected
         */
        this.batchDirty = -1;
        /**
         * Used to check if the cache is dirty.
         *
         * @member {number}
         * @protected
         */
        this.cacheDirty = -1;
        /**
         * Used to detect if we clear the graphics WebGL data.
         *
         * @member {number}
         * @default 0
         * @protected
         */
        this.clearDirty = 0;
        /**
         * List of current draw calls drived from the batches.
         *
         * @member {object[]}
         * @protected
         */
        this.drawCalls = [];
        /**
         * Intermediate abstract format sent to batch system.
         * Can be converted to drawCalls or to batchable objects.
         *
         * @member {object[]}
         * @protected
         */
        this.batches = [];
        /**
         * Index of the current last shape in the stack of calls.
         *
         * @member {number}
         * @protected
         */
        this.shapeIndex = 0;
        /**
         * Cached bounds.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds_1.Bounds();
        /**
         * The bounds dirty flag.
         *
         * @member {number}
         * @protected
         */
        this.boundsDirty = -1;
        /**
         * Padding to add to the bounds.
         *
         * @member {number}
         * @default 0
         */
        this.boundsPadding = 0;
        this.batchable = false;
        this.indicesUint16 = null;
        this.uvsFloat32 = null;
    }
    static getFillCommand(type) {
        if (!GraphicsGeometry.fillCommands) {
            GraphicsGeometry.fillCommands = {};
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.POLY] = GraphicsGeometry.buildPoly;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.CIRC] = GraphicsGeometry.buildCircle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.ELIP] = GraphicsGeometry.buildCircle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.RECT] = GraphicsGeometry.buildRectangle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.RREC] = GraphicsGeometry.buildRoundedRectangle;
        }
        return GraphicsGeometry.fillCommands[type];
    }
    /**
     * Get the current bounds of the graphic geometry.
     *
     * @member {PIXI.Bounds}
     * @readonly
     */
    get bounds() {
        if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
        }
        return this._bounds;
    }
    ;
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls
     */
    clear() {
        if (this.graphicsData.length > 0) {
            this.boundsDirty = -1;
            this.dirty++;
            this.clearDirty++;
            this.batchDirty++;
            this.graphicsData.length = 0;
            this.shapeIndex = 0;
            this.points.length = 0;
            this.colors.length = 0;
            this.uvs.length = 0;
            this.indices.length = 0;
            this.textureIds.length = 0;
            for (var i = 0; i < this.drawCalls.length; i++) {
                this.drawCalls[i].textures.length = 0;
                GraphicsGeometry.DRAW_CALL_POOL.push(this.drawCalls[i]);
            }
            this.drawCalls.length = 0;
            for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
                var batch = this.batches[i$1];
                batch.start = 0;
                batch.attribStart = 0;
                batch.style = null;
                GraphicsGeometry.BATCH_POOL.push(batch);
            }
            this.batches.length = 0;
        }
        return this;
    }
    ;
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.
     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    drawShape(shape, fillStyle, lineStyle, matrix) {
        var data = new GraphicsData_1.GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
    }
    ;
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    drawHole(shape, matrix) {
        if (!this.graphicsData.length) {
            return null;
        }
        var data = new GraphicsData_1.GraphicsData(shape, null, null, matrix);
        var lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return data;
    }
    ;
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        // destroy each of the GraphicsData objects
        for (var i = 0; i < this.graphicsData.length; ++i) {
            this.graphicsData[i].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
    }
    ;
    /**
     * Check to see if a point is contained within this geometry.
     *
     * @param {PIXI.Point} point - Point to check if it's contained.
     * @return {Boolean} `true` if the point is contained within geometry.
     */
    containsPoint(point) {
        var graphicsData = this.graphicsData;
        for (var i = 0; i < graphicsData.length; ++i) {
            var data = graphicsData[i];
            if (!data.fillStyle.visible) {
                continue;
            }
            // only deal with fills..
            if (data.shape) {
                if (data.shape.contains(point.x, point.y)) {
                    if (data.holes) {
                        for (var i$1 = 0; i$1 < data.holes.length; i$1++) {
                            var hole = data.holes[i$1];
                            if (hole.shape.contains(point.x, point.y)) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    }
    ;
    /**
     * Generates intermediate batch data. Either gets converted to drawCalls
     * or used to convert to batch objects directly by the Graphics object.
     * @protected
     */
    updateBatches() {
        if (this.dirty === this.cacheDirty) {
            return;
        }
        if (this.graphicsData.length === 0) {
            return;
        }
        if (this.dirty !== this.cacheDirty) {
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                // reveal(data.fillStyle.texture.baseTexture.resource);
                // reveal(data.lineStyle.texture.baseTexture.resource);
                if (data.fillStyle && !data.fillStyle.texture.baseTexture.valid) {
                    return;
                }
                if (data.lineStyle && !data.lineStyle.texture.baseTexture.valid) {
                    return;
                }
            }
        }
        this.cacheDirty = this.dirty;
        var uvs = this.uvs;
        var batchPart = this.batches.pop()
            || GraphicsGeometry.BATCH_POOL.pop()
            || new BatchPart();
        batchPart.style = batchPart.style
            || this.graphicsData[0].fillStyle
            || this.graphicsData[0].lineStyle;
        var currentTexture = batchPart.style.texture.baseTexture;
        // reveal(currentTexture);
        var currentColor = batchPart.style.color + batchPart.style.alpha;
        this.batches.push(batchPart);
        // reveal(this.batches);
        // TODO - this can be simplified
        for (var i$1 = this.shapeIndex; i$1 < this.graphicsData.length; i$1++) {
            this.shapeIndex++;
            var data$1 = this.graphicsData[i$1];
            // reveal(data$1);
            var command = GraphicsGeometry.getFillCommand(data$1.type);
            // reveal(command)
            var fillStyle = data$1.fillStyle;
            var lineStyle = data$1.lineStyle;
            // build out the shapes points..
            command.build(data$1);
            if (data$1.matrix) {
                this.transformPoints(data$1.points, data$1.matrix);
                // reveal(data$1.points)
                // 	reveal(data$1.matrix)
            }
            for (var j = 0; j < 2; j++) {
                var style = (j === 0) ? fillStyle : lineStyle;
                if (!style.visible) {
                    continue;
                }
                var nextTexture = style.texture.baseTexture;
                if (currentTexture !== nextTexture || (style.color + style.alpha) !== currentColor) {
                    // TODO use a const
                    nextTexture.wrapMode = 10497;
                    currentTexture = nextTexture;
                    currentColor = style.color + style.alpha;
                    var index$1 = this.indices.length;
                    var attribIndex = this.points.length / 2;
                    batchPart.size = index$1 - batchPart.start;
                    batchPart.attribSize = attribIndex - batchPart.attribStart;
                    if (batchPart.size > 0) {
                        batchPart = GraphicsGeometry.BATCH_POOL.pop() || new BatchPart();
                        this.batches.push(batchPart);
                    }
                    batchPart.style = style;
                    batchPart.start = index$1;
                    batchPart.attribStart = attribIndex;
                    // TODO add this to the render part..
                }
                var start = this.points.length / 2;
                if (j === 0) {
                    if (data$1.holes.length) {
                        this.processHoles(data$1.holes);
                        GraphicsGeometry.buildPoly.triangulate(data$1, this);
                    }
                    else {
                        command.triangulate(data$1, this);
                    }
                }
                else {
                    GraphicsGeometry.buildLine(data$1, this);
                    for (var i$2 = 0; i$2 < data$1.holes.length; i$2++) {
                        GraphicsGeometry.buildLine(data$1.holes[i$2], this);
                    }
                }
                var size = (this.points.length / 2) - start;
                this.addUvs(this.points, uvs, style.texture, start, size, style.matrix);
            }
        }
        var index = this.indices.length;
        var attrib = this.points.length / 2;
        batchPart.size = index - batchPart.start;
        batchPart.attribSize = attrib - batchPart.attribStart;
        this.indicesUint16 = new Uint16Array(this.indices);
        // TODO make this a const..
        this.batchable = this.isBatchable();
        if (this.batchable) {
            this.batchDirty++;
            this.uvsFloat32 = new Float32Array(this.uvs);
            // offset the indices so that it works with the batcher...
            for (var i$3 = 0; i$3 < this.batches.length; i$3++) {
                var batch = this.batches[i$3];
                for (var j$1 = 0; j$1 < batch.size; j$1++) {
                    var index$2 = batch.start + j$1;
                    this.indicesUint16[index$2] = this.indicesUint16[index$2] - batch.attribStart;
                }
            }
        }
        else {
            this.buildDrawCalls();
        }
    }
    ;
    /**
     * Checks to see if this graphics geometry can be batched.
     * Currently it needs to be small enough and not contain any native lines.
     * @protected
     */
    isBatchable() {
        var batches = this.batches;
        for (var i = 0; i < batches.length; i++) {
            if (batches[i].style.native) {
                return false;
            }
        }
        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);
    }
    ;
    /**
     * Converts intermediate batches data to drawCalls.
     * @protected
     */
    buildDrawCalls() {
        var TICK = ++BaseTexture_1.BaseTexture._globalBatch;
        for (var i = 0; i < this.drawCalls.length; i++) {
            this.drawCalls[i].textures.length = 0;
            GraphicsGeometry.DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var currentGroup = GraphicsGeometry.DRAW_CALL_POOL.pop() || new BatchDrawCall_1.BatchDrawCall();
        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
        var index = 0;
        this.drawCalls.push(currentGroup);
        // TODO - this can be simplified
        for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
            var data = this.batches[i$1];
            // TODO add some full on MAX_TEXTURE CODE..
            var MAX_TEXTURES = 8;
            var style = data.style;
            var nextTexture = style.texture.baseTexture;
            if (native !== style.native) {
                native = style.native;
                drawMode = native ? DrawModeSettings_1.DrawModeSettings.DRAW_MODES.LINES : DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }
            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;
                if (nextTexture._batchEnabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;
                        textureCount = 0;
                        if (currentGroup.size > 0) {
                            currentGroup = GraphicsGeometry.DRAW_CALL_POOL.pop() || new BatchDrawCall_1.BatchDrawCall();
                            this.drawCalls.push(currentGroup);
                        }
                        currentGroup.start = index;
                        currentGroup.size = 0;
                        currentGroup.textureCount = 0;
                        currentGroup.type = drawMode;
                    }
                    // TODO add this to the render part..
                    nextTexture.touched = 1; // touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    nextTexture.wrapMode = 10497;
                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    textureCount++;
                }
            }
            currentGroup.size += data.size;
            index += data.size;
            textureId = nextTexture._id;
            this.addColors(colors, style.color, style.alpha, data.attribSize);
            this.addTextureIds(textureIds, textureId, data.attribSize);
        }
        BaseTexture_1.BaseTexture._globalBatch = TICK;
        // upload..
        // merge for now!
        var verts = this.points;
        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);
        var p = 0;
        for (var i$2 = 0; i$2 < verts.length / 2; i$2++) {
            f32[p++] = verts[i$2 * 2];
            f32[p++] = verts[(i$2 * 2) + 1];
            f32[p++] = uvs[i$2 * 2];
            f32[p++] = uvs[(i$2 * 2) + 1];
            u32[p++] = colors[i$2];
            f32[p++] = textureIds[i$2];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
    }
    ;
    /**
     * Process the holes data.
     *
     * @param {PIXI.GraphicsData[]} holes - Holes to render
     * @protected
     */
    processHoles(holes) {
        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];
            var command = GraphicsGeometry.fillCommands[hole.type];
            command.build(hole);
            if (hole.matrix) {
                this.transformPoints(hole.points, hole.matrix);
            }
        }
    }
    ;
    /**
     * Update the local bounds of the object. Expensive to use performance-wise.
     * @protected
     */
    calculateBounds() {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        if (this.graphicsData.length) {
            var shape = null;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                var type = data.type;
                var lineWidth = data.lineStyle ? data.lineStyle.width : 0;
                shape = data.shape;
                if (type === ShapeSettings_1.ShapeSettings.SHAPES.RECT || type === ShapeSettings_1.ShapeSettings.SHAPES.RREC) {
                    x = shape.x - (lineWidth / 2);
                    y = shape.y - (lineWidth / 2);
                    w = shape.width + lineWidth;
                    h = shape.height + lineWidth;
                    minX = x < minX ? x : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y < minY ? y : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === ShapeSettings_1.ShapeSettings.SHAPES.CIRC) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.radius + (lineWidth / 2);
                    h = shape.radius + (lineWidth / 2);
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === ShapeSettings_1.ShapeSettings.SHAPES.ELIP) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.width + (lineWidth / 2);
                    h = shape.height + (lineWidth / 2);
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else {
                    // POLY
                    var points = shape.points;
                    var x2 = 0;
                    var y2 = 0;
                    var dx = 0;
                    var dy = 0;
                    var rw = 0;
                    var rh = 0;
                    var cx = 0;
                    var cy = 0;
                    for (var j = 0; j + 2 < points.length; j += 2) {
                        x = points[j];
                        y = points[j + 1];
                        x2 = points[j + 2];
                        y2 = points[j + 3];
                        dx = Math.abs(x2 - x);
                        dy = Math.abs(y2 - y);
                        h = lineWidth;
                        w = Math.sqrt((dx * dx) + (dy * dy));
                        if (w < 1e-9) {
                            continue;
                        }
                        rw = ((h / w * dy) + dx) / 2;
                        rh = ((h / w * dx) + dy) / 2;
                        cx = (x2 + x) / 2;
                        cy = (y2 + y) / 2;
                        minX = cx - rw < minX ? cx - rw : minX;
                        maxX = cx + rw > maxX ? cx + rw : maxX;
                        minY = cy - rh < minY ? cy - rh : minY;
                        maxY = cy + rh > maxY ? cy + rh : maxY;
                    }
                }
            }
        }
        else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        var padding = this.boundsPadding;
        this._bounds.minX = minX - padding;
        this._bounds.maxX = maxX + padding;
        this._bounds.minY = minY - padding;
        this._bounds.maxY = maxY + padding;
    }
    ;
    /**
     * Transform points using matrix.
     *
     * @protected
     * @param {number[]} points - Points to transform
     * @param {PIXI.Matrix} matrix - Transform matrix
     */
    transformPoints(points, matrix) {
        for (var i = 0; i < points.length / 2; i++) {
            var x = points[(i * 2)];
            var y = points[(i * 2) + 1];
            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;
            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;
        }
    }
    ;
    /**
     * Add colors.
     *
     * @protected
     * @param {number[]} colors - List of colors to add to
     * @param {number} color - Color to add
     * @param {number} alpha - Alpha to use
     * @param {number} size - Number of colors to add
     */
    addColors(colors, color, alpha, size) {
        // TODO use the premultiply bits Ivan added
        var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);
        var rgba = ColorSettings_1.ColorSettings.premultiplyTint(rgb, alpha);
        while (size-- > 0) {
            colors.push(rgba);
        }
    }
    ;
    /**
     * Add texture id that the shader/fragment wants to use.
     *
     * @protected
     * @param {number[]} textureIds
     * @param {number} id
     * @param {number} size
     */
    addTextureIds(textureIds, id, size) {
        while (size-- > 0) {
            textureIds.push(id);
        }
    }
    ;
    /**
     * Generates the UVs for a shape.
     *
     * @protected
     * @param {number[]} verts - Vertices
     * @param {number[]} uvs - UVs
     * @param {PIXI.Texture} texture - Reference to Texture
     * @param {number} start - Index buffer start index.
     * @param {number} size - The size/length for index buffer.
     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.
     */
    addUvs(verts, uvs, texture, start, size, matrix) {
        var index = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;
        while (index < size) {
            var x = verts[(start + index) * 2];
            var y = verts[((start + index) * 2) + 1];
            if (matrix) {
                var nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;
                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;
                x = nx;
            }
            index++;
            uvs.push(x / frame.width, y / frame.height);
        }
        var baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width
            || frame.height < baseTexture.height) {
            this.adjustUvs(uvs, texture, uvsStart, size);
        }
    }
    ;
    /**
     * Modify uvs array according to position of texture region
     * Does not work with rotated or trimmed textures
     * @param {number} uvs array
     * @param {PIXI.Texture} texture region
     * @param {number} start starting index for uvs
     * @param {number} size how many points to adjust
     */
    adjustUvs(uvs, texture, start, size) {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + (size * 2);
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.width;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);
        for (var i = start + 2; i < finish; i += 2) {
            minX = Math.min(minX, Math.floor(uvs[i] + eps));
            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i$1 = start; i$1 < finish; i$1 += 2) {
            uvs[i$1] = (uvs[i$1] + offsetX) * scaleX;
            uvs[i$1 + 1] = (uvs[i$1 + 1] + offsetY) * scaleY;
        }
    }
    ;
    /**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildLine(graphicsData, graphicsGeometry) {
        if (graphicsData.lineStyle.native) {
            GraphicsGeometry.buildNativeLine(graphicsData, graphicsGeometry);
        }
        else {
            GraphicsGeometry.buildLine$1(graphicsData, graphicsGeometry);
        }
    }
    /**
 * Builds a line to draw using the gl.drawArrays(gl.LINES) method
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildNativeLine(graphicsData, graphicsGeometry) {
        var i = 0;
        var points = graphicsData.points || graphicsData.shape.points;
        if (points.length === 0) {
            return;
        }
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var length = points.length / 2;
        var indexStart = verts.length / 2;
        // sort color
        for (i = 1; i < length; i++) {
            var p1x = points[(i - 1) * 2];
            var p1y = points[((i - 1) * 2) + 1];
            var p2x = points[i * 2];
            var p2y = points[(i * 2) + 1];
            verts.push(p1x, p1y);
            verts.push(p2x, p2y);
            indices.push(indexStart++, indexStart++);
        }
    }
    /**
 * Builds a line to draw using the polygon method.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildLine$1(graphicsData, graphicsGeometry) {
        var shape = graphicsData.shape;
        var points = graphicsData.points || shape.points.slice();
        if (points.length === 0) {
            return;
        }
        // if the line width is an odd number add 0.5 to align to a whole pixel
        // commenting this out fixes #711 and #1620
        // if (graphicsData.lineWidth%2)
        // {
        //     for (i = 0; i < points.length; i++)
        //     {
        //         points[i] += 0.5;
        //     }
        // }
        var style = graphicsData.lineStyle;
        // get first and last point.. figure out the middle!
        var firstPoint = new Point_1.Point(points[0], points[1]);
        var lastPoint = new Point_1.Point(points[points.length - 2], points[points.length - 1]);
        var closedShape = shape.type !== ShapeSettings_1.ShapeSettings.SHAPES.POLY || shape.closeStroke;
        var closedPath = firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
        // if the first point is the last point - gonna have issues :)
        if (closedShape) {
            // need to clone as we are going to slightly modify the shape..
            points = points.slice();
            if (closedPath) {
                points.pop();
                points.pop();
                lastPoint.set(points[points.length - 2], points[points.length - 1]);
            }
            var midPointX = lastPoint.x + ((firstPoint.x - lastPoint.x) * 0.5);
            var midPointY = lastPoint.y + ((firstPoint.y - lastPoint.y) * 0.5);
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
        var verts = graphicsGeometry.points;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 2;
        // DRAW the Line
        var width = style.width / 2;
        // sort color
        var p1x = points[0];
        var p1y = points[1];
        var p2x = points[2];
        var p2y = points[3];
        var p3x = 0;
        var p3y = 0;
        var perpx = -(p1y - p2y);
        var perpy = p1x - p2x;
        var perp2x = 0;
        var perp2y = 0;
        var perp3x = 0;
        var perp3y = 0;
        var dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        var ratio = style.alignment; // 0.5;
        var r1 = (1 - ratio) * 2;
        var r2 = ratio * 2;
        // start
        verts.push(p1x - (perpx * r1), p1y - (perpy * r1));
        verts.push(p1x + (perpx * r2), p1y + (perpy * r2));
        for (var i = 1; i < length - 1; ++i) {
            p1x = points[(i - 1) * 2];
            p1y = points[((i - 1) * 2) + 1];
            p2x = points[i * 2];
            p2y = points[(i * 2) + 1];
            p3x = points[(i + 1) * 2];
            p3y = points[((i + 1) * 2) + 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
            dist = Math.sqrt((perp2x * perp2x) + (perp2y * perp2y));
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
            var a1 = (-perpy + p1y) - (-perpy + p2y);
            var b1 = (-perpx + p2x) - (-perpx + p1x);
            var c1 = ((-perpx + p1x) * (-perpy + p2y)) - ((-perpx + p2x) * (-perpy + p1y));
            var a2 = (-perp2y + p3y) - (-perp2y + p2y);
            var b2 = (-perp2x + p2x) - (-perp2x + p3x);
            var c2 = ((-perp2x + p3x) * (-perp2y + p2y)) - ((-perp2x + p2x) * (-perp2y + p3y));
            var denom = (a1 * b2) - (a2 * b1);
            if (Math.abs(denom) < 0.1) {
                denom += 10.1;
                verts.push(p2x - (perpx * r1), p2y - (perpy * r1));
                verts.push(p2x + (perpx * r2), p2y + (perpy * r2));
                continue;
            }
            var px = ((b1 * c2) - (b2 * c1)) / denom;
            var py = ((a2 * c1) - (a1 * c2)) / denom;
            var pdist = ((px - p2x) * (px - p2x)) + ((py - p2y) * (py - p2y));
            if (pdist > (196 * width * width)) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
                dist = Math.sqrt((perp3x * perp3x) + (perp3y * perp3y));
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
                verts.push(p2x - (perp3x * r1), p2y - (perp3y * r1));
                verts.push(p2x + (perp3x * r2), p2y + (perp3y * r2));
                verts.push(p2x - (perp3x * r2 * r1), p2y - (perp3y * r1));
                indexCount++;
            }
            else {
                verts.push(p2x + ((px - p2x) * r1), p2y + ((py - p2y) * r1));
                verts.push(p2x - ((px - p2x) * r2), p2y - ((py - p2y) * r2));
            }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[((length - 2) * 2) + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[((length - 1) * 2) + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - (perpx * r1), p2y - (perpy * r1));
        verts.push(p2x + (perpx * r2), p2y + (perpy * r2));
        var indices = graphicsGeometry.indices;
        // indices.push(indexStart);
        for (var i$1 = 0; i$1 < indexCount - 2; ++i$1) {
            indices.push(indexStart, indexStart + 1, indexStart + 2);
            indexStart++;
        }
    }
    static earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = GraphicsGeometry.linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) {
            return triangles;
        }
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) {
            outerNode = GraphicsGeometry.eliminateHoles(data, holeIndices, outerNode, dim);
        }
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) {
                    minX = x;
                }
                if (y < minY) {
                    minY = y;
                }
                if (x > maxX) {
                    maxX = x;
                }
                if (y > maxY) {
                    maxY = y;
                }
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        GraphicsGeometry.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
    // create a circular doubly linked list from polygon points in the specified winding order
    static linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (GraphicsGeometry.signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) {
                last = GraphicsGeometry.insertNode(i, data[i], data[i + 1], last);
            }
        }
        else {
            for (i = end - dim; i >= start; i -= dim) {
                last = GraphicsGeometry.insertNode(i, data[i], data[i + 1], last);
            }
        }
        if (last && GraphicsGeometry.equals(last, last.next)) {
            GraphicsGeometry.removeNode(last);
            last = last.next;
        }
        return last;
    }
    // link every hole into the outer loop, producing a single-ring polygon without holes
    static eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = GraphicsGeometry.linkedList(data, start, end, dim, false);
            if (list === list.next) {
                list.steiner = true;
            }
            queue.push(GraphicsGeometry.getLeftmost(list));
        }
        queue.sort(GraphicsGeometry.compareX);
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            GraphicsGeometry.eliminateHole(queue[i], outerNode);
            outerNode = GraphicsGeometry.filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
        if (!ear) {
            return;
        }
        // interlink polygon nodes in z-order
        if (!pass && invSize) {
            GraphicsGeometry.indexCurve(ear, minX, minY, invSize);
        }
        var stop = ear, prev, next;
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? GraphicsGeometry.isEarHashed(ear, minX, minY, invSize) : GraphicsGeometry.isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                GraphicsGeometry.removeNode(ear);
                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    GraphicsGeometry.earcutLinked(GraphicsGeometry.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                    // if this didn't work, try curing all small self-intersections locally
                }
                else if (pass === 1) {
                    ear = GraphicsGeometry.cureLocalIntersections(ear, triangles, dim);
                    GraphicsGeometry.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    // as a last resort, try splitting the remaining polygon into two
                }
                else if (pass === 2) {
                    GraphicsGeometry.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }
    static signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    static insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        }
        else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    // check if two points are equal
    static equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    static removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) {
            p.prevZ.nextZ = p.nextZ;
        }
        if (p.nextZ) {
            p.nextZ.prevZ = p.prevZ;
        }
    }
    // find the leftmost node of a polygon ring
    static getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) {
                leftmost = p;
            }
            p = p.next;
        } while (p !== start);
        return leftmost;
    }
    static compareX(a, b) {
        return a.x - b.x;
    }
    // find a bridge between vertices that connects hole with an outer ring and and link it
    static eliminateHole(hole, outerNode) {
        outerNode = GraphicsGeometry.findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = GraphicsGeometry.splitPolygon(outerNode, hole);
            GraphicsGeometry.filterPoints(b, b.next);
        }
    }
    // eliminate colinear or duplicate points
    static filterPoints(start, end = null) {
        if (!start) {
            return start;
        }
        if (!end) {
            end = start;
        }
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (GraphicsGeometry.equals(p, p.next) || GraphicsGeometry.area(p.prev, p, p.next) === 0)) {
                GraphicsGeometry.removeNode(p);
                p = end = p.prev;
                if (p === p.next) {
                    break;
                }
                again = true;
            }
            else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }
    // signed area of a triangle
    static area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    static splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    static findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) {
                            return p;
                        }
                        if (hy === p.next.y) {
                            return p.next;
                        }
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m) {
            return null;
        }
        if (hx === qx) {
            return m.prev;
        } // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                GraphicsGeometry.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && GraphicsGeometry.locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }
    // check if a polygon diagonal is locally inside the polygon
    static locallyInside(a, b) {
        return GraphicsGeometry.area(a.prev, a, a.next) < 0 ?
            GraphicsGeometry.area(a, b, a.next) >= 0 && GraphicsGeometry.area(a, a.prev, b) >= 0 :
            GraphicsGeometry.area(a, b, a.prev) < 0 || GraphicsGeometry.area(a, a.next, b) < 0;
    }
    // check if a point lies within a convex triangle
    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    // try splitting polygon into two and triangulate them independently
    static splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && GraphicsGeometry.isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = GraphicsGeometry.splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = GraphicsGeometry.filterPoints(a, a.next);
                    c = GraphicsGeometry.filterPoints(c, c.next);
                    // run earcut on each half
                    GraphicsGeometry.earcutLinked(a, triangles, dim, minX, minY, invSize);
                    GraphicsGeometry.earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    static isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !GraphicsGeometry.intersectsPolygon(a, b) &&
            GraphicsGeometry.locallyInside(a, b) && GraphicsGeometry.locallyInside(b, a) && GraphicsGeometry.middleInside(a, b);
    }
    // check if the middle point of a polygon diagonal is inside the polygon
    static middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a);
        return inside;
    }
    // check if a polygon diagonal intersects any polygon segments
    static intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                GraphicsGeometry.intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a);
        return false;
    }
    // check if two segments intersect
    static intersects(p1, q1, p2, q2) {
        if ((GraphicsGeometry.equals(p1, q1) && GraphicsGeometry.equals(p2, q2)) ||
            (GraphicsGeometry.equals(p1, q2) && GraphicsGeometry.equals(p2, q1))) {
            return true;
        }
        return GraphicsGeometry.area(p1, q1, p2) > 0 !== GraphicsGeometry.area(p1, q1, q2) > 0 &&
            GraphicsGeometry.area(p2, q2, p1) > 0 !== GraphicsGeometry.area(p2, q2, q1) > 0;
    }
    // go through all polygon nodes and cure small local self-intersections
    static cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!GraphicsGeometry.equals(a, b) && GraphicsGeometry.intersects(a, p, p.next, b) && GraphicsGeometry.locallyInside(a, b) && GraphicsGeometry.locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                // remove two nodes involved
                GraphicsGeometry.removeNode(p);
                GraphicsGeometry.removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return p;
    }
    static isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (GraphicsGeometry.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        // z-order range for the current triangle bbox;
        var minZ = GraphicsGeometry.zOrder(minTX, minTY, minX, minY, invSize), maxZ = GraphicsGeometry.zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
            if (n !== ear.prev && n !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                GraphicsGeometry.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
        }
        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n !== ear.prev && n !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                GraphicsGeometry.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        return true;
    }
    // z-order of a point given coords and inverse of the longer side of data bbox
    static zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // check whether a polygon node forms a valid ear with adjacent nodes
    static isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (GraphicsGeometry.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    // interlink polygon nodes in z-order
    static indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) {
                p.z = GraphicsGeometry.zOrder(p.x, p.y, minX, minY, invSize);
            }
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        GraphicsGeometry.sortLinked(p);
    }
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    static sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) {
                        break;
                    }
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail) {
                        tail.nextZ = e;
                    }
                    else {
                        list = e;
                    }
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    /**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
    static quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
        if (out === void 0) {
            out = [];
        }
        var n = 20;
        var points = out;
        var xa = 0;
        var ya = 0;
        var xb = 0;
        var yb = 0;
        var x = 0;
        var y = 0;
        for (var i = 0, j = 0; i <= n; ++i) {
            j = i / n;
            // The Green Line
            xa = GraphicsGeometry.getPt(fromX, cpX, j);
            ya = GraphicsGeometry.getPt(fromY, cpY, j);
            xb = GraphicsGeometry.getPt(cpX, toX, j);
            yb = GraphicsGeometry.getPt(cpY, toY, j);
            // The Black Dot
            x = GraphicsGeometry.getPt(xa, xb, j);
            y = GraphicsGeometry.getPt(ya, yb, j);
            points.push(x, y);
        }
        return points;
    }
    /**
 * Calculate a single point for a quadratic bezier curve.
 * Utility function used by quadraticBezierCurve.
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} n1 - first number
 * @param {number} n2 - second number
 * @param {number} perc - percentage
 * @return {number} the result
 *
 */
    static getPt(n1, n2, perc) {
        var diff = n2 - n1;
        return n1 + (diff * perc);
    }
}
GraphicsGeometry.BATCH_POOL = [];
GraphicsGeometry.DRAW_CALL_POOL = [];
/**
* The maximum number of points to consider an object "batchable",
* able to be batched by the renderer's batch system.
*
* @memberof PIXI.GraphicsGeometry
* @static
* @member {number} BATCHABLE_SIZE
* @default 100
*/
GraphicsGeometry.BATCHABLE_SIZE = 100;
/**
* Builds a polygon to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildPoly = {
    name: "buildPoly",
    build: function build(graphicsData) {
        graphicsData.points = graphicsData.shape.points.slice();
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var holes = graphicsData.holes;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        if (points.length >= 6) {
            var holeArray = [];
            // Process holes..
            for (var i = 0; i < holes.length; i++) {
                var hole = holes[i];
                holeArray.push(points.length / 2);
                points = points.concat(hole.points);
            }
            // sort color
            var triangles = GraphicsGeometry.earcut(points, holeArray, 2);
            if (!triangles) {
                return;
            }
            var vertPos = verts.length / 2;
            for (var i$1 = 0; i$1 < triangles.length; i$1 += 3) {
                indices.push(triangles[i$1] + vertPos);
                indices.push(triangles[i$1 + 1] + vertPos);
                indices.push(triangles[i$1 + 2] + vertPos);
            }
            for (var i$2 = 0; i$2 < points.length; i$2++) {
                verts.push(points[i$2]);
            }
        }
    },
};
/**
* Builds a rectangle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildRectangle = {
    name: "buildRectangle",
    build: function build(graphicsData) {
        // --- //
        // need to convert points to a nice regular data
        //
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;
        var points = graphicsData.points;
        points.length = 0;
        points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var vertPos = verts.length / 2;
        verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
    },
};
/**
* Builds a rounded rectangle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildRoundedRectangle = {
    name: "buildRoundedRectangle",
    build: function build(graphicsData) {
        var rrectData = graphicsData.shape;
        var points = graphicsData.points;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;
        var radius = rrectData.radius;
        points.length = 0;
        GraphicsGeometry.quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);
        GraphicsGeometry.quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);
        GraphicsGeometry.quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);
        GraphicsGeometry.quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);
        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
        // TODO - fix this properly, this is not very elegant.. but it works for now.
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vecPos = verts.length / 2;
        var triangles = GraphicsGeometry.earcut(points, null, 2);
        for (var i = 0, j = triangles.length; i < j; i += 3) {
            indices.push(triangles[i] + vecPos);
            //     indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            //   indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
        }
        for (var i$1 = 0, j$1 = points.length; i$1 < j$1; i$1++) {
            verts.push(points[i$1], points[++i$1]);
        }
    },
};
/**
* Builds a circle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildCircle = {
    name: "buildCircle",
    build: function build(graphicsData) {
        // need to convert points to a nice regular data
        var circleData = graphicsData.shape;
        var points = graphicsData.points;
        var x = circleData.x;
        var y = circleData.y;
        var width;
        var height;
        points.length = 0;
        // TODO - bit hacky??
        if (graphicsData.type === ShapeSettings_1.ShapeSettings.SHAPES.CIRC) {
            width = circleData.radius;
            height = circleData.radius;
        }
        else {
            width = circleData.width;
            height = circleData.height;
        }
        if (width === 0 || height === 0) {
            return;
        }
        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))
            || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
        totalSegs /= 2.3;
        var seg = (Math.PI * 2) / totalSegs;
        for (var i = 0; i < totalSegs; i++) {
            points.push(x + (Math.sin(-seg * i) * width), y + (Math.cos(-seg * i) * height));
        }
        points.push(points[0], points[1]);
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vertPos = verts.length / 2;
        var center = vertPos;
        verts.push(graphicsData.shape.x, graphicsData.shape.y);
        for (var i = 0; i < points.length; i += 2) {
            verts.push(points[i], points[i + 1]);
            // add some uvs
            indices.push(vertPos++, center, vertPos);
        }
    },
};
exports.GraphicsGeometry = GraphicsGeometry;
class Node {
    constructor(i, x, y) {
        // vertex index in coordinates array
        this.i = i;
        // vertex coordinates
        this.x = x;
        this.y = y;
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = null;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
    }
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GroupD8.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/GroupD8.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class GroupD8 {
    static uX(ind) {
        GroupD8.init();
        return GroupD8.ux[ind];
    }
    static uY(ind) {
        GroupD8.init();
        return GroupD8.uy[ind];
    }
    static vX(ind) {
        GroupD8.init();
        return GroupD8.vx[ind];
    }
    static vY(ind) {
        GroupD8.init();
        return GroupD8.vy[ind];
    }
    static inv(rotation) {
        if (rotation & 8) {
            return rotation & 15;
        }
        return (-rotation) & 7;
    }
    static add(rotationSecond, rotationFirst) {
        GroupD8.init();
        return GroupD8.mul[rotationSecond][rotationFirst];
    }
    static sub(rotationSecond, rotationFirst) {
        GroupD8.init();
        return GroupD8.mul[rotationSecond][GroupD8.inv(rotationFirst)];
    }
    static rotate180(rotation) {
        return rotation ^ 4;
    }
    static isVertical(rotation) {
        return (rotation & 3) === 2;
    }
    static byDirection(dx, dy) {
        GroupD8.init();
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
                return GroupD8.S;
            }
            return GroupD8.N;
        }
        else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
                return GroupD8.E;
            }
            return GroupD8.W;
        }
        else if (dy > 0) {
            if (dx > 0) {
                return GroupD8.SE;
            }
            return GroupD8.SW;
        }
        else if (dx > 0) {
            return GroupD8.NE;
        }
        return GroupD8.NW;
    }
    static matrixAppendRotationInv(matrix, rotation, tx = 0, ty = 0) {
        GroupD8.init();
        let mat = GroupD8.tempMatrices[GroupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    }
    static signum(x) {
        if (x < 0) {
            return -1;
        }
        if (x > 0) {
            return 1;
        }
        return 0;
    }
    static init() {
        if (GroupD8.isInit) {
            return;
        }
        GroupD8.isInit = true;
        for (var i = 0; i < 16; i++) {
            var row = [];
            GroupD8.mul.push(row);
            for (var j = 0; j < 16; j++) {
                var _ux = GroupD8.signum((GroupD8.ux[i] * GroupD8.ux[j]) + (GroupD8.vx[i] * GroupD8.uy[j]));
                var _uy = GroupD8.signum((GroupD8.uy[i] * GroupD8.ux[j]) + (GroupD8.vy[i] * GroupD8.uy[j]));
                var _vx = GroupD8.signum((GroupD8.ux[i] * GroupD8.vx[j]) + (GroupD8.vx[i] * GroupD8.vy[j]));
                var _vy = GroupD8.signum((GroupD8.uy[i] * GroupD8.vx[j]) + (GroupD8.vy[i] * GroupD8.vy[j]));
                for (var k = 0; k < 16; k++) {
                    if (GroupD8.ux[k] === _ux && GroupD8.uy[k] === _uy && GroupD8.vx[k] === _vx && GroupD8.vy[k] === _vy) {
                        row.push(k);
                        break;
                    }
                }
            }
        }
        for (var i$1 = 0; i$1 < 16; i$1++) {
            var mat = new Matrix_1.Matrix();
            mat.set(GroupD8.ux[i$1], GroupD8.uy[i$1], GroupD8.vx[i$1], GroupD8.vy[i$1], 0, 0);
            GroupD8.tempMatrices.push(mat);
        }
    }
}
GroupD8.isInit = false;
GroupD8.E = 0;
GroupD8.SE = 1;
GroupD8.S = 2;
GroupD8.SW = 3;
GroupD8.W = 4;
GroupD8.NW = 5;
GroupD8.N = 6;
GroupD8.NE = 7;
GroupD8.MIRROR_VERTICAL = 8;
GroupD8.MIRROR_HORIZONTAL = 12;
GroupD8.ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
GroupD8.uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
GroupD8.vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
GroupD8.vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
GroupD8.tempMatrices = [];
GroupD8.mul = [];
exports.GroupD8 = GroupD8;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/IOErrorEvent.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/IOErrorEvent.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class IOErrorEvent extends Event_1.Event {
    constructor(type, bubble = true, cancelable = true) {
        super(type, bubble, cancelable);
        this.errorId = 0;
    }
    clone() {
        var event = new IOErrorEvent(this.type, this.bubbles, this.cancelable);
        event.text = this.text;
        event.errorId = this.errorId;
        return event;
    }
    get isDisposable() {
        return false;
    }
}
IOErrorEvent.IO_ERROR = "ioError";
exports.IOErrorEvent = IOErrorEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ImageResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ImageResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class ImageResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options = {}) {
        super(source);
        if (!(source instanceof HTMLImageElement)) {
            var imageElement = new Image();
            // BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
            imageElement.src = source;
            source = imageElement;
            this.source = source;
        }
        /**
         * URL of the image source
         * @member {string}
         */
        this.url = source.src;
        /**
         * When process is completed
         * @member {Promise<void>}
         * @private
         */
        this._process = null;
        /**
         * If the image should be disposed after upload
         * @member {boolean}
         * @default false
         */
        this.preserveBitmap = false;
        /**
         * If capable, convert the image using createImageBitmap API
         * @member {boolean}
         * @default PIXI.settings.CREATE_IMAGE_BITMAP
         */
        this.createBitmap = options.createBitmap !== false && DisplaySettings_1.DisplaySettings.CREATE_IMAGE_BITMAP && !!window.createImageBitmap;
        /**
         * Controls texture premultiplyAlpha field
         * Copies from options
         * @member {boolean|null}
         * @readonly
         */
        this.premultiplyAlpha = options.premultiplyAlpha !== false;
        /**
         * The ImageBitmap element created for HTMLImageElement
         * @member {ImageBitmap}
         * @default null
         */
        this.bitmap = null;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * returns a promise when image will be loaded and processed
     *
     * @param {boolean} [createBitmap=true] whether process image into bitmap
     * @returns {Promise<void>}
     */
    load(createBitmap = undefined) {
        if (createBitmap !== undefined) {
            this.createBitmap = createBitmap;
        }
        if (this._load) {
            return this._load;
        }
        this._load = new Promise((resolve) => {
            Logger_1.trace("source " + this.source);
            this.url = this.source.src;
            var ref = this;
            var source = ref.source;
            var completed = () => {
                if (this.destroyed) {
                    return;
                }
                source.onload = null;
                source.onerror = null;
                this.resize(source.width, source.height);
                this._load = null;
                if (this.createBitmap) {
                    resolve(this.process());
                }
                else {
                    resolve(this);
                }
            };
            if (source.complete && source.src) {
                completed();
            }
            else {
                source.onload = completed;
            }
        });
        return this._load;
    }
    ;
    /**
    * Called when we need to convert image into BitmapImage.
    * Can be called multiple times, real promise is cached inside.
    *
    * @returns {Promise<void>} cached promise to fill that bitmap
    */
    process() {
        if (this._process !== null) {
            return this._process;
        }
        if (this.bitmap !== null || !window.createImageBitmap) {
            return Promise.resolve(this);
        }
        this._process = window.createImageBitmap(this.source, 0, 0, this.source.width, this.source.height)
            .then((bitmap) => {
            if (this.destroyed) {
                return Promise.reject("");
            }
            this.bitmap = bitmap;
            this.update(0);
            this._process = null;
            return Promise.resolve(this);
        });
        return this._process;
    }
    ;
    /**
    * Upload the image resource to GPU.
    *
    * @param {PIXI.Renderer} renderer - Renderer to upload to
    * @param {PIXI.BaseTexture} baseTexture - BaseTexture for this resource
    * @param {PIXI.GLTexture} glTexture - GLTexture to use
    * @returns {boolean} true is success
    */
    upload(renderer, baseTexture, glTexture) {
        baseTexture.premultiplyAlpha = this.premultiplyAlpha;
        // reveal(this.bitmap)
        if (!this.createBitmap) {
            return super.upload(renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
            // yeah, ignore the output
            this.process();
            if (!this.bitmap) {
                return false;
            }
        }
        Logger_1.trace("uploading");
        super.upload(renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
            // checks if there are other renderers that possibly need this bitmap
            var flag = true;
            for (var key in baseTexture._glTextures) {
                var otherTex = baseTexture._glTextures[key];
                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                if (this.bitmap.close) {
                    this.bitmap.close();
                }
                Logger_1.trace("bitmap flagged");
                this.bitmap = null;
            }
        }
        return true;
    }
    ;
    /**
    * Destroys this texture
    * @override
    */
    dispose() {
        super.dispose();
        if (this.bitmap) {
            this.bitmap.close();
            this.bitmap = null;
        }
        this._process = null;
        this._load = null;
    }
    ;
}
exports.ImageResource = ImageResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionData.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionData.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
class InteractionData {
    constructor() {
        this.global = new Point_1.Point();
        this.target = null;
        this.originalEvent = null;
        this.identifier = null;
        this.isPrimary = false;
        this.button = 0;
        this.buttons = 0;
        this.width = 0;
        this.height = 0;
        this.tiltX = 0;
        this.tiltY = 0;
        this.pointerType = null;
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
        this.which = 0;
    }
    getLocalPosition(displayObject, point = null, globalPos = null) {
        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
    }
    ;
    copyEvent(event) {
        if (event.isPrimary) {
            this.isPrimary = true;
        }
        this.button = event.button;
        this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;
        this.width = event.width;
        this.height = event.height;
        this.tiltX = event.tiltX;
        this.tiltY = event.tiltY;
        this.pointerType = event.pointerType;
        this.pressure = event.pressure;
        this.rotationAngle = event.rotationAngle;
        this.twist = event.twist || 0;
        this.tangentialPressure = event.tangentialPressure || 0;
    }
    ;
    get pointerId() {
        return this.identifier;
    }
    ;
    reset() {
        this.isPrimary = false;
    }
    ;
}
exports.InteractionData = InteractionData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionEvent.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionEvent.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class InteractionEvent extends Event_1.Event {
    constructor(type, bubble = true, cancelable = true) {
        super(type, bubble, cancelable);
        this.target = null;
        this.stopped = false;
        this._currentTarget = null;
        this._type = null;
        this.data = null;
    }
    reset() {
        this.stopped = false;
        this._currentTarget = null;
        this.target = null;
    }
    ;
    stopPropagation() {
        this.stopped = true;
    }
    ;
}
exports.InteractionEvent = InteractionEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionManager.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionManager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const InteractionData_1 = __webpack_require__(/*! ./InteractionData */ "./js-compile/raw-pixi-ts/InteractionData.js");
const InteractionEvent_1 = __webpack_require__(/*! ./InteractionEvent */ "./js-compile/raw-pixi-ts/InteractionEvent.js");
const MouseEvent_1 = __webpack_require__(/*! ./MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const InteractionTrackingData_1 = __webpack_require__(/*! ./InteractionTrackingData */ "./js-compile/raw-pixi-ts/InteractionTrackingData.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
class InteractionManager extends EventDispatcher_1.EventDispatcher {
    constructor(renderer) {
        super();
        this.update = (deltaTime) => {
            this._deltaTime += deltaTime;
            if (this._deltaTime < this.interactionFrequency) {
                return;
            }
            this._deltaTime = 0;
            if (!this.interactionDOMElement) {
                return;
            }
            if (this.didMove) {
                this.didMove = false;
                return;
            }
            this.cursor = null;
            for (let k in this.activeInteractionData) {
                if (this.activeInteractionData.hasOwnProperty(k)) {
                    let interactionData = this.activeInteractionData[k];
                    if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {
                        let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
                        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true);
                    }
                }
            }
            this.setCursorMode(this.cursor);
        };
        this.onPointerUp = (event) => {
            if (this.supportsTouchEvents && event.pointerType === 'touch') {
                return;
            }
            this.onPointerComplete(event, false, this.processPointerUp);
        };
        this.onPointerCancel = (event) => {
            if (this.supportsTouchEvents && event.pointerType === 'touch') {
                return;
            }
            this.onPointerComplete(event, true, this.processPointerCancel);
        };
        this.onPointerOver = (originalEvent) => {
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = event;
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = true;
            }
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OVER);
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                this.dispatchEvent(pointer);
            }
        };
        this.onPointerOut = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = false;
                this.setCursorMode(null);
            }
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = event;
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OUT);
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
            }
            else {
                this.releaseInteractionDataForPointerId(interactionData.identifier);
            }
        };
        this.onPointerDown = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            if (this.autoPreventDefault && event.isNormalized) {
                let cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);
                if (cancelable) {
                    originalEvent.preventDefault();
                }
            }
            let eventLen = events.length;
            for (let i = 0; i < eventLen; i++) {
                let event = events[i];
                let interactionData = this.getInteractionDataForPointerId(event);
                let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                interactionEvent.data.originalEvent = originalEvent;
                let result = this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_DOWN);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                if (event.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_START);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
                else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    let isRightButton = event.button === 2;
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_DOWN : MouseEvent_1.MouseEvent.MOUSE_DOWN);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
            }
        };
        this.onPointerMove = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen') {
                this.didMove = true;
                this.cursor = null;
            }
            let eventLen = events.length;
            for (var i = 0; i < eventLen; i++) {
                let event = events[i];
                let interactionData = this.getInteractionDataForPointerId(event);
                let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                interactionEvent.data.originalEvent = originalEvent;
                let interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;
                this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, interactive);
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_MOVE);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                if (event.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_MOVE);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
                if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
            }
            if (events[0].pointerType === 'mouse') {
                this.setCursorMode(this.cursor);
            }
        };
        this.processPointerDown = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            if (hit) {
                if (!displayObject.trackedPointers[id]) {
                    displayObject.trackedPointers[id] = new InteractionTrackingData_1.InteractionTrackingData(id);
                }
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_DOWN);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (data.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_START);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {
                    let isRightButton = data.button === 2;
                    if (isRightButton) {
                        displayObject.trackedPointers[id].rightDown = true;
                    }
                    else {
                        displayObject.trackedPointers[id].leftDown = true;
                    }
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_DOWN : MouseEvent_1.MouseEvent.MOUSE_DOWN);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
        };
        this.processPointerUp = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            let trackingData = displayObject.trackedPointers[id];
            let isTouch = data.pointerType === 'touch';
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            let isMouseTap = false;
            if (isMouse) {
                let isRightButton = data.button === 2;
                let flags = InteractionTrackingData_1.InteractionTrackingData.FLAGS;
                let test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
                let isDown = trackingData !== undefined && (trackingData.flags & test);
                if (hit) {
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP : MouseEvent_1.MouseEvent.MOUSE_UP);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                    if (isDown) {
                        let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_CLICK : MouseEvent_1.MouseEvent.CLICK);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                        isMouseTap = true;
                    }
                }
                else if (isDown) {
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP_OUTSIDE : MouseEvent_1.MouseEvent.MOUSE_UP_OUTSIDE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData) {
                    if (isRightButton) {
                        trackingData.rightDown = false;
                    }
                    else {
                        trackingData.leftDown = false;
                    }
                }
            }
            if (hit) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_UP);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_END);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData) {
                    if (!isMouse || isMouseTap) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_TAP);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                    }
                    if (isTouch) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_TAP);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                        trackingData.over = false;
                    }
                }
            }
            else if (trackingData) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_END_OUTSIDE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
            if (trackingData && trackingData.none) {
                delete displayObject.trackedPointers[id];
            }
        };
        this.processPointerMove = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let isTouch = data.pointerType === 'touch';
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            if (isMouse) {
                this.processPointerOverOut(interactionEvent, displayObject, hit);
            }
            if (!this.moveWhenInside || hit) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_MOVE);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_MOVE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (isMouse) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
        };
        this.processPointerOverOut = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            let trackingData = displayObject.trackedPointers[id];
            if (hit && !trackingData) {
                trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData_1.InteractionTrackingData(id);
            }
            if (trackingData === undefined) {
                return;
            }
            if (hit && this.mouseOverRenderer) {
                if (!trackingData.over) {
                    trackingData.over = true;
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OVER);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                    if (isMouse) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                    }
                }
                if (isMouse && this.cursor === null) {
                    this.cursor = displayObject.cursor;
                }
            }
            else if (trackingData.over) {
                trackingData.over = false;
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OUT);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isMouse) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData.none) {
                    delete displayObject.trackedPointers[id];
                }
            }
        };
        this.hitTestEvent = new InteractionEvent_1.InteractionEvent(null, null, null);
        this.hitTestEvent.target = null;
        this.renderer = renderer;
        this.autoPreventDefault = true;
        this.interactionFrequency = 10;
        this.mouse = new InteractionData_1.InteractionData();
        this.mouse.identifier = InteractionManager.MOUSE_POINTER_ID;
        this.mouse.global.set(-999999);
        this.activeInteractionData = {};
        this.activeInteractionData[InteractionManager.MOUSE_POINTER_ID] = this.mouse;
        this.interactionDataPool = [];
        this.eventData = new InteractionEvent_1.InteractionEvent("interaction");
        this.interactionDOMElement = null;
        this.moveWhenInside = false;
        this.eventsAdded = false;
        this.mouseOverRenderer = false;
        this.supportsTouchEvents = 'ontouchstart' in window;
        this.supportsPointerEvents = !!window['PointerEvent'];
        this.cursorStyles = {
            default: 'inherit',
            pointer: 'pointer'
        };
        this.currentCursorMode = null;
        this.cursor = null;
        this._tempPoint = new Point_1.Point();
        this.resolution = 1;
        this.setTargetElement(this.renderer.view, this.renderer.resolution);
    }
    setTargetElement(element, resolution = 1) {
        this.removeEvents();
        this.interactionDOMElement = element;
        this.resolution = resolution;
        this.addEvents();
    }
    ;
    removeEvents() {
        if (!this.interactionDOMElement) {
            return;
        }
        Ticker_1.Ticker.system.remove(this.update);
        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = '';
            this.interactionDOMElement.style['-ms-touch-action'] = '';
        }
        else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = '';
        }
        if (this.supportsPointerEvents) {
            window.document.removeEventListener('pointermove', this.onPointerMove);
            this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut);
            this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver);
            window.removeEventListener('pointercancel', this.onPointerCancel);
            window.removeEventListener('pointerup', this.onPointerUp);
        }
        else {
            window.document.removeEventListener('mousemove', this.onPointerMove);
            this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut);
            this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver);
            window.removeEventListener('mouseup', this.onPointerUp);
        }
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel);
            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp);
            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove);
        }
        this.interactionDOMElement = null;
        this.eventsAdded = false;
    }
    ;
    mapPositionToPoint(point, x, y) {
        let rect;
        if (!this.interactionDOMElement.parentElement) {
            rect = new Rectangle_1.Rectangle();
        }
        else {
            rect = this.interactionDOMElement.getBoundingClientRect();
        }
        let resolutionMultiplier = 1.0 / this.resolution;
        point.x = ((x - rect.left) * (this.interactionDOMElement.width / rect.width)) * resolutionMultiplier;
        point.y = ((y - rect.top) * (this.interactionDOMElement.height / rect.height)) * resolutionMultiplier;
    }
    ;
    configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
        interactionEvent.data = interactionData;
        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
        if (pointerEvent.pointerType === 'touch') {
            pointerEvent.globalX = interactionData.global.x;
            pointerEvent.globalY = interactionData.global.y;
        }
        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();
        return interactionEvent;
    }
    ;
    addEvents() {
        if (!this.interactionDOMElement) {
            return;
        }
        Ticker_1.Ticker.system.add(this.update, this, Ticker_1.Ticker.UPDATE_PRIORITY.INTERACTION);
        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
            this.interactionDOMElement.style['-ms-touch-action'] = 'none';
        }
        else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = 'none';
        }
        if (this.supportsPointerEvents) {
            window.document.addEventListener('pointermove', this.onPointerMove);
            this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown);
            this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut);
            this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver);
            window.addEventListener('pointercancel', this.onPointerCancel);
            window.addEventListener('pointerup', this.onPointerUp);
        }
        else {
            window.document.addEventListener('mousemove', this.onPointerMove);
            this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown);
            this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut);
            this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver);
            window.addEventListener('mouseup', this.onPointerUp);
        }
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown);
            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel);
            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp);
            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove);
        }
        this.eventsAdded = true;
    }
    ;
    processInteractive(interactionEvent, displayObject, func, hitTest, interactive = true) {
        if (!displayObject || !displayObject.visible) {
            return false;
        }
        let point = interactionEvent.data.global;
        interactive = displayObject.interactive || interactive;
        let hit = false;
        let interactiveParent = interactive;
        let hitTestChildren = true;
        if (displayObject.hitArea) {
            if (hitTest) {
                displayObject.worldTransform.applyInverse(point, this._tempPoint);
                if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
                    hitTest = false;
                    hitTestChildren = false;
                }
                else {
                    hit = true;
                }
            }
            interactiveParent = false;
        }
        else if (displayObject._mask) {
            if (hitTest) {
                if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
                    hitTest = false;
                    hitTestChildren = false;
                }
            }
        }
        if (displayObject instanceof Container_1.Container) {
            if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
                let children = displayObject.children;
                for (let i = children.length - 1; i >= 0; i--) {
                    let child = children[i];
                    let childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);
                    if (childHit) {
                        if (!child.parent) {
                            continue;
                        }
                        interactiveParent = false;
                        if (childHit) {
                            if (interactionEvent.target) {
                                hitTest = false;
                            }
                            hit = true;
                        }
                    }
                }
            }
        }
        if (interactive) {
            if (hitTest && !interactionEvent.target) {
                if (!displayObject.hitArea && displayObject.containsPoint) {
                    if (displayObject.containsPoint(point)) {
                        hit = true;
                    }
                }
            }
            if (displayObject.interactive) {
                if (hit && !interactionEvent.target) {
                    interactionEvent.target = displayObject;
                }
                if (func) {
                    func(interactionEvent, displayObject, !!hit);
                }
            }
        }
        return hit;
    }
    ;
    setCursorMode(mode = "default") {
        if (this.currentCursorMode === mode) {
            return;
        }
        this.currentCursorMode = mode;
        let style = this.cursorStyles[mode];
        if (style) {
            switch (typeof style) {
                case 'string':
                    this.interactionDOMElement.style.cursor = style;
                    break;
                case 'function':
                    style(mode);
                    break;
                case 'object':
                    Object.assign(this.interactionDOMElement.style, style);
                    break;
            }
        }
        else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.interactionDOMElement.style.cursor = mode;
        }
    }
    ;
    hitTest(globalPoint, root) {
        this.hitTestEvent.target = null;
        this.hitTestEvent.data.global = globalPoint;
        let currentdisplay;
        if (root) {
            currentdisplay = root;
        }
        else {
            currentdisplay = this.renderer._lastObjectRendered;
        }
        this.processInteractive(this.hitTestEvent, currentdisplay, null, true);
        return this.hitTestEvent.target;
    }
    ;
    normalizeToPointerData(event) {
        let normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i = 0, li = event.changedTouches.length; i < li; i++) {
                let touch = event.changedTouches[i];
                if (typeof touch.button === 'undefined') {
                    touch.button = event.touches.length ? 1 : 0;
                }
                if (typeof touch.buttons === 'undefined') {
                    touch.buttons = event.touches.length ? 1 : 0;
                }
                if (typeof touch.isPrimary === 'undefined') {
                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                }
                if (typeof touch.width === 'undefined') {
                    touch.width = touch.radiusX || 1;
                }
                if (typeof touch.height === 'undefined') {
                    touch.height = touch.radiusY || 1;
                }
                if (typeof touch.tiltX === 'undefined') {
                    touch.tiltX = 0;
                }
                if (typeof touch.tiltY === 'undefined') {
                    touch.tiltY = 0;
                }
                if (typeof touch.pointerType === 'undefined') {
                    touch.pointerType = 'touch';
                }
                if (typeof touch.pointerId === 'undefined') {
                    touch.pointerId = touch.identifier || 0;
                }
                if (typeof touch.pressure === 'undefined') {
                    touch.pressure = touch.force || 0.5;
                }
                if (typeof touch.twist === 'undefined') {
                    touch.twist = 0;
                }
                if (typeof touch.tangentialPressure === 'undefined') {
                    touch.tangentialPressure = 0;
                }
                if (typeof touch.layerX === 'undefined') {
                    touch.layerX = touch.offsetX = touch.clientX;
                }
                if (typeof touch.layerY === 'undefined') {
                    touch.layerY = touch.offsetY = touch.clientY;
                }
                touch.isNormalized = true;
                normalizedEvents.push(touch);
            }
        }
        else if (event instanceof MouseEvent_1.MouseEvent && (!this.supportsPointerEvents || !(event instanceof window['PointerEvent']))) {
            let originevent = event;
            if (typeof originevent.isPrimary === 'undefined') {
                originevent.isPrimary = true;
            }
            if (typeof originevent.width === 'undefined') {
                originevent.width = 1;
            }
            if (typeof originevent.height === 'undefined') {
                originevent.height = 1;
            }
            if (typeof originevent.tiltX === 'undefined') {
                originevent.tiltX = 0;
            }
            if (typeof originevent.tiltY === 'undefined') {
                originevent.tiltY = 0;
            }
            if (typeof originevent.pointerType === 'undefined') {
                originevent.pointerType = 'mouse';
            }
            if (typeof originevent.pointerId === 'undefined') {
                originevent.pointerId = InteractionManager.MOUSE_POINTER_ID;
            }
            if (typeof originevent.pressure === 'undefined') {
                originevent.pressure = 0.5;
            }
            if (typeof originevent.twist === 'undefined') {
                originevent.twist = 0;
            }
            if (typeof originevent.tangentialPressure === 'undefined') {
                originevent.tangentialPressure = 0;
            }
            originevent.isNormalized = true;
            normalizedEvents.push(event);
        }
        else {
            normalizedEvents.push(event);
        }
        return normalizedEvents;
    }
    ;
    getInteractionDataForPointerId(event) {
        let pointerId = event.pointerId;
        let interactionData;
        if (pointerId === InteractionManager.MOUSE_POINTER_ID || event.pointerType === 'mouse') {
            interactionData = this.mouse;
        }
        else if (this.activeInteractionData[pointerId]) {
            interactionData = this.activeInteractionData[pointerId];
        }
        else {
            interactionData = this.interactionDataPool.pop() || new InteractionData_1.InteractionData();
            interactionData.identifier = pointerId;
            this.activeInteractionData[pointerId] = interactionData;
        }
        interactionData.copyEvent(event);
        return interactionData;
    }
    ;
    onPointerComplete(originalEvent, cancelled, func) {
        let events = this.normalizeToPointerData(originalEvent);
        let eventLen = events.length;
        let eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';
        for (let i = 0; i < eventLen; i++) {
            let event = events[i];
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = originalEvent;
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);
            let pointer = new MouseEvent_1.MouseEvent(cancelled ? MouseEvent_1.MouseEvent.POINTER_CANCEL : (MouseEvent_1.MouseEvent.POINTER_UP));
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let isRightButton = event.button === 2;
                let pointer = new MouseEvent_1.MouseEvent(isRightButton ? (MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP) : (MouseEvent_1.MouseEvent.MOUSE_UP));
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
            }
            else if (event.pointerType === 'touch') {
                let pointer = new MouseEvent_1.MouseEvent(cancelled ? MouseEvent_1.MouseEvent.TOUCH_CANCEL : (MouseEvent_1.MouseEvent.TOUCH_END));
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                this.releaseInteractionDataForPointerId(event.pointerId);
            }
        }
    }
    ;
    releaseInteractionDataForPointerId(pointerId) {
        let interactionData = this.activeInteractionData[pointerId];
        if (interactionData) {
            delete this.activeInteractionData[pointerId];
            interactionData.reset();
            this.interactionDataPool.push(interactionData);
        }
    }
    ;
    processPointerCancel(interactionEvent, displayObject) {
        let data = interactionEvent.data;
        let id = interactionEvent.data.identifier;
        if (displayObject.trackedPointers[id] !== undefined) {
            delete displayObject.trackedPointers[id];
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_CANCEL);
            pointer.data = data;
            displayObject.dispatchEvent(pointer);
            if (data.pointerType === 'touch') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_CANCEL);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
            }
        }
    }
    ;
    destroy(options = null) {
        this.removeEvents();
        this.renderer = null;
        this.mouse = null;
        this.eventData = null;
        this.interactionDOMElement = null;
        this.onPointerDown = null;
        this.processPointerDown = null;
        this.onPointerUp = null;
        this.processPointerUp = null;
        this.onPointerCancel = null;
        this.processPointerCancel = null;
        this.onPointerMove = null;
        this.processPointerMove = null;
        this.onPointerOut = null;
        this.processPointerOverOut = null;
        this.onPointerOver = null;
        this._tempPoint = null;
    }
    ;
}
InteractionManager.MOUSE_POINTER_ID = 1;
exports.InteractionManager = InteractionManager;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionTrackingData.js":
/*!***********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionTrackingData.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class InteractionTrackingData {
    constructor(pointerId) {
        this._pointerId = pointerId;
        this._flags = InteractionTrackingData.FLAGS.NONE;
    }
    _doSet(flag, yn) {
        if (yn) {
            this._flags = this._flags | flag;
        }
        else {
            this._flags = this._flags & (~flag);
        }
    }
    ;
    get pointerId() {
        return this._pointerId;
    }
    ;
    get flags() {
        return this._flags;
    }
    ;
    set flags(flags) {
        this._flags = flags;
    }
    ;
    get none() {
        return this._flags === InteractionTrackingData.FLAGS.NONE;
    }
    ;
    get over() {
        return (this._flags & InteractionTrackingData.FLAGS.OVER) !== 0;
    }
    ;
    set over(yn) {
        this._doSet(InteractionTrackingData.FLAGS.OVER, yn);
    }
    ;
    get rightDown() {
        return (this._flags & InteractionTrackingData.FLAGS.RIGHT_DOWN) !== 0;
    }
    ;
    set rightDown(yn) {
        this._doSet(InteractionTrackingData.FLAGS.RIGHT_DOWN, yn);
    }
    ;
    get leftDown() {
        return (this._flags & InteractionTrackingData.FLAGS.LEFT_DOWN) !== 0;
    }
    ;
    set leftDown(yn) {
        this._doSet(InteractionTrackingData.FLAGS.LEFT_DOWN, yn);
    }
    ;
}
InteractionTrackingData.FLAGS = {
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2,
};
exports.InteractionTrackingData = InteractionTrackingData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/LineStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/LineStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FillStyle_1 = __webpack_require__(/*! ./FillStyle */ "./js-compile/raw-pixi-ts/FillStyle.js");
class LineStyle extends FillStyle_1.FillStyle {
    constructor() {
        super();
    }
    clone() {
        var obj = new LineStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        return obj;
    }
    ;
    /**
     * Reset the line style to default.
     */
    reset() {
        super.reset();
        // Override default line style color
        this.color = 0x0;
        /**
         * The width (thickness) of any lines drawn.
         *
         * @member {number}
         * @default 0
         */
        this.width = 0;
        /**
         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
         *
         * @member {number}
         * @default 0
         */
        this.alignment = 0.5;
        /**
         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         *
         * @member {boolean}
         * @default false
         */
        this.native = false;
    }
    ;
}
exports.LineStyle = LineStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Logger.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Logger.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OUTPUT_TO_CONSOLE = true;
exports.trace = function (value) {
    try {
        if (!value) {
            if (isNaN(value)) {
                var result = "show: null";
            }
            else {
                var result = "show: 0";
            }
        }
        else {
            var result = "show: " + value.toString();
        }
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return result;
    }
    catch (e) {
    }
    return null;
};
exports.revealMethods = function (value) {
    try {
        if (!value) {
            var result = "reveal methods: null";
        }
        else {
            var result = "reveal methods: ";
        }
        for (var key in value) {
            var instanceItem = value[key];
            if (instanceItem instanceof Function) {
                result += 'method: ' + key + ' : ' + value[key] + "\n";
            }
        }
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return result;
    }
    catch (e) {
    }
    return null;
};
exports.reveal = function (value) {
    if (!value) {
        var result = "reveal: null";
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return;
    }
    if (value === undefined) {
        var result = "reveal: undefined";
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return;
    }
    var result = "reveal: ";
    for (var key in value) {
        var instanceItem = getValue(key, value);
        if (instanceItem) {
            if (instanceItem instanceof Function) {
                result += 'method: ' + key + "\n";
            }
            else {
                try {
                    result += key + ' : ' + instanceItem + "\n";
                }
                catch (e) {
                }
            }
        }
    }
    if (exports.OUTPUT_TO_CONSOLE) {
        console.log(result);
    }
    return result;
};
const getValue = function (key, value) {
    var valueResult = null;
    try {
        valueResult = value[key];
    }
    catch (e) {
    }
    return valueResult;
};


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MaskSystem.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/MaskSystem.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const SpriteMaskFilter_1 = __webpack_require__(/*! ./SpriteMaskFilter */ "./js-compile/raw-pixi-ts/SpriteMaskFilter.js");
class MaskSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // TODO - we don't need both!
        /**
         * `true` if current pushed masked is scissor
         * @member {boolean}
         * @readonly
         */
        this.scissor = false;
        /**
         * Mask data
         * @member {PIXI.Graphics}
         * @readonly
         */
        this.scissorData = null;
        /**
         * Target to mask
         * @member {PIXI.DisplayObject}
         * @readonly
         */
        this.scissorRenderTarget = null;
        /**
         * Enable scissor
         * @member {boolean}
         * @readonly
         */
        this.enableScissor = false;
        /**
         * Pool of used sprite mask filters
         * @member {PIXI.SpriteMaskFilter[]}
         * @readonly
         */
        this.alphaMaskPool = [];
        /**
         * Current index of alpha mask pool
         * @member {number}
         * @default 0
         * @readonly
         */
        this.alphaMaskIndex = 0;
    }
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    push(target, maskData) {
        // TODO the root check means scissor rect will not
        // be used on render textures more info here:
        // https://github.com/pixijs/pixi.js/pull/3545
        if (maskData.isSprite) {
            this.pushSpriteMask(target, maskData);
        }
        else if (this.enableScissor
            && !this.scissor
            && this.renderer._activeRenderTarget.root
            && !this.renderer.stencil.stencilMaskStack.length
            && maskData.isFastRect()) {
            var matrix = maskData.worldTransform;
            var rot = Math.atan2(matrix.b, matrix.a);
            // use the nearest degree!
            rot = Math.round(rot * (180 / Math.PI));
            if (rot % 90) {
                this.pushStencilMask(maskData);
            }
            else {
                this.pushScissorMask(target, maskData);
            }
        }
        else {
            this.pushStencilMask(maskData);
        }
    }
    ;
    /**
     * Removes the last mask from the mask stack and doesn't return it.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    pop(target, maskData) {
        if (maskData.isSprite) {
            this.popSpriteMask(target, maskData);
        }
        else if (this.enableScissor && !this.renderer.stencil.stencilMaskStack.length) {
            this.popScissorMask(target, maskData);
        }
        else {
            this.popStencilMask(target, maskData);
        }
    }
    ;
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.RenderTexture} target - Display Object to push the sprite mask to
     * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
     */
    pushSpriteMask(target, maskData) {
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter_1.SpriteMaskFilter(maskData)];
        }
        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskData;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskData.getBounds(true);
        this.renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        this.alphaMaskIndex++;
    }
    ;
    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    popSpriteMask(a, b) {
        this.renderer.filter.pop();
        this.alphaMaskIndex--;
    }
    ;
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    pushStencilMask(maskData) {
        this.renderer.batch.flush();
        this.renderer.stencil.pushStencil(maskData);
    }
    ;
    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    popStencilMask(a, b) {
        // this.renderer.currentRenderer.stop();
        this.renderer.stencil.popStencil();
    }
    ;
    /**
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Graphics} maskData - The masking data.
     */
    pushScissorMask(target, maskData) {
        maskData.renderable = true;
        var renderTarget = this.renderer._activeRenderTarget;
        var bounds = maskData.getBounds();
        bounds.fit(renderTarget.size);
        maskData.renderable = false;
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
        var resolution = this.renderer.resolution;
        this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);
        this.scissorRenderTarget = renderTarget;
        this.scissorData = maskData;
        this.scissor = true;
    }
    ;
    /**
     * Pop scissor mask
     *
     */
    popScissorMask(a, b) {
        this.scissorRenderTarget = null;
        this.scissorData = null;
        this.scissor = false;
        // must be scissor!
        var ref = this.renderer;
        var gl = ref.gl;
        gl.disable(gl.SCISSOR_TEST);
    }
    ;
}
exports.MaskSystem = MaskSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MathSettings.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MathSettings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MathSettings {
    static uid() {
        return ++MathSettings.nextUid;
    }
    static sign(n) {
        if (n === 0) {
            return 0;
        }
        return n < 0 ? -1 : 1;
    }
    static string2hex(string) {
        if (typeof string === 'string' && string[0] === '#') {
            string = string.substr(1);
        }
        return parseInt(string, 16);
    }
    static hex2string(hex) {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;
        return ("#" + hex);
    }
    static log2(v) {
        var r = (v > 0xFFFF) << 4;
        v >>>= r;
        var shift = (v > 0xFF) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 0xF) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 0x3) << 1;
        v >>>= shift;
        r |= shift;
        return r | (v >> 1);
    }
    static nextPow2(v) {
        v += v === 0;
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
    }
    static isPow2(v) {
        return !(v & (v - 1)) && (!!v);
    }
}
MathSettings.nextUid = 0;
MathSettings.PI_2 = Math.PI * 2;
MathSettings.RAD_TO_DEG = 180 / Math.PI;
MathSettings.DEG_TO_RAD = Math.PI / 180;
exports.MathSettings = MathSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Matrix.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Matrix.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class Matrix {
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
        if (a === void 0) {
            a = 1;
        }
        if (b === void 0) {
            b = 0;
        }
        if (c === void 0) {
            c = 0;
        }
        if (d === void 0) {
            d = 1;
        }
        if (tx === void 0) {
            tx = 0;
        }
        if (ty === void 0) {
            ty = 0;
        }
        /**
         * @member {number}
         * @default 1
         */
        this.a = a;
        /**
         * @member {number}
         * @default 0
         */
        this.b = b;
        /**
         * @member {number}
         * @default 0
         */
        this.c = c;
        /**
         * @member {number}
         * @default 1
         */
        this.d = d;
        /**
         * @member {number}
         * @default 0
         */
        this.tx = tx;
        /**
         * @member {number}
         * @default 0
         */
        this.ty = ty;
        this.array = null;
    }
    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */
    fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    }
    ;
    /**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    set(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
    }
    ;
    /**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */
    toArray(transpose, out = null) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        }
        else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }
        return array;
    }
    ;
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, transformed through this matrix
     */
    apply(pos, newPos) {
        newPos = newPos || new Point_1.Point();
        var x = pos.x;
        var y = pos.y;
        newPos.x = (this.a * x) + (this.c * y) + this.tx;
        newPos.y = (this.b * x) + (this.d * y) + this.ty;
        return newPos;
    }
    ;
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, inverse-transformed through this matrix
     */
    applyInverse(pos, newPos) {
        newPos = newPos || new Point_1.Point();
        var id = 1 / ((this.a * this.d) + (this.c * -this.b));
        var x = pos.x;
        var y = pos.y;
        newPos.x = (this.d * id * x) + (-this.c * id * y) + (((this.ty * this.c) - (this.tx * this.d)) * id);
        newPos.y = (this.a * id * y) + (-this.b * id * x) + (((-this.ty * this.a) + (this.tx * this.b)) * id);
        return newPos;
    }
    ;
    /**
     * Translates the matrix on the x and y.
     *
     * @param {number} x How much to translate x by
     * @param {number} y How much to translate y by
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    translate(x, y) {
        this.tx += x;
        this.ty += y;
        return this;
    }
    ;
    /**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x The amount to scale horizontally
     * @param {number} y The amount to scale vertically
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    scale(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
    }
    ;
    /**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    rotate(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = (a1 * cos) - (this.b * sin);
        this.b = (a1 * sin) + (this.b * cos);
        this.c = (c1 * cos) - (this.d * sin);
        this.d = (c1 * sin) + (this.d * cos);
        this.tx = (tx1 * cos) - (this.ty * sin);
        this.ty = (tx1 * sin) + (this.ty * cos);
        return this;
    }
    ;
    /**
     * Appends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to append.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    append(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = (matrix.a * a1) + (matrix.b * c1);
        this.b = (matrix.a * b1) + (matrix.b * d1);
        this.c = (matrix.c * a1) + (matrix.d * c1);
        this.d = (matrix.c * b1) + (matrix.d * d1);
        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;
        return this;
    }
    ;
    /**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));
        return this;
    }
    ;
    /**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to prepend
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    prepend(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            var a1 = this.a;
            var c1 = this.c;
            this.a = (a1 * matrix.a) + (this.b * matrix.c);
            this.b = (a1 * matrix.b) + (this.b * matrix.d);
            this.c = (c1 * matrix.a) + (this.d * matrix.c);
            this.d = (c1 * matrix.b) + (this.d * matrix.d);
        }
        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;
        return this;
    }
    ;
    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {PIXI.Transform} transform - The transform to apply the properties to.
     * @return {PIXI.Transform} The transform with the newly applied properties
     */
    decompose(transform) {
        // sort out rotation / skew..
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);
        var delta = Math.abs(skewX + skewY);
        if (delta < 0.00001 || Math.abs(MathSettings_1.MathSettings.PI_2 - delta) < 0.00001) {
            transform.rotation = skewY;
            transform.skew.x = transform.skew.y = 0;
        }
        else {
            transform.rotation = 0;
            transform.skew.x = skewX;
            transform.skew.y = skewY;
        }
        // next set scale
        transform.scale.x = Math.sqrt((a * a) + (b * b));
        transform.scale.y = Math.sqrt((c * c) + (d * d));
        // next set position
        transform.position.x = this.tx;
        transform.position.y = this.ty;
        return transform;
    }
    ;
    /**
     * Inverts this matrix
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    invert() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = (a1 * d1) - (b1 * c1);
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;
        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;
        return this;
    }
    ;
    /**
     * Resets this Matrix to an identity (default) matrix.
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
    }
    ;
    /**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
     */
    clone() {
        var matrix = new Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    ;
    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy to.
     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
     */
    copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    ;
    /**
     * Changes the values of the matrix to be the same as the ones in given matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy from.
     * @return {PIXI.Matrix} this
     */
    copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
    }
    ;
    /**
     * A default (identity) matrix
     *
     * @static
     * @const
     * @member {PIXI.Matrix}
     */
    static get IDENTITY() {
        return new Matrix();
    }
    ;
    /**
     * A temp matrix
     *
     * @static
     * @const
     * @member {PIXI.Matrix}
     */
    static get TEMP_MATRIX() {
        return new Matrix();
    }
    ;
}
exports.Matrix = Matrix;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Mesh.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Mesh.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const MeshBatchUvs_1 = __webpack_require__(/*! ./MeshBatchUvs */ "./js-compile/raw-pixi-ts/MeshBatchUvs.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class Mesh extends Container_1.Container {
    constructor(geometry, shader, state = null, drawMode = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES) {
        super();
        this.interactive = false;
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh objects.
         * @member {PIXI.Geometry}
         * @readonly
         */
        this.geometry = geometry;
        geometry.refCount++;
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Mesh objects.
         * @member {PIXI.Shader|PIXI.MeshMaterial}
         */
        this.shader = shader;
        /**
         * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = state || State_1.State.for2d();
        /**
         * The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants.
         *
         * @member {number}
         * @see PIXI.DRAW_MODES
         */
        this.drawMode = drawMode;
        /**
         * Typically the index of the IndexBuffer where to start drawing.
         * @member {number}
         * @default 0
         */
        this.start = 0;
        /**
         * How much of the geometry to draw, by default `0` renders everything.
         * @member {number}
         * @default 0
         */
        this.size = 0;
        /**
         * thease are used as easy access for batching
         * @member {Float32Array}
         * @private
         */
        this.uvs = null;
        /**
         * thease are used as easy access for batching
         * @member {Uint16Array}
         * @private
         */
        this.indices = null;
        /**
         * this is the caching layer used by the batcher
         * @member {Float32Array}
         * @private
         */
        this.vertexData = new Float32Array(1);
        /**
         * If geometry is changed used to decide to re-transform
         * the vertexData.
         * @member {number}
         * @private
         */
        this.vertexDirty = 0;
        this._transformID = -1;
        // Inherited from DisplayMode, set defaults
        this.tint = 0xFFFFFF;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
        /**
         * Batched UV's are cached for atlas textures
         * @member {PIXI.MeshBatchUvs}
         * @private
         */
        this.batchUvs = null;
    }
    /**
     * To change mesh uv's, change its uvBuffer data and increment its _updateID.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get uvBuffer() {
        return this.geometry.buffers[1].data;
    }
    ;
    /**
     * To change mesh vertices, change its uvBuffer data and increment its _updateID.
     * Incrementing _updateID is optional because most of Mesh objects do it anyway.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get verticesBuffer() {
        return this.geometry.buffers[0].data;
    }
    ;
    /**
     * Alias for {@link PIXI.Mesh#shader}.
     * @member {PIXI.Shader|PIXI.MeshMaterial}
     */
    set material(value) {
        this.shader = value;
    }
    ;
    get material() {
        return this.shader;
    }
    ;
    /**
     * The blend mode to be applied to the Mesh. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set roundPixels(value) {
        if (this._roundPixels !== value) {
            this._transformID = -1;
        }
        this._roundPixels = value;
    }
    ;
    get roundPixels() {
        return this._roundPixels;
    }
    ;
    /**
     * The multiply tint applied to the Mesh. This is a hex value. A value of
     * `0xFFFFFF` will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this.shader.tint;
    }
    ;
    set tint(value) {
        this.shader.tint = value;
    }
    ;
    /**
     * The texture that the Mesh uses.
     *
     * @member {PIXI.Texture}
     */
    get texture() {
        return this.shader.texture;
    }
    ;
    set texture(value) {
        this.shader.texture = value;
    }
    ;
    /**
     * Standard renderer draw.
     * @protected
     */
    _render(renderer) {
        // set properties for batching..
        // TODO could use a different way to grab verts?
        var vertices = this.geometry.buffers[0].data;
        // TODO benchmark check for attribute size..
        if (this.shader.batchable && this.drawMode === DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES && vertices.length < Mesh.BATCHABLE_SIZE * 2) {
            this._renderToBatch(renderer);
        }
        else {
            this._renderDefault(renderer);
        }
    }
    ;
    /**
     * Standard non-batching way of rendering.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    _renderDefault(renderer) {
        var shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
            shader.update();
        }
        renderer.batch.flush();
        if (shader.program.uniformData.translationMatrix) {
            shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        }
        // bind and sync uniforms..
        renderer.shader.bind(shader);
        // set state..
        renderer.state.setState(this.state);
        // bind the geometry...
        renderer.geometry.bind(this.geometry, shader);
        // then render it
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }
    ;
    /**
     * Rendering by using the Batch system.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    _renderToBatch(renderer) {
        var geometry = this.geometry;
        if (this.shader.uvMatrix) {
            this.shader.uvMatrix.update();
            this.calculateUvs();
        }
        // set properties for batching..
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = this.shader._tintRGB;
        this._texture = this.shader.texture;
        var pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
    }
    ;
    /**
     * Updates vertexData field based on transform and vertices
     */
    calculateVertices() {
        var geometry = this.geometry;
        var vertices = geometry.buffers[0].data;
        if (geometry.vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
            return;
        }
        this._transformID = this.transform._worldID;
        if (this.vertexData.length !== vertices.length) {
            this.vertexData = new Float32Array(vertices.length);
        }
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        for (var i = 0; i < vertexData.length / 2; i++) {
            var x = vertices[(i * 2)];
            var y = vertices[(i * 2) + 1];
            vertexData[(i * 2)] = (a * x) + (c * y) + tx;
            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;
        }
        if (this._roundPixels) {
            for (var i$1 = 0; i$1 < vertexData.length; i$1++) {
                vertexData[i$1] = Math.round(vertexData[i$1]);
            }
        }
        this.vertexDirty = geometry.vertexDirtyId;
    }
    ;
    /**
     * Updates uv field based on from geometry uv's or batchUvs
     */
    calculateUvs() {
        var geomUvs = this.geometry.buffers[1];
        if (!this.shader.uvMatrix.isSimple) {
            if (!this.batchUvs) {
                this.batchUvs = new MeshBatchUvs_1.MeshBatchUvs(geomUvs, this.shader.uvMatrix);
            }
            this.batchUvs.update();
            this.uvs = this.batchUvs.data;
        }
        else {
            this.uvs = geomUvs.data;
        }
    }
    ;
    /**
     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.
     *
     * @protected
     */
    _calculateBounds() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }
    ;
    /**
     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.
     *
     * @param {PIXI.Point} point the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        if (!this.interactive) {
            return false;
        }
        if (!this.getBounds().contains(point.x, point.y)) {
            return false;
        }
        this.worldTransform.applyInverse(point, Mesh.tempPoint$2);
        var vertices = this.geometry.getAttribute('aVertexPosition').data;
        var points = Mesh.tempPolygon.points;
        var indices = this.geometry.getIndex().data;
        var len = indices.length;
        var step = this.drawMode === 4 ? 3 : 1;
        for (var i = 0; i + 2 < len; i += step) {
            var ind0 = indices[i] * 2;
            var ind1 = indices[i + 1] * 2;
            var ind2 = indices[i + 2] * 2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];
            if (Mesh.tempPolygon.contains(Mesh.tempPoint$2.x, Mesh.tempPoint$2.y)) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys the Mesh object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     */
    destroy(options) {
        super.destroy(options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
            this.geometry.dispose();
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
    }
    ;
}
Mesh.tempPolygon = new Polygon_1.Polygon();
Mesh.tempPoint$2 = new Point_1.Point();
/**
 * The maximum number of vertices to consider batchable. Generally, the complexity
 * of the geometry.
 * @memberof PIXI.Mesh
 * @static
 * @member {number} BATCHABLE_SIZE
 */
Mesh.BATCHABLE_SIZE = 100;
exports.Mesh = Mesh;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshBatchUvs.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshBatchUvs.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MeshBatchUvs {
    constructor(uvBuffer, uvMatrix) {
        /**
                 * Buffer with normalized UV's
                 * @member {PIXI.Buffer}
                 */
        this.uvBuffer = uvBuffer;
        /**
         * Material UV matrix
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = uvMatrix;
        /**
         * UV Buffer data
         * @member {Float32Array}
         * @readonly
         */
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
    }
    /**
     * updates
     *
     * @param {boolean} forceUpdate - force the update
     */
    update(forceUpdate) {
        if (!forceUpdate
            && this._bufferUpdateId === this.uvBuffer._updateID
            && this._textureUpdateId === this.uvMatrix._updateID) {
            return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        var data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
            this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
    }
    ;
}
exports.MeshBatchUvs = MeshBatchUvs;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshGeometry.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshGeometry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class MeshGeometry extends Geometry_1.Geometry {
    constructor(vertices = null, uvs = null, index = null) {
        super();
        var verticesBuffer = new Buffer_1.Buffer(vertices);
        var uvsBuffer = new Buffer_1.Buffer(uvs, true);
        var indexBuffer = new Buffer_1.Buffer(index, true, true);
        this.addAttribute('aVertexPosition', verticesBuffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aTextureCoord', uvsBuffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addIndex(indexBuffer);
        /**
         * Dirty flag to limit update calls on Mesh. For example,
         * limiting updates on a single Mesh instance with a shared Geometry
         * within the render loop.
         * @private
         * @member {number}
         * @default -1
         */
        this._updateId = -1;
    }
    /**
     * If the vertex position is updated.
     * @member {number}
     * @readonly
     * @private
     */
    get vertexDirtyId() {
        return this.buffers[0]._updateID;
    }
    ;
}
exports.MeshGeometry = MeshGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshMaterial.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshMaterial.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class MeshMaterial extends Shader_1.Shader {
    constructor(uSampler, options = null) {
        var uniforms = {
            uSampler: uSampler,
            alpha: 1,
            uTextureMatrix: Matrix_1.Matrix.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1]),
        };
        // Set defaults
        options = Object.assign({
            tint: 0xFFFFFF,
            alpha: 1,
            pluginName: 'batch',
        }, options);
        if (options.uniforms) {
            Object.assign(uniforms, options.uniforms);
        }
        super(options.program || Program_1.Program.from(MeshMaterial.vertex$6, MeshMaterial.fragment$8), uniforms);
        /**
         * Only do update if tint or alpha changes.
         * @member {boolean}
         * @private
         * @default false
         */
        this._colorDirty = false;
        /**
         * TextureMatrix instance for this Mesh, used to track Texture changes
         *
         * @member {PIXI.TextureMatrix}
         * @readonly
         */
        this.uvMatrix = new TextureMatrix_1.TextureMatrix(uSampler);
        /**
         * `true` if shader can be batch with the renderer's batch system.
         * @member {boolean}
         * @default true
         */
        this.batchable = options.program === undefined;
        /**
         * Renderer plugin for batching
         *
         * @member {string}
         * @default 'batch'
         */
        this.pluginName = options.pluginName;
        this.tint = options.tint;
        this.alpha = options.alpha;
    }
    /**
     * Reference to the texture being rendered.
     * @member {PIXI.Texture}
     */
    get texture() {
        return this.uniforms.uSampler;
    }
    ;
    set texture(value) {
        if (this.uniforms.uSampler !== value) {
            this.uniforms.uSampler = value;
            this.uvMatrix.texture = value;
        }
    }
    ;
    /**
     * This gets automatically set by the object using this.
     *
     * @default 1
     * @member {number}
     */
    set alpha(value) {
        if (value === this._alpha) {
            return;
        }
        this._alpha = value;
        this._colorDirty = true;
    }
    ;
    get alpha() {
        return this._alpha;
    }
    ;
    /**
     * Multiply tint for the material.
     * @member {number}
     * @default 0xFFFFFF
     */
    set tint(value) {
        if (value === this._tint) {
            return;
        }
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
        this._colorDirty = true;
    }
    ;
    get tint() {
        return this._tint;
    }
    ;
    /**
     * Gets called automatically by the Mesh. Intended to be overridden for custom
     * MeshMaterial objects.
     */
    update() {
        if (this._colorDirty) {
            this._colorDirty = false;
            var baseTexture = this.texture.baseTexture;
            ColorSettings_1.ColorSettings.premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.premultiplyAlpha);
        }
        if (this.uvMatrix.update()) {
            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
    }
    ;
}
MeshMaterial.vertex$6 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
MeshMaterial.fragment$8 = "varying vec2 vTextureCoord;\r\nuniform vec4 uColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\r\n}\r\n";
exports.MeshMaterial = MeshMaterial;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MouseEvent.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/MouseEvent.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class MouseEvent extends Event_1.Event {
    constructor(type, bubbles = false) {
        super(type, bubbles);
        this.movementX = 0;
        this.movementY = 0;
    }
}
MouseEvent.CLICK = "click";
MouseEvent.MOUSE_DOWN = "mouseDown";
MouseEvent.MOUSE_UP = "mouseUp";
MouseEvent.MIDDLE_CLICK = "middleClick";
MouseEvent.MIDDLE_MOUSE_DOWN = "middleMouseDown";
MouseEvent.MIDDLE_MOUSE_UP = "middleMouseUp";
MouseEvent.RIGHT_CLICK = "rightClick";
MouseEvent.RIGHT_MOUSE_DOWN = "rightMouseDown";
MouseEvent.RIGHT_MOUSE_UP = "rightMouseUp";
MouseEvent.MOUSE_MOVE = "mouseMove";
MouseEvent.MOUSE_OVER = "mouseOver";
MouseEvent.MOUSE_OUT = "mouseOut";
MouseEvent.RIGHT_MOUSE_UP_OUTSIDE = "rightupoutside";
MouseEvent.MOUSE_UP_OUTSIDE = "mouseupoutside";
MouseEvent.POINTER_OVER = "pointerover";
MouseEvent.POINTER_ENTER = "pointerenter";
MouseEvent.POINTER_DOWN = "pointerdown";
MouseEvent.POINTER_MOVE = "pointermove";
MouseEvent.POINTER_UP = "pointerup";
MouseEvent.POINTER_CANCEL = "pointercancel";
MouseEvent.POINTER_OUT = "pointerout";
MouseEvent.POINTER_LEAVE = "pointerleave";
MouseEvent.POINTER_CAPTURE = "gotpointercapture";
MouseEvent.POINTER_LOST = "lostpointercapture";
MouseEvent.POINTER_UP_OUTSIDE = "pointerupoutside";
MouseEvent.POINTER_TAP = "pointertap";
MouseEvent.TOUCH_START = "touchstart";
MouseEvent.TOUCH_END = "touchend";
MouseEvent.TOUCH_END_OUTSIDE = "touchendoutside";
MouseEvent.TOUCH_MOVE = "touchmove";
MouseEvent.TOUCH_CANCEL = "touchcancel";
MouseEvent.TOUCH_TAP = "tap";
exports.MouseEvent = MouseEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/NetworkSettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/NetworkSettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Url_1 = __webpack_require__(/*! ./Url */ "./js-compile/raw-pixi-ts/Url.js");
class NetworkSettings {
    static getResolutionOfUrl(url, defaultValue = null) {
        var resolution = NetworkSettings.RETINA_PREFIX.exec(url);
        if (resolution) {
            return parseFloat(resolution[1]);
        }
        return defaultValue !== undefined ? defaultValue : 1;
    }
    static determineCrossOrigin(url$1, loc = null) {
        if (loc === void 0) {
            loc = window.location;
        }
        if (url$1.indexOf('data:') === 0) {
            return '';
        }
        loc = loc || window.location;
        if (!NetworkSettings.tempAnchor) {
            NetworkSettings.tempAnchor = document.createElement('a');
        }
        NetworkSettings.tempAnchor.href = url$1;
        url$1 = NetworkSettings.url.parse(NetworkSettings.tempAnchor.href);
        var samePort = (!url$1.port && loc.port === '') || (url$1.port === loc.port);
        if (url$1.hostname !== loc.hostname || !samePort || url$1.protocol !== loc.protocol) {
            return 'anonymous';
        }
        return '';
    }
}
NetworkSettings.RETINA_PREFIX = /@([0-9\.]+)x/;
NetworkSettings.url = {
    parse: Url_1.Url.urlParse,
    resolve: Url_1.Url.urlResolve,
    resolveObject: Url_1.Url.urlResolveObject,
    format: Url_1.Url.urlFormat,
    Url: Url_1.Url
};
exports.NetworkSettings = NetworkSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ObjectRenderer.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ObjectRenderer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
class ObjectRenderer extends System_1.System {
    constructor(renderer) {
        super(renderer);
    }
    start() {
        // set the shader..
    }
    ;
    /**
     * Stops the renderer
     *
     */
    stop() {
        this.flush();
    }
    ;
    /**
     * Stub method for rendering content and emptying the current batch.
     *
     */
    flush() {
        // flush!
    }
    ;
    /**
     * Renders an object
     *
     * @param {PIXI.DisplayObject} object - The object to render.
     */
    render(object) {
        // render the object
    }
    ;
}
exports.ObjectRenderer = ObjectRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ObservablePoint.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ObservablePoint.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ObservablePoint {
    constructor(cb, scope, x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        this._x = x;
        this._y = y;
        this.cb = cb;
        this.scope = scope;
    }
    /**
     * Creates a clone of this point.
     * The callback and scope params can be overidden otherwise they will default
     * to the clone object's values.
     *
     * @override
     * @param {Function} [cb=null] - callback when changed
     * @param {object} [scope=null] - owner of callback
     * @return {PIXI.ObservablePoint} a copy of the point
     */
    clone(cb, scope) {
        if (cb === void 0) {
            cb = null;
        }
        if (scope === void 0) {
            scope = null;
        }
        var _cb = cb || this.cb;
        var _scope = scope || this.scope;
        return new ObservablePoint(_cb, _scope, this._x, this._y);
    }
    ;
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    set(x, y) {
        var _x = x || 0;
        var _y = y || ((y !== 0) ? _x : 0);
        if (this._x !== _x || this._y !== _y) {
            this._x = _x;
            this._y = _y;
            this.cb.call(this.scope);
        }
    }
    ;
    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPoint} p - The point to copy from.
     * @returns {PIXI.IPoint} Returns itself.
     */
    copyFrom(p) {
        if (this._x !== p.x || this._y !== p.y) {
            this._x = p.x;
            this._y = p.y;
            this.cb.call(this.scope);
        }
        return this;
    }
    ;
    /**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */
    copyTo(p) {
        p.set(this._x, this._y);
        return p;
    }
    ;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p) {
        return (p.x === this._x) && (p.y === this._y);
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */
    get x() {
        return this._x;
    }
    ;
    set x(value) {
        if (this._x !== value) {
            this._x = value;
            this.cb.call(this.scope);
        }
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */
    get y() {
        return this._y;
    }
    ;
    set y(value) {
        if (this._y !== value) {
            this._y = value;
            this.cb.call(this.scope);
        }
    }
    ;
}
exports.ObservablePoint = ObservablePoint;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleBuffer.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ParticleBuffer {
    constructor(properties, dynamicPropertyFlags, size) {
        this.geometry = new Geometry_1.Geometry();
        this.indexBuffer = null;
        /**
         * The number of particles the buffer can hold
         *
         * @private
         * @member {number}
         */
        this.size = size;
        /**
         * A list of the properties that are dynamic.
         *
         * @private
         * @member {object[]}
         */
        this.dynamicProperties = [];
        /**
         * A list of the properties that are static.
         *
         * @private
         * @member {object[]}
         */
        this.staticProperties = [];
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            // Make copy of properties object so that when we edit the offset it doesn't
            // change all other instances of the object literal
            property = {
                attributeName: property.attributeName,
                size: property.size,
                uploadFunction: property.uploadFunction,
                type: property.type || WebGLSettings_1.WebGLSettings.TYPES.FLOAT,
                offset: property.offset,
            };
            if (dynamicPropertyFlags[i]) {
                this.dynamicProperties.push(property);
            }
            else {
                this.staticProperties.push(property);
            }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this._updateID = 0;
        this.initBuffers();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */
    initBuffers() {
        var geometry = this.geometry;
        var dynamicOffset = 0;
        /**
         * Holds the indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         * @private
         */
        this.indexBuffer = new Buffer_1.Buffer(WebGLSettings_1.WebGLSettings.createIndicesForQuads(this.size), true, true);
        geometry.addIndex(this.indexBuffer);
        this.dynamicStride = 0;
        for (var i = 0; i < this.dynamicProperties.length; ++i) {
            var property = this.dynamicProperties[i];
            property.offset = dynamicOffset;
            dynamicOffset += property.size;
            this.dynamicStride += property.size;
        }
        var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = new Buffer_1.Buffer(this.dynamicData, false, false);
        // static //
        var staticOffset = 0;
        this.staticStride = 0;
        for (var i$1 = 0; i$1 < this.staticProperties.length; ++i$1) {
            var property$1 = this.staticProperties[i$1];
            property$1.offset = staticOffset;
            staticOffset += property$1.size;
            this.staticStride += property$1.size;
        }
        var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = new Buffer_1.Buffer(this.staticData, true, false);
        for (var i$2 = 0; i$2 < this.dynamicProperties.length; ++i$2) {
            var property$2 = this.dynamicProperties[i$2];
            geometry.addAttribute(property$2.attributeName, this.dynamicBuffer, 0, property$2.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE, property$2.type, this.dynamicStride * 4, property$2.offset * 4);
        }
        for (var i$3 = 0; i$3 < this.staticProperties.length; ++i$3) {
            var property$3 = this.staticProperties[i$3];
            geometry.addAttribute(property$3.attributeName, this.staticBuffer, 0, property$3.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE, property$3.type, this.staticStride * 4, property$3.offset * 4);
        }
    }
    ;
    /**
     * Uploads the dynamic properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */
    uploadDynamic(children, startIndex, amount) {
        for (var i = 0; i < this.dynamicProperties.length; i++) {
            var property = this.dynamicProperties[i];
            property.uploadFunction(children, startIndex, amount, property.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
        }
        this.dynamicBuffer._updateID++;
    }
    ;
    /**
     * Uploads the static properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */
    uploadStatic(children, startIndex, amount) {
        for (var i = 0; i < this.staticProperties.length; i++) {
            var property = this.staticProperties[i];
            property.uploadFunction(children, startIndex, amount, property.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
        }
        this.staticBuffer._updateID++;
    }
    ;
    /**
     * Destroys the ParticleBuffer.
     *
     * @private
     */
    destroy() {
        this.indexBuffer = null;
        this.dynamicProperties = null;
        // this.dynamicBuffer.destroy();
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this.staticProperties = null;
        // this.staticBuffer.destroy();
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        // all buffers are destroyed inside geometry
        this.geometry.destroy();
    }
    ;
}
exports.ParticleBuffer = ParticleBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleContainer.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleContainer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class ParticleContainer extends Container_1.Container {
    constructor(maxSize = 1500, properties = null, batchSize = 16384, autoResize = false) {
        if (maxSize === void 0) {
            maxSize = 1500;
        }
        if (batchSize === void 0) {
            batchSize = 16384;
        }
        if (autoResize === void 0) {
            autoResize = false;
        }
        super();
        // Making sure the batch size is valid
        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        var maxBatchSize = 16384;
        if (batchSize > maxBatchSize) {
            batchSize = maxBatchSize;
        }
        if (batchSize > maxSize) {
            batchSize = maxSize;
        }
        /**
         * Set properties to be dynamic (true) / static (false)
         *
         * @member {boolean[]}
         * @private
         */
        this._properties = [false, true, false, false, false];
        /**
         * @member {number}
         * @private
         */
        this._maxSize = maxSize;
        /**
         * @member {number}
         * @private
         */
        this._batchSize = batchSize;
        /**
         * @member {Array<PIXI.Buffer>}
         * @private
         */
        this._buffers = null;
        /**
         * for every batch stores _updateID corresponding to the last change in that batch
         * @member {number[]}
         * @private
         */
        this._bufferUpdateIDs = [];
        /**
         * when child inserted, removed or changes position this number goes up
         * @member {number[]}
         * @private
         */
        this._updateID = 0;
        /**
         * @member {boolean}
         *
         */
        this.interactiveChildren = false;
        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`
         * to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * If true, container allocates more batches in case there are more than `maxSize` particles.
         * @member {boolean}
         * @default false
         */
        this.autoResize = autoResize;
        /**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * Default to true here as performance is usually the priority for particles.
         *
         * @member {boolean}
         * @default true
         */
        this.roundPixels = true;
        /**
         * The texture used to render the children.
         *
         * @readonly
         * @member {BaseTexture}
         */
        this.baseTexture = null;
        this.setProperties(properties);
        /**
         * The tint applied to the container.
         * This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this._tint = 0;
        this.tintRgb = new Float32Array(4);
        this.tint = 0xFFFFFF;
    }
    /**
     * Sets the private properties array to dynamic / static based on the passed properties object
     *
     * @param {object} properties - The properties to be uploaded
     */
    setProperties(properties) {
        if (properties) {
            this._properties[0] = 'vertices' in properties || 'scale' in properties
                ? !!properties.vertices || !!properties.scale : this._properties[0];
            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
            this._properties[4] = 'tint' in properties || 'alpha' in properties
                ? !!properties.tint || !!properties.alpha : this._properties[4];
        }
    }
    ;
    /**
     * Updates the object transform for rendering
     *
     * @private
     */
    updateTransform() {
        super.updateTransform();
        // TODO don't need to!
        // this.displayObjectUpdateTransform();
        //  PIXI.Container.prototype.updateTransform.call( this );
    }
    ;
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     ** IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
        * @member {number}
        * @default 0xFFFFFF
        */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
        ColorSettings_1.ColorSettings.hex2rgb(value, this.tintRgb);
    }
    ;
    /**
     * Renders the container using the WebGL renderer
     *
     * @private
     * @param {PIXI.Renderer} renderer - The webgl renderer
     */
    render(renderer) {
        var this$1 = this;
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
            return;
        }
        if (!this.baseTexture) {
            this.baseTexture = this.children[0]._texture.baseTexture;
            if (!this.baseTexture.valid) {
                this.baseTexture.once('update', function () { return this$1.onChildrenChange(0); });
            }
        }
        renderer.batch.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
    }
    ;
    /**
     * Set the flag that static data should be updated to true
     *
     * @private
     * @param {number} smallestChildIndex - The smallest child index
     */
    onChildrenChange(smallestChildIndex) {
        var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
        while (this._bufferUpdateIDs.length < bufferIndex) {
            this._bufferUpdateIDs.push(0);
        }
        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
    }
    ;
    dispose() {
        if (this._buffers) {
            for (var i = 0; i < this._buffers.length; ++i) {
                this._buffers[i].destroy();
            }
            this._buffers = null;
        }
    }
    ;
    /**
     * Destroys the container
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.dispose();
        this._properties = null;
        this._buffers = null;
        this._bufferUpdateIDs = null;
    }
    ;
}
exports.ParticleContainer = ParticleContainer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleRenderer.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleRenderer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const ParticleBuffer_1 = __webpack_require__(/*! ./ParticleBuffer */ "./js-compile/raw-pixi-ts/ParticleBuffer.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ParticleRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        // and max number of element in the index buffer is 16384 * 6 = 98304
        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
        // let numIndices = 98304;
        /**
         * The default shader that is used if a sprite doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */
        this.shader = null;
        this.properties = null;
        this.tempMatrix = new Matrix_1.Matrix();
        this.properties = [
            // verticesData
            {
                attributeName: 'aVertexPosition',
                size: 2,
                uploadFunction: this.uploadVertices,
                offset: 0,
            },
            // positionData
            {
                attributeName: 'aPositionCoord',
                size: 2,
                uploadFunction: this.uploadPosition,
                offset: 0,
            },
            // rotationData
            {
                attributeName: 'aRotation',
                size: 1,
                uploadFunction: this.uploadRotation,
                offset: 0,
            },
            // uvsData
            {
                attributeName: 'aTextureCoord',
                size: 2,
                uploadFunction: this.uploadUvs,
                offset: 0,
            },
            // tintData
            {
                attributeName: 'aColor',
                size: 1,
                type: WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE,
                uploadFunction: this.uploadTint,
                offset: 0,
            }
        ];
        this.shader = Shader_1.Shader.from(ParticleRenderer.vertex$2, ParticleRenderer.fragment$1, {});
    }
    /**
     * Renders the particle container object.
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     */
    render(container) {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;
        if (totalChildren === 0) {
            return;
        }
        else if (totalChildren > maxSize) {
            totalChildren = maxSize;
        }
        var buffers = container._buffers;
        if (!buffers) {
            buffers = container._buffers = this.generateBuffers(container);
        }
        var baseTexture = children[0]._texture.baseTexture;
        // if the uvs have not updated then no point rendering just yet!
        this.renderer.state.setBlendMode(BlendModesSettings_1.BlendModesSettings.correctBlendMode(container.blendMode, baseTexture.premultiplyAlpha));
        var gl = renderer.gl;
        var m = container.worldTransform.copyTo(this.tempMatrix);
        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m.toArray(true);
        this.shader.uniforms.uColor = ColorSettings_1.ColorSettings.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultiplyAlpha);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        var updateStatic = false;
        // now lets upload and render the buffers..
        for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
            var amount = (totalChildren - i);
            if (amount > batchSize) {
                amount = batchSize;
            }
            if (j >= buffers.length) {
                if (!container.autoResize) {
                    break;
                }
                buffers.push(this._generateOneMoreBuffer(container));
            }
            var buffer = buffers[j];
            // we always upload the dynamic
            buffer.uploadDynamic(children, i, amount);
            var bid = container._bufferUpdateIDs[j] || 0;
            updateStatic = updateStatic || (buffer._updateID < bid);
            // we only upload the static content when we have to!
            if (updateStatic) {
                buffer._updateID = container._updateID;
                buffer.uploadStatic(children, i, amount);
            }
            // bind the buffer
            renderer.geometry.bind(buffer.geometry);
            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
    }
    ;
    /**
     * Creates one particle buffer for each child in the container we want to render and updates internal properties
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer[]} The buffers
     * @private
     */
    generateBuffers(container) {
        var buffers = [];
        var size = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        for (var i = 0; i < size; i += batchSize) {
            buffers.push(new ParticleBuffer_1.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }
        return buffers;
    }
    ;
    /**
     * Creates one more particle buffer, because container has autoResize feature
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer} generated buffer
     * @private
     */
    _generateOneMoreBuffer(container) {
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        return new ParticleBuffer_1.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    }
    ;
    /**
     * Uploads the vertices.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their vertices uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadVertices(children, startIndex, amount, array, stride, offset) {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var texture = sprite._texture;
            var sx = sprite.scale.x;
            var sy = sprite.scale.y;
            var trim = texture.trim;
            var orig = texture.orig;
            if (trim) {
                // if the sprite is trimmed and is not a tilingsprite then we need to add the
                // extra space before transforming the sprite coords..
                w1 = trim.x - (sprite.anchor.x * orig.width);
                w0 = w1 + trim.width;
                h1 = trim.y - (sprite.anchor.y * orig.height);
                h0 = h1 + trim.height;
            }
            else {
                w0 = (orig.width) * (1 - sprite.anchor.x);
                w1 = (orig.width) * -sprite.anchor.x;
                h0 = orig.height * (1 - sprite.anchor.y);
                h1 = orig.height * -sprite.anchor.y;
            }
            array[offset] = w1 * sx;
            array[offset + 1] = h1 * sy;
            array[offset + stride] = w0 * sx;
            array[offset + stride + 1] = h1 * sy;
            array[offset + (stride * 2)] = w0 * sx;
            array[offset + (stride * 2) + 1] = h0 * sy;
            array[offset + (stride * 3)] = w1 * sx;
            array[offset + (stride * 3) + 1] = h0 * sy;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the position.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their positions uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadPosition(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spritePosition = children[startIndex + i].position;
            array[offset] = spritePosition.x;
            array[offset + 1] = spritePosition.y;
            array[offset + stride] = spritePosition.x;
            array[offset + stride + 1] = spritePosition.y;
            array[offset + (stride * 2)] = spritePosition.x;
            array[offset + (stride * 2) + 1] = spritePosition.y;
            array[offset + (stride * 3)] = spritePosition.x;
            array[offset + (stride * 3) + 1] = spritePosition.y;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the rotiation.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadRotation(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spriteRotation = children[startIndex + i].rotation;
            array[offset] = spriteRotation;
            array[offset + stride] = spriteRotation;
            array[offset + (stride * 2)] = spriteRotation;
            array[offset + (stride * 3)] = spriteRotation;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the Uvs
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadUvs(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var textureUvs = children[startIndex + i]._texture._uvs;
            if (textureUvs) {
                array[offset] = textureUvs.x0;
                array[offset + 1] = textureUvs.y0;
                array[offset + stride] = textureUvs.x1;
                array[offset + stride + 1] = textureUvs.y1;
                array[offset + (stride * 2)] = textureUvs.x2;
                array[offset + (stride * 2) + 1] = textureUvs.y2;
                array[offset + (stride * 3)] = textureUvs.x3;
                array[offset + (stride * 3) + 1] = textureUvs.y3;
                offset += stride * 4;
            }
            else {
                // TODO you know this can be easier!
                array[offset] = 0;
                array[offset + 1] = 0;
                array[offset + stride] = 0;
                array[offset + stride + 1] = 0;
                array[offset + (stride * 2)] = 0;
                array[offset + (stride * 2) + 1] = 0;
                array[offset + (stride * 3)] = 0;
                array[offset + (stride * 3) + 1] = 0;
                offset += stride * 4;
            }
        }
    }
    ;
    /**
     * Uploads the tint.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadTint(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var premultiplied = sprite._texture.baseTexture.premultiplyAlpha;
            var alpha = sprite.alpha;
            // we dont call extra function if alpha is 1.0, that's faster
            var argb = alpha < 1.0 && premultiplied ? ColorSettings_1.ColorSettings.premultiplyTint(sprite._tintRGB, alpha)
                : sprite._tintRGB + (alpha * 255 << 24);
            array[offset] = argb;
            array[offset + stride] = argb;
            array[offset + (stride * 2)] = argb;
            array[offset + (stride * 3)] = argb;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Destroys the ParticleRenderer.
     */
    destroy() {
        super.destroy();
        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }
        this.tempMatrix = null;
    }
    ;
}
ParticleRenderer.vertex$2 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nattribute vec2 aPositionCoord;\r\nattribute float aRotation;\r\n\r\nuniform mat3 translationMatrix;\r\nuniform vec4 uColor;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void){\r\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\r\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\r\n\r\n    vec2 v = vec2(x, y);\r\n    v = v + aPositionCoord;\r\n\r\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vColor = aColor * uColor;\r\n}\r\n";
ParticleRenderer.fragment$1 = "varying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\r\n    gl_FragColor = color;\r\n}";
exports.ParticleRenderer = ParticleRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Point.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Point.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Point {
    constructor(x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
    }
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    set(x = 0, y = 0) {
        this.x = x || 0;
        this.y = y || ((y !== 0) ? this.x : 0);
    }
    ;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p) {
        return (p.x === this.x) && (p.y === this.y);
    }
    ;
    /**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */
    copyTo(p) {
        p.set(this.x, this.y);
        return p;
    }
    ;
    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPoint} p - The point to copy from
     * @returns {PIXI.IPoint} Returns itself.
     */
    copyFrom(p) {
        this.set(p.x, p.y);
        return this;
    }
    ;
    /**
     * Creates a clone of this point
     *
     * @return {PIXI.Point} a copy of the point
     */
    clone() {
        return new Point(this.x, this.y);
    }
    ;
}
exports.Point = Point;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Polygon.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Polygon.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Polygon {
    constructor(arg = null) {
        var arguments$1 = arguments;
        var points = [], len = arguments.length;
        while (len--) {
            points[len] = arguments$1[len];
        }
        if (Array.isArray(points[0])) {
            points = points[0];
        }
        // if this is an array of points, convert it to a flat array of numbers
        if (points[0] instanceof Point_1.Point) {
            var p = [];
            for (var i = 0, il = points.length; i < il; i++) {
                p.push(points[i].x, points[i].y);
            }
            points = p;
        }
        /**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */
        this.points = points;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.POLY;
        /**
         * `false` after moveTo, `true` after `closePath`. In all other cases it is `true`.
         * @member {boolean}
         * @default true
         */
        this.closeStroke = true;
    }
    /**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */
    clone() {
        var polygon = new Polygon(this.points.slice());
        polygon.closeStroke = this.closeStroke;
        return polygon;
    }
    ;
    /**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */
    contains(x, y) {
        var inside = false;
        // use some raycasting to test hits
        // https://github.com/substack/point-in-polygon/blob/master/index.js
        var length = this.points.length / 2;
        for (var i = 0, j = length - 1; i < length; j = i++) {
            var xi = this.points[i * 2];
            var yi = this.points[(i * 2) + 1];
            var xj = this.points[j * 2];
            var yj = this.points[(j * 2) + 1];
            var intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);
            if (intersect) {
                inside = !inside;
            }
        }
        return inside;
    }
    ;
}
exports.Polygon = Polygon;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Prepare.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Prepare.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BasePrepare_1 = __webpack_require__(/*! ./BasePrepare */ "./js-compile/raw-pixi-ts/BasePrepare.js");
// import { settings } from "./settings";
const Graphics_1 = __webpack_require__(/*! ./Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class Prepare extends BasePrepare_1.BasePrepare {
    constructor(renderer) {
        super(renderer);
        this.uploadHookHelper = this.renderer;
        // Add textures and graphics to upload
        this.registerFindHook(Prepare.findGraphics);
        this.registerUploadHook(Prepare.uploadBaseTextures);
        this.registerUploadHook(Prepare.uploadGraphics);
    }
    static findGraphics(item, queue) {
        if (item instanceof Graphics_1.Graphics) {
            queue.push(item);
            return true;
        }
        return false;
    }
    static uploadBaseTextures(renderer, item) {
        if (item instanceof BaseTexture_1.BaseTexture) {
            if (!item._glTextures[renderer.CONTEXT_UID]) {
                renderer.textureManager.updateTexture(item);
            }
            return true;
        }
        return false;
    }
    static uploadGraphics(renderer, item) {
        if (item instanceof Graphics_1.Graphics) {
            if (item.dirty || item.clearDirty || !item._webGL[renderer.plugins.graphics.CONTEXT_UID]) {
                renderer.plugins.graphics.updateGraphics(item);
            }
            return true;
        }
        return false;
    }
}
exports.Prepare = Prepare;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Program.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Program.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class Program {
    constructor(vertexSrc, fragmentSrc, name = 'pixi-shader') {
        this.id = Program.UID$3++;
        /**
         * The vertex shader.
         *
         * @member {string}
         */
        this.vertexSrc = vertexSrc || Program.defaultVertexSrc;
        /**
         * The fragment shader.
         *
         * @member {string}
         */
        this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== '#version') {
            name = name.replace(/\s+/g, '-');
            if (CacheSettings_1.CacheSettings.nameCache[name]) {
                CacheSettings_1.CacheSettings.nameCache[name]++;
                name += "-" + (CacheSettings_1.CacheSettings.nameCache[name]);
            }
            else {
                CacheSettings_1.CacheSettings.nameCache[name] = 1;
            }
            this.vertexSrc = "#define SHADER_NAME " + name + "\n" + (this.vertexSrc);
            this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + (this.fragmentSrc);
            this.vertexSrc = WebGLSettings_1.WebGLSettings.setPrecision(this.vertexSrc, WebGLSettings_1.WebGLSettings.PRECISION_VERTEX);
            this.fragmentSrc = WebGLSettings_1.WebGLSettings.setPrecision(this.fragmentSrc, WebGLSettings_1.WebGLSettings.PRECISION_FRAGMENT);
        }
        if (name == "pixi-shader-4") {
        }
        // currently this does not extract structs only default types
        this.extractData(this.vertexSrc, this.fragmentSrc);
        // this is where we store shader references..
        this.glPrograms = {};
        this.syncUniforms = null;
    }
    /**
     * Extracts the data for a buy creating a small test program
     * or reading the src directly.
     * @protected
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     */
    extractData(vertexSrc, fragmentSrc) {
        var gl = WebGLSettings_1.WebGLSettings.getTestContext();
        if (gl) {
            var program = Program.compileProgram(gl, vertexSrc, fragmentSrc);
            this.attributeData = this.getAttributeData(program, gl);
            this.uniformData = this.getUniformData(program, gl);
            gl.deleteProgram(program);
        }
        else {
            this.uniformData = {};
            this.attributeData = {};
        }
    }
    ;
    /**
     * returns the attribute data from the program
     * @private
     *
     * @param {WebGLProgram} [program] - the WebGL program
     * @param {WebGLRenderingContext} [gl] - the WebGL context
     *
     * @returns {object} the attribute data for this program
     */
    getAttributeData(program, gl) {
        var attributes = {};
        var attributesArray = [];
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = gl.getActiveAttrib(program, i);
            var type = WebGLSettings_1.WebGLSettings.mapType(gl, attribData.type);
            /*eslint-disable */
            var data = {
                type: type,
                name: attribData.name,
                size: WebGLSettings_1.WebGLSettings.mapSize(type),
                location: 0,
            };
            /* eslint-enable */
            attributes[attribData.name] = data;
            attributesArray.push(data);
        }
        attributesArray.sort(function (a, b) { return (a.name > b.name) ? 1 : -1; }); // eslint-disable-line no-confusing-arrow
        for (var i$1 = 0; i$1 < attributesArray.length; i$1++) {
            attributesArray[i$1].location = i$1;
        }
        return attributes;
    }
    ;
    /**
     * returns the uniform data from the program
     * @private
     *
     * @param {webGL-program} [program] - the webgl program
     * @param {context} [gl] - the WebGL context
     *
     * @returns {object} the uniform data for this program
     */
    getUniformData(program, gl) {
        var uniforms = {};
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        // TODO expose this as a prop?
        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = gl.getActiveUniform(program, i);
            var name = uniformData.name.replace(/\[.*?\]/, '');
            var isArray = uniformData.name.match(/\[.*?\]/, '');
            var type = WebGLSettings_1.WebGLSettings.mapType(gl, uniformData.type);
            /*eslint-disable */
            uniforms[name] = {
                type: type,
                size: uniformData.size,
                isArray: isArray,
                value: WebGLSettings_1.WebGLSettings.defaultValue(type, uniformData.size),
            };
            /* eslint-enable */
        }
        return uniforms;
    }
    ;
    /**
     * The default vertex shader source
     *
     * @static
     * @constant
     * @member {string}
     */
    static get defaultVertexSrc() {
        return Program.defaultVertex;
    }
    ;
    /**
     * The default fragment shader source
     *
     * @static
     * @constant
     * @member {string}
     */
    static get defaultFragmentSrc() {
        return Program.defaultFragment;
    }
    ;
    /**
     * A short hand function to create a program based of a vertex and fragment shader
     * this method will also check to see if there is a cached program.
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Program} an shiny new Pixi shader!
     */
    static from(vertexSrc, fragmentSrc, name = "pixi-shader") {
        var key = vertexSrc + fragmentSrc;
        var program = CacheSettings_1.CacheSettings.ProgramCache[key];
        if (!program) {
            CacheSettings_1.CacheSettings.ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);
        }
        return program;
    }
    ;
    /**
 * @method compileProgram
 * @private
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
    static compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations = null) {
        var glVertShader = Shader_1.Shader.compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
        var glFragShader = Shader_1.Shader.compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
        var program = gl.createProgram();
        gl.attachShader(program, glVertShader);
        gl.attachShader(program, glFragShader);
        // optionally, set the attributes manually for the program rather than letting WebGL decide..
        if (attributeLocations) {
            for (var i in attributeLocations) {
                gl.bindAttribLocation(program, attributeLocations[i], i);
            }
        }
        gl.linkProgram(program);
        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Pixi.js Error: Could not initialize shader.');
            console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
            console.error('gl.getError()', gl.getError());
            // if there is a program info log, log it
            if (gl.getProgramInfoLog(program) !== '') {
                console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
            }
            gl.deleteProgram(program);
            program = null;
        }
        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
        return program;
    }
}
Program.UID$3 = 0;
Program.defaultFragment = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\r\n}";
Program.defaultVertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void){\r\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n   vTextureCoord = aTextureCoord;\r\n}\r\n";
exports.Program = Program;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ProgressEvent.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ProgressEvent.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class ProgressEvent extends Event_1.Event {
    constructor(type, bubbles = false, cancelable = false) {
        super(type, bubbles, cancelable);
    }
    clone() {
        var event = ProgressEvent.getProgressEvent(this.type, this.bubbles, this.cancelable);
        event.bytesLoaded = this.bytesLoaded;
        event.bytesTotal = this.bytesTotal;
        event.percent = this.percent;
        return event;
    }
    get isDisposable() {
        return true;
    }
    static getProgressEvent(type, bubble = true, cancelable = true) {
        if (ProgressEvent.ProgressEventCache.length) {
            let te = ProgressEvent.ProgressEventCache[ProgressEvent.ProgressEventCache.length - 1];
            ProgressEvent.ProgressEventCache.length -= 1;
            te.reset(type, bubble, cancelable);
            return te;
        }
        return new ProgressEvent(type, bubble, cancelable);
    }
    destructor() {
        this._currentTarget = null;
        // this._legacyTarget = null;
        let index = ProgressEvent.ProgressEventCache.indexOf(this);
        if (index < 0) {
            ProgressEvent.ProgressEventCache.push(this);
        }
    }
}
ProgressEvent.ProgressEventCache = [];
ProgressEvent.PROGRESS = "progress";
exports.ProgressEvent = ProgressEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ProjectionSystem.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ProjectionSystem.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class ProjectionSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = null;
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = null;
        /**
         * Default destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.defaultFrame = null;
        /**
         * Project matrix
         * @member {PIXI.Matrix}
         * @readonly
         */
        this.projectionMatrix = new Matrix_1.Matrix();
        /**
         * A transform that will be appended to the projection matrix
         * if null, nothing will be applied
         * @member {PIXI.Matrix}
         */
        this.transform = null;
    }
    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    update(destinationFrame, sourceFrame, resolution, root) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
        if (this.transform) {
            this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        // this will work for now
        // but would be sweet to stick and even on the global uniforms..
        if (renderer.shader.shader) {
            renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
    }
    ;
    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    calculateProjection(destinationFrame, sourceFrame, resolution, root) {
        var pm = this.projectionMatrix;
        // I don't think we will need this line..
        // pm.identity();
        if (!root) {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (1 / destinationFrame.height * 2) * resolution;
            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = -1 - (sourceFrame.y * pm.d);
        }
        else {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (-1 / destinationFrame.height * 2) * resolution;
            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = 1 - (sourceFrame.y * pm.d);
        }
    }
    ;
    /**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */
    setTransform() {
        // this._activeRenderTarget.transform = matrix;
    }
    ;
}
exports.ProjectionSystem = ProjectionSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Quad.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Quad.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
class Quad extends Geometry_1.Geometry {
    constructor() {
        super();
        this.addAttribute('aVertexPosition', [0, 0, 1, 0, 1, 1, 0, 1]).addIndex([0, 1, 3, 2]);
    }
}
exports.Quad = Quad;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/QuadUv.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/QuadUv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
class QuadUv extends Geometry_1.Geometry {
    constructor() {
        super();
        /**
         * An array of vertices
         *
         * @member {Float32Array}
         */
        this.vertices = new Float32Array([
            -1, -1,
            1, -1,
            1, 1,
            -1, 1
        ]);
        /**
         * The Uvs of the quad
         *
         * @member {Float32Array}
         */
        this.uvs = new Float32Array([
            0, 0,
            1, 0,
            1, 1,
            0, 1
        ]);
        this.vertexBuffer = new Buffer_1.Buffer(this.vertices);
        this.uvBuffer = new Buffer_1.Buffer(this.uvs);
        this.addAttribute('aVertexPosition', this.vertexBuffer)
            .addAttribute('aTextureCoord', this.uvBuffer)
            .addIndex([0, 1, 2, 0, 2, 3]);
    }
    /**
     * Maps two Rectangle to the quad.
     *
     * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
     * @param {PIXI.Rectangle} destinationFrame - the second rectangle
     * @return {PIXI.Quad} Returns itself.
     */
    map(targetTextureFrame, destinationFrame) {
        var x = 0; // destinationFrame.x / targetTextureFrame.width;
        var y = 0; // destinationFrame.y / targetTextureFrame.height;
        this.uvs[0] = x;
        this.uvs[1] = y;
        this.uvs[2] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[3] = y;
        this.uvs[4] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[5] = y + (destinationFrame.height / targetTextureFrame.height);
        this.uvs[6] = x;
        this.uvs[7] = y + (destinationFrame.height / targetTextureFrame.height);
        x = destinationFrame.x;
        y = destinationFrame.y;
        this.vertices[0] = x;
        this.vertices[1] = y;
        this.vertices[2] = x + destinationFrame.width;
        this.vertices[3] = y;
        this.vertices[4] = x + destinationFrame.width;
        this.vertices[5] = y + destinationFrame.height;
        this.vertices[6] = x;
        this.vertices[7] = y + destinationFrame.height;
        this.invalidate();
        return this;
    }
    ;
    /**
     * legacy upload method, just marks buffers dirty
     * @returns {PIXI.QuadUv} Returns itself.
     */
    invalidate() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
    }
    ;
}
exports.QuadUv = QuadUv;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/QuadraticUtils.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/QuadraticUtils.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class QuadraticUtils {
    static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - (2.0 * cpX) + toX;
        var ay = fromY - (2.0 * cpY) + toY;
        var bx = (2.0 * cpX) - (2.0 * fromX);
        var by = (2.0 * cpY) - (2.0 * fromY);
        var a = 4.0 * ((ax * ax) + (ay * ay));
        var b = 4.0 * ((ax * bx) + (ay * by));
        var c = (bx * bx) + (by * by);
        var s = 2.0 * Math.sqrt(a + b + c);
        var a2 = Math.sqrt(a);
        var a32 = 2.0 * a * a2;
        var c2 = 2.0 * Math.sqrt(c);
        var ba = b / a2;
        return ((a32 * s)
            + (a2 * b * (s - c2))
            + (((4.0 * c * a) - (b * b))
                * Math.log(((2.0 * a2) + ba + s) / (ba + c2)))) / (4.0 * a32);
    }
    ;
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @private
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Points to add segments to.
     */
    static curveTo(cpX, cpY, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        var xa = 0;
        var ya = 0;
        for (var i = 1; i <= n; ++i) {
            var j = i / n;
            xa = fromX + ((cpX - fromX) * j);
            ya = fromY + ((cpY - fromY) * j);
            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j), ya + (((cpY + ((toY - cpY) * j)) - ya) * j));
        }
    }
    ;
}
exports.QuadraticUtils = QuadraticUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Rectangle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Rectangle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Rectangle {
    constructor(x = 0, y = 0, width = 0, height = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (width === void 0) {
            width = 0;
        }
        if (height === void 0) {
            height = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = Number(x);
        /**
         * @member {number}
         * @default 0
         */
        this.y = Number(y);
        /**
         * @member {number}
         * @default 0
         */
        this.width = Number(width);
        /**
         * @member {number}
         * @default 0
         */
        this.height = Number(height);
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.RECT
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.RECT;
    }
    /**
     * returns the left edge of the rectangle
     *
     * @member {number}
     */
    get left() {
        return this.x;
    }
    ;
    /**
     * returns the right edge of the rectangle
     *
     * @member {number}
     */
    get right() {
        return this.x + this.width;
    }
    ;
    /**
     * returns the top edge of the rectangle
     *
     * @member {number}
     */
    get top() {
        return this.y;
    }
    ;
    /**
     * returns the bottom edge of the rectangle
     *
     * @member {number}
     */
    get bottom() {
        return this.y + this.height;
    }
    ;
    /**
     * A constant empty rectangle.
     *
     * @static
     * @constant
     * @member {PIXI.Rectangle}
     */
    static get EMPTY() {
        return new Rectangle(0, 0, 0, 0);
    }
    ;
    /**
     * Creates a clone of this Rectangle
     *
     * @return {PIXI.Rectangle} a copy of the rectangle
     */
    clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }
    ;
    /**
     * Copies another rectangle to this one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy from.
     * @return {PIXI.Rectangle} Returns itself.
     */
    copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
    }
    ;
    /**
     * Copies this rectangle to another one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy to.
     * @return {PIXI.Rectangle} Returns given parameter.
     */
    copyTo(rectangle) {
        rectangle.x = this.x;
        rectangle.y = this.y;
        rectangle.width = this.width;
        rectangle.height = this.height;
        return rectangle;
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rectangle
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x < this.x + this.width) {
            if (y >= this.y && y < this.y + this.height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Pads the rectangle making it grow in all directions.
     *
     * @param {number} paddingX - The horizontal padding amount.
     * @param {number} paddingY - The vertical padding amount.
     */
    pad(paddingX, paddingY) {
        paddingX = paddingX || 0;
        paddingY = paddingY || ((paddingY !== 0) ? paddingX : 0);
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
    }
    ;
    /**
     * Fits this rectangle around the passed one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
     */
    fit(rectangle) {
        var x1 = Math.max(this.x, rectangle.x);
        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.max(this.y, rectangle.y);
        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
    }
    ;
    /**
     * Enlarges rectangle that way its corners lie on grid
     *
     * @param {number} [resolution=1] resolution
     * @param {number} [eps=0.001] precision
     */
    ceil(resolution, eps) {
        if (resolution === void 0) {
            resolution = 1;
        }
        if (eps === void 0) {
            eps = 0.001;
        }
        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
    }
    ;
    /**
     * Enlarges this rectangle to include the passed rectangle.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to include.
     */
    enlarge(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
    }
    ;
}
exports.Rectangle = Rectangle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RenderTexture.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RenderTexture.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseRenderTexture_1 = __webpack_require__(/*! ./BaseRenderTexture */ "./js-compile/raw-pixi-ts/BaseRenderTexture.js");
class RenderTexture extends Texture_1.Texture {
    constructor(baseRenderTexture = null, frame = null) {
        super(baseRenderTexture, frame);
        var _legacyRenderer = null;
        if (!(baseRenderTexture instanceof BaseRenderTexture_1.BaseRenderTexture)) {
            /* eslint-disable prefer-rest-params, no-console */
            var width = arguments[1];
            var height = arguments[2];
            var scaleMode = arguments[3];
            var resolution = arguments[4];
            // we have an old render texture..
            console.warn(("Please use RenderTexture.create(" + width + ", " + height + ") instead of the ctor directly."));
            _legacyRenderer = arguments[0];
            /* eslint-enable prefer-rest-params, no-console */
            frame = null;
            baseRenderTexture = new BaseRenderTexture_1.BaseRenderTexture({
                width: width,
                height: height,
                scaleMode: scaleMode,
                resolution: resolution,
            });
        }
        this.legacyRenderer = _legacyRenderer;
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = true;
        /**
         * FilterSystem temporary storage
         * @protected
         * @member {PIXI.Rectangle}
         */
        this.filterFrame = null;
        /**
        * The key for pooled texture of FilterSystem
        * @protected
        * @member {string}
        */
        this.filterPoolKey = null;
        this.updateUvs();
    }
    /**
    * Resizes the RenderTexture.
    *
    * @param {number} width - The width to resize to.
    * @param {number} height - The height to resize to.
    * @param {boolean} [resizeBaseTexture=true] - Should the baseTexture.width and height values be resized as well?
    */
    resize(width, height, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
            resizeBaseTexture = true;
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        // TODO - could be not required..
        this.valid = (width > 0 && height > 0);
        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;
        if (resizeBaseTexture) {
            this.baseTexture.resize(width, height);
        }
        this.updateUvs();
    }
    ;
    /**
     * A short hand way of creating a render texture.
     *
     * @param {object} [options] - Options
     * @param {number} [options.width=100] - The width of the render texture
     * @param {number} [options.height=100] - The height of the render texture
     * @param {number} [options.scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the texture being generated
     * @return {PIXI.RenderTexture} The new render texture
     */
    static create(options, height = null, scaleMode = null, resolution = null) {
        // fallback, old-style: create(width, height, scaleMode, resolution)
        if (typeof options === 'number') {
            /* eslint-disable prefer-rest-params */
            options = {
                width: options,
                height: arguments[1],
                scaleMode: arguments[2],
                resolution: arguments[3],
            };
            /* eslint-enable prefer-rest-params */
        }
        return new RenderTexture(new BaseRenderTexture_1.BaseRenderTexture(options));
    }
    ;
}
exports.RenderTexture = RenderTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RenderTextureSystem.js":
/*!*******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RenderTextureSystem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class RenderTextureSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * The clear background color as rgba
         * @member {number[]}
         */
        this.clearColor = renderer._backgroundColorRgba;
        // TODO move this property somewhere else!
        /**
         * List of masks for the StencilSystem
         * @member {PIXI.Graphics[]}
         * @readonly
         */
        this.defaultMaskStack = [];
        // empty render texture?
        /**
         * Render texture
         * @member {PIXI.RenderTexture}
         * @readonly
         */
        this.current = null;
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = new Rectangle_1.Rectangle();
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = new Rectangle_1.Rectangle();
    }
    /**
     * Bind the current render texture
     * @param {PIXI.RenderTexture} renderTexture
     * @param {PIXI.Rectangle} sourceFrame
     * @param {PIXI.Rectangle} destinationFrame
     */
    bind(renderTexture, sourceFrame = null, destinationFrame = null) {
        if (renderTexture === void 0) {
            renderTexture = null;
        }
        this.current = renderTexture;
        var renderer = this.renderer;
        var resolution;
        if (renderTexture) {
            var baseTexture = renderTexture.baseTexture;
            resolution = baseTexture.resolution;
            if (!destinationFrame) {
                RenderTextureSystem.tempRect.width = baseTexture.realWidth;
                RenderTextureSystem.tempRect.height = baseTexture.realHeight;
                destinationFrame = RenderTextureSystem.tempRect;
            }
            if (!sourceFrame) {
                sourceFrame = destinationFrame;
            }
            this.renderer.framebuffer.bind(baseTexture.framebuffer, destinationFrame);
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, false);
            this.renderer.stencil.setMaskStack(baseTexture.stencilMaskStack);
        }
        else {
            resolution = this.renderer.resolution;
            // TODO these validation checks happen deeper down..
            // thing they can be avoided..
            if (!destinationFrame) {
                RenderTextureSystem.tempRect.width = renderer.width;
                RenderTextureSystem.tempRect.height = renderer.height;
                destinationFrame = RenderTextureSystem.tempRect;
            }
            if (!sourceFrame) {
                sourceFrame = destinationFrame;
            }
            renderer.framebuffer.bind(null, destinationFrame);
            // TODO store this..
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, true);
            this.renderer.stencil.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.x = destinationFrame.x / resolution;
        this.destinationFrame.y = destinationFrame.y / resolution;
        this.destinationFrame.width = destinationFrame.width / resolution;
        this.destinationFrame.height = destinationFrame.height / resolution;
    }
    ;
    /**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {number[]} [clearColor] - The color as rgba, default to use the renderer backgroundColor
     * @return {PIXI.Renderer} Returns itself.
     */
    clear(clearColor = null) {
        if (this.current) {
            clearColor = clearColor || this.current.baseTexture.clearColor;
        }
        else {
            clearColor = clearColor || this.clearColor;
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    }
    ;
    resize() {
        // resize the root only!
        this.bind(null);
    }
    ;
    /**
     * Resets renderTexture state
     */
    reset() {
        this.bind(null);
    }
    ;
}
RenderTextureSystem.tempRect = new Rectangle_1.Rectangle();
exports.RenderTextureSystem = RenderTextureSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Renderer.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Renderer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const AbstractRenderer_1 = __webpack_require__(/*! ./AbstractRenderer */ "./js-compile/raw-pixi-ts/AbstractRenderer.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const BatchRenderer_1 = __webpack_require__(/*! ./BatchRenderer */ "./js-compile/raw-pixi-ts/BatchRenderer.js");
const BatchSystem_1 = __webpack_require__(/*! ./BatchSystem */ "./js-compile/raw-pixi-ts/BatchSystem.js");
const RenderTextureSystem_1 = __webpack_require__(/*! ./RenderTextureSystem */ "./js-compile/raw-pixi-ts/RenderTextureSystem.js");
const FilterSystem_1 = __webpack_require__(/*! ./FilterSystem */ "./js-compile/raw-pixi-ts/FilterSystem.js");
const TextureGCSystem_1 = __webpack_require__(/*! ./TextureGCSystem */ "./js-compile/raw-pixi-ts/TextureGCSystem.js");
const ProjectionSystem_1 = __webpack_require__(/*! ./ProjectionSystem */ "./js-compile/raw-pixi-ts/ProjectionSystem.js");
const StencilSystem_1 = __webpack_require__(/*! ./StencilSystem */ "./js-compile/raw-pixi-ts/StencilSystem.js");
const FramebufferSystem_1 = __webpack_require__(/*! ./FramebufferSystem */ "./js-compile/raw-pixi-ts/FramebufferSystem.js");
const GeometrySystem_1 = __webpack_require__(/*! ./GeometrySystem */ "./js-compile/raw-pixi-ts/GeometrySystem.js");
const TextureSystem_1 = __webpack_require__(/*! ./TextureSystem */ "./js-compile/raw-pixi-ts/TextureSystem.js");
const ShaderSystem_1 = __webpack_require__(/*! ./ShaderSystem */ "./js-compile/raw-pixi-ts/ShaderSystem.js");
const StateSystem_1 = __webpack_require__(/*! ./StateSystem */ "./js-compile/raw-pixi-ts/StateSystem.js");
const ContextSystem_1 = __webpack_require__(/*! ./ContextSystem */ "./js-compile/raw-pixi-ts/ContextSystem.js");
const MaskSystem_1 = __webpack_require__(/*! ./MaskSystem */ "./js-compile/raw-pixi-ts/MaskSystem.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const TilingSpriteRenderer_1 = __webpack_require__(/*! ./TilingSpriteRenderer */ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js");
const AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./js-compile/raw-pixi-ts/AccessibilityManager.js");
const Extract_1 = __webpack_require__(/*! ./Extract */ "./js-compile/raw-pixi-ts/Extract.js");
const InteractionManager_1 = __webpack_require__(/*! ./InteractionManager */ "./js-compile/raw-pixi-ts/InteractionManager.js");
const ParticleRenderer_1 = __webpack_require__(/*! ./ParticleRenderer */ "./js-compile/raw-pixi-ts/ParticleRenderer.js");
const Prepare_1 = __webpack_require__(/*! ./Prepare */ "./js-compile/raw-pixi-ts/Prepare.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Renderer extends AbstractRenderer_1.AbstractRenderer {
    constructor(options) {
        super('WebGL', options);
        this.plugins = {};
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.WEBGL;
        this.gl = null;
        this.CONTEXT_UID = 0;
        this.runners = {
            destroy: new Runner_1.Runner('destroy'),
            contextChange: new Runner_1.Runner('contextChange', 1),
            reset: new Runner_1.Runner('reset'),
            update: new Runner_1.Runner('update'),
            postrender: new Runner_1.Runner('postrender'),
            prerender: new Runner_1.Runner('prerender'),
            resize: new Runner_1.Runner('resize', 2),
        };
        this.globalUniforms = new UniformGroup_1.UniformGroup({
            projectionMatrix: new Matrix_1.Matrix(),
        }, true);
        this.addSystem(MaskSystem_1.MaskSystem, 'mask')
            .addSystem(ContextSystem_1.ContextSystem, 'context')
            .addSystem(StateSystem_1.StateSystem, 'state')
            .addSystem(ShaderSystem_1.ShaderSystem, 'shader')
            .addSystem(TextureSystem_1.TextureSystem, 'texture')
            .addSystem(GeometrySystem_1.GeometrySystem, 'geometry')
            .addSystem(FramebufferSystem_1.FramebufferSystem, 'framebuffer')
            .addSystem(StencilSystem_1.StencilSystem, 'stencil')
            .addSystem(ProjectionSystem_1.ProjectionSystem, 'projection')
            .addSystem(TextureGCSystem_1.TextureGCSystem, 'textureGC')
            .addSystem(FilterSystem_1.FilterSystem, 'filter')
            .addSystem(RenderTextureSystem_1.RenderTextureSystem, 'renderTexture')
            .addSystem(BatchSystem_1.BatchSystem, 'batch');
        this.initPlugins(Renderer.__plugins);
        if (options.context) {
            this.context.initFromContext(options.context);
        }
        else {
            this.context.initFromOptions({
                alpha: this.transparent,
                antialias: options.antialias,
                premultipliedAlpha: this.transparent,
                stencil: true,
                preserveDrawingBuffer: options.preserveDrawingBuffer,
                powerPreference: this.options.powerPreference,
            });
        }
        this.renderingToScreen = true;
        //     sayHello(this.context.webGLVersion === 2 ? 'WebGL 2' : 'WebGL 1');
        this.resize(this.options.width, this.options.height);
    }
    static registerPlugin(pluginName, ctor) {
        Renderer.__plugins = Renderer.__plugins || {};
        Renderer.__plugins[pluginName] = ctor;
    }
    ;
    initPlugins(staticMap) {
        for (var o in staticMap) {
            this.plugins[o] = new (staticMap[o])(this);
        }
    }
    ;
    addSystem(ClassRef, name) {
        if (!name) {
            name = ClassRef.name;
        }
        var system = new ClassRef(this);
        if (this[name]) {
            throw new Error(("Whoops! The name \"" + name + "\" is already in use"));
        }
        this[name] = system;
        for (var i in this.runners) {
            this.runners[i].add(system);
        }
        /**
         * Fired after rendering finishes.
         *
         * @event PIXI.Renderer#postrender
         */
        /**
         * Fired before rendering starts.
         *
         * @event PIXI.Renderer#prerender
         */
        /**
         * Fired when the WebGL context is set.
         *
         * @event PIXI.Renderer#context
         * @param {WebGLRenderingContext} gl - WebGL context.
         */
        return this;
    }
    ;
    // protected handleContextChange = (event:Event)=>
    // {
    // 	this.plugins.particle.contextChange(this.context.gl)
    // 	this.framebuffer.contextChange(this.context.gl)		
    // 	this.shader.contextChange(this.context.gl)
    // 	this.geometry.contextChange();
    // 	this.state.contextChange(this.context.gl)
    // 	this.texture.contextChange();
    // 	this.framebuffer.contextChange(this.context.gl)
    // 	this.stencil.contextChange(this.context.gl)
    // 	this.projection.contextChange(this.context.gl)
    // 	this.textureGC.contextChange(this.context.gl)
    // 	this.filter.contextChange(this.context.gl)
    // 	this.renderTexture.contextChange(this.context.gl)
    // 	this.batch.contextChange(this.context.gl)
    // 	this.mask.contextChange(this.context.gl);
    // 	this.plugins.batch.contextChange();		
    // 	this.plugins.tilingSprite.contextChange(this.context.gl)		
    // }
    render(displayObject, renderTexture = null, clear = true, transform = null, skipUpdateTransform = false) {
        this.renderingToScreen = !renderTexture;
        this.runners.prerender.run();
        // this.emit('prerender');
        this.dispatchEvent(Event_1.Event.getEvent("prerender"));
        if (this.context.isLost) {
            return;
        }
        if (!renderTexture) {
            this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
            let cacheParent = displayObject.parent;
            displayObject.parent = this._tempDisplayObjectParent;
            displayObject.updateTransform();
            displayObject.parent = cacheParent;
        }
        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();
        if (clear !== undefined ? clear : this.clearBeforeRender) {
            this.renderTexture.clear();
        }
        displayObject.render(this);
        this.batch.currentRenderer.flush();
        if (renderTexture) {
            renderTexture.baseTexture.update();
        }
        this.runners.postrender.run();
        this.dispatchEvent(Event_1.Event.getEvent("postrender"));
    }
    ;
    resize(screenWidth, screenHeight) {
        super.resize(screenWidth, screenHeight);
        this.runners.resize.run(screenWidth, screenHeight);
        // this.dispatchEvent(Event.getEvent("resize"));
    }
    ;
    reset() {
        this.runners.reset.run();
        // this.dispatchEvent(Event.getEvent("reset"));
        return this;
    }
    ;
    clear() {
        this.framebuffer.bind();
        this.framebuffer.clear();
    }
    ;
    destroy(options = null) {
        this.runners.destroy.run();
        // this.dispatchEvent(Event.getEvent("destroy"));
        super.destroy(options);
        this.gl = null;
    }
    ;
}
Renderer.__plugins = {};
exports.Renderer = Renderer;
class RendererPlugins {
    constructor(renderer) {
        this.particle = new ParticleRenderer_1.ParticleRenderer(renderer);
        this.tilingSprite = new TilingSpriteRenderer_1.TilingSpriteRenderer(renderer);
        this.accessibility = new AccessibilityManager_1.AccessibilityManager(renderer);
        this.extract = new Extract_1.Extract(renderer);
        this.interaction = new InteractionManager_1.InteractionManager(renderer);
        this.prepare = new Prepare_1.Prepare(renderer);
        this.batch = new BatchRenderer_1.BatchRenderer(renderer);
        // Loader$2.registerPlugin(BitmapFontLoader);
        // Loader$2.registerPlugin(SpritesheetLoader);	
    }
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Resource.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Resource.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Resource extends EventDispatcher_1.EventDispatcher {
    constructor(width = 0, height = 0) {
        super();
        /**
         * Internal width of the resource
         * @member {number}
         * @protected
         */
        this._width = width;
        /**
         * Internal height of the resource
         * @member {number}
         * @protected
         */
        this._height = height;
        /**
         * If resource has been destroyed
         * @member {boolean}
         * @readonly
         * @default false
         */
        this.destroyed = false;
        /**
         * `true` if resource is created by BaseTexture
         * useful for doing cleanup with BaseTexture destroy
         * and not cleaning up resources that were created
         * externally.
         * @member {boolean}
         * @protected
         */
        this.internal = false;
        /**
         * Mini-runner for handling resize events
         *
         * @member {Runner}
         * @private
         */
        // this.onResize = Event.getEvent("setRealSize")
        // Runner('setRealSize', 2);
        /**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */
        // this.onUpdate = Event.getEvent("update")
        // new Runner('update');
        this.onResize = new Runner_1.Runner('setRealSize', 2);
        /**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */
        this.onUpdate = new Runner_1.Runner('update');
    }
    /**
     * Bind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */
    bind(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        // Call a resize immediate if we already
        // have the width and height of the resource
        if (this._width || this._height) {
            this.onResize.run(this._width, this._height);
        }
        // this.onResize.add(baseTexture);
        // this.onUpdate.add(baseTexture);
        // Call a resize immediate if we already
        // have the width and height of the resource
        // if (this._width || this._height)
        // {
        // 	this.dispatchEvent(Event.getEvent("setRealSize"))
        //     // this.onResize.run(this._width, this._height);
        // }
    }
    ;
    /**
     * Unbind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */
    unbind(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        // this.onResize.remove(baseTexture);
        // this.onUpdate.remove(baseTexture);
    }
    ;
    /**
     * Trigger a resize event
     */
    resize(width, height) {
        if (width !== this._width || height !== this._height) {
            this._width = width;
            this._height = height;
            this.onResize.run(width, height);
            this.dispatchEvent(Event_1.Event.getEvent("setRealSize"));
            // Event.getEvent("setRealSize")
            // this.onResize.run(width, height);
        }
    }
    ;
    /**
     * Has been validated
     * @readonly
     * @member {boolean}
     */
    get valid() {
        return !!this._width && !!this._height;
    }
    ;
    /**
     * Has been updated trigger event
     */
    update(deltaTime) {
        if (!this.destroyed) {
            this.dispatchEvent(Event_1.Event.getEvent("update"));
        }
    }
    ;
    /**
     * This can be overridden to start preloading a resource
     * or do any other prepare step.
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    load() {
        return Promise.resolve();
    }
    ;
    /**
     * The width of the resource.
     *
     * @member {number}
     * @readonly
     */
    get width() {
        return this._width;
    }
    ;
    /**
     * The height of the resource.
     *
     * @member {number}
     * @readonly
     */
    get height() {
        return this._height;
    }
    ;
    /**
     * Uploads the texture or returns false if it cant for some reason. Override this.
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture, source) {
        return false;
    }
    ;
    /**
     * Set the style, optional to override
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} `true` is success
     */
    style(renderer, baseTexture, glTexture) {
        return false;
    }
    ;
    /**
     * Clean up anything, this happens when destroying is ready.
     *
     * @protected
     */
    dispose() {
        // override
    }
    ;
    /**
     * Call when destroying resource, unbind any BaseTexture object
     * before calling this method, as reference counts are maintained
     * internally.
     */
    destroy() {
        if (!this.destroyed) {
            this.onResize.removeAll();
            this.onResize = null;
            this.onUpdate.removeAll();
            this.onUpdate = null;
            this.destroyed = true;
            this.dispose();
        }
    }
    ;
}
exports.Resource = Resource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ResourceLoader.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ResourceLoader.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const ProgressEvent_1 = __webpack_require__(/*! ./ProgressEvent */ "./js-compile/raw-pixi-ts/ProgressEvent.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class ResourceLoader extends EventDispatcher_1.EventDispatcher {
    constructor(request) {
        super();
        this.complete = (event) => {
            Logger_1.trace("complete");
            let promise = window.createImageBitmap(this._imageElement, 0, 0, this._imageElement.width, this._imageElement.height);
            promise.then(this.onImageBitmapCreated).catch();
        };
        this.onImageBitmapCreated = (image) => {
            Logger_1.trace("onImageBitmapCreated");
            this._imageData = image;
            this._clearEvents();
            this._finish();
        };
        this._onTimeout = () => {
            this.abort('Load timed out.');
        };
        this._onProgress = (event) => {
            if (event && event.lengthComputable) {
                let pe = ProgressEvent_1.ProgressEvent.getProgressEvent(ProgressEvent_1.ProgressEvent.PROGRESS);
                pe.bytesLoaded = event.loaded;
                pe.bytesTotal = event.total;
                pe.percent = event.loaded / event.total;
                this.dispatchEvent(pe);
            }
        };
        this._onError = (event) => {
            this.abort('Failed to load element using: ' + event.target.nodeName);
        };
        this._request = request;
        this._flags = 0;
        this._setFlag(ResourceLoader.STATUS_FLAGS.DATA_URL, this._request.url.indexOf('data:') === 0);
        this.extension = this._getExtension();
        this.data = null;
        this.crossOrigin = request.crossOrigin === true ? 'anonymous' : "";
        this.timeout = request.timeout || 0;
        this.loadType = this._determineLoadType();
        this.error = null;
        this.xhr = null;
        this.type = ResourceLoader.TYPE.UNKNOWN;
        this.progressChunk = 0;
        this._elementTimer = 0;
        this.metadata = request.requestMetaData;
        this.xhrType = null;
        // this.children = [];
        // this._dequeue = ResourceLoader._noop;
        // this._onLoadBinding = null;
    }
    load() {
        if (this.isLoading) {
            return;
        }
        if (this.isComplete) {
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            return;
        }
        this._setFlag(ResourceLoader.STATUS_FLAGS.LOADING, true);
        if (!this.crossOrigin) {
            this.crossOrigin = this._determineCrossOrigin(this._request.url);
        }
        switch (this.loadType) {
            case ResourceLoader.LOAD_TYPE.IMAGE:
                this.type = ResourceLoader.TYPE.IMAGE;
                this._loadElement('image');
                break;
            case ResourceLoader.LOAD_TYPE.AUDIO:
                this.type = ResourceLoader.TYPE.AUDIO;
                // this._loadSourceElement('audio');
                break;
            case ResourceLoader.LOAD_TYPE.VIDEO:
                this.type = ResourceLoader.TYPE.VIDEO;
                // this._loadSourceElement('video');
                break;
            case ResourceLoader.LOAD_TYPE.XHR:
            default:
                if (ResourceLoader.useXdr && this.crossOrigin) {
                    this._loadXdr();
                }
                else {
                    this._loadXhr();
                }
                break;
        }
        // _loadSourceElement
        // _loadXdr
        // _loadXhr
    }
    ;
    /**
     * Loads this resources using an element that has multiple sources,
     * like an HTMLAudioElement or HTMLVideoElement.
     *
     * @private
     * @param {string} type - The type of element to use.
     */
    // protected _loadSourceElement(type):void
    // {
    //     if (this.metadata.loadElement) 
    //     {
    //         this.data = this.metadata.loadElement;
    //     } else if (type === 'audio' && typeof window['Audio'] !== 'undefined') {
    //         this.data = new Audio();
    //     } else {
    //         this.data = document.createElement(type);
    //     }
    //     if (this.data === null) {
    //         this.abort('Unsupported element: ' + type);
    //         return;
    //     }
    //     if (this.crossOrigin) {
    //         this.data.crossOrigin = this.crossOrigin;
    //     }
    //     if (!this.metadata.skipSource) {
    //         // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
    //         if (navigator['isCocoonJS']) {
    //             this.data.src = Array.isArray(this._request.url) ? this._request.url[0] : this._request.url;
    //         } else if (Array.isArray(this._request.url)) {
    //             var mimeTypes = this.metadata.mimeType;
    //             for (var i = 0; i < this._request.url.length; ++i) {
    //                 this.data.appendChild(this._createSource(type, this._request.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
    //             }
    //         } else {
    //             var _mimeTypes = this.metadata.mimeType;
    //             this.data.appendChild(this._createSource(type, this._request.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
    //         }
    //     }
    //     this.data.addEventListener('error', this._boundOnError, false);
    //     this.data.addEventListener('load', this._boundComplete, false);
    //     this.data.addEventListener('progress', this._boundOnProgress, false);
    //     this.data.addEventListener('canplaythrough', this._boundComplete, false);
    //     this.data.load();
    //     if (this.timeout) {
    //         this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    //     }
    // };
    _clearEvents() {
        clearTimeout(this._elementTimer);
        if (this._imageElement && this._imageElement.removeEventListener) {
            this._imageElement.removeEventListener('error', this._onError);
            this._imageElement.removeEventListener('load', this.complete);
            this._imageElement.removeEventListener('progress', this._onProgress);
            this._imageElement.removeEventListener('canplaythrough', this.complete);
        }
        if (this.xhr) {
            // if (this.xhr.removeEventListener) {
            //     this.xhr.removeEventListener('error', this._boundXhrOnError, false);
            //     this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);
            //     this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
            //     this.xhr.removeEventListener('progress', this._boundOnProgress, false);
            //     this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);
            // } else {
            //     this.xhr.onerror = null;
            //     this.xhr.ontimeout = null;
            //     this.xhr.onprogress = null;
            //     this.xhr.onload = null;
            // }
        }
    }
    ;
    _loadElement(type) {
        Logger_1.trace("_loadElement " + type);
        this._imageElement = document.createElement("img");
        if (this.crossOrigin) {
            this._imageElement.crossOrigin = this.crossOrigin;
        }
        this._imageElement.src = this._request.url;
        this._imageElement.addEventListener('error', this._onError);
        this._imageElement.addEventListener('load', this.complete);
        this._imageElement.addEventListener('progress', this._onProgress);
        // if (this.timeout > 0) 
        // {
        //     this._elementTimer = setTimeout(this._onTimeout, this.timeout);
        // }
    }
    ;
    get imageData() {
        return this._imageData;
    }
    abort(message) {
        if (this.error) {
            return;
        }
        this.error = new Error(message);
        this._clearEvents();
        if (this.xhr) {
            this.xhr.abort();
        }
        else if (this.xdr) {
            this.xdr.abort();
        }
        else if (this.data) {
            if (this.data.src) {
                this.data.src = ResourceLoader.EMPTY_GIF;
            }
            else {
                while (this.data.firstChild) {
                    this.data.removeChild(this.data.firstChild);
                }
            }
        }
        this._finish();
    }
    ;
    _finish() {
        if (this.isComplete) {
            return;
        }
        this._setFlag(ResourceLoader.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(ResourceLoader.STATUS_FLAGS.LOADING, false);
        this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
    }
    ;
    _determineCrossOrigin(url, loc = null) {
        if (url.indexOf('data:') === 0) {
            return '';
        }
        if (window['origin'] !== window.location.origin) {
            return 'anonymous';
        }
        loc = loc || window.location;
        if (!ResourceLoader.tempAnchor) {
            ResourceLoader.tempAnchor = document.createElement('a');
        }
        ResourceLoader.tempAnchor.href = url;
        let uri = ResourceLoader.parseUri(ResourceLoader.tempAnchor.href, true);
        let samePort = !uri.port && loc.port === '' || uri.port === loc.port;
        let protocol = uri.protocol ? uri.protocol + ':' : '';
        if (uri.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
            return 'anonymous';
        }
        return '';
    }
    ;
    static parseUri(str, strict = true) {
        let o = {
            key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
            q: {
                name: 'queryKey',
                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
            },
            parser: {
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
            }
        };
        let m = o.parser[strict ? 'strict' : 'loose'].exec(str);
        let uri = new URIData();
        uri.source = m["source"] || '';
        uri.protocol = m["protocol"] || '';
        uri.authority = m["authority"] || '';
        uri.userInfo = m["userInfo"] || '';
        uri.user = m["user"] || '';
        uri.password = m["password"] || '';
        uri.host = m["host"] || '';
        uri.port = m["port"] || '';
        uri.relative = m["relative"] || '';
        uri.path = m["path"] || '';
        uri.directory = m["directory"] || '';
        uri.file = m["file"] || '';
        uri.query = m["query"] || '';
        uri.anchor = m["anchor"] || '';
        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
            if ($1) {
                uri[o.q.name][$1] = $2;
            }
        });
        return uri;
    }
    ;
    _determineLoadType() {
        return ResourceLoader._loadTypeMap[this.extension] || ResourceLoader.LOAD_TYPE.XHR;
    }
    ;
    _getExtension() {
        let url = this._request.url;
        let ext = '';
        if (this.isDataUrl) {
            let slashIndex = url.indexOf('/');
            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
        }
        else {
            let queryStart = url.indexOf('?');
            let hashStart = url.indexOf('#');
            let index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);
            url = url.substring(0, index);
            ext = url.substring(url.lastIndexOf('.') + 1);
        }
        return ext.toLowerCase();
    }
    ;
    _hasFlag(flag) {
        return (this._flags & flag) !== 0;
    }
    ;
    _setFlag(flag, value) {
        this._flags = value ? this._flags | flag : this._flags & ~flag;
    }
    ;
    static setExtMap(map, extname, val) {
        if (extname && extname.indexOf('.') === 0) {
            extname = extname.substring(1);
        }
        if (!extname) {
            return;
        }
        map[extname] = val;
    }
    static setExtensionLoadType(extname, loadType) {
        ResourceLoader.setExtMap(ResourceLoader._loadTypeMap, extname, loadType);
    }
    ;
    static setExtensionXhrType(extname, xhrType) {
        ResourceLoader.setExtMap(ResourceLoader._xhrTypeMap, extname, xhrType);
    }
    ;
    /**
     * Quick helper to get string xhr type.
     *
     * @ignore
     * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
     * @return {string} The type.
     */
    static reqType(xhr) {
        return xhr.toString().replace('object ', '');
    }
    /**
     * Loads this resources using an XMLHttpRequest.
     *
     * @private
     */
    _loadXhr() {
        // // if unset, determine the value
        // if (typeof this.xhrType !== 'string') {
        //     this.xhrType = this._determineXhrType();
        // }
        // var xhr = this.xhr = new XMLHttpRequest();
        // // set the request type and url
        // xhr.open('GET', this._request.url, true);
        // xhr.timeout = this.timeout;
        // // load json as text and parse it ourselves. We do this because some browsers
        // // *cough* safari *cough* can't deal with it.
        // if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.JSON || this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT) {
        //     xhr.responseType = <any>ResourceLoader.XHR_RESPONSE_TYPE.TEXT;
        // } else {
        //     xhr.responseType = this.xhrType;
        // }
        // xhr.addEventListener('error', this._boundXhrOnError, false);
        // xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);
        // xhr.addEventListener('abort', this._boundXhrOnAbort, false);
        // xhr.addEventListener('progress', this._boundOnProgress, false);
        // xhr.addEventListener('load', this._boundXhrOnLoad, false);
        // xhr.send();
    }
    ;
    /**
     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
     *
     * @private
     */
    _loadXdr() {
        // // if unset, determine the value
        // if (typeof this.xhrType !== 'string') {
        //     this.xhrType = this._determineXhrType();
        // }
        // var xdr = this.xhr = new window['XDomainRequest'](); // eslint-disable-line no-undef
        // // XDomainRequest has a few quirks. Occasionally it will abort requests
        // // A way to avoid this is to make sure ALL callbacks are set even if not used
        // // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
        // xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9
        // xdr.onerror = this._boundXhrOnError;
        // xdr.ontimeout = this._boundXhrOnTimeout;
        // xdr.onprogress = this._boundOnProgress;
        // xdr.onload = this._boundXhrOnLoad;
        // xdr.open('GET', this._request.url, true);
        // // Note: The xdr.send() call is wrapped in a timeout to prevent an
        // // issue with the interface where some requests are lost if multiple
        // // XDomainRequests are being sent at the same time.
        // // Some info here: https://github.com/photonstorm/phaser/issues/1248
        // setTimeout(function () {
        //     return xdr.send();
        // }, 1);
    }
    ;
    /**
     * Creates a source used in loading via an element.
     *
     * @private
     * @param {string} type - The element type (video or audio).
     * @param {string} url - The source URL to load from.
     * @param {string} [mime] - The mime type of the video
     * @return {HTMLSourceElement} The source element.
     */
    _createSource(type, url, mime) {
        // if (!mime) {
        //     mime = type + '/' + this._getExtension(url);
        // }
        // var source = document.createElement('source');
        // source.src = url;
        // source.type = mime;
        // return source;
    }
    ;
    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnError() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"');
    }
    ;
    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnTimeout() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request timed out.');
    }
    ;
    /**
     * Called if an abort event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnAbort() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request was aborted by the user.');
    }
    ;
    /**
     * Called when data successfully loads from an xhr/xdr request.
     *
     * @private
     * @param {XMLHttpRequestLoadEvent|Event} event - Load event
     */
    _xhrOnLoad() {
        // var xhr = this.xhr;
        // var text = '';
        // var status = typeof xhr.status === 'undefined' ? ResourceLoader.STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.
        // // responseText is accessible only if responseType is '' or 'text' and on older browsers
        // if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {
        //     text = xhr.responseText;
        // }
        // // status can be 0 when using the `file://` protocol so we also check if a response is set.
        // // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.
        // if (status === ResourceLoader.STATUS_NONE && (text.length > 0 || xhr.responseType === ResourceLoader.XHR_RESPONSE_TYPE.BUFFER)) {
        //     status = ResourceLoader.STATUS_OK;
        // }
        // // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        // else if (status === ResourceLoader.STATUS_IE_BUG_EMPTY) {
        //         status = ResourceLoader.STATUS_EMPTY;
        //     }
        // var statusType = status / 100 | 0;
        // if (statusType === ResourceLoader.STATUS_TYPE_OK) {
        //     // if text, just return it
        //     if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.TEXT) {
        //         this.data = text;
        //         this.type = ResourceLoader.TYPE.TEXT;
        //     }
        //     // if json, parse into json object
        //     else if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.JSON) {
        //             try {
        //                 this.data = JSON.parse(text);
        //                 this.type = ResourceLoader.TYPE.JSON;
        //             } catch (e) {
        //                 this.abort('Error trying to parse loaded json: ' + e);
        //                 return;
        //             }
        //         }
        //         // if xml, parse into an xml document or div element
        //         else if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT) {
        //                 try {
        //                     if (window['DOMParser']) {
        //                         var domparser = new DOMParser();
        //                         this.data = domparser.parseFromString(text, 'text/xml');
        //                     } else {
        //                         var div = document.createElement('div');
        //                         div.innerHTML = text;
        //                         this.data = div;
        //                     }
        //                     this.type = ResourceLoader.TYPE.XML;
        //                 } catch (e) {
        //                     this.abort('Error trying to parse loaded xml: ' + e);
        //                     return;
        //                 }
        //             }
        //             // other types just return the response
        //             else {
        //                     this.data = xhr.response || text;
        //                 }
        // } else {
        //     this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);
        //     return;
        // }
        // this.complete();
    }
    ;
    /**
     * Determines the responseType of an XHR request based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
     */
    _determineXhrType() {
        return ResourceLoader._xhrTypeMap[this.extension] || ResourceLoader.XHR_RESPONSE_TYPE.TEXT;
    }
    ;
    /**
     * Determines the loadType of a resource based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.LOAD_TYPE} The loadType to use.
     */
    /**
     * Determines the mime type of an XHR request based on the responseType of
     * resource being loaded.
     *
     * @private
     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
     * @return {string} The mime type to use.
     */
    _getMimeFromXhrType(type) {
        switch (type) {
            case ResourceLoader.XHR_RESPONSE_TYPE.BUFFER:
                return 'application/octet-binary';
            case ResourceLoader.XHR_RESPONSE_TYPE.BLOB:
                return 'application/blob';
            case ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT:
                return 'application/xml';
            case ResourceLoader.XHR_RESPONSE_TYPE.JSON:
                return 'application/json';
            case ResourceLoader.XHR_RESPONSE_TYPE.DEFAULT:
            case ResourceLoader.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
            default:
                return 'text/plain';
        }
    }
    ;
    get isDataUrl() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.DATA_URL);
    }
    get isComplete() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.COMPLETE);
    }
    get isLoading() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.LOADING);
    }
}
ResourceLoader.STATUS_NONE = 0;
ResourceLoader.STATUS_OK = 200;
ResourceLoader.STATUS_EMPTY = 204;
ResourceLoader.STATUS_IE_BUG_EMPTY = 1223;
ResourceLoader.STATUS_TYPE_OK = 2;
ResourceLoader.useXdr = !!(window['XDomainRequest'] && !('withCredentials' in new XMLHttpRequest()));
ResourceLoader.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';
ResourceLoader.LOAD_TYPE = {
    XHR: 1,
    IMAGE: 2,
    AUDIO: 3,
    VIDEO: 4
};
ResourceLoader.XHR_RESPONSE_TYPE = {
    DEFAULT: 'text',
    BUFFER: 'arraybuffer',
    BLOB: 'blob',
    DOCUMENT: 'document',
    JSON: 'json',
    TEXT: 'text'
};
ResourceLoader._xhrTypeMap = {
    xhtml: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    html: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    png: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    bmp: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    jpg: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    jpeg: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tif: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tiff: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    webp: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tga: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    json: ResourceLoader.XHR_RESPONSE_TYPE.JSON,
    text: ResourceLoader.XHR_RESPONSE_TYPE.TEXT,
    txt: ResourceLoader.XHR_RESPONSE_TYPE.TEXT,
    ttf: ResourceLoader.XHR_RESPONSE_TYPE.BUFFER,
    otf: ResourceLoader.XHR_RESPONSE_TYPE.BUFFER
};
ResourceLoader._loadTypeMap = {
    gif: ResourceLoader.LOAD_TYPE.IMAGE,
    png: ResourceLoader.LOAD_TYPE.IMAGE,
    bmp: ResourceLoader.LOAD_TYPE.IMAGE,
    jpg: ResourceLoader.LOAD_TYPE.IMAGE,
    jpeg: ResourceLoader.LOAD_TYPE.IMAGE,
    tif: ResourceLoader.LOAD_TYPE.IMAGE,
    tiff: ResourceLoader.LOAD_TYPE.IMAGE,
    webp: ResourceLoader.LOAD_TYPE.IMAGE,
    tga: ResourceLoader.LOAD_TYPE.IMAGE,
    svg: ResourceLoader.LOAD_TYPE.IMAGE,
    'svg+xml': ResourceLoader.LOAD_TYPE.IMAGE,
    mp3: ResourceLoader.LOAD_TYPE.AUDIO,
    ogg: ResourceLoader.LOAD_TYPE.AUDIO,
    wav: ResourceLoader.LOAD_TYPE.AUDIO,
    mp4: ResourceLoader.LOAD_TYPE.VIDEO,
    webm: ResourceLoader.LOAD_TYPE.VIDEO
};
ResourceLoader.TYPE = {
    UNKNOWN: 0,
    JSON: 1,
    XML: 2,
    IMAGE: 3,
    AUDIO: 4,
    VIDEO: 5,
    TEXT: 6
};
ResourceLoader.STATUS_FLAGS = {
    NONE: 0,
    DATA_URL: 1 << 0,
    COMPLETE: 1 << 1,
    LOADING: 1 << 2
};
exports.ResourceLoader = ResourceLoader;
class URIData {
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ResourceSettings.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ResourceSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ImageResource_1 = __webpack_require__(/*! ./ImageResource */ "./js-compile/raw-pixi-ts/ImageResource.js");
const CanvasResource_1 = __webpack_require__(/*! ./CanvasResource */ "./js-compile/raw-pixi-ts/CanvasResource.js");
const VideoResource_1 = __webpack_require__(/*! ./VideoResource */ "./js-compile/raw-pixi-ts/VideoResource.js");
const SVGResource_1 = __webpack_require__(/*! ./SVGResource */ "./js-compile/raw-pixi-ts/SVGResource.js");
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
const CubeResource_1 = __webpack_require__(/*! ./CubeResource */ "./js-compile/raw-pixi-ts/CubeResource.js");
const ArrayResource_1 = __webpack_require__(/*! ./ArrayResource */ "./js-compile/raw-pixi-ts/ArrayResource.js");
class ResourceSettings {
    static autoDetectResource(source, options) {
        if (!source) {
            return null;
        }
        var extension = '';
        if (typeof source === 'string') {
            var result = (/\.(\w{3,4})(?:$|\?|#)/i).exec(source);
            if (result) {
                extension = result[1].toLowerCase();
            }
        }
        for (var i = ResourceSettings.INSTALLED.length - 1; i >= 0; --i) {
            var ResourcePlugin = ResourceSettings.INSTALLED[i];
            if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
                return new ResourcePlugin(source, options);
            }
        }
        return new ImageResource_1.ImageResource(source, options);
    }
}
ResourceSettings.INSTALLED = [
    ImageResource_1.ImageResource,
    CanvasResource_1.CanvasResource,
    VideoResource_1.VideoResource,
    SVGResource_1.SVGResource,
    BufferResource_1.BufferResource,
    CubeResource_1.CubeResource,
    ArrayResource_1.ArrayResource
];
exports.ResourceSettings = ResourceSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RopeGeometry.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RopeGeometry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MeshGeometry_1 = __webpack_require__(/*! ./MeshGeometry */ "./js-compile/raw-pixi-ts/MeshGeometry.js");
class RopeGeometry extends MeshGeometry_1.MeshGeometry {
    constructor(width = 200, points = null) {
        if (width === void 0) {
            width = 200;
        }
        super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
        /**
        * An array of points that determine the rope
        * @member {PIXI.Point[]}
        */
        this.points = points;
        /**
        * The width (i.e., thickness) of the rope.
        * @member {number}
        * @readOnly
        */
        this.width = width;
        this.build();
    }
    /**
    * Refreshes Rope indices and uvs
    * @private
    */
    build() {
        var points = this.points;
        if (!points) {
            return;
        }
        var vertexBuffer = this.getAttribute('aVertexPosition');
        var uvBuffer = this.getAttribute('aTextureCoord');
        var indexBuffer = this.getIndex();
        // if too little points, or texture hasn't got UVs set yet just move on.
        if (points.length < 1) {
            return;
        }
        // if the number of points has changed we will need to recreate the arraybuffers
        if (vertexBuffer.data.length / 4 !== points.length) {
            vertexBuffer.data = new Float32Array(points.length * 4);
            uvBuffer.data = new Float32Array(points.length * 4);
            indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        var uvs = uvBuffer.data;
        var indices = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        // indices[0] = 0;
        // indices[1] = 1;
        var total = points.length; // - 1;
        for (var i = 0; i < total; i++) {
            // time to do some smart drawing!
            var index = i * 4;
            var amount = i / (total - 1);
            uvs[index] = amount;
            uvs[index + 1] = 0;
            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
        }
        var indexCount = 0;
        for (var i$1 = 0; i$1 < total - 1; i$1++) {
            var index$1 = i$1 * 2;
            indices[indexCount++] = index$1;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 3;
        }
        // ensure that the changes are uploaded
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
    }
    ;
    /**
    * refreshes vertices of Rope mesh
    */
    updateVertices() {
        var points = this.points;
        if (points.length < 1) {
            return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        // this.count -= 0.2;
        var vertices = this.buffers[0].data;
        var total = points.length;
        for (var i = 0; i < total; i++) {
            var point = points[i];
            var index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            }
            else {
                nextPoint = point;
            }
            perpY = -(nextPoint.x - lastPoint.x);
            perpX = nextPoint.y - lastPoint.y;
            var perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));
            var num = this.width / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
            perpX /= perpLength;
            perpY /= perpLength;
            perpX *= num;
            perpY *= num;
            vertices[index] = point.x + perpX;
            vertices[index + 1] = point.y + perpY;
            vertices[index + 2] = point.x - perpX;
            vertices[index + 3] = point.y - perpY;
            lastPoint = point;
        }
        this.buffers[0].update();
    }
    ;
    update() {
        this.updateVertices();
    }
    ;
}
exports.RopeGeometry = RopeGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RoundedRectangle.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RoundedRectangle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class RoundedRectangle {
    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (width === void 0) {
            width = 0;
        }
        if (height === void 0) {
            height = 0;
        }
        if (radius === void 0) {
            radius = 20;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.width = width;
        /**
         * @member {number}
         * @default 0
         */
        this.height = height;
        /**
         * @member {number}
         * @default 20
         */
        this.radius = radius;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readonly
         * @default PIXI.SHAPES.RREC
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.RREC;
    }
    /**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
     */
    clone() {
        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
            if (y >= this.y && y <= this.y + this.height) {
                if ((y >= this.y + this.radius && y <= this.y + this.height - this.radius)
                    || (x >= this.x + this.radius && x <= this.x + this.width - this.radius)) {
                    return true;
                }
                var dx = x - (this.x + this.radius);
                var dy = y - (this.y + this.radius);
                var radius2 = this.radius * this.radius;
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.width - this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dy = y - (this.y + this.height - this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
            }
        }
        return false;
    }
    ;
}
exports.RoundedRectangle = RoundedRectangle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Runner.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Runner.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Runner {
    constructor(name, priority = 0) {
        this.items = [];
        this._name = name;
        this.dispatch = this.emit;
        this.run = this.emit;
    }
    emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
            throw new Error('max arguments reached');
        }
        var ref = this;
        var name = ref.name;
        var items = ref.items;
        for (var i = 0, len = items.length; i < len; i++) {
            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
    }
    ;
    /**
     * Add a listener to the Runner
     *
     * Runners do not need to have scope or functions passed to them.
     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
     * as the name provided to the Runner when it was created.
     *
     * Eg A listener passed to this Runner will require a 'complete' function.
     *
     * ```
     * const complete = new PIXI.Runner('complete');
     * ```
     *
     * The scope used will be the object itself.
     *
     * @param {any} item - The object that will be listening.
     */
    add(item) {
        if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
        }
        return this;
    }
    ;
    /**
     * Remove a single listener from the dispatch queue.
     * @param {any} item - The listenr that you would like to remove.
     */
    remove(item) {
        var index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
        }
        return this;
    }
    ;
    /**
     * Check to see if the listener is already in the Runner
     * @param {any} item - The listener that you would like to check.
     */
    contains(item) {
        return this.items.indexOf(item) !== -1;
    }
    ;
    /**
     * Remove all listeners from the Runner
     */
    removeAll() {
        this.items.length = 0;
        return this;
    }
    ;
    /**
     * Remove all references, don't use after this.
     */
    destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
    }
    ;
    /**
     * `true` if there are no this Runner contains no listeners
     *
     * @member {boolean}
     * @readonly
     */
    get empty() {
        return this.items.length === 0;
    }
    ;
    /**
     * The name of the runner.
     *
     * @member {string}
     * @readonly
     */
    get name() {
        return this._name;
    }
    ;
}
exports.Runner = Runner;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SVGResource.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/SVGResource.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class SVGResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options) {
        options = options || {};
        super(document.createElement('canvas'));
        /**
         * Base64 encoded SVG element or URL for SVG file
         * @readonly
         * @member {string}
         */
        this.svg = source;
        /**
         * The source scale to apply to render
         * @readonly
         * @member {number}
         */
        this.scale = options.scale || 1;
        /**
         * Call when completely loaded
         * @private
         * @member {function}
         */
        this._resolve = null;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        this._load = new Promise(function (resolve) {
            // Save this until after load is finished
            this$1._resolve = function () {
                this$1.resize(this$1.source.width, this$1.source.height);
                resolve(this$1);
            };
            // Convert SVG inline string to data-uri
            if ((/^\<svg/).test(this$1.svg.trim())) {
                this$1.svg = "data:image/svg+xml;utf8," + (this$1.svg);
            }
            // Checks if `source` is an SVG image and whether it's
            // loaded via a URL or a data URI. Then calls
            // `_loadDataUri` or `_loadXhr`.
            var dataUri = settings_1.settings.decomposeDataUri(this$1.svg);
            if (dataUri) {
                this$1._loadDataUri(dataUri);
            }
            else {
                // We got an URL, so we need to do an XHR to check the svg size
                this$1._loadXhr();
            }
        });
        return this._load;
    }
    ;
    /**
     * Reads an SVG string from data URI and then calls `_loadString`.
     *
     * @param {string} dataUri - The data uri to load from.
     */
    _loadDataUri(dataUri) {
        var svgString;
        if (dataUri.encoding === 'base64') {
            if (!atob) {
                throw new Error('Your browser doesn\'t support base64 conversions.');
            }
            svgString = atob(dataUri.data);
        }
        else {
            svgString = dataUri.data;
        }
        this._loadString(svgString);
    }
    ;
    /**
     * Loads an SVG string from `imageUrl` using XHR and then calls `_loadString`.
     *
     * @private
     */
    _loadXhr() {
        var this$1 = this;
        var svgXhr = new XMLHttpRequest();
        // This throws error on IE, so SVG Document can't be used
        // svgXhr.responseType = 'document';
        // This is not needed since we load the svg as string (breaks IE too)
        // but overrideMimeType() can be used to force the response to be parsed as XML
        // svgXhr.overrideMimeType('image/svg+xml');
        svgXhr.onload = function () {
            if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
                throw new Error('Failed to load SVG using XHR.');
            }
            this$1._loadString(svgXhr.response);
        };
        // svgXhr.onerror = () => this.emit('error', this);
        svgXhr.open('GET', this.svg, true);
        svgXhr.send();
    }
    ;
    /**
     * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
     * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
     * `_loadXhr` or `_loadDataUri`.
     *
     * @private
     * @param  {string} svgString SVG source as string
     *
     * @fires loaded
     */
    _loadString(svgString) {
        var svgSize = SVGResource.getSize(svgString);
        // TODO do we need to wait for this to load?
        // seems instant!
        //
        var tempImage = new Image();
        tempImage.src = "data:image/svg+xml," + svgString;
        var svgWidth = svgSize.width;
        var svgHeight = svgSize.height;
        if (!svgWidth || !svgHeight) {
            throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
        }
        // Scale realWidth and realHeight
        this._width = Math.round(svgWidth * this.scale);
        this._height = Math.round(svgHeight * this.scale);
        // Create a canvas element
        var canvas = this.source;
        canvas.width = this._width;
        canvas.height = this._height;
        canvas._pixiId = "canvas_" + (MathSettings_1.MathSettings.uid());
        // Draw the Svg to the canvas
        canvas
            .getContext('2d')
            .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, this.width, this.height);
        this._resolve();
        this._resolve = null;
    }
    ;
    /**
     * Typedef for Size object.
     *
     * @memberof PIXI.resources.SVGResource
     * @typedef {object} Size
     * @property {number} width - Width component
     * @property {number} height - Height component
     */
    /**
     * Get size from an svg string using regexp.
     *
     * @method
     * @param {string} svgString - a serialized svg element
     * @return {PIXI.resources.SVGResource.Size} image extension
     */
    static getSize(svgString) {
        var sizeMatch = SVGResource.SVG_SIZE.exec(svgString);
        var size = {};
        if (sizeMatch) {
            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size;
    }
    ;
    /**
     * Destroys this texture
     * @override
     */
    dispose() {
        BaseImageResource_1.BaseImageResource.prototype.dispose.call(this);
        this._resolve = null;
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */
    static test(source, extension) {
        // url file extension is SVG
        return extension === 'svg'
            // source is SVG data-uri
            || (typeof source === 'string' && source.indexOf('data:image/svg+xml') === 0);
    }
    ;
}
/**
* RegExp for SVG size.
*
* @static
* @constant {RegExp|string} SVG_SIZE
* @memberof PIXI.resources.SVGResource
* @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
*/
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; // eslint-disable-line max-len
exports.SVGResource = SVGResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Shader.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Shader.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
class Shader {
    constructor(program, uniforms) {
        this.program = program;
        // lets see whats been passed in
        // uniforms should be converted to a uniform group
        if (uniforms) {
            if (uniforms instanceof UniformGroup_1.UniformGroup) {
                this.uniformGroup = uniforms;
            }
            else {
                this.uniformGroup = new UniformGroup_1.UniformGroup(uniforms);
            }
        }
        else {
            this.uniformGroup = new UniformGroup_1.UniformGroup({});
        }
        // time to build some getters and setters!
        // I guess down the line this could sort of generate an instruction list rather than use dirty ids?
        // does the trick for now though!
        for (var i in program.uniformData) {
            if (this.uniformGroup.uniforms[i] instanceof Array) {
                this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);
            }
        }
    }
    // TODO move to shader system..
    checkUniformExists(name, group) {
        if (group.uniforms[name]) {
            return true;
        }
        for (var i in group.uniforms) {
            var uniform = group.uniforms[i];
            if (uniform.group) {
                if (this.checkUniformExists(name, uniform)) {
                    return true;
                }
            }
        }
        return false;
    }
    ;
    destroy() {
        // usage count on programs?
        // remove if not used!
        this.uniformGroup = null;
    }
    ;
    /**
     * Shader uniform values, shortcut for `uniformGroup.uniforms`
     * @readonly
     * @member {object}
     */
    get uniforms() {
        return this.uniformGroup.uniforms;
    }
    ;
    /**
     * A short hand function to create a shader based of a vertex and fragment shader
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Shader} an shiny new Pixi shader!
     */
    static from(vertexSrc, fragmentSrc, uniforms) {
        var program = Program_1.Program.from(vertexSrc, fragmentSrc);
        return new Shader(program, uniforms);
    }
    ;
    /**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
    static compileShader(gl, type, src) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.warn(src);
            console.error(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
}
exports.Shader = Shader;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ShaderSystem.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ShaderSystem.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const GLProgram_1 = __webpack_require__(/*! ./GLProgram */ "./js-compile/raw-pixi-ts/GLProgram.js");
const StateSystem_1 = __webpack_require__(/*! ./StateSystem */ "./js-compile/raw-pixi-ts/StateSystem.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ShaderSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // Validation check that this environment support `new Function`
        this.systemCheck();
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = null;
        this.shader = null;
        this.program = null;
        /**
         * Cache to holds the generated functions. Stored against UniformObjects unique signature
         * @type {Object}
         * @private
         */
        this.cache = {};
        this.id = StateSystem_1.StateSystem.UID$4++;
    }
    /**
     * Overrideable function by `@pixi/unsafe-eval` to silence
     * throwing an error if platform doesn't support unsafe-evals.
     *
     * @private
     */
    systemCheck() {
        if (!UtilsSettings_1.UtilsSettings.unsafeEvalSupported()) {
            throw new Error('Current environment does not allow unsafe-eval, '
                + 'please use @pixi/unsafe-eval module to enable support.');
        }
    }
    ;
    contextChange(gl) {
        this.gl = gl;
    }
    ;
    /**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} dontSync - false if the shader should automatically sync its uniforms.
     * @returns {PIXI.GLProgram} the glProgram that belongs to the shader.
     */
    bind(shader, dontSync = false) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
        this.shader = shader;
        // TODO - some current Pixi plugins bypass this.. so it not safe to use yet..
        if (this.program !== program) {
            this.program = program;
            this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
            this.syncUniformGroup(shader.uniformGroup);
        }
        return glProgram;
    }
    ;
    /**
     * Uploads the uniforms values to the currently bound shader.
     *
     * @param {object} uniforms - the uniforms values that be applied to the current shader
     */
    setUniforms(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    }
    ;
    syncUniformGroup(group) {
        var glProgram = this.getglProgram();
        if (!group.static || group.dirtyId !== glProgram.uniformGroups[group.id]) {
            glProgram.uniformGroups[group.id] = group.dirtyId;
            this.syncUniforms(group, glProgram);
        }
    }
    ;
    /**
     * Overrideable by the @pixi/unsafe-eval package to use static
     * syncUnforms instead.
     *
     * @private
     */
    syncUniforms(group, glProgram) {
        var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer);
    }
    ;
    createSyncGroups(group) {
        var id = this.getSignature(group, this.shader.program.uniformData);
        if (!this.cache[id]) {
            this.cache[id] = WebGLSettings_1.WebGLSettings.generateUniformsSync(group, this.shader.program.uniformData);
        }
        group.syncUniforms[this.shader.program.id] = this.cache[id];
        return group.syncUniforms[this.shader.program.id];
    }
    ;
    /**
     * Takes a uniform group and data and generates a unique signature for them.
     *
     * @param {PIXI.UniformGroup} group the uniform group to get signature of
     * @param {Object} uniformData uniform information generated by the shader
     * @returns {String} Unique signature of the uniform group
     * @private
     */
    getSignature(group, uniformData) {
        var uniforms = group.uniforms;
        var strings = [];
        for (var i in uniforms) {
            strings.push(i);
            if (uniformData[i]) {
                strings.push(uniformData[i].type);
            }
        }
        return strings.join('-');
    }
    ;
    /**
     * Returns the underlying GLShade rof the currently bound shader.
     * This can be handy for when you to have a little more control over the setting of your uniforms.
     *
     * @return {PIXI.GLProgram} the glProgram for the currently bound Shader for this context
     */
    getglProgram() {
        if (this.shader) {
            return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
    }
    ;
    /**
     * Generates a glProgram version of the Shader provided.
     *
     * @private
     * @param {PIXI.Shader} shader the shader that the glProgram will be based on.
     * @return {PIXI.GLProgram} A shiny new glProgram!
     */
    generateShader(shader) {
        var gl = this.gl;
        var program = shader.program;
        var attribMap = {};
        for (var i in program.attributeData) {
            attribMap[i] = program.attributeData[i].location;
        }
        var shaderProgram = Program_1.Program.compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
        var uniformData = {};
        for (var i$1 in program.uniformData) {
            var data = program.uniformData[i$1];
            uniformData[i$1] = {
                location: gl.getUniformLocation(shaderProgram, i$1),
                value: WebGLSettings_1.WebGLSettings.defaultValue(data.type, data.size),
            };
        }
        var glProgram = new GLProgram_1.GLProgram(shaderProgram, uniformData);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
    }
    ;
    /**
     * Resets ShaderSystem state, does not affect WebGL state
     */
    reset() {
        this.program = null;
        this.shader = null;
    }
    ;
    /**
     * Destroys this System and removes all its textures
     */
    destroy() {
        // TODO implement destroy method for ShaderSystem
        this.destroyed = true;
    }
    ;
}
exports.ShaderSystem = ShaderSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ShapeSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ShapeSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ShapeSettings {
}
/**
* Constants that identify shapes, mainly to prevent `instanceof` calls.
*
* @static
* @constant
* @name SHAPES
* @memberof PIXI
* @type {object}
* @property {number} POLY Polygon
* @property {number} RECT Rectangle
* @property {number} CIRC Circle
* @property {number} ELIP Ellipse
* @property {number} RREC Rounded Rectangle
*/
ShapeSettings.SHAPES = {
    POLY: 0,
    RECT: 1,
    CIRC: 2,
    ELIP: 3,
    RREC: 4,
};
exports.ShapeSettings = ShapeSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SimpleRope.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/SimpleRope.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Mesh_1 = __webpack_require__(/*! ./Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const RopeGeometry_1 = __webpack_require__(/*! ./RopeGeometry */ "./js-compile/raw-pixi-ts/RopeGeometry.js");
const MeshMaterial_1 = __webpack_require__(/*! ./MeshMaterial */ "./js-compile/raw-pixi-ts/MeshMaterial.js");
class SimpleRope extends Mesh_1.Mesh {
    constructor(texture, points) {
        var ropeGeometry = new RopeGeometry_1.RopeGeometry(texture.height, points);
        var meshMaterial = new MeshMaterial_1.MeshMaterial(texture);
        super(ropeGeometry, meshMaterial);
        this.autoUpdate = true;
    }
    _render(renderer) {
        if (this.autoUpdate
            || this.geometry.width !== this.shader.texture.height) {
            this.geometry.width = this.shader.texture.height;
            this.geometry.update();
        }
        super._render(renderer);
    }
    ;
}
exports.SimpleRope = SimpleRope;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Sprite.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Sprite.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Sprite extends Container_1.Container {
    constructor(texture) {
        super();
        /**
         * When the texture is updated, this event will fire to update the scale and frame
         *
         * @private
         */
        this._onTextureUpdate = () => {
            Logger_1.trace("Sprite update");
            this._textureID = -1;
            this._textureTrimmedID = -1;
            this.cachedTint = 0xFFFFFF;
            // reveal(this._texture)
            this.uvs = this._texture._uvs.uvsFloat32;
            // so if _width is 0 then width was not set..
            if (this._width) {
                this.scale.x = MathSettings_1.MathSettings.sign(this.scale.x) * this._width / this._texture.orig.width;
            }
            if (this._height) {
                this.scale.y = MathSettings_1.MathSettings.sign(this.scale.y) * this._height / this._texture.orig.height;
            }
        };
        /**
         * The anchor sets the origin point of the texture.
         * The default is 0,0 or taken from the {@link PIXI.Texture#defaultAnchor|Texture}
         * passed to the constructor. A value of 0,0 means the texture's origin is the top left.
         * Setting the anchor to 0.5,0.5 means the texture's origin is centered.
         * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner.
         * Note: Updating the {@link PIXI.Texture#defaultAnchor} after a Texture is
         * created does _not_ update the Sprite's anchor values.
         *
         * @member {PIXI.ObservablePoint}
         * @private
         */
        this._anchor = new ObservablePoint_1.ObservablePoint(this._onAnchorUpdate, this, (texture ? texture.defaultAnchor.x : 0), (texture ? texture.defaultAnchor.y : 0));
        /**
         * The texture that the sprite is using
         *
         * @private
         * @member {PIXI.Texture}
         */
        this._texture = null;
        /**
         * The width of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        this._width = 0;
        /**
         * The height of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        this._height = 0;
        /**
         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this._tint = null;
        this._tintRGB = null;
        this.tint = 0xFFFFFF;
        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * The shader that will be used to render the sprite. Set to null to remove a current shader.
         *
         * @member {PIXI.Filter|PIXI.Shader}
         */
        this.shader = null;
        /**
         * An internal cached value of the tint.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this.cachedTint = 0xFFFFFF;
        this.uvs = null;
        // call texture setter
        this.texture = texture || Texture_1.Texture.EMPTY;
        /**
         * this is used to store the vertex data of the sprite (basically a quad)
         *
         * @private
         * @member {Float32Array}
         */
        this.vertexData = new Float32Array(8);
        /**
         * This is used to calculate the bounds of the object IF it is a trimmed sprite
         *
         * @private
         * @member {Float32Array}
         */
        this.vertexTrimmedData = null;
        this._transformID = -1;
        this._textureID = -1;
        this._transformTrimmedID = -1;
        this._textureTrimmedID = -1;
        // Batchable stuff..
        // TODO could make this a mixin?
        this.indices = Sprite.indices;
        this.size = 4;
        this.start = 0;
        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_render' & '_renderCanvas' methods.
         *
         * @member {string}
         * @default 'sprite'
         */
        this.pluginName = 'batch';
        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = true;
        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
    }
    /**
     * Called when the anchor position updates.
     *
     * @private
     */
    _onAnchorUpdate() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
    }
    ;
    /**
     * calculates worldTransform * vertices, store it in vertexData
     */
    calculateVertices() {
        var texture = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
            return;
        }
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        // set the vertex data
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        if (trim) {
            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
            // space before transforming the sprite coords.
            w1 = trim.x - (anchor._x * orig.width);
            w0 = w1 + trim.width;
            h1 = trim.y - (anchor._y * orig.height);
            h0 = h1 + trim.height;
        }
        else {
            w1 = -anchor._x * orig.width;
            w0 = w1 + orig.width;
            h1 = -anchor._y * orig.height;
            h0 = h1 + orig.height;
        }
        // xy
        vertexData[0] = (a * w1) + (c * h1) + tx;
        vertexData[1] = (d * h1) + (b * w1) + ty;
        // xy
        vertexData[2] = (a * w0) + (c * h1) + tx;
        vertexData[3] = (d * h1) + (b * w0) + ty;
        // xy
        vertexData[4] = (a * w0) + (c * h0) + tx;
        vertexData[5] = (d * h0) + (b * w0) + ty;
        // xy
        vertexData[6] = (a * w1) + (c * h0) + tx;
        vertexData[7] = (d * h0) + (b * w1) + ty;
        if (this._roundPixels) {
            for (var i = 0; i < 8; i++) {
                vertexData[i] = Math.round(vertexData[i]);
            }
        }
    }
    ;
    /**
     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
     * This is used to ensure that the true width and height of a trimmed texture is respected
     */
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) {
            this.vertexTrimmedData = new Float32Array(8);
        }
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
            return;
        }
        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;
        // lets do some special trim code!
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;
        // lets calculate the new untrimmed bounds..
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;
        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;
        // xy
        vertexData[0] = (a * w1) + (c * h1) + tx;
        vertexData[1] = (d * h1) + (b * w1) + ty;
        // xy
        vertexData[2] = (a * w0) + (c * h1) + tx;
        vertexData[3] = (d * h1) + (b * w0) + ty;
        // xy
        vertexData[4] = (a * w0) + (c * h0) + tx;
        vertexData[5] = (d * h0) + (b * w0) + ty;
        // xy
        vertexData[6] = (a * w1) + (c * h0) + tx;
        vertexData[7] = (d * h0) + (b * w1) + ty;
    }
    ;
    /**
    *
    * Renders the object using the WebGL renderer
    *
    * @protected
    * @param {PIXI.Renderer} renderer - The webgl renderer to use.
    */
    _render(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    }
    ;
    /**
     * Updates the bounds of the sprite.
     *
     * @protected
     */
    _calculateBounds() {
        var trim = this._texture.trim;
        var orig = this._texture.orig;
        // First lets check to see if the current texture has a trim..
        if (!trim || (trim.width === orig.width && trim.height === orig.height)) {
            // no trim! lets use the usual calculations..
            this.calculateVertices();
            this._bounds.addQuad(this.vertexData);
        }
        else {
            // lets calculate a special trimmed bounds...
            this.calculateTrimmedVertices();
            this._bounds.addQuad(this.vertexTrimmedData);
        }
    }
    ;
    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._texture.orig.width * -this._anchor._x;
            this._bounds.minY = this._texture.orig.height * -this._anchor._y;
            this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
            this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
            if (!rect) {
                if (!this._localBoundsRect) {
                    this._localBoundsRect = new Rectangle_1.Rectangle();
                }
                rect = this._localBoundsRect;
            }
            return this._bounds.getRectangle(rect);
        }
        return Container_1.Container.prototype.getLocalBounds.call(this, rect);
    }
    ;
    /**
     * Tests if a point is inside this sprite
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        this.worldTransform.applyInverse(point, Sprite.tempPoint);
        var width = this._texture.orig.width;
        var height = this._texture.orig.height;
        var x1 = -width * this.anchor.x;
        var y1 = 0;
        if (Sprite.tempPoint.x >= x1 && Sprite.tempPoint.x < x1 + width) {
            y1 = -height * this.anchor.y;
            if (Sprite.tempPoint.y >= y1 && Sprite.tempPoint.y < y1 + height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        super.destroy(options);
        // this._texture.off('update', this._onTextureUpdate, this);
        this._anchor = null;
        var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;
        if (destroyTexture) {
            var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;
            this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
        this.shader = null;
    }
    ;
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set roundPixels(value) {
        if (this._roundPixels !== value) {
            this._transformID = -1;
        }
        this._roundPixels = value;
    }
    ;
    get roundPixels() {
        return this._roundPixels;
    }
    ;
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    ;
    set width(value) {
        var s = MathSettings_1.MathSettings.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }
    ;
    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    ;
    set height(value) {
        var s = MathSettings_1.MathSettings.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }
    ;
    /**
     * The anchor sets the origin point of the text. The default value is taken from the {@link PIXI.Texture|Texture}
     * and passed to the constructor.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
     *
     * @member {PIXI.ObservablePoint}
     */
    get anchor() {
        return this._anchor;
    }
    ;
    set anchor(value) {
        this._anchor.copyFrom(value);
    }
    ;
    /**
     * The tint applied to the sprite. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    }
    ;
    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     */
    get texture() {
        return this._texture;
    }
    ;
    set texture(value) {
        if (this._texture === value) {
            return;
        }
        this._texture = value || Texture_1.Texture.EMPTY;
        this.cachedTint = 0xFFFFFF;
        this._textureID = -1;
        this._textureTrimmedID = -1;
        if (value) {
            // wait for the texture to load
            if (value.baseTexture.valid) {
                this._onTextureUpdate();
            }
            else {
                value.addEventListener('update', this._onTextureUpdate);
                // value.once('update', this._onTextureUpdate, this);
            }
        }
    }
    ;
}
Sprite.tempPoint = new Point_1.Point();
Sprite.indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
// some helper functions..
/**
 * Helper function that creates a new sprite based on the source you provide.
 * The source can be - frame id, image url, video url, canvas element, video element, base texture
 *
 * @static
 * @param {number|string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
 * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
 * @return {PIXI.Sprite} The newly created sprite
 */
Sprite.from = function from(source, options = {}) {
    if (options == null) {
        options = {};
    }
    var texture = (source instanceof Texture_1.Texture)
        ? source
        : Texture_1.Texture.from(source, options);
    return new Sprite(texture);
};
exports.Sprite = Sprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SpriteMaskFilter.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/SpriteMaskFilter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
class SpriteMaskFilter extends Filter_1.Filter {
    constructor(sprite) {
        var maskMatrix = new Matrix_1.Matrix();
        super(SpriteMaskFilter.vertex, SpriteMaskFilter.fragment);
        sprite.renderable = false;
        /**
         * Sprite mask
         * @member {PIXI.Sprite}
         */
        this.maskSprite = sprite;
        /**
         * Mask matrix
         * @member {PIXI.Matrix}
         */
        this.maskMatrix = maskMatrix;
    }
    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it.
     */
    apply(filterManager, input, output, clear) {
        var maskSprite = this.maskSprite;
        var tex = this.maskSprite.texture;
        if (!tex.valid) {
            return;
        }
        if (!tex.transform) {
            // margin = 0.0, let it bleed a bit, shader code becomes easier
            // assuming that atlas textures were made with 1-pixel padding
            tex.transform = new TextureMatrix_1.TextureMatrix(tex, 0.0);
        }
        tex.transform.update();
        this.uniforms.npmAlpha = tex.baseTexture.premultiplyAlpha ? 0.0 : 1.0;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)
            .prepend(tex.transform.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.transform.uClampFrame;
        filterManager.applyFilter(this, input, output, clear);
    }
    ;
}
SpriteMaskFilter.vertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 otherMatrix;\r\n\r\nvarying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\r\n}\r\n";
SpriteMaskFilter.fragment = "varying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mask;\r\nuniform float alpha;\r\nuniform float npmAlpha;\r\nuniform vec4 maskClamp;\r\n\r\nvoid main(void)\r\n{\r\n    float clip = step(3.5,\r\n        step(maskClamp.x, vMaskCoord.x) +\r\n        step(maskClamp.y, vMaskCoord.y) +\r\n        step(vMaskCoord.x, maskClamp.z) +\r\n        step(vMaskCoord.y, maskClamp.w));\r\n\r\n    vec4 original = texture2D(uSampler, vTextureCoord);\r\n    vec4 masky = texture2D(mask, vMaskCoord);\r\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\r\n\r\n    original *= (alphaMul * masky.r * alpha * clip);\r\n\r\n    gl_FragColor = original;\r\n}\r\n";
exports.SpriteMaskFilter = SpriteMaskFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Spritesheet.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Spritesheet.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
class Spritesheet {
    constructor(baseTexture, data, resolutionFilename = null) {
        /**
         * Reference to ths source texture
         * @type {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;
        /**
         * A map containing all textures of the sprite sheet.
         * Can be used to create a {@link PIXI.Sprite|Sprite}:
         * ```js
         * new PIXI.Sprite(sheet.textures["image.png"]);
         * ```
         * @member {Object}
         */
        this.textures = {};
        /**
         * A map containing the textures for each animation.
         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:
         * ```js
         * new PIXI.AnimatedSprite(sheet.animations["anim_name"])
         * ```
         * @member {Object}
         */
        this.animations = {};
        /**
         * Reference to the original JSON data.
         * @type {Object}
         */
        this.data = data;
        /**
         * The resolution of the spritesheet.
         * @type {number}
         */
        this.resolution = this._updateResolution(resolutionFilename
            || (this.baseTexture.resource ? this.baseTexture.resource.url : null));
        /**
         * Map of spritesheet frames.
         * @type {Object}
         * @private
         */
        this._frames = this.data.frames;
        /**
         * Collection of frame names.
         * @type {string[]}
         * @private
         */
        this._frameKeys = Object.keys(this._frames);
        /**
         * Current batch index being processed.
         * @type {number}
         * @private
         */
        this._batchIndex = 0;
        /**
         * Callback when parse is completed.
         * @type {Function}
         * @private
         */
        this._callback = null;
    }
    _updateResolution(resolutionFilename) {
        var scale = this.data.meta.scale;
        // Use a defaultValue of `null` to check if a url-based resolution is set
        var resolution = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(resolutionFilename, null);
        // No resolution found via URL
        if (resolution === null) {
            // Use the scale value or default to 1
            resolution = scale !== undefined ? parseFloat(scale) : 1;
        }
        // For non-1 resolutions, update baseTexture
        if (resolution !== 1) {
            this.baseTexture.setResolution(resolution);
        }
        return resolution;
    }
    ;
    /**
     * Generate the resolution from the filename or fallback
     * to the meta.scale field of the JSON data.
     *
     * @private
     * @param {string} resolutionFilename - The filename to use for resolving
     *    the default resolution.
     * @return {number} Resolution to use for spritesheet.
     */
    static get BATCH_SIZE() {
        return 1000;
    }
    ;
    /**
     * Parser spritesheet from loaded data. This is done asynchronously
     * to prevent creating too many Texture within a single process.
     *
     * @param {Function} callback - Callback when complete returns
     *    a map of the Textures for this spritesheet.
     */
    parse(callback) {
        this._batchIndex = 0;
        this._callback = callback;
        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
        }
        else {
            this._nextBatch();
        }
    }
    ;
    /**
     * Process a batch of frames
     *
     * @private
     * @param {number} initialFrameIndex - The index of frame to start.
     */
    _processFrames(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            var i = this._frameKeys[frameIndex];
            var data = this._frames[i];
            var rect = data.frame;
            if (rect) {
                var frame = null;
                var trim = null;
                var sourceSize = data.trimmed !== false && data.sourceSize
                    ? data.sourceSize : data.frame;
                var orig = new Rectangle_1.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
                if (data.rotated) {
                    frame = new Rectangle_1.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
                }
                else {
                    frame = new Rectangle_1.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                //  Check to see if the sprite is trimmed
                if (data.trimmed !== false && data.spriteSourceSize) {
                    trim = new Rectangle_1.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                this.textures[i] = new Texture_1.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);
                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                Texture_1.Texture.addToCache(this.textures[i], i);
            }
            frameIndex++;
        }
    }
    ;
    /**
     * Parse animations config
     *
     * @private
     */
    _processAnimations() {
        var animations = this.data.animations || {};
        for (var animName in animations) {
            this.animations[animName] = [];
            for (var i = 0; i < animations[animName].length; i++) {
                var frameName = animations[animName][i];
                this.animations[animName].push(this.textures[frameName]);
            }
        }
    }
    ;
    /**
     * The parse has completed.
     *
     * @private
     */
    _parseComplete() {
        var callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
    }
    ;
    /**
     * Begin the next batch of textures.
     *
     * @private
     */
    _nextBatch() {
        var this$1 = this;
        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function () {
            if (this$1._batchIndex * Spritesheet.BATCH_SIZE < this$1._frameKeys.length) {
                this$1._nextBatch();
            }
            else {
                this$1._processAnimations();
                this$1._parseComplete();
            }
        }, 0);
    }
    ;
    /**
     * Destroy Spritesheet and don't use after this.
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    destroy(destroyBase) {
        if (destroyBase === void 0) {
            destroyBase = false;
        }
        for (var i in this.textures) {
            this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
            this.baseTexture.destroy();
        }
        this.baseTexture = null;
    }
    ;
}
exports.Spritesheet = Spritesheet;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StageOptions.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/StageOptions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class StageOptions {
    constructor() {
        this.sharedLoader = false;
        this.forceCanvas = false;
        this.view = null;
        this.antialias = false;
        this.forceFXAA = false;
        this.autoDensity = true;
        this.autoResize = true;
        this.transparent = false;
        this.backgroundColor = 0x000000;
        this.clearBeforeRender = true;
        this.autoStart = true;
        this.preserveDrawingBuffer = false;
        this.width = 1024;
        this.height = 768;
        this.resolution = 1;
        this.legacy = false;
        this.roundPixels = false;
        this.sharedTicker = false;
        this.context = null;
        this.resizeTo = null;
        this.powerPreference = "high-performance";
    }
}
exports.StageOptions = StageOptions;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Star.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Star.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class Star extends Polygon_1.Polygon {
    constructor(x, y, points, radius, innerRadius, rotation) {
        innerRadius = innerRadius || radius / 2;
        var startAngle = (-1 * Math.PI / 2) + rotation;
        var len = points * 2;
        var delta = MathSettings_1.MathSettings.PI_2 / len;
        var polygon = [];
        for (var i = 0; i < len; i++) {
            var r = i % 2 ? innerRadius : radius;
            var angle = (i * delta) + startAngle;
            polygon.push(x + (r * Math.cos(angle)), y + (r * Math.sin(angle)));
        }
        super(polygon);
    }
}
exports.Star = Star;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/State.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/State.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class State {
    constructor() {
        this.data = 0;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
        //  this.depthTest = true;
    }
    /**
     * Activates blending of the computed fragment color values
     *
     * @member {boolean}
     */
    get blend() {
        return !!(this.data & (1 << State.BLEND));
    }
    ;
    set blend(value) {
        if (!!(this.data & (1 << State.BLEND)) !== value) {
            this.data ^= (1 << State.BLEND);
        }
    }
    ;
    /**
     * Activates adding an offset to depth values of polygon's fragments
     *
     * @member {boolean}
     * @default false
     */
    get offsets() {
        return !!(this.data & (1 << State.OFFSET));
    }
    ;
    set offsets(value) {
        if (!!(this.data & (1 << State.OFFSET)) !== value) {
            this.data ^= (1 << State.OFFSET);
        }
    }
    ;
    /**
     * Activates culling of polygons.
     *
     * @member {boolean}
     * @default false
     */
    get culling() {
        return !!(this.data & (1 << State.CULLING));
    }
    ;
    set culling(value) {
        if (!!(this.data & (1 << State.CULLING)) !== value) {
            this.data ^= (1 << State.CULLING);
        }
    }
    ;
    /**
     * Activates depth comparisons and updates to the depth buffer.
     *
     * @member {boolean}
     * @default false
     */
    get depthTest() {
        return !!(this.data & (1 << State.DEPTH_TEST));
    }
    ;
    set depthTest(value) {
        if (!!(this.data & (1 << State.DEPTH_TEST)) !== value) {
            this.data ^= (1 << State.DEPTH_TEST);
        }
    }
    ;
    /**
     * Specifies whether or not front or back-facing polygons can be culled.
     * @member {boolean}
     * @default false
     */
    get clockwiseFrontFace() {
        return !!(this.data & (1 << State.WINDING));
    }
    ;
    set clockwiseFrontFace(value) {
        if (!!(this.data & (1 << State.WINDING)) !== value) {
            this.data ^= (1 << State.WINDING);
        }
    }
    ;
    /**
     * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
     *
     * @member {boolean}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    get blendMode() {
        return this._blendMode;
    }
    ;
    set blendMode(value) {
        this.blend = (value !== BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NONE);
        this._blendMode = value;
    }
    ;
    /**
     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
     *
     * @member {number}
     * @default 0
     */
    get polygonOffset() {
        return this._polygonOffset;
    }
    ;
    set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
    }
    ;
    static for2d() {
        var state = new State();
        state.depthTest = false;
        state.blend = true;
        return state;
    }
    ;
}
State.BLEND = 0;
State.OFFSET = 1;
State.CULLING = 2;
State.DEPTH_TEST = 3;
State.WINDING = 4;
exports.State = State;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StateSystem.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/StateSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class StateSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * GL context
         * @member {WebGLRenderingContext}
         * @readonly
         */
        this.gl = null;
        /**
         * State ID
         * @member {number}
         * @readonly
         */
        this.stateId = 0;
        /**
         * Polygon offset
         * @member {number}
         * @readonly
         */
        this.polygonOffset = 0;
        /**
         * Blend mode
         * @member {number}
         * @default PIXI.BLEND_MODES.NONE
         * @readonly
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NONE;
        /**
         * Whether current blend equation is different
         * @member {boolean}
         * @protected
         */
        this._blendEq = false;
        /**
         * Collection of calls
         * @member {function[]}
         * @readonly
         */
        this.map = [];
        // map functions for when we set state..
        this.map[StateSystem.BLEND$1] = this.setBlend;
        this.map[StateSystem.OFFSET$1] = this.setOffset;
        this.map[StateSystem.CULLING$1] = this.setCullFace;
        this.map[StateSystem.DEPTH_TEST$1] = this.setDepthTest;
        this.map[StateSystem.WINDING$1] = this.setFrontFace;
        /**
         * Collection of check calls
         * @member {function[]}
         * @readonly
         */
        this.checks = [];
        /**
         * Default WebGL State
         * @member {PIXI.State}
         * @readonly
         */
        this.defaultState = new State_1.State();
        this.defaultState.blend = true;
        this.defaultState.depth = true;
    }
    contextChange(gl) {
        this.gl = gl;
        this.blendModes = BlendModesSettings_1.BlendModesSettings.mapWebGLBlendModesToPixi(gl);
        this.setState(this.defaultState);
        this.reset();
    }
    ;
    /**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */
    setState(state) {
        state = state || this.defaultState;
        // TODO maybe to an object check? ( this.state === state )?
        if (this.stateId !== state.data) {
            var diff = this.stateId ^ state.data;
            var i = 0;
            // order from least to most common
            while (diff) {
                if (diff & 1) {
                    // state change!
                    this.map[i].call(this, !!(state.data & (1 << i)));
                }
                diff = diff >> 1;
                i++;
            }
            this.stateId = state.data;
        }
        // based on the above settings we check for specific modes..
        // for example if blend is active we check and set the blend modes
        // or of polygon offset is active we check the poly depth.
        for (var i$1 = 0; i$1 < this.checks.length; i$1++) {
            this.checks[i$1](this, state);
        }
    }
    ;
    /**
     * Sets the state, when previous state is unknown
     *
     * @param {*} state - The state to set
     */
    forceState(state) {
        state = state || this.defaultState;
        for (var i = 0; i < this.map.length; i++) {
            this.map[i].call(this, !!(state.data & (1 << i)));
        }
        for (var i$1 = 0; i$1 < this.checks.length; i$1++) {
            this.checks[i$1](this, state);
        }
        this.stateId = state.data;
    }
    ;
    /**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */
    setBlend(value) {
        this.updateCheck(StateSystem.checkBlendMode, value);
        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
    }
    ;
    /**
     * Enables or disable polygon offset fill
     *
     * @param {boolean} value - Turn on or off webgl polygon offset testing.
     */
    setOffset(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
    }
    ;
    /**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */
    setDepthTest(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
    }
    ;
    /**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */
    setCullFace(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
    }
    ;
    /**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */
    setFrontFace(value) {
        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
    }
    ;
    /**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */
    setBlendMode(value) {
        if (value === this.blendMode) {
            return;
        }
        this.blendMode = value;
        var mode = this.blendModes[value];
        var gl = this.gl;
        if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
        }
        else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
        }
        else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
    }
    ;
    /**
     * Sets the polygon offset.
     *
     * @param {number} value - the polygon offset
     * @param {number} scale - the polygon offset scale
     */
    setPolygonOffset(value, scale) {
        this.gl.polygonOffset(value, scale);
    }
    ;
    // used
    /**
     * Resets all the logic and disables the vaos
     */
    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(0);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
    }
    ;
    /**
     * checks to see which updates should be checked based on which settings have been activated.
     * For example, if blend is enabled then we should check the blend modes each time the state is changed
     * or if polygon fill is activated then we need to check if the polygon offset changes.
     * The idea is that we only check what we have too.
     *
     * @param {Function} func  the checking function to add or remove
     * @param {boolean} value  should the check function be added or removed.
     */
    updateCheck(func, value) {
        var index = this.checks.indexOf(func);
        if (value && index === -1) {
            this.checks.push(func);
        }
        else if (!value && index !== -1) {
            this.checks.splice(index, 1);
        }
    }
    ;
    /**
     * A private little wrapper function that we call to check the blend mode.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System  the System to perform the state check on
     * @param {PIXI.State} state  the state that the blendMode will pulled from
     */
    static checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
    }
    ;
}
StateSystem.UID$4 = 0;
StateSystem.BLEND$1 = 0;
StateSystem.OFFSET$1 = 1;
StateSystem.CULLING$1 = 2;
StateSystem.DEPTH_TEST$1 = 3;
StateSystem.WINDING$1 = 4;
exports.StateSystem = StateSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StencilSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/StencilSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
class StencilSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        this.stencilMaskStack = [];
    }
    /**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
     */
    setMaskStack(stencilMaskStack) {
        var gl = this.renderer.gl;
        if (stencilMaskStack.length !== this.stencilMaskStack.length) {
            if (stencilMaskStack.length === 0) {
                gl.disable(gl.STENCIL_TEST);
            }
            else {
                gl.enable(gl.STENCIL_TEST);
            }
        }
        this.stencilMaskStack = stencilMaskStack;
    }
    ;
    /**
     * Applies the Mask and adds it to the current stencil stack. @alvin
     *
     * @param {PIXI.Graphics} graphics - The mask
     */
    pushStencil(graphics) {
        var gl = this.renderer.gl;
        var prevMaskCount = this.stencilMaskStack.length;
        if (prevMaskCount === 0) {
            gl.enable(gl.STENCIL_TEST);
        }
        this.stencilMaskStack.push(graphics);
        // Increment the reference stencil value where the new mask overlaps with the old ones.
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        graphics.renderable = true;
        graphics.render(this.renderer);
        this.renderer.batch.flush();
        graphics.renderable = false;
        this._useCurrent();
    }
    ;
    /**
     * Removes the last mask from the stencil stack. @alvin
     */
    popStencil() {
        var gl = this.renderer.gl;
        var graphics = this.stencilMaskStack.pop();
        if (this.stencilMaskStack.length === 0) {
            // the stack is empty!
            gl.disable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.clearStencil(0);
        }
        else {
            // Decrement the reference stencil value where the popped mask overlaps with the other ones
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            graphics.renderable = true;
            graphics.render(this.renderer);
            this.renderer.batch.flush();
            graphics.renderable = false;
            this._useCurrent();
        }
    }
    ;
    /**
     * Setup renderer to use the current stencil data.
     * @private
     */
    _useCurrent() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    }
    ;
    /**
     * Fill 1s equal to the number of acitve stencil masks.
     * @private
     * @return {number} The bitwise mask.
     */
    _getBitwiseMask() {
        return (1 << this.stencilMaskStack.length) - 1;
    }
    ;
    /**
     * Destroys the mask stack.
     *
     */
    destroy() {
        super.destroy();
        this.stencilMaskStack = null;
    }
    ;
}
exports.StencilSystem = StencilSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/System.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/System.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
class System extends EventDispatcher_1.EventDispatcher {
    constructor(renderer = null) {
        super();
        this.renderer = renderer;
        this.renderer.runners.contextChange.add(this);
    }
    contextChange(gl) {
    }
    ;
    destroy(options = null) {
        this.renderer.runners.contextChange.remove(this);
        this.renderer = null;
    }
    ;
}
exports.System = System;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Text.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Text.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const TextMetrics_1 = __webpack_require__(/*! ./TextMetrics */ "./js-compile/raw-pixi-ts/TextMetrics.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const CanvasSettings_1 = __webpack_require__(/*! ./CanvasSettings */ "./js-compile/raw-pixi-ts/CanvasSettings.js");
const TextSettings_1 = __webpack_require__(/*! ./TextSettings */ "./js-compile/raw-pixi-ts/TextSettings.js");
const CleanUpSettings_1 = __webpack_require__(/*! ./CleanUpSettings */ "./js-compile/raw-pixi-ts/CleanUpSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class Text extends Sprite_1.Sprite {
    constructor(text, style = null, canvas = null) {
        canvas = canvas || document.createElement('canvas');
        canvas.width = 3;
        canvas.height = 3;
        var texture = Texture_1.Texture.from(canvas);
        texture.orig = new Rectangle_1.Rectangle();
        texture.trim = new Rectangle_1.Rectangle();
        super(texture);
        /**
         * The canvas element that everything is drawn to
         *
         * @member {HTMLCanvasElement}
         */
        this.canvas = canvas;
        /**
         * The canvas 2d context that everything is drawn with
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
        /**
         * The resolution / device pixel ratio of the canvas.
         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
         * @member {number}
         * @default 1
         */
        this._resolution = DisplaySettings_1.DisplaySettings.RESOLUTION;
        this._autoResolution = true;
        /**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */
        this._text = null;
        /**
         * Private tracker for the current style.
         *
         * @member {object}
         * @private
         */
        this._style = null;
        /**
         * Private listener to track style changes.
         *
         * @member {Function}
         * @private
         */
        this._styleListener = null;
        /**
         * Private tracker for the current font.
         *
         * @member {string}
         * @private
         */
        this._font = '';
        this.text = text;
        this.style = style;
        this.localStyleID = -1;
    }
    /**
     * Renders text and updates it when needed.
     *
     * @private
     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
     */
    updateText(respectDirty) {
        var style = this._style;
        // check if style has changed..
        if (this.localStyleID !== style.styleID) {
            this.dirty = true;
            this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
            return;
        }
        this._font = this._style.toFontString();
        var context = this.context;
        TextMetrics_1.TextMetrics.init();
        var measured = TextMetrics_1.TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas);
        var width = measured.width;
        var height = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * this._resolution);
        this.canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * this._resolution);
        context.scale(this._resolution, this._resolution);
        context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context.font = this._font;
        context.strokeStyle = style.stroke;
        context.lineWidth = style.strokeThickness;
        context.textBaseline = style.textBaseline;
        context.lineJoin = style.lineJoin;
        context.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        if (style.dropShadow) {
            var dropShadowColor = style.dropShadowColor;
            var rgb = ColorSettings_1.ColorSettings.hex2rgb(typeof dropShadowColor === 'number' ? dropShadowColor : MathSettings_1.MathSettings.string2hex(dropShadowColor));
            context.shadowColor = "rgba(" + (rgb[0] * 255) + "," + (rgb[1] * 255) + "," + (rgb[2] * 255) + "," + (style.dropShadowAlpha) + ")";
            context.shadowBlur = style.dropShadowBlur;
            context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
        }
        else {
            context.shadowColor = 0;
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
        }
        // set canvas text styles
        context.fillStyle = this._generateFillStyle(style, lines);
        // draw lines line by line
        for (var i = 0; i < lines.length; i++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;
            if (style.align === 'right') {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if (style.align === 'center') {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding, true);
            }
            if (style.fill) {
                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding);
            }
        }
        this.updateTexture();
    }
    ;
    /**
     * Render the text with letter-spacing.
     * @param {string} text - The text to draw
     * @param {number} x - Horizontal position to draw the text
     * @param {number} y - Vertical position to draw the text
     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
     *  text? If not, it's for the inside fill
     * @private
     */
    drawLetterSpacing(text, x, y, isStroke = false) {
        if (isStroke === void 0) {
            isStroke = false;
        }
        var style = this._style;
        // letterSpacing of 0 means normal
        var letterSpacing = style.letterSpacing;
        if (letterSpacing === 0) {
            if (isStroke) {
                this.context.strokeText(text, x, y);
            }
            else {
                this.context.fillText(text, x, y);
            }
            return;
        }
        var characters = String.prototype.split.call(text, '');
        var currentPosition = x;
        var index = 0;
        var current = '';
        while (index < text.length) {
            current = characters[index++];
            if (isStroke) {
                this.context.strokeText(current, currentPosition, y);
            }
            else {
                this.context.fillText(current, currentPosition, y);
            }
            currentPosition += this.context.measureText(current).width + letterSpacing;
        }
    }
    ;
    /**
     * Updates texture size based on canvas size
     *
     * @private
     */
    updateTexture() {
        var canvas = this.canvas;
        if (this._style.trim) {
            var trimmed = CanvasSettings_1.CanvasSettings.trimCanvas(canvas);
            if (trimmed.data) {
                canvas.width = trimmed.width;
                canvas.height = trimmed.height;
                this.context.putImageData(trimmed.data, 0, 0);
            }
        }
        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = canvas.width / this._resolution;
        texture.trim.height = texture._frame.height = canvas.height / this._resolution;
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - (padding * 2);
        texture.orig.height = texture._frame.height - (padding * 2);
        // call sprite onTextureUpdate to update scale if _width or _height were set
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
        this.dirty = false;
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
            this._resolution = renderer.resolution;
            this.dirty = true;
        }
        this.updateText(true);
        super.render(renderer);
    }
    ;
    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    _renderCanvas(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
            this._resolution = renderer.resolution;
            this.dirty = true;
        }
        this.updateText(true);
        // super._renderCanvas(renderer);
    }
    ;
    /**
     * Gets the local bounds of the text object.
     *
     * @param {Rectangle} rect - The output rectangle.
     * @return {Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        this.updateText(true);
        return super.getLocalBounds(rect);
    }
    ;
    /**
     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
     * @protected
     */
    _calculateBounds() {
        this.updateText(true);
        this.calculateVertices();
        // if we have already done this on THIS frame.
        this._bounds.addQuad(this.vertexData);
    }
    ;
    /**
     * Method to be called upon a TextStyle change.
     * @private
     */
    _onStyleChange() {
        this.dirty = true;
    }
    ;
    /**
     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
     *
     * @private
     * @param {object} style - The style.
     * @param {string[]} lines - The lines of text.
     * @return {string|number|CanvasGradient} The fill style
     */
    _generateFillStyle(style, lines) {
        if (!Array.isArray(style.fill)) {
            return style.fill;
        }
        // the gradient will be evenly spaced out according to how large the array is.
        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75
        var gradient;
        var totalIterations;
        var currentIteration;
        var stop;
        var width = this.canvas.width / this._resolution;
        var height = this.canvas.height / this._resolution;
        // make a copy of the style settings, so we can manipulate them later
        var fill = style.fill.slice();
        var fillGradientStops = style.fillGradientStops.slice();
        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
        if (!fillGradientStops.length) {
            var lengthPlus1 = fill.length + 1;
            for (var i = 1; i < lengthPlus1; ++i) {
                fillGradientStops.push(i / lengthPlus1);
            }
        }
        // stop the bleeding of the last gradient on the line above to the top gradient of the this line
        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1
        fill.unshift(style.fill[0]);
        fillGradientStops.unshift(0);
        fill.push(style.fill[style.fill.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === TextSettings_1.TextSettings.TEXT_GRADIENT.LINEAR_VERTICAL) {
            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);
            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect
            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875
            totalIterations = (fill.length + 1) * lines.length;
            currentIteration = 0;
            for (var i$1 = 0; i$1 < lines.length; i$1++) {
                currentIteration += 1;
                for (var j = 0; j < fill.length; j++) {
                    if (typeof fillGradientStops[j] === 'number') {
                        stop = (fillGradientStops[j] / lines.length) + (i$1 / lines.length);
                    }
                    else {
                        stop = currentIteration / totalIterations;
                    }
                    gradient.addColorStop(stop, fill[j]);
                    currentIteration++;
                }
            }
        }
        else {
            // start the gradient at the center left of the canvas, and end at the center right of the canvas
            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);
            // can just evenly space out the gradients in this case, as multiple lines makes no difference
            // to an even left to right gradient
            totalIterations = fill.length + 1;
            currentIteration = 1;
            for (var i$2 = 0; i$2 < fill.length; i$2++) {
                if (typeof fillGradientStops[i$2] === 'number') {
                    stop = fillGradientStops[i$2];
                }
                else {
                    stop = currentIteration / totalIterations;
                }
                gradient.addColorStop(stop, fill[i$2]);
                currentIteration++;
            }
        }
        return gradient;
    }
    ;
    /**
     * Destroys this text object.
     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
     * the majority of the time the texture will not be shared with any other Sprites.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        if (typeof options === 'boolean') {
            options = { children: options };
        }
        options = Object.assign({}, CleanUpSettings_1.CleanUpSettings.defaultDestroyOptions, options);
        super.destroy(options);
        // make sure to reset the the context and canvas.. dont want this hanging around in memory!
        this.context = null;
        this.canvas = null;
        this._style = null;
    }
    ;
    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        this.updateText(true);
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    ;
    set width(value) {
        this.updateText(true);
        var s = MathSettings_1.MathSettings.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }
    ;
    /**
     * The height of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        this.updateText(true);
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    ;
    set height(value) {
        this.updateText(true);
        var s = MathSettings_1.MathSettings.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }
    ;
    /**
     * Set the style of the text. Set up an event listener to listen for changes on the style
     * object and mark the text as dirty.
     *
     * @member {object|PIXI.TextStyle}
     */
    get style() {
        return this._style;
    }
    ;
    set style(style) {
        style = style || {};
        if (style instanceof TextStyle_1.TextStyle) {
            this._style = style;
        }
        else {
            this._style = new TextStyle_1.TextStyle(style);
        }
        this.localStyleID = -1;
        this.dirty = true;
    }
    ;
    /**
     * Set the copy for the text object. To split a line you can use '\n'.
     *
     * @member {string}
     */
    get text() {
        return this._text;
    }
    ;
    set text(text) {
        text = String(text === null || text === undefined ? '' : text);
        if (this._text === text) {
            return;
        }
        this._text = text;
        this.dirty = true;
    }
    ;
    /**
     * The resolution / device pixel ratio of the canvas.
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @member {number}
     * @default 1
     */
    get resolution() {
        return this._resolution;
    }
    ;
    set resolution(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
            return;
        }
        this._resolution = value;
        this.dirty = true;
    }
    ;
}
exports.Text = Text;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextMetrics.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextMetrics.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextMetrics {
    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        if (!TextMetrics.canvas) {
            TextMetrics.canvas = document.createElement('canvas');
            TextMetrics.canvas.width = TextMetrics.canvas.height = 10;
            TextMetrics._canvas = TextMetrics.canvas;
            TextMetrics._context = TextMetrics.canvas.getContext('2d');
        }
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
    }
    static init() {
        if (!TextMetrics.canvas) {
            TextMetrics.canvas = document.createElement('canvas');
            TextMetrics.canvas.width = TextMetrics.canvas.height = 10;
            TextMetrics._canvas = TextMetrics.canvas;
            TextMetrics._context = TextMetrics.canvas.getContext('2d');
        }
    }
    /**
     * Measures the supplied string of text and returns a Rectangle.
     *
     * @param {string} text - the text to measure.
     * @param {PIXI.TextStyle} style - the text style to use for measuring
     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {PIXI.TextMetrics} measured width and height of the text.
     */
    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas) {
        wordWrap = (wordWrap === undefined || wordWrap === null) ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics.measureFont(font);
        // fallback in case UA disallow canvas data extraction
        // (toDataURI, getImageData functions)
        if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
        }
        var context = canvas.getContext('2d');
        context.font = font;
        var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
            width += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)
            + ((lines.length - 1) * (lineHeight + style.leading));
        if (style.dropShadow) {
            height += style.dropShadowDistance;
        }
        return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    }
    ;
    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     *
     * @private
     * @param {string} text - String to apply word wrapping to
     * @param {PIXI.TextStyle} style - the style to use when wrapping
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {string} New string with new lines applied where required
     */
    static wordWrap(text, style, canvas) {
        if (canvas === void 0) {
            canvas = TextMetrics._canvas;
        }
        var context = canvas.getContext('2d');
        var width = 0;
        var line = '';
        var lines = '';
        var cache = {};
        var letterSpacing = style.letterSpacing;
        var whiteSpace = style.whiteSpace;
        // How to handle whitespaces
        var collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);
        // whether or not spaces may be added to the beginning of lines
        var canPrependSpaces = !collapseSpaces;
        // There is letterSpacing after every char except the last one
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!
        // so for convenience the above needs to be compared to width + 1 extra letterSpace
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_
        // ________________________________________________
        // And then the final space is simply no appended to each line
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        // break text into words, spaces and newline chars
        var tokens = TextMetrics.tokenize(text);
        for (var i = 0; i < tokens.length; i++) {
            // get the word, space or newlineChar
            var token = tokens[i];
            // if word is a new line
            if (TextMetrics.isNewline(token)) {
                // keep the new line
                if (!collapseNewlines) {
                    lines += TextMetrics.addLine(line);
                    canPrependSpaces = !collapseSpaces;
                    line = '';
                    width = 0;
                    continue;
                }
                // if we should collapse new lines
                // we simply convert it into a space
                token = ' ';
            }
            // if we should collapse repeated whitespaces
            if (collapseSpaces) {
                // check both this and the last tokens for spaces
                var currIsBreakingSpace = TextMetrics.isBreakingSpace(token);
                var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);
                if (currIsBreakingSpace && lastIsBreakingSpace) {
                    continue;
                }
            }
            // get word width from cache if possible
            var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);
            // word is longer than desired bounds
            if (tokenWidth > wordWrapWidth) {
                // if we are not already at the beginning of a line
                if (line !== '') {
                    // start newlines for overflow words
                    lines += TextMetrics.addLine(line);
                    line = '';
                    width = 0;
                }
                // break large word over multiple lines
                if (TextMetrics.canBreakWords(token, style.breakWords)) {
                    // break word into characters
                    var characters = token.split('');
                    // loop the characters
                    for (var j = 0; j < characters.length; j++) {
                        var char = characters[j];
                        var k = 1;
                        // we are not at the end of the token
                        while (characters[j + k]) {
                            var nextChar = characters[j + k];
                            var lastChar = char[char.length - 1];
                            // should not split chars
                            if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                                // combine chars & move forward one
                                char += nextChar;
                            }
                            else {
                                break;
                            }
                            k++;
                        }
                        j += char.length - 1;
                        var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);
                        if (characterWidth + width > wordWrapWidth) {
                            lines += TextMetrics.addLine(line);
                            canPrependSpaces = false;
                            line = '';
                            width = 0;
                        }
                        line += char;
                        width += characterWidth;
                    }
                }
                // run word out of the bounds
                else {
                    // if there are words in this line already
                    // finish that line and start a new one
                    if (line.length > 0) {
                        lines += TextMetrics.addLine(line);
                        line = '';
                        width = 0;
                    }
                    var isLastToken = i === tokens.length - 1;
                    // give it its own line if it's not the end
                    lines += TextMetrics.addLine(token, !isLastToken);
                    canPrependSpaces = false;
                    line = '';
                    width = 0;
                }
            }
            // word could fit
            else {
                // word won't fit because of existing words
                // start a new line
                if (tokenWidth + width > wordWrapWidth) {
                    // if its a space we don't want it
                    canPrependSpaces = false;
                    // add a new line
                    lines += TextMetrics.addLine(line);
                    // start a new line
                    line = '';
                    width = 0;
                }
                // don't add spaces to the beginning of lines
                if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                    // add the word to the current line
                    line += token;
                    // update width counter
                    width += tokenWidth;
                }
            }
        }
        lines += TextMetrics.addLine(line, false);
        return lines;
    }
    ;
    /**
     * Convienience function for logging each line added during the wordWrap
     * method
     *
     * @private
     * @param  {string}   line    - The line of text to add
     * @param  {boolean}  newLine - Add new line character to end
     * @return {string}   A formatted line
     */
    static addLine(line, newLine = true) {
        if (newLine === void 0) {
            newLine = true;
        }
        line = TextMetrics.trimRight(line);
        line = (newLine) ? (line + "\n") : line;
        return line;
    }
    ;
    /**
     * Gets & sets the widths of calculated characters in a cache object
     *
     * @private
     * @param  {string}                key        The key
     * @param  {number}                letterSpacing  The letter spacing
     * @param  {object}                cache      The cache
     * @param  {CanvasRenderingContext2D}  context    The canvas context
     * @return {number}                The from cache.
     */
    static getFromCache(key, letterSpacing, cache, context) {
        var width = cache[key];
        if (width === undefined) {
            var spacing = ((key.length) * letterSpacing);
            width = context.measureText(key).width + spacing;
            cache[key] = width;
        }
        return width;
    }
    ;
    /**
     * Determines whether we should collapse breaking spaces
     *
     * @private
     * @param  {string}   whiteSpace  The TextStyle property whiteSpace
     * @return {boolean}  should collapse
     */
    static collapseSpaces(whiteSpace) {
        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');
    }
    ;
    /**
     * Determines whether we should collapse newLine chars
     *
     * @private
     * @param  {string}   whiteSpace  The white space
     * @return {boolean}  should collapse
     */
    static collapseNewlines(whiteSpace) {
        return (whiteSpace === 'normal');
    }
    ;
    /**
     * trims breaking whitespaces from string
     *
     * @private
     * @param  {string}  text  The text
     * @return {string}  trimmed string
     */
    static trimRight(text) {
        if (typeof text !== 'string') {
            return '';
        }
        for (var i = text.length - 1; i >= 0; i--) {
            var char = text[i];
            if (!TextMetrics.isBreakingSpace(char)) {
                break;
            }
            text = text.slice(0, -1);
        }
        return text;
    }
    ;
    /**
     * Determines if char is a newline.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if newline, False otherwise.
     */
    static isNewline(char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0);
    }
    ;
    /**
     * Determines if char is a breaking whitespace.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if whitespace, False otherwise.
     */
    static isBreakingSpace(char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0);
    }
    ;
    /**
     * Splits a string into words, breaking-spaces and newLine characters
     *
     * @private
     * @param  {string}  text   The text
     * @return {string[]}  A tokenized array
     */
    static tokenize(text) {
        var tokens = [];
        var token = '';
        if (typeof text !== 'string') {
            return tokens;
        }
        for (var i = 0; i < text.length; i++) {
            var char = text[i];
            if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {
                if (token !== '') {
                    tokens.push(token);
                    token = '';
                }
                tokens.push(char);
                continue;
            }
            token += char;
        }
        if (token !== '') {
            tokens.push(token);
        }
        return tokens;
    }
    ;
    /**
     * This method exists to be easily overridden
     * It allows one to customise which words should break
     * Examples are if the token is CJK or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  token   The token
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */
    static canBreakWords(token, breakWords) {
        return breakWords;
    }
    ;
    /**
     * This method exists to be easily overridden
     * It allows one to determine whether a pair of characters
     * should be broken by newlines
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  char  The character
     * @param  {string}  nextChar  The next character
     * @param  {string}  token The token/word the characters are from
     * @param  {number}  index The index in the token of the char
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */
    static canBreakChars(char, nextChar, token, index, breakWords) {
        return true;
    }
    ;
    /**
     * Calculates the ascent, descent and fontSize of a given font-style
     *
     * @static
     * @param {string} font - String representing the style of the font
     * @return {PIXI.IFontMetrics} Font properties object
     */
    static measureFont(font) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
        }
        var properties = {};
        var canvas = TextMetrics._canvas;
        var context = TextMetrics._context;
        context.font = font;
        var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
        var height = 2 * baseline;
        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            }
            else {
                break;
            }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var j$1 = 0; j$1 < line; j$1 += 4) {
                if (imagedata[idx + j$1] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx -= line;
            }
            else {
                break;
            }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics._fonts[font] = properties;
        return properties;
    }
    ;
    /**
     * Clear font metrics in metrics cache.
     *
     * @static
     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
     */
    static clearMetrics(font) {
        if (font === void 0) {
            font = '';
        }
        if (font) {
            delete TextMetrics._fonts[font];
        }
        else {
            TextMetrics._fonts = {};
        }
    }
    ;
}
/**
 * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.
 *
 * @typedef {object} FontMetrics
 * @property {number} ascent - The ascent distance
 * @property {number} descent - The descent distance
 * @property {number} fontSize - Font size from ascent to descent
 * @memberof PIXI.TextMetrics
 * @private
 */
/**
 * Cache of {@see PIXI.TextMetrics.FontMetrics} objects.
 * @memberof PIXI.TextMetrics
 * @type {Object}
 * @private
 */
TextMetrics._fonts = {};
/**
 * String used for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name METRICS_STRING
 * @type {string}
 * @default |Éq
 */
TextMetrics.METRICS_STRING = '|Éq';
/**
 * Baseline symbol for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_SYMBOL
 * @type {string}
 * @default M
 */
TextMetrics.BASELINE_SYMBOL = 'M';
/**
 * Baseline multiplier for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_MULTIPLIER
 * @type {number}
 * @default 1.4
 */
TextMetrics.BASELINE_MULTIPLIER = 1.4;
/**
 * Cache of new line chars.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._newlines = [
    0x000A,
    0x000D
];
/**
 * Cache of breaking spaces.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._breakingSpaces = [
    0x0009,
    0x0020,
    0x2000,
    0x2001,
    0x2002,
    0x2003,
    0x2004,
    0x2005,
    0x2006,
    0x2008,
    0x2009,
    0x200A,
    0x205F,
    0x3000
];
exports.TextMetrics = TextMetrics;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextSettings.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextSettings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextSettings {
}
TextSettings.TEXT_GRADIENT = {
    LINEAR_VERTICAL: 0,
    LINEAR_HORIZONTAL: 1,
};
TextSettings.defaultStyle = {
    align: 'left',
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: 'black',
    dropShadowDistance: 5,
    fill: 'black',
    fillGradientType: TextSettings.TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: 'Arial',
    fontSize: 26,
    fontStyle: 'normal',
    fontVariant: 'normal',
    fontWeight: 'normal',
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: 'miter',
    miterLimit: 10,
    padding: 0,
    stroke: 'black',
    strokeThickness: 0,
    textBaseline: 'alphabetic',
    trim: false,
    whiteSpace: 'pre',
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0,
};
exports.TextSettings = TextSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TextSettings_1 = __webpack_require__(/*! ./TextSettings */ "./js-compile/raw-pixi-ts/TextSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class TextStyle {
    constructor(style) {
        this.styleID = 0;
        this.reset();
        UtilsSettings_1.UtilsSettings.deepCopyProperties(this, style, style);
    }
    /**
     * Creates a new TextStyle object with the same values as this one.
     * Note that the only the properties of the object are cloned.
     *
     * @return {PIXI.TextStyle} New cloned TextStyle object
     */
    clone() {
        var clonedProperties = {};
        UtilsSettings_1.UtilsSettings.deepCopyProperties(clonedProperties, this, TextSettings_1.TextSettings.defaultStyle);
        return new TextStyle(clonedProperties);
    }
    ;
    /**
     * Resets all properties to the defaults specified in TextStyle.prototype._default
     */
    reset() {
        UtilsSettings_1.UtilsSettings.deepCopyProperties(this, TextSettings_1.TextSettings.defaultStyle, TextSettings_1.TextSettings.defaultStyle);
    }
    ;
    /**
     * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     *
     * @member {string}
     */
    get align() {
        return this._align;
    }
    ;
    set align(align) {
        if (this._align !== align) {
            this._align = align;
            this.styleID++;
        }
    }
    ;
    /**
     * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
     *
     * @member {boolean}
     */
    get breakWords() {
        return this._breakWords;
    }
    ;
    set breakWords(breakWords) {
        if (this._breakWords !== breakWords) {
            this._breakWords = breakWords;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a drop shadow for the text
     *
     * @member {boolean}
     */
    get dropShadow() {
        return this._dropShadow;
    }
    ;
    set dropShadow(dropShadow) {
        if (this._dropShadow !== dropShadow) {
            this._dropShadow = dropShadow;
            this.styleID++;
        }
    }
    ;
    /**
     * Set alpha for the drop shadow
     *
     * @member {number}
     */
    get dropShadowAlpha() {
        return this._dropShadowAlpha;
    }
    ;
    set dropShadowAlpha(dropShadowAlpha) {
        if (this._dropShadowAlpha !== dropShadowAlpha) {
            this._dropShadowAlpha = dropShadowAlpha;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a angle of the drop shadow
     *
     * @member {number}
     */
    get dropShadowAngle() {
        return this._dropShadowAngle;
    }
    ;
    set dropShadowAngle(dropShadowAngle) {
        if (this._dropShadowAngle !== dropShadowAngle) {
            this._dropShadowAngle = dropShadowAngle;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a shadow blur radius
     *
     * @member {number}
     */
    get dropShadowBlur() {
        return this._dropShadowBlur;
    }
    ;
    set dropShadowBlur(dropShadowBlur) {
        if (this._dropShadowBlur !== dropShadowBlur) {
            this._dropShadowBlur = dropShadowBlur;
            this.styleID++;
        }
    }
    ;
    /**
     * A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     *
     * @member {string|number}
     */
    get dropShadowColor() {
        return this._dropShadowColor;
    }
    ;
    set dropShadowColor(dropShadowColor) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(dropShadowColor);
        if (this._dropShadowColor !== outputColor) {
            this._dropShadowColor = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a distance of the drop shadow
     *
     * @member {number}
     */
    get dropShadowDistance() {
        return this._dropShadowDistance;
    }
    ;
    set dropShadowDistance(dropShadowDistance) {
        if (this._dropShadowDistance !== dropShadowDistance) {
            this._dropShadowDistance = dropShadowDistance;
            this.styleID++;
        }
    }
    ;
    /**
     * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
     * Can be an array to create a gradient eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     *
     * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
     */
    get fill() {
        return this._fill;
    }
    ;
    set fill(fill) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(fill);
        if (this._fill !== outputColor) {
            this._fill = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
     * See {@link PIXI.TEXT_GRADIENT}
     *
     * @member {number}
     */
    get fillGradientType() {
        return this._fillGradientType;
    }
    ;
    set fillGradientType(fillGradientType) {
        if (this._fillGradientType !== fillGradientType) {
            this._fillGradientType = fillGradientType;
            this.styleID++;
        }
    }
    ;
    /**
     * If fill is an array of colours to create a gradient, this array can set the stop points
     * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     *
     * @member {number[]}
     */
    get fillGradientStops() {
        return this._fillGradientStops;
    }
    ;
    set fillGradientStops(fillGradientStops) {
        if (!UtilsSettings_1.UtilsSettings.areArraysEqual(this._fillGradientStops, fillGradientStops)) {
            this._fillGradientStops = fillGradientStops;
            this.styleID++;
        }
    }
    ;
    /**
     * The font family
     *
     * @member {string|string[]}
     */
    get fontFamily() {
        return this._fontFamily;
    }
    ;
    set fontFamily(fontFamily) {
        if (this.fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.styleID++;
        }
    }
    ;
    /**
     * The font size
     * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
     *
     * @member {number|string}
     */
    get fontSize() {
        return this._fontSize;
    }
    ;
    set fontSize(fontSize) {
        if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this.styleID++;
        }
    }
    ;
    /**
     * The font style
     * ('normal', 'italic' or 'oblique')
     *
     * @member {string}
     */
    get fontStyle() {
        return this._fontStyle;
    }
    ;
    set fontStyle(fontStyle) {
        if (this._fontStyle !== fontStyle) {
            this._fontStyle = fontStyle;
            this.styleID++;
        }
    }
    ;
    /**
     * The font variant
     * ('normal' or 'small-caps')
     *
     * @member {string}
     */
    get fontVariant() {
        return this._fontVariant;
    }
    ;
    set fontVariant(fontVariant) {
        if (this._fontVariant !== fontVariant) {
            this._fontVariant = fontVariant;
            this.styleID++;
        }
    }
    ;
    /**
     * The font weight
     * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
     *
     * @member {string}
     */
    get fontWeight() {
        return this._fontWeight;
    }
    ;
    set fontWeight(fontWeight) {
        if (this._fontWeight !== fontWeight) {
            this._fontWeight = fontWeight;
            this.styleID++;
        }
    }
    ;
    /**
     * The amount of spacing between letters, default is 0
     *
     * @member {number}
     */
    get letterSpacing() {
        return this._letterSpacing;
    }
    ;
    set letterSpacing(letterSpacing) {
        if (this._letterSpacing !== letterSpacing) {
            this._letterSpacing = letterSpacing;
            this.styleID++;
        }
    }
    ;
    /**
     * The line height, a number that represents the vertical space that a letter uses
     *
     * @member {number}
     */
    get lineHeight() {
        return this._lineHeight;
    }
    ;
    set lineHeight(lineHeight) {
        if (this._lineHeight !== lineHeight) {
            this._lineHeight = lineHeight;
            this.styleID++;
        }
    }
    ;
    /**
     * The space between lines
     *
     * @member {number}
     */
    get leading() {
        return this._leading;
    }
    ;
    set leading(leading) {
        if (this._leading !== leading) {
            this._leading = leading;
            this.styleID++;
        }
    }
    ;
    /**
     * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
     * Default is 'miter' (creates a sharp corner).
     *
     * @member {string}
     */
    get lineJoin() {
        return this._lineJoin;
    }
    ;
    set lineJoin(lineJoin) {
        if (this._lineJoin !== lineJoin) {
            this._lineJoin = lineJoin;
            this.styleID++;
        }
    }
    ;
    /**
     * The miter limit to use when using the 'miter' lineJoin mode
     * This can reduce or increase the spikiness of rendered text.
     *
     * @member {number}
     */
    get miterLimit() {
        return this._miterLimit;
    }
    ;
    set miterLimit(miterLimit) {
        if (this._miterLimit !== miterLimit) {
            this._miterLimit = miterLimit;
            this.styleID++;
        }
    }
    ;
    /**
     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
     * by adding padding to all sides of the text.
     *
     * @member {number}
     */
    get padding() {
        return this._padding;
    }
    ;
    set padding(padding) {
        if (this._padding !== padding) {
            this._padding = padding;
            this.styleID++;
        }
    }
    ;
    /**
     * A canvas fillstyle that will be used on the text stroke
     * e.g 'blue', '#FCFF00'
     *
     * @member {string|number}
     */
    get stroke() {
        return this._stroke;
    }
    ;
    set stroke(stroke) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(stroke);
        if (this._stroke !== outputColor) {
            this._stroke = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * A number that represents the thickness of the stroke.
     * Default is 0 (no stroke)
     *
     * @member {number}
     */
    get strokeThickness() {
        return this._strokeThickness;
    }
    ;
    set strokeThickness(strokeThickness) {
        if (this._strokeThickness !== strokeThickness) {
            this._strokeThickness = strokeThickness;
            this.styleID++;
        }
    }
    ;
    /**
     * The baseline of the text that is rendered.
     *
     * @member {string}
     */
    get textBaseline() {
        return this._textBaseline;
    }
    ;
    set textBaseline(textBaseline) {
        if (this._textBaseline !== textBaseline) {
            this._textBaseline = textBaseline;
            this.styleID++;
        }
    }
    ;
    /**
     * Trim transparent borders
     *
     * @member {boolean}
     */
    get trim() {
        return this._trim;
    }
    ;
    set trim(trim) {
        if (this._trim !== trim) {
            this._trim = trim;
            this.styleID++;
        }
    }
    ;
    /**
     * How newlines and spaces should be handled.
     * Default is 'pre' (preserve, preserve).
     *
     *  value   | New lines |   Spaces
     *  ---     | ---       |   ---
     * 'normal' | Collapse  |   Collapse
     * 'pre'    | Preserve  |   Preserve
     * 'pre-line'   | Preserve  |   Collapse
     *
     * @member {string}
     */
    get whiteSpace() {
        return this._whiteSpace;
    }
    ;
    set whiteSpace(whiteSpace) {
        if (this._whiteSpace !== whiteSpace) {
            this._whiteSpace = whiteSpace;
            this.styleID++;
        }
    }
    ;
    /**
     * Indicates if word wrap should be used
     *
     * @member {boolean}
     */
    get wordWrap() {
        return this._wordWrap;
    }
    ;
    set wordWrap(wordWrap) {
        if (this._wordWrap !== wordWrap) {
            this._wordWrap = wordWrap;
            this.styleID++;
        }
    }
    ;
    /**
     * The width at which text will wrap, it needs wordWrap to be set to true
     *
     * @member {number}
     */
    get wordWrapWidth() {
        return this._wordWrapWidth;
    }
    ;
    set wordWrapWidth(wordWrapWidth) {
        if (this._wordWrapWidth !== wordWrapWidth) {
            this._wordWrapWidth = wordWrapWidth;
            this.styleID++;
        }
    }
    ;
    /**
     * Generates a font style string to use for `TextMetrics.measureFont()`.
     *
     * @return {string} Font style string, for passing to `TextMetrics.measureFont()`
     */
    toFontString() {
        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
        var fontSizeString = (typeof this.fontSize === 'number') ? ((this.fontSize) + "px") : this.fontSize;
        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
            fontFamilies = this.fontFamily.split(',');
        }
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();
            // Check if font already contains strings
            if (!(/([\"\'])[^\'\"]+\1/).test(fontFamily)) {
                fontFamily = "\"" + fontFamily + "\"";
            }
            fontFamilies[i] = fontFamily;
        }
        return ((this.fontStyle) + " " + (this.fontVariant) + " " + (this.fontWeight) + " " + fontSizeString + " " + (fontFamilies.join(',')));
    }
    ;
}
exports.TextStyle = TextStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Texture.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Texture.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const TextureUvs_1 = __webpack_require__(/*! ./TextureUvs */ "./js-compile/raw-pixi-ts/TextureUvs.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ImageResource_1 = __webpack_require__(/*! ./ImageResource */ "./js-compile/raw-pixi-ts/ImageResource.js");
const CanvasResource_1 = __webpack_require__(/*! ./CanvasResource */ "./js-compile/raw-pixi-ts/CanvasResource.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Texture extends EventDispatcher_1.EventDispatcher {
    constructor(baseTexture, frame = null, orig = null, trim = null, rotate = null, anchor = null) {
        super();
        /**
         * Called when the base texture is updated
         *
         * @protected
         * @param {PIXI.BaseTexture} baseTexture - The base texture.
         */
        this.onBaseTextureUpdated = (baseTexture) => {
            Logger_1.trace("onBaseTextureUpdated");
            this._updateID++;
            // TODO this code looks confusing.. boo to abusing getters and setters!
            if (this.noFrame) {
                this.frame = new Rectangle_1.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            }
            else {
                this.frame = this._frame;
                // TODO maybe watch out for the no frame option
                // updating the texture will should update the frame if it was set to no frame..
            }
            this.valid = this.baseTexture.valid;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update', this);
            // this.baseTexture.addEventListener("update", this.onBaseTextureUpdated)
        };
        this.noFrame = false;
        if (!frame) {
            this.noFrame = true;
            frame = new Rectangle_1.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture) {
            baseTexture = baseTexture.baseTexture;
        }
        /**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;
        /**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */
        this._frame = frame;
        /**
         * This is the trimmed area of original texture, before it was put in atlas
         * Please call `updateUvs()` after you change coordinates of `trim` manually.
         *
         * @member {PIXI.Rectangle}
         */
        this.trim = trim;
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = false;
        /**
         * This will let a renderer know that a texture has been updated (used mainly for WebGL uv updates)
         *
         * @member {boolean}
         */
        this.requiresUpdate = false;
        /**
         * The WebGL UV data cache. Can be used as quad UV
         *
         * @member {PIXI.TextureUvs}
         * @protected
         */
        this._uvs = Texture.DEFAULT_UVS;
        /**
         * Default TextureMatrix instance for this texture
         * By default that object is not created because its heavy
         *
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = null;
        /**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */
        this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);
        this._rotate = Number(rotate || 0);
        if (rotate === true) {
            // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
            this._rotate = 2;
        }
        else if (this._rotate % 2 !== 0) {
            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
        }
        if (baseTexture.valid) {
            if (this.noFrame) {
                frame = new Rectangle_1.Rectangle(0, 0, baseTexture.width, baseTexture.height);
                // if there is no frame we should monitor for any base texture changes..
                baseTexture.addEventListener("update", this.onBaseTextureUpdated);
                // baseTexture.on('update', this.onBaseTextureUpdated, this);
            }
            this.frame = frame;
        }
        else {
            baseTexture.addEventListener("loaded", this.onBaseTextureUpdated);
            // baseTexture.once('loaded', this.onBaseTextureUpdated, this);
        }
        /**
         * Anchor point that is used as default if sprite is created with this texture.
         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
         * @member {PIXI.Point}
         * @default {0,0}
         */
        if (anchor) {
            this.defaultAnchor = new Point_1.Point(anchor.x, anchor.y);
        }
        else {
            this.defaultAnchor = new Point_1.Point(0, 0);
        }
        /**
         * Update ID is observed by sprites and TextureMatrix instances.
         * Call updateUvs() to increment it.
         *
         * @member {number}
         * @protected
         */
        this._updateID = 0;
        /**
         * The ids under which this Texture has been added to the texture cache. This is
         * automatically set as long as Texture.addToCache is used, but may not be set if a
         * Texture is added directly to the TextureCache array.
         *
         * @member {string[]}
         */
        this.textureCacheIds = [];
    }
    /**
     * Updates this texture on the gpu.
     *
     */
    update() {
        this.baseTexture.update();
    }
    ;
    /**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    destroy(destroyBase) {
        if (this.baseTexture) {
            if (destroyBase) {
                // delete the texture if it exists in the texture cache..
                // this only needs to be removed if the base texture is actually destroyed too..
                if (CacheSettings_1.CacheSettings.TextureCache[this.baseTexture.imageUrl]) {
                    Texture.removeFromCache(this.baseTexture.imageUrl);
                }
                this.baseTexture.destroy();
            }
            // this.baseTexture.remo('update', this.onBaseTextureUpdated, this);
            this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;
        this.valid = false;
        Texture.removeFromCache(this);
        this.textureCacheIds = null;
    }
    ;
    /**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */
    clone() {
        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);
    }
    ;
    /**
     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
     * Call it after changing the frame
     */
    updateUvs() {
        if (this._uvs === Texture.DEFAULT_UVS) {
            this._uvs = new TextureUvs_1.TextureUvs();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
    }
    ;
    /**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture} source
     *        Source to create texture from
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Texture} The newly created texture
     */
    static from(source, options = {}) {
        var cacheId = null;
        if (typeof source === 'string') {
            cacheId = source;
        }
        else {
            if (!source._pixiId) {
                source._pixiId = "pixiid_" + (MathSettings_1.MathSettings.uid());
            }
            cacheId = source._pixiId;
        }
        var texture = CacheSettings_1.CacheSettings.TextureCache[cacheId];
        if (!texture) {
            if (options['resolution'] == undefined) {
                options.resolution = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(source);
            }
            texture = new Texture(new BaseTexture_1.BaseTexture(source, options));
            texture.baseTexture.cacheId = cacheId;
            BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, cacheId);
            Texture.addToCache(texture, cacheId);
        }
        // lets assume its a base texture!
        return texture;
    }
    ;
    /**
     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the Texture will be stored against.
     */
    static addToCache(texture, id) {
        if (id) {
            if (texture.textureCacheIds.indexOf(id) === -1) {
                texture.textureCacheIds.push(id);
            }
            if (CacheSettings_1.CacheSettings.TextureCache[id]) {
                // eslint-disable-next-line no-console
                console.warn(("Texture added to the cache with an id [" + id + "] that already had an entry"));
            }
            CacheSettings_1.CacheSettings.TextureCache[id] = texture;
        }
    }
    ;
    /**
     * Remove a Texture from the global TextureCache.
     *
     * @static
     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
     * @return {PIXI.Texture|null} The Texture that was removed
     */
    static removeFromCache(texture) {
        if (typeof texture === 'string') {
            var textureFromCache = CacheSettings_1.CacheSettings.TextureCache[texture];
            if (textureFromCache) {
                var index = textureFromCache.textureCacheIds.indexOf(texture);
                if (index > -1) {
                    textureFromCache.textureCacheIds.splice(index, 1);
                }
                delete CacheSettings_1.CacheSettings.TextureCache[texture];
                return textureFromCache;
            }
        }
        else if (texture && texture.textureCacheIds) {
            for (var i = 0; i < texture.textureCacheIds.length; ++i) {
                // Check that texture matches the one being passed in before deleting it from the cache.
                if (CacheSettings_1.CacheSettings.TextureCache[texture.textureCacheIds[i]] === texture) {
                    delete CacheSettings_1.CacheSettings.TextureCache[texture.textureCacheIds[i]];
                }
            }
            texture.textureCacheIds.length = 0;
            return texture;
        }
        return null;
    }
    ;
    /**
     * The frame specifies the region of the base texture that this texture uses.
     * Please call `updateUvs()` after you change coordinates of `frame` manually.
     *
     * @member {PIXI.Rectangle}
     */
    get frame() {
        return this._frame;
    }
    ;
    set frame(frame) {
        this._frame = frame;
        this.noFrame = false;
        var x = frame.x;
        var y = frame.y;
        var width = frame.width;
        var height = frame.height;
        var xNotFit = x + width > this.baseTexture.width;
        var yNotFit = y + height > this.baseTexture.height;
        if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? 'and' : 'or';
            var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + (this.baseTexture.width);
            var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + (this.baseTexture.height);
            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: '
                + errorX + " " + relationship + " " + errorY);
        }
        this.valid = width && height && this.baseTexture.valid;
        if (!this.trim && !this.rotate) {
            this.orig = frame;
        }
        if (this.valid) {
            this.updateUvs();
        }
    }
    ;
    /**
     * Indicates whether the texture is rotated inside the atlas
     * set to 2 to compensate for texture packer rotation
     * set to 6 to compensate for spine packer rotation
     * can be used to rotate or mirror sprites
     * See {@link PIXI.GroupD8} for explanation
     *
     * @member {number}
     */
    get rotate() {
        return this._rotate;
    }
    ;
    set rotate(rotate) {
        this._rotate = rotate;
        if (this.valid) {
            this.updateUvs();
        }
    }
    ;
    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    get width() {
        return this.orig.width;
    }
    ;
    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    get height() {
        return this.orig.height;
    }
    ;
    /**
     * An empty texture, used often to not have to create multiple empty textures.
     * Can not be destroyed.
     *
     * @static
     * @constant
     * @member {PIXI.Texture}
     */
    static get EMPTY() {
        return new Texture(new BaseTexture_1.BaseTexture());
    }
    /**
 * A white texture of 10x10 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */
    static get WHITE() {
        return Texture.createWhiteTexture();
    }
    static createWhiteTexture() {
        var canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 16, 16);
        return new Texture(new BaseTexture_1.BaseTexture(new CanvasResource_1.CanvasResource(canvas)));
    }
}
Texture.DEFAULT_UVS = new TextureUvs_1.TextureUvs();
/**
 * Create a new Texture with a BufferResource from a Float32Array.
 * RGBA values are floats from 0 to 1.
 * @static
 * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
 *        is provided, a new Float32Array is created.
 * @param {number} width - Width of the resource
 * @param {number} height - Height of the resource
 * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
 * @return {PIXI.Texture} The resulting new BaseTexture
 */
Texture.fromBuffer = function fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture_1.BaseTexture.fromBuffer(buffer, width, height, options));
};
/**
 * Create a texture from a source and add to the cache.
 *
 * @static
 * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
 * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
 * @param {String} [name] - Human readable name for the texture cache. If no name is
 *        specified, only `imageUrl` will be used as the cache ID.
 * @return {PIXI.Texture} Output texture
 */
Texture.fromLoader = function fromLoader(source, imageUrl, name) {
    var resource = new ImageResource_1.ImageResource(source);
    resource.url = imageUrl;
    var baseTexture = new BaseTexture_1.BaseTexture(resource, {
        scaleMode: DisplaySettings_1.DisplaySettings.SCALE_MODE,
        resolution: NetworkSettings_1.NetworkSettings.getResolutionOfUrl(imageUrl),
    });
    var texture = new Texture(baseTexture);
    // No name, use imageUrl instead
    if (!name) {
        name = imageUrl;
    }
    // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
    BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    // also add references by url if they are different.
    if (name !== imageUrl) {
        BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture.addToCache(texture, imageUrl);
    }
    return texture;
};
exports.Texture = Texture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureGCSystem.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureGCSystem.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class TextureGCSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Count
         * @member {number}
         * @readonly
         */
        this.count = 0;
        /**
         * Check count
         * @member {number}
         * @readonly
         */
        this.checkCount = 0;
        /**
         * Maximum idle time, in seconds
         * @member {number}
         * @see PIXI.settings.GC_MAX_IDLE
         */
        this.maxIdle = settings_1.settings.GC_MAX_IDLE;
        /**
         * Maximum number of itesm to check
         * @member {number}
         * @see PIXI.settings.GC_MAX_CHECK_COUNT
         */
        this.checkCountMax = settings_1.settings.GC_MAX_CHECK_COUNT;
        /**
         * Current garabage collection mode
         * @member {PIXI.GC_MODES}
         * @see PIXI.settings.GC_MODE
         */
        this.mode = settings_1.settings.GC_MODE;
    }
    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    postrender() {
        this.count++;
        if (this.mode === settings_1.settings.GC_MODES.MANUAL) {
            return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
        }
    }
    ;
    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    run() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i = 0; i < managedTextures.length; i++) {
            var texture = managedTextures[i];
            // only supports non generated textures at the moment!
            if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
                tm.destroyTexture(texture, true);
                managedTextures[i] = null;
                wasRemoved = true;
            }
        }
        if (wasRemoved) {
            var j = 0;
            for (var i$1 = 0; i$1 < managedTextures.length; i$1++) {
                if (managedTextures[i$1] !== null) {
                    managedTextures[j++] = managedTextures[i$1];
                }
            }
            managedTextures.length = j;
        }
    }
    ;
    /**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */
    unload(displayObject) {
        // var tm = this.renderer.textureSystem;
        var tm = this.renderer.texture;
        // only destroy non generated textures
        if (displayObject._texture && displayObject._texture._glRenderTargets) {
            tm.destroyTexture(displayObject._texture);
        }
        for (var i = displayObject.children.length - 1; i >= 0; i--) {
            this.unload(displayObject.children[i]);
        }
    }
    ;
}
exports.TextureGCSystem = TextureGCSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureMatrix.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureMatrix.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class TextureMatrix {
    constructor(texture, clampMargin = null) {
        this._texture = texture;
        this.mapCoord = new Matrix_1.Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        /**
         * Tracks Texture frame changes
         * @member {number}
         * @protected
         */
        this._updateID = -1;
        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
         *
         * @default 0
         * @member {number}
         */
        this.clampOffset = 0;
        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */
        this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;
        /**
         * If texture size is the same as baseTexture
         * @member {boolean}
         * @default false
         * @readonly
         */
        this.isSimple = false;
    }
    /**
     * texture property
     * @member {PIXI.Texture}
     */
    get texture() {
        return this._texture;
    }
    ;
    set texture(value) {
        this._texture = value;
        this._updateID = -1;
    }
    ;
    /**
     * Multiplies uvs array to transform
     * @param {Float32Array} uvs mesh uvs
     * @param {Float32Array} [out=uvs] output
     * @returns {Float32Array} output
     */
    multiplyUvs(uvs, out) {
        if (out === undefined) {
            out = uvs;
        }
        var mat = this.mapCoord;
        for (var i = 0; i < uvs.length; i += 2) {
            var x = uvs[i];
            var y = uvs[i + 1];
            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;
            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;
        }
        return out;
    }
    ;
    /**
     * updates matrices if texture was changed
     * @param {boolean} forceUpdate if true, matrices will be updated any case
     * @returns {boolean} whether or not it was updated
     */
    update(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
            return false;
        }
        if (!forceUpdate
            && this._updateID === tex._updateID) {
            return false;
        }
        this._updateID = tex._updateID;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim = tex.trim;
        if (trim) {
            TextureMatrix.tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
            this.mapCoord.append(TextureMatrix.tempMat);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.realWidth;
        this.uClampOffset[1] = offset / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width
            && tex._frame.height === texBase.height
            && tex.rotate === 0;
        return true;
    }
    ;
}
TextureMatrix.tempMat = new Matrix_1.Matrix();
exports.TextureMatrix = TextureMatrix;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const GLTexture_1 = __webpack_require__(/*! ./GLTexture */ "./js-compile/raw-pixi-ts/GLTexture.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class TextureSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // TODO set to max textures...
        /**
         * Bound textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.boundTextures = [];
        /**
         * Current location
         * @member {number}
         * @readonly
         */
        this.currentLocation = -1;
        /**
         * List of managed textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.managedTextures = [];
        /**
         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
         * @member {boolean}
         * @private
         */
        this._unknownBoundTextures = false;
        /**
         * BaseTexture value that shows that we don't know what is bound
         * @member {PIXI.BaseTexture}
         * @readonly
         */
        this.unknownTexture = new BaseTexture_1.BaseTexture();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i = 0; i < maxTextures; i++) {
            this.boundTextures[i] = null;
        }
        // TODO move this.. to a nice make empty textures class..
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture_1.GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture_1.GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i$1 = 0; i$1 < 6; i$1++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i$1, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i$2 = 0; i$2 < this.boundTextures.length; i$2++) {
            this.bind(null, i$2);
        }
    }
    ;
    /**
     * Bind a texture to a specific location
     *
     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
     *
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     * @param {number} [location=0] - Location to bind at
     */
    bind(texture, location = 0) {
        var ref = this;
        var gl = ref.gl;
        if (texture) {
            texture = texture.baseTexture || texture;
            if (texture.valid) {
                texture.touched = this.renderer.textureGC.count;
                var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
                if (this.currentLocation !== location) {
                    this.currentLocation = location;
                    gl.activeTexture(gl.TEXTURE0 + location);
                }
                if (this.boundTextures[location] !== texture) {
                    gl.bindTexture(texture.target, glTexture.texture);
                }
                if (glTexture.dirtyId !== texture.dirtyId) {
                    this.updateTexture(texture);
                }
                this.boundTextures[location] = texture;
            }
        }
        else {
            if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
            }
            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
            this.boundTextures[location] = null;
        }
    }
    ;
    /**
     * Resets texture location and bound textures
     *
     * Actual `bind(null, i)` calls will be performed at next `unbind()` call
     */
    reset() {
        this._unknownBoundTextures = true;
        this.currentLocation = -1;
        for (var i = 0; i < this.boundTextures.length; i++) {
            this.boundTextures[i] = this.unknownTexture;
        }
    }
    ;
    /**
     * Unbind a texture
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     */
    unbind(texture) {
        var ref = this;
        var gl = ref.gl;
        var boundTextures = ref.boundTextures;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = false;
            // someone changed webGL state,
            // we have to be sure that our texture does not appear in multi-texture renderer samplers
            for (var i = 0; i < boundTextures.length; i++) {
                if (boundTextures[i] === this.unknownTexture) {
                    this.bind(null, i);
                }
            }
        }
        for (var i$1 = 0; i$1 < boundTextures.length; i$1++) {
            if (boundTextures[i$1] === texture) {
                if (this.currentLocation !== i$1) {
                    gl.activeTexture(gl.TEXTURE0 + i$1);
                    this.currentLocation = i$1;
                }
                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[texture.target].texture);
                boundTextures[i$1] = null;
            }
        }
    }
    ;
    /**
     * Initialize a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    initTexture(texture) {
        var glTexture = new GLTexture_1.GLTexture(this.gl.createTexture());
        // guarantee an update..
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        // texture.on('dispose', this.destroyTexture, this);
        return glTexture;
    }
    ;
    /**
     * Update a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    updateTexture(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        var renderer = this.renderer;
        if (texture.resource && texture.resource.canUpload) {
            texture.resource.upload(renderer, texture, glTexture);
        }
        // if (texture.resource && texture.resource.upload(renderer, texture, glTexture))
        else if (texture.resource && this.uploadTexture(renderer, texture, glTexture, texture.resource)) {
        }
        else {
            // default, renderTexture-like logic
            var width = texture.realWidth;
            var height = texture.realHeight;
            var gl = renderer.gl;
            if (glTexture.width !== width
                || glTexture.height !== height
                || glTexture.dirtyId < 0) {
                glTexture.width = width;
                glTexture.height = height;
                gl.texImage2D(texture.target, 0, texture.format, width, height, 0, texture.format, texture.type, null);
            }
        }
        // lets only update what changes..
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
            this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
    }
    ;
    uploadTexture(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        // source = source || this.source;
        if (source.constructor['name'] == "CanvasResource") {
            source = source.source;
        }
        else if (source.constructor['name'] == "ImageResource") {
            source = source.source;
        }
        else if (source.constructor['name'] == "VideoResource") {
            source = source.source;
        }
        // else if(source.constructor['name'] == "GradientResource")
        // {
        //     if(!source.source)
        //     {
        //         return
        //     }
        //     source = source.source
        //     reveal(source)
        // }
        else {
            Logger_1.reveal(source);
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else {
            glTexture.width = width;
            glTexture.height = height;
            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
    }
    ;
    /**
     * Deletes the texture from WebGL
     *
     * @private
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */
    destroyTexture(texture, skipRemove = false) {
        var ref = this;
        var gl = ref.gl;
        texture = texture.baseTexture || texture;
        if (texture._glTextures[this.renderer.CONTEXT_UID]) {
            this.unbind(texture);
            gl.deleteTexture(texture._glTextures[this.renderer.CONTEXT_UID].texture);
            // texture.off('dispose', this.destroyTexture, this);
            delete texture._glTextures[this.renderer.CONTEXT_UID];
            if (!skipRemove) {
                var i = this.managedTextures.indexOf(texture);
                if (i !== -1) {
                    UtilsSettings_1.UtilsSettings.removeItems(this.managedTextures, i, 1);
                }
            }
        }
    }
    ;
    /**
     * Update texture style such as mipmap flag
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     */
    updateTextureStyle(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
            return;
        }
        if ((texture.mipmap === WebGLSettings_1.WebGLSettings.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
            glTexture.mipmap = 0;
            glTexture.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP;
        }
        else {
            glTexture.mipmap = texture.mipmap >= 1;
            glTexture.wrapMode = texture.wrapMode;
        }
        // if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
        // { ; }
        // else
        // {
        this.setStyle(texture, glTexture);
        // }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
    }
    ;
    /**
     * Set style for texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     * @param {glTexture} glTexture
     */
    setStyle(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap) {
            gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
            /* eslint-disable max-len */
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
            /* eslint-disable max-len */
        }
        else {
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
    }
    ;
}
exports.TextureSystem = TextureSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureUvs.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureUvs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const GroupD8_1 = __webpack_require__(/*! ./GroupD8 */ "./js-compile/raw-pixi-ts/GroupD8.js");
class TextureUvs {
    constructor() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
    }
    /**
 * Sets the texture Uvs based on the given frame information.
 *
 * @protected
 * @param {PIXI.Rectangle} frame - The frame of the texture
 * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
 * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
 */
    set(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;
        if (rotate) {
            // width and height div 2 div baseFrame size
            var w2 = frame.width / 2 / tw;
            var h2 = frame.height / 2 / th;
            // coordinates of center
            var cX = (frame.x / tw) + w2;
            var cY = (frame.y / th) + h2;
            rotate = GroupD8_1.GroupD8.add(rotate, GroupD8_1.GroupD8.NW); // NW is top-left corner
            this.x0 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y0 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2); // rotate 90 degrees clockwise
            this.x1 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y1 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2);
            this.x2 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y2 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2);
            this.x3 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y3 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
        }
        else {
            this.x0 = frame.x / tw;
            this.y0 = frame.y / th;
            this.x1 = (frame.x + frame.width) / tw;
            this.y1 = frame.y / th;
            this.x2 = (frame.x + frame.width) / tw;
            this.y2 = (frame.y + frame.height) / th;
            this.x3 = frame.x / tw;
            this.y3 = (frame.y + frame.height) / th;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
    }
    ;
}
exports.TextureUvs = TextureUvs;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Ticker.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Ticker.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const TickerListener_1 = __webpack_require__(/*! ./TickerListener */ "./js-compile/raw-pixi-ts/TickerListener.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class Ticker extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        var this$1 = this;
        /**
         * The first listener. All new listeners added are chained on this.
         * @private
         * @type {TickerListener}
         */
        this._head = new TickerListener_1.TickerListener(null, null, Infinity);
        /**
         * Internal current frame request ID
         * @type {?number}
         * @private
         */
        this._requestId = null;
        /**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         * @type {number}
         * @private
         */
        this._maxElapsedMS = 100;
        /**
         * Internal value managed by maxFPS property setter and getter.
         * This is the minimum allowed milliseconds between updates.
         * @private
         */
        this._minElapsedMS = 0;
        /**
         * Whether or not this ticker should invoke the method
         * {@link PIXI.Ticker#start} automatically
         * when a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.autoStart = false;
        /**
         * Scalar time value from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         *
         * @member {number}
         * @default 1
         */
        this.deltaTime = 1;
        /**
         * Scaler time elapsed in milliseconds from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.deltaMS = 1 / settings_1.settings.TARGET_FPMS;
        /**
         * Time elapsed in milliseconds from last frame to this frame.
         * Opposed to what the scalar {@link PIXI.Ticker#deltaTime}
         * is based, this value is neither capped nor scaled.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.elapsedMS = 1 / settings_1.settings.TARGET_FPMS;
        /**
         * The last time {@link PIXI.Ticker#update} was invoked.
         * This value is also reset internally outside of invoking
         * update, but only when a new animation frame is requested.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         *
         * @member {number}
         * @default -1
         */
        this.lastTime = -1;
        /**
         * Factor of current {@link PIXI.Ticker#deltaTime}.
         * @example
         * // Scales ticker.deltaTime to what would be
         * // the equivalent of approximately 120 FPS
         * ticker.speed = 2;
         *
         * @member {number}
         * @default 1
         */
        this.speed = 1;
        /**
         * Whether or not this ticker has been started.
         * `true` if {@link PIXI.Ticker#start} has been called.
         * `false` if {@link PIXI.Ticker#stop} has been called.
         * While `false`, this value may change to `true` in the
         * event of {@link PIXI.Ticker#autoStart} being `true`
         * and a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.started = false;
        /**
         * If enabled, deleting is disabled.
         * @member {boolean}
         * @default false
         * @private
         */
        this._protected = false;
        /**
         * Internal tick method bound to ticker instance.
         * This is because in early 2015, Function.bind
         * is still 60% slower in high performance scenarios.
         * Also separating frame requests from update method
         * so listeners may be called at any time and with
         * any animation API, just invoke ticker.update(time).
         *
         * @private
         * @param {number} time - Time since last tick.
         */
        this._tick = function (time) {
            this$1._requestId = null;
            if (this$1.started) {
                // Invoke listeners now
                this$1.update(time);
                // Listener side effects may have modified ticker state.
                if (this$1.started && this$1._requestId === null && this$1._head.next) {
                    this$1._requestId = requestAnimationFrame(this$1._tick);
                }
            }
        };
    }
    /**
     * Internally adds the event handler so that it can be sorted by priority.
     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
     * before the rendering.
     *
     * @private
     * @param {TickerListener} listener - Current listener being added.
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    _addListener(listener) {
        // For attaching to head
        var current = this._head.next;
        var previous = this._head;
        // Add the first item
        if (!current) {
            listener.connect(previous);
        }
        else {
            // Go from highest to lowest priority
            while (current) {
                if (listener.priority > current.priority) {
                    listener.connect(previous);
                    break;
                }
                previous = current;
                current = current.next;
            }
            // Not yet connected
            if (!listener.previous) {
                listener.connect(previous);
            }
        }
        this._startIfPossible();
        return this;
    }
    ;
    /**
     * Triggers an update. An update entails setting the
     * current {@link PIXI.Ticker#elapsedMS},
     * the current {@link PIXI.Ticker#deltaTime},
     * invoking all listeners with current deltaTime,
     * and then finally setting {@link PIXI.Ticker#lastTime}
     * with the value of currentTime that was provided.
     * This method will be called automatically by animation
     * frame callbacks if the ticker instance has been started
     * and listeners are added.
     *
     * @param {number} [currentTime=performance.now()] - the current time of execution
     */
    update(currentTime) {
        if (currentTime === void 0) {
            currentTime = performance.now();
        }
        var elapsedMS;
        // If the difference in time is zero or negative, we ignore most of the work done here.
        // If there is no valid difference, then should be no reason to let anyone know about it.
        // A zero delta, is exactly that, nothing should update.
        //
        // The difference in time can be negative, and no this does not mean time traveling.
        // This can be the result of a race condition between when an animation frame is requested
        // on the current JavaScript engine event loop, and when the ticker's start method is invoked
        // (which invokes the internal _requestIfNeeded method). If a frame is requested before
        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
        // can receive a time argument that can be less than the lastTime value that was set within
        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
        //
        // This check covers this browser engine timing issue, as well as if consumers pass an invalid
        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.
        if (currentTime > this.lastTime) {
            // Save uncapped elapsedMS for measurement
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            // cap the milliseconds elapsed used for deltaTime
            if (elapsedMS > this._maxElapsedMS) {
                elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            // if not enough time has passed, exit the function.
            // We give an extra ms to elapsedMS for this check, because the nature of
            // request animation frame means that not all browsers will return precise values.
            // However, because rAF works based on v-sync, it's won't change the effective FPS.
            if (this._minElapsedMS && elapsedMS + 1 < this._minElapsedMS) {
                return;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * settings_1.settings.TARGET_FPMS;
            // Cache a local reference, in-case ticker is destroyed
            // during the emit, we can still check for head.next
            var head = this._head;
            // Invoke listeners added to internal emitter
            var listener = head.next;
            while (listener) {
                listener = listener.emit(this.deltaTime);
            }
            if (!head.next) {
                this._cancelIfNeeded();
            }
        }
        else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
    }
    ;
    /**
     * Destroy the ticker and don't use after this. Calling
     * this method removes all references to internal events.
     */
    destroy() {
        if (!this._protected) {
            this.stop();
            var listener = this._head.next;
            while (listener) {
                listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
        }
    }
    ;
    /**
     * Stops the ticker. If the ticker has requested
     * an animation frame it is canceled at this point.
     */
    stop() {
        if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
        }
    }
    ;
    /**
     * Starts the ticker. If the ticker has listeners
     * a new animation frame is requested at this point.
     */
    start() {
        if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
        }
    }
    ;
    /**
     * Removes any handlers matching the function and context parameters.
     * If no handlers are left after removing, then it cancels the animation frame.
     *
     * @param {Function} fn - The listener function to be removed
     * @param {*} [context] - The listener context to be removed
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    remove(fn, context) {
        var listener = this._head.next;
        while (listener) {
            // We found a match, lets remove it
            // no break to delete all possible matches
            // incase a listener was added 2+ times
            if (listener.match(fn, context)) {
                listener = listener.destroy();
            }
            else {
                listener = listener.next;
            }
        }
        if (!this._head.next) {
            this._cancelIfNeeded();
        }
        return this;
    }
    ;
    /**
     * Add a handler for the tick event which is only execute once.
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    addOnce(fn, context, priority) {
        if (priority === void 0) {
            priority = Ticker.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener_1.TickerListener(fn, context, priority, true));
    }
    ;
    /**
     * Register a handler for tick events. Calls continuously unless
     * it is removed or the ticker is stopped.
     *
     * @param {Function} fn - The listener function to be added for updates
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    add(fn, context = null, priority = null) {
        if (priority === void 0) {
            priority = Ticker.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener_1.TickerListener(fn, context, priority));
    }
    ;
    /**
     * Conditionally requests a new animation frame.
     * If the ticker has been started it checks if a frame has not already
     * been requested, and if the internal emitter has listeners. If these
     * conditions are met, a new frame is requested. If the ticker has not
     * been started, but autoStart is `true`, then the ticker starts now,
     * and continues with the previous conditions to request a new frame.
     *
     * @private
     */
    _startIfPossible() {
        if (this.started) {
            this._requestIfNeeded();
        }
        else if (this.autoStart) {
            this.start();
        }
    }
    ;
    /**
     * Conditionally cancels a pending animation frame.
     *
     * @private
     */
    _cancelIfNeeded() {
        if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
    }
    ;
    /**
 * Conditionally requests a new animation frame.
 * If a frame has not already been requested, and if the internal
 * emitter has listeners, a new frame is requested.
 *
 * @private
 */
    _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
            // ensure callbacks get correct delta
            this.lastTime = performance.now();
            this._requestId = requestAnimationFrame(this._tick);
        }
    }
    ;
    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.Ticker#speed}, which is specific
     * to scaling {@link PIXI.Ticker#deltaTime}.
     *
     * @member {number}
     * @readonly
     */
    get FPS() {
        return 1000 / this.elapsedMS;
    }
    ;
    /**
     * Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This value is used to cap {@link PIXI.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
     *
     * @member {number}
     * @default 10
     */
    get minFPS() {
        return 1000 / this._maxElapsedMS;
    }
    ;
    set minFPS(fps) {
        // Minimum must be below the maxFPS
        var minFPS = Math.min(this.maxFPS, fps);
        // Must be at least 0, but below 1 / settings.TARGET_FPMS
        var minFPMS = Math.min(Math.max(0, minFPS) / 1000, settings_1.settings.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
    }
    ;
    set maxFPS(fps) {
        if (fps / 1000 >= settings_1.settings.TARGET_FPMS) {
            this._minElapsedMS = 0;
        }
        else {
            // Max must be at least the minFPS
            var maxFPS = Math.max(this.minFPS, fps);
            // Must be at least 1, but below 1 / settings.TARGET_FPMS
            var maxFPMS = Math.min(Math.max(1, maxFPS) / 1000, settings_1.settings.TARGET_FPMS);
            this._minElapsedMS = 1 / maxFPMS;
        }
    }
    ;
    /**
 * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
 * {@link PIXI.VideoResource} to update animation frames / video textures.
 *
 * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
 *
 * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
 * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
 *
 * @example
 * let ticker = PIXI.Ticker.shared;
 * // Set this to prevent starting this ticker when listeners are added.
 * // By default this is true only for the PIXI.Ticker.shared instance.
 * ticker.autoStart = false;
 * // FYI, call this to ensure the ticker is stopped. It should be stopped
 * // if you have not attempted to render anything yet.
 * ticker.stop();
 * // Call this when you are ready for a running shared ticker.
 * ticker.start();
 *
 * @example
 * // You may use the shared ticker to render...
 * let renderer = PIXI.autoDetectRenderer();
 * let stage = new PIXI.Container();
 * document.body.appendChild(renderer.view);
 * ticker.add(function (time) {
 * renderer.render(stage);
 * });
 *
 * @example
 * // Or you can just update it manually.
 * ticker.autoStart = false;
 * ticker.stop();
 * function animate(time) {
 * ticker.update(time);
 * renderer.render(stage);
 * requestAnimationFrame(animate);
 * }
 * animate(performance.now());
 *
 * @member {PIXI.Ticker}
 * @static
 */
    static get shared() {
        if (!Ticker._shared) {
            var shared = Ticker._shared = new Ticker();
            shared.autoStart = true;
            shared._protected = true;
        }
        return Ticker._shared;
    }
    ;
    /**
     * The system ticker instance used by {@link PIXI.interaction.InteractionManager} and by
     * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
     * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
     *
     * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
     *
     * @member {PIXI.Ticker}
     * @static
     */
    static get system() {
        if (!Ticker._system) {
            var system = Ticker._system = new Ticker();
            system.autoStart = true;
            system._protected = true;
        }
        return Ticker._system;
    }
    ;
    /**
     * Manages the minimum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This will effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `1` and `TARGET_FPMS * 1000`.
     *
     * @member {number}
     * @default 60
     */
    get maxFPS() {
        if (this._minElapsedMS) {
            return 1000 / this._minElapsedMS;
        }
        return settings_1.settings.TARGET_FPMS * 1000;
    }
    ;
}
/**
 * Represents the update priorities used by internal PIXI classes when registered with
 * the {@link PIXI.Ticker} object. Higher priority items are updated first and lower
 * priority items, such as render, should go later.
 *
 * @static
 * @constant
 * @name UPDATE_PRIORITY
 * @memberof PIXI
 * @type {object}
 * @property {number} INTERACTION=50 Highest priority, used for {@link PIXI.interaction.InteractionManager}
 * @property {number} HIGH=25 High priority updating, {@link PIXI.VideoBaseTexture} and {@link PIXI.AnimatedSprite}
 * @property {number} NORMAL=0 Default priority for ticker events, see {@link PIXI.Ticker#add}.
 * @property {number} LOW=-25 Low priority used for {@link PIXI.Application} rendering.
 * @property {number} UTILITY=-50 Lowest priority used for {@link PIXI.prepare.BasePrepare} utility.
 */
Ticker.UPDATE_PRIORITY = {
    INTERACTION: 50,
    HIGH: 25,
    NORMAL: 0,
    LOW: -25,
    UTILITY: -50,
};
exports.Ticker = Ticker;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TickerListener.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TickerListener.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TickerListener {
    constructor(fn, context, priority, once = false) {
        if (context === void 0) {
            context = null;
        }
        if (priority === void 0) {
            priority = 0;
        }
        if (once === void 0) {
            once = false;
        }
        /**
         * The handler function to execute.
         * @private
         * @member {Function}
         */
        this.fn = fn;
        /**
         * The calling to execute.
         * @private
         * @member {*}
         */
        this.context = context;
        /**
         * The current priority.
         * @private
         * @member {number}
         */
        this.priority = priority;
        /**
         * If this should only execute once.
         * @private
         * @member {boolean}
         */
        this.once = once;
        /**
         * The next item in chain.
         * @private
         * @member {TickerListener}
         */
        this.next = null;
        /**
         * The previous item in chain.
         * @private
         * @member {TickerListener}
         */
        this.previous = null;
        /**
         * `true` if this listener has been destroyed already.
         * @member {boolean}
         * @private
         */
        this._destroyed = false;
    }
    /**
     * Emit by calling the current function.
     * @private
     * @param {number} deltaTime - time since the last emit.
     * @return {TickerListener} Next ticker
     */
    emit(deltaTime) {
        if (this.fn) {
            if (this.context) {
                this.fn.call(this.context, deltaTime);
            }
            else {
                this.fn(deltaTime);
            }
        }
        var redirect = this.next;
        if (this.once) {
            this.destroy(true);
        }
        // Soft-destroying should remove
        // the next reference
        if (this._destroyed) {
            this.next = null;
        }
        return redirect;
    }
    ;
    /**
     * Destroy and don't use after this.
     * @private
     * @param {boolean} [hard = false] `true` to remove the `next` reference, this
     *    is considered a hard destroy. Soft destroy maintains the next reference.
     * @return {TickerListener} The listener to redirect while emitting or removing.
     */
    destroy(hard) {
        if (hard === void 0) {
            hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        // Disconnect, hook up next and previous
        if (this.previous) {
            this.previous.next = this.next;
        }
        if (this.next) {
            this.next.previous = this.previous;
        }
        // Redirect to the next item
        var redirect = this.next;
        // Remove references
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
    }
    ;
    /**
     * Connect to the list.
     * @private
     * @param {TickerListener} previous - Input node, previous listener
     */
    connect(previous) {
        this.previous = previous;
        if (previous.next) {
            previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
    }
    ;
    /**
     * Simple compare function to figure out if a function and context match.
     * @private
     * @param {Function} fn - The listener function to be added for one update
     * @param {Function} context - The listener context
     * @return {boolean} `true` if the listener match the arguments
     */
    match(fn, context) {
        context = context || null;
        return this.fn === fn && this.context === context;
    }
    ;
}
exports.TickerListener = TickerListener;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TilingSprite.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TilingSprite.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./js-compile/raw-pixi-ts/Transform.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
class TilingSprite extends Sprite_1.Sprite {
    constructor(texture, width = 100, height = 100) {
        super(texture);
        /**
         * @private
         */
        this._onTextureUpdate = () => {
            if (this.uvMatrix) {
                this.uvMatrix.texture = this._texture;
            }
            this.cachedTint = 0xFFFFFF;
        };
        if (width === void 0) {
            width = 100;
        }
        if (height === void 0) {
            height = 100;
        }
        /**
         * Tile transform
         *
         * @member {PIXI.Transform}
         */
        this.tileTransform = new Transform_1.Transform();
        // /// private
        /**
         * The with of the tiling sprite
         *
         * @member {number}
         * @private
         */
        this._width = width;
        /**
         * The height of the tiling sprite
         *
         * @member {number}
         * @private
         */
        this._height = height;
        /**
         * Canvas pattern
         *
         * @type {CanvasPattern}
         * @private
         */
        this._canvasPattern = null;
        /**
         * matrix that is applied to UV to get the coords in Texture normalized space to coords in BaseTexture space
         *
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = texture.uvMatrix || new TextureMatrix_1.TextureMatrix(texture);
        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_render' method.
         *
         * @member {string}
         * @default 'tilingSprite'
         */
        this.pluginName = 'tilingSprite';
        /**
         * Whether or not anchor affects uvs
         *
         * @member {boolean}
         * @default false
         */
        this.uvRespectAnchor = false;
    }
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     *
     * @default 0.5
     * @member {number}
     */
    get clampMargin() {
        return this.uvMatrix.clampMargin;
    }
    ;
    set clampMargin(value) {
        this.uvMatrix.clampMargin = value;
        this.uvMatrix.update(true);
    }
    ;
    /**
     * The scaling of the image that is being tiled
     *
     * @member {PIXI.ObservablePoint}
     */
    get tileScale() {
        return this.tileTransform.scale;
    }
    ;
    set tileScale(value) {
        this.tileTransform.scale.copyFrom(value);
    }
    ;
    /**
     * The offset of the image that is being tiled
     *
     * @member {PIXI.ObservablePoint}
     */
    get tilePosition() {
        return this.tileTransform.position;
    }
    ;
    set tilePosition(value) {
        this.tileTransform.position.copyFrom(value);
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        // tweak our texture temporarily..
        var texture = this._texture;
        if (!texture || !texture.valid) {
            return;
        }
        this.tileTransform.updateLocalTransform();
        this.uvMatrix.update();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    }
    ;
    /**
     * Updates the bounds of the tiling sprite.
     *
     * @protected
     */
    _calculateBounds() {
        var minX = this._width * -this._anchor._x;
        var minY = this._height * -this._anchor._y;
        var maxX = this._width * (1 - this._anchor._x);
        var maxY = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    }
    ;
    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._width * -this._anchor._x;
            this._bounds.minY = this._height * -this._anchor._y;
            this._bounds.maxX = this._width * (1 - this._anchor._x);
            this._bounds.maxY = this._height * (1 - this._anchor._y);
            if (!rect) {
                if (!this._localBoundsRect) {
                    this._localBoundsRect = new Rectangle_1.Rectangle();
                }
                rect = this._localBoundsRect;
            }
            return this._bounds.getRectangle(rect);
        }
        return Sprite_1.Sprite.prototype.getLocalBounds.call(this, rect);
    }
    ;
    /**
     * Checks if a point is inside this tiling sprite.
     *
     * @param {PIXI.Point} point - the point to check
     * @return {boolean} Whether or not the sprite contains the point.
     */
    containsPoint(point) {
        this.worldTransform.applyInverse(point, TilingSprite.tempPoint$1);
        var width = this._width;
        var height = this._height;
        var x1 = -width * this.anchor._x;
        if (TilingSprite.tempPoint$1.x >= x1 && TilingSprite.tempPoint$1.x < x1 + width) {
            var y1 = -height * this.anchor._y;
            if (TilingSprite.tempPoint$1.y >= y1 && TilingSprite.tempPoint$1.y < y1 + height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        super.destroy(options);
        this.tileTransform = null;
        this.uvMatrix = null;
    }
    ;
    /**
     * Helper function that creates a new tiling sprite based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @return {PIXI.TilingSprite} The newly created texture
     */
    // static from  (source, width, height)
    // {
    //     return new TilingSprite(Texture.from(source), width, height);
    // };
    /**
     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId
     * The frame ids are created when a Texture packer file has been loaded
     *
     * @static
     * @param {string} frameId - The frame Id of the texture in the cache
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @return {PIXI.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId
     */
    static fromFrame(frameId, width, height) {
        var texture = CacheSettings_1.CacheSettings.TextureCache[frameId];
        if (!texture) {
            throw new Error(("The frameId \"" + frameId + "\" does not exist in the texture cache " + (this)));
        }
        return new TilingSprite(texture, width, height);
    }
    ;
    /**
     * Helper function that creates a sprite that will contain a texture based on an image url
     * If the image is not in the texture cache it will be loaded
     *
     * @static
     * @param {string} imageId - The image url of the texture
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @param {Object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id
     */
    static fromImage(imageId, width, height, options) {
        // Fallback support for crossorigin, scaleMode parameters
        if (options && typeof options !== 'object') {
            options = {
                scaleMode: arguments[4],
                resourceOptions: {
                    crossorigin: arguments[3],
                },
            };
        }
        return new TilingSprite(Texture_1.Texture.from(imageId, options), width, height);
    }
    ;
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return this._width;
    }
    ;
    set width(value) {
        this._width = value;
    }
    ;
    /**
     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return this._height;
    }
    ;
    set height(value) {
        this._height = value;
    }
    ;
}
TilingSprite.tempPoint$1 = new Point_1.Point();
exports.TilingSprite = TilingSprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js":
/*!********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TilingSpriteRenderer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const QuadUv_1 = __webpack_require__(/*! ./QuadUv */ "./js-compile/raw-pixi-ts/QuadUv.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class TilingSpriteRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        var uniforms = { globals: this.renderer.globalUniforms };
        this.shader = Shader_1.Shader.from(TilingSpriteRenderer.vertex$3, TilingSpriteRenderer.fragment$2, uniforms);
        this.simpleShader = Shader_1.Shader.from(TilingSpriteRenderer.vertex$3, TilingSpriteRenderer.fragmentSimple, uniforms);
        this.quad = new QuadUv_1.QuadUv();
    }
    /**
     *
     * @param {PIXI.TilingSprite} ts tilingSprite to be rendered
     */
    render(ts) {
        var renderer = this.renderer;
        var quad = this.quad;
        var vertices = quad.vertices;
        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);
        if (ts.uvRespectAnchor) {
            vertices = quad.uvs;
            vertices[0] = vertices[6] = -ts.anchor.x;
            vertices[1] = vertices[3] = -ts.anchor.y;
            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;
            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;
        }
        quad.invalidate();
        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvMatrix;
        var isSimple = baseTex.isPowerOfTwo
            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        // auto, force repeat wrapMode for big tiling textures
        if (isSimple) {
            if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
                if (baseTex.wrapMode === WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP) {
                    baseTex.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.REPEAT;
                }
            }
            else {
                isSimple = baseTex.wrapMode !== WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP;
            }
        }
        var shader = isSimple ? this.simpleShader : this.shader;
        var w = tex.width;
        var h = tex.height;
        var W = ts._width;
        var H = ts._height;
        TilingSpriteRenderer.tempMat$1.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
        // that part is the same as above:
        // tempMat.identity();
        // tempMat.scale(tex.width, tex.height);
        // tempMat.prepend(lt);
        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);
        TilingSpriteRenderer.tempMat$1.invert();
        if (isSimple) {
            TilingSpriteRenderer.tempMat$1.prepend(uv.mapCoord);
        }
        else {
            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
            shader.uniforms.uClampFrame = uv.uClampFrame;
            shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = TilingSpriteRenderer.tempMat$1.toArray(true);
        shader.uniforms.uColor = ColorSettings_1.ColorSettings.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.premultiplyAlpha);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad); // , renderer.shader.getGLShader());
        renderer.state.setBlendMode(BlendModesSettings_1.BlendModesSettings.correctBlendMode(ts.blendMode, baseTex.premultiplyAlpha));
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }
    ;
}
TilingSpriteRenderer.fragmentSimple = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 sample = texture2D(uSampler, vTextureCoord);\r\n    gl_FragColor = sample * uColor;\r\n}\r\n";
TilingSpriteRenderer.fragment$2 = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\nuniform mat3 uMapCoord;\r\nuniform vec4 uClampFrame;\r\nuniform vec2 uClampOffset;\r\n\r\nvoid main(void)\r\n{\r\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\r\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\r\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\r\n\r\n    vec4 sample = texture2D(uSampler, coord);\r\n    gl_FragColor = sample * uColor;\r\n}\r\n";
TilingSpriteRenderer.vertex$3 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTransform;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
TilingSpriteRenderer.tempMat$1 = new Matrix_1.Matrix();
exports.TilingSpriteRenderer = TilingSpriteRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Transform.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Transform.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
class Transform {
    constructor() {
        /**
                 * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
                 *
                 * @member {PIXI.Matrix}
                 */
        this.worldTransform = new Matrix_1.Matrix();
        /**
         * The local matrix transform
         *
         * @member {PIXI.Matrix}
         */
        this.localTransform = new Matrix_1.Matrix();
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.position = new ObservablePoint_1.ObservablePoint(this.onChange, this, 0, 0);
        /**
         * The scale factor of the object.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.scale = new ObservablePoint_1.ObservablePoint(this.onChange, this, 1, 1);
        /**
         * The pivot point of the displayObject that it rotates around.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.pivot = new ObservablePoint_1.ObservablePoint(this.onChange, this, 0, 0);
        /**
         * The skew amount, on the x and y axis.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.skew = new ObservablePoint_1.ObservablePoint(this.updateSkew, this, 0, 0);
        this._rotation = 0;
        this._cx = 1; // cos rotation + skewY;
        this._sx = 0; // sin rotation + skewY;
        this._cy = 0; // cos rotation + Math.PI/2 - skewX;
        this._sy = 1; // sin rotation + Math.PI/2 - skewX;
        this._localID = 0;
        this._currentLocalID = 0;
        this._worldID = 0;
        this._parentID = 0;
    }
    /**
     * Called when a value changes.
     *
     * @private
     */
    onChange() {
        this._localID++;
    }
    ;
    /**
     * Called when skew or rotation changes
     *
     * @private
     */
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew._y);
        this._sx = Math.sin(this._rotation + this.skew._y);
        this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
        this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
        this._localID++;
    }
    ;
    /**
     * Updates only local matrix
     */
    updateLocalTransform() {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;
            lt.tx = this.position._x - ((this.pivot._x * lt.a) + (this.pivot._y * lt.c));
            lt.ty = this.position._y - ((this.pivot._x * lt.b) + (this.pivot._y * lt.d));
            this._currentLocalID = this._localID;
            // force an update..
            this._parentID = -1;
        }
    }
    ;
    /**
     * Updates the values of the object and applies the parent's transform.
     *
     * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
     */
    updateTransform(parentTransform) {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;
            lt.tx = this.position._x - ((this.pivot._x * lt.a) + (this.pivot._y * lt.c));
            lt.ty = this.position._y - ((this.pivot._x * lt.b) + (this.pivot._y * lt.d));
            this._currentLocalID = this._localID;
            // force an update..
            this._parentID = -1;
        }
        if (this._parentID !== parentTransform._worldID) {
            // concat the parent matrix with the objects transform.
            var pt = parentTransform.worldTransform;
            var wt = this.worldTransform;
            wt.a = (lt.a * pt.a) + (lt.b * pt.c);
            wt.b = (lt.a * pt.b) + (lt.b * pt.d);
            wt.c = (lt.c * pt.a) + (lt.d * pt.c);
            wt.d = (lt.c * pt.b) + (lt.d * pt.d);
            wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;
            wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;
            this._parentID = parentTransform._worldID;
            // update the id of the transform..
            this._worldID++;
        }
    }
    ;
    /**
     * Decomposes a matrix and sets the transforms properties based on it.
     *
     * @param {PIXI.Matrix} matrix - The matrix to decompose
     */
    setFromMatrix(matrix) {
        matrix.decompose(this);
        this._localID++;
    }
    ;
    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */
    get rotation() {
        return this._rotation;
    }
    ;
    set rotation(value) {
        if (this._rotation !== value) {
            this._rotation = value;
            this.updateSkew();
        }
    }
    ;
}
Transform.IDENTITY = new Transform();
exports.Transform = Transform;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLLoader.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLLoader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IOErrorEvent_1 = __webpack_require__(/*! ./IOErrorEvent */ "./js-compile/raw-pixi-ts/IOErrorEvent.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class URLLoader extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        this.onHttpResponse = () => {
            if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 200) {
                this._data = this.xmlhttp.responseText;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 0 && this.xmlhttp.responseText) {
                this._data = this.xmlhttp.responseText;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 404) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Could not find file " + this.request.url;
                errorevent.errorId = 404;
                this.dispatchEvent(errorevent);
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 403) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Cross Origin Error " + this.request.url;
                errorevent.errorId = 403;
                this.dispatchEvent(errorevent);
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status != 200) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Unkown Error " + this.request.url;
                errorevent.errorId = this.xmlhttp.status;
                this.dispatchEvent(errorevent);
            }
        };
        this.xmlhttp = new XMLHttpRequest();
    }
    destructor() {
        super.destructor();
        if (this.xmlhttp) {
            this.xmlhttp.onreadystatechange = null;
        }
        this.xmlhttp = null;
        if (this.request) {
            this.request.destructor();
        }
        this.request = null;
        this._data = null;
    }
    get url() {
        if (this.request) {
            return this.request.url;
        }
        return null;
    }
    get data() {
        return this._data;
    }
    set data(value) {
    }
    close() {
    }
    load(value) {
        this.request = value;
        var path = this.request.url;
        if (!path) {
            return;
        }
        if (this.request.data) {
            var params = '';
            for (var key in this.request.data) {
                params += key + "=" + this.request.data[key] + "&";
            }
            params = params.substr(0, params.length - 1);
            path += "?" + params;
        }
        this.xmlhttp.open(this.request.method, path, true);
        this.xmlhttp.onreadystatechange = this.onHttpResponse;
        if (path.indexOf(".json") < 0) {
            if (this.request.contentType != 'json') {
                this.xmlhttp.setRequestHeader('Content-Type', 'text/xml');
            }
        }
        if (this.request.envelop) {
            this.xmlhttp.send(this.request.envelop);
        }
        else {
            this.xmlhttp.send();
        }
    }
    get dataFormat() {
        return null;
    }
    set dataFormat(value) {
    }
}
exports.URLLoader = URLLoader;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLRequest.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLRequest.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const URLRequestMethod_1 = __webpack_require__(/*! ./URLRequestMethod */ "./js-compile/raw-pixi-ts/URLRequestMethod.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class URLRequest extends FlashBaseObject_1.FlashBaseObject {
    constructor(path = null) {
        super();
        this._requestMetaData = new RequestMetaData();
        this._timeout = 0;
        this._crossOrigin = true;
        this.reset(path);
    }
    destructor() {
        this._url = null;
        this._method = URLRequestMethod_1.URLRequestMethod.POST;
        let index = URLRequest.URLRequestCache.indexOf(this);
        if (index < 0) {
            URLRequest.URLRequestCache.push(this);
        }
    }
    reset(path = null) {
        this._url = path;
        this._method = URLRequestMethod_1.URLRequestMethod.POST;
        this._contentType = null;
        this._envelop = null;
        this._data = null;
    }
    static getURLRequest(path = null) {
        if (URLRequest.URLRequestCache.length) {
            let ur = URLRequest.URLRequestCache[URLRequest.URLRequestCache.length - 1];
            URLRequest.URLRequestCache.length -= 1;
            ur.reset(path);
            return ur;
        }
        return new URLRequest(path);
    }
    set requestMetaData(value) {
        this._requestMetaData = value;
    }
    get requestMetaData() {
        return this._requestMetaData;
    }
    set timeout(value) {
        this._timeout = value;
    }
    get timeout() {
        return this._timeout;
    }
    set crossOrigin(value) {
        this._crossOrigin = value;
    }
    get crossOrigin() {
        return this._crossOrigin;
    }
    set envelop(value) {
        this._envelop = value;
    }
    get envelop() {
        return this._envelop;
    }
    get requestHeaders() {
        return null;
    }
    set requestHeaders(value) {
    }
    get contentType() {
        return this._contentType;
    }
    set contentType(value) {
        this._contentType = value;
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    set data(value) {
        this._data = value;
    }
    get data() {
        return this._data;
    }
    get method() {
        return this._method;
    }
    set method(value) {
        this._method = value;
    }
}
URLRequest.URLRequestCache = [];
exports.URLRequest = URLRequest;
class RequestMetaData {
    constructor() {
        this.mimeType = '';
        this.skipSource = false;
    }
}
exports.RequestMetaData = RequestMetaData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLRequestMethod.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLRequestMethod.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class URLRequestMethod {
}
URLRequestMethod.GET = "GET";
URLRequestMethod.POST = "POST";
exports.URLRequestMethod = URLRequestMethod;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/UniformGroup.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/UniformGroup.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class UniformGroup {
    constructor(uniforms = null, _static = null) {
        /**
                 * uniform values
                 * @member {object}
                 * @readonly
                 */
        this.uniforms = uniforms;
        /**
         * Its a group and not a single uniforms
         * @member {boolean}
         * @readonly
         * @default true
         */
        this.group = true;
        // lets generate this when the shader ?
        this.syncUniforms = {};
        /**
         * dirty version
         * @protected
         * @member {number}
         */
        this.dirtyId = 0;
        /**
         * unique id
         * @protected
         * @member {number}
         */
        this.id = UniformGroup.UID$2++;
        /**
         * Uniforms wont be changed after creation
         * @member {boolean}
         */
        this.static = !!_static;
    }
    update() {
        this.dirtyId++;
    }
    ;
    add(name, uniforms, _static) {
        this.uniforms[name] = new UniformGroup(uniforms, _static);
    }
    ;
    static from(uniforms, _static) {
        return new UniformGroup(uniforms, _static);
    }
    ;
}
UniformGroup.UID$2 = 0;
exports.UniformGroup = UniformGroup;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Url.js":
/*!***************************************!*\
  !*** ./js-compile/raw-pixi-ts/Url.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class Url {
    constructor() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
    // format a parsed object into a url string
    static urlFormat(obj) {
        // ensure it's an object, and not a string url.
        // If it's an obj, this is a no-op.
        // this way, you can call url_format() on strings
        // to clean up potentially wonky urls.
        if (UtilsSettings_1.UtilsSettings.util.isString(obj)) {
            obj = Url.urlParse(obj);
        }
        if (!(obj instanceof Url)) {
            return Url.prototype.format.call(obj);
        }
        return obj.format();
    }
    static urlResolveObject(source, relative) {
        if (!source) {
            return relative;
        }
        return Url.urlParse(source, false, true).resolveObject(relative);
    }
    static urlResolve(source, relative) {
        return Url.urlParse(source, false, true).resolve(relative);
    }
    resolveObject(relative) {
        if (UtilsSettings_1.UtilsSettings.util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        // hash is always overridden, no matter what.
        // even href="" will remove it.
        result.hash = relative.hash;
        // if the relative url is empty, then there's nothing left to do here.
        if (relative.href === '') {
            result.href = result.format();
            return result;
        }
        // hrefs like //foo/bar always cut to the protocol.
        if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk];
                if (rkey !== 'protocol') {
                    result[rkey] = relative[rkey];
                }
            }
            //urlParse appends trailing / to urls like http://www.example.com
            if (Url.slashedProtocol[result.protocol] &&
                result.hostname && !result.pathname) {
                result.path = result.pathname = '/';
            }
            result.href = result.format();
            return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!Url.slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative);
                for (var v = 0; v < keys.length; v++) {
                    var k = keys[v];
                    result[k] = relative[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !Url.hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/');
                while (relPath.length && !(relative.host = relPath.shift())) {
                    ;
                }
                if (!relative.host) {
                    relative.host = '';
                }
                if (!relative.hostname) {
                    relative.hostname = '';
                }
                if (relPath[0] !== '') {
                    relPath.unshift('');
                }
                if (relPath.length < 2) {
                    relPath.unshift('');
                }
                result.pathname = relPath.join('/');
            }
            else {
                result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
                var p = result.pathname || '';
                var s = result.search || '';
                result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        }
        var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'), isRelAbs = (relative.host ||
            relative.pathname && relative.pathname.charAt(0) === '/'), mustEndAbs = (isRelAbs || isSourceAbs ||
            (result.host && relative.pathname)), removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], relPath = relative.pathname && relative.pathname.split('/') || [], psychotic = result.protocol && !Url.slashedProtocol[result.protocol];
        // if the url is a non-slashed url, then relative
        // links like ../.. should be able
        // to crawl up to the hostname, as well.  This is strange.
        // result.protocol has already been set by now.
        // Later on, put the first path part into the host field.
        if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
                if (srcPath[0] === '') {
                    srcPath[0] = result.host;
                }
                else {
                    srcPath.unshift(result.host);
                }
            }
            result.host = '';
            if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                if (relative.host) {
                    if (relPath[0] === '') {
                        relPath[0] = relative.host;
                    }
                    else {
                        relPath.unshift(relative.host);
                    }
                }
                relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
        }
        if (isRelAbs) {
            // it's absolute.
            result.host = (relative.host || relative.host === '') ?
                relative.host : result.host;
            result.hostname = (relative.hostname || relative.hostname === '') ?
                relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
            // fall through to the dot-handling below.
        }
        else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) {
                srcPath = [];
            }
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
        }
        else if (!UtilsSettings_1.UtilsSettings.util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
                result.hostname = result.host = srcPath.shift();
                //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = result.host && result.host.indexOf('@') > 0 ?
                    result.host.split('@') : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!UtilsSettings_1.UtilsSettings.util.isNull(result.pathname) || !UtilsSettings_1.UtilsSettings.util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
                result.path = '/' + result.search;
            }
            else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        // if a url ENDs in . or .., then it must get a trailing slash.
        // however, if it ends in anything else non-slashy,
        // then it must NOT get a trailing slash.
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) &&
            (last === '.' || last === '..') || last === '');
        // strip single dots, resolve double dots to parent dir
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === '.') {
                srcPath.splice(i, 1);
            }
            else if (last === '..') {
                srcPath.splice(i, 1);
                up++;
            }
            else if (up) {
                srcPath.splice(i, 1);
                up--;
            }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
                srcPath.unshift('..');
            }
        }
        if (mustEndAbs && srcPath[0] !== '' &&
            (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
        }
        if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
            srcPath.push('');
        }
        var isAbsolute = srcPath[0] === '' ||
            (srcPath[0] && srcPath[0].charAt(0) === '/');
        // put the host back
        if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' :
                srcPath.length ? srcPath.shift() : '';
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ?
                result.host.split('@') : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        mustEndAbs = mustEndAbs || (result.host && srcPath.length);
        if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        }
        else {
            result.pathname = srcPath.join('/');
        }
        //to support request.http
        if (!UtilsSettings_1.UtilsSettings.util.isNull(result.pathname) || !UtilsSettings_1.UtilsSettings.util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') +
                (result.search ? result.search : '');
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    ;
    static urlParse(url, parseQueryString = null, slashesDenoteHost = null) {
        if (url && UtilsSettings_1.UtilsSettings.util.isObject(url) && url instanceof Url) {
            return url;
        }
        var u = new Url;
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
    }
    resolve(relative) {
        return this.resolveObject(Url.urlParse(relative, false, true)).format();
    }
    ;
    parseHost() {
        var host = this.host;
        var port = Url.portPattern.exec(host);
        if (port) {
            port = port[0];
            if (port !== ':') {
                this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
        }
        if (host) {
            this.hostname = host;
        }
    }
    ;
    parse(url, parseQueryString = null, slashesDenoteHost = null) {
        if (!UtilsSettings_1.UtilsSettings.util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }
        // Copy chrome, IE, opera backslash-handling behavior.
        // Back slashes before the query string get converted to forward slashes
        // See: https://code.google.com/p/chromium/issues/detail?id=25916
        var queryIndex = url.indexOf('?'), splitter = (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#', uSplit = url.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, '/');
        url = uSplit.join(splitter);
        var rest = url;
        // trim before proceeding.
        // This is to support parse stuff like "  http://foo.com  \n"
        rest = rest.trim();
        if (!slashesDenoteHost && url.split('#').length === 1) {
            // Try fast path regexp
            var simplePath = Url.simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = this.parse(this.search.substr(1));
                    }
                    else {
                        this.query = this.search.substr(1);
                    }
                }
                else if (parseQueryString) {
                    this.search = '';
                    this.query = {};
                }
                return this;
            }
        }
        var proto = Url.protocolPattern.exec(rest);
        if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
        }
        // figure out if it's got a host
        // user@server is *always* interpreted as a hostname, and url
        // resolution will treat //foo/bar as host=foo,path=bar because that's
        // how the browser resolves relative URLs.
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && Url.hostlessProtocol[proto])) {
                rest = rest.substr(2);
                this.slashes = true;
            }
        }
        if (!Url.hostlessProtocol[proto] &&
            (slashes || (proto && !Url.slashedProtocol[proto]))) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c
            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.
            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < Url.hostEndingChars.length; i++) {
                var hec = rest.indexOf(Url.hostEndingChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                    hostEnd = hec;
                }
            }
            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
                // atSign can be anywhere.
                atSign = rest.lastIndexOf('@');
            }
            else {
                // atSign must be in auth portion.
                // http://a@b/c@d => host:b auth:a path:/c@d
                atSign = rest.lastIndexOf('@', hostEnd);
            }
            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
                auth = rest.slice(0, atSign);
                rest = rest.slice(atSign + 1);
                this.auth = decodeURIComponent(auth);
            }
            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < Url.nonHostChars.length; i++) {
                var hec = rest.indexOf(Url.nonHostChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                    hostEnd = hec;
                }
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) {
                hostEnd = rest.length;
            }
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            // pull out port.
            this.parseHost();
            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || '';
            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']';
            // validate a little.
            if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                    var part = hostparts[i];
                    if (!part) {
                        continue;
                    }
                    if (!part.match(Url.hostnamePartPattern)) {
                        var newpart = '';
                        for (var j = 0, k = part.length; j < k; j++) {
                            if (part.charCodeAt(j) > 127) {
                                // we replace non-ASCII char with a temporary placeholder
                                // we need this to make sure size of hostname is not
                                // broken by replacing non-ASCII by nothing
                                newpart += 'x';
                            }
                            else {
                                newpart += part[j];
                            }
                        }
                        // we test again with ASCII char only
                        if (!newpart.match(Url.hostnamePartPattern)) {
                            var validParts = hostparts.slice(0, i);
                            var notHost = hostparts.slice(i + 1);
                            var bit = part.match(Url.hostnamePartStart);
                            if (bit) {
                                validParts.push(bit[1]);
                                notHost.unshift(bit[2]);
                            }
                            if (notHost.length) {
                                rest = '/' + notHost.join('.') + rest;
                            }
                            this.hostname = validParts.join('.');
                            break;
                        }
                    }
                }
            }
            if (this.hostname.length > Url.hostnameMaxLen) {
                this.hostname = '';
            }
            else {
                // hostnames are always lower case.
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                // IDNA Support: Returns a punycoded representation of "domain".
                // It only converts parts of the domain name that
                // have non-ASCII characters, i.e. it doesn't matter if
                // you call it with a domain that already is ASCII-only.
                this.hostname = this.toASCII(this.hostname);
            }
            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;
            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
                this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                if (rest[0] !== '/') {
                    rest = '/' + rest;
                }
            }
        }
        // now rest is set to the post-host stuff.
        // chop off any delim chars.
        if (!Url.unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = Url.autoEscape.length; i < l; i++) {
                var ae = Url.autoEscape[i];
                if (rest.indexOf(ae) === -1) {
                    continue;
                }
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                    esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
            }
        }
        // chop off from the tail first.
        var hash = rest.indexOf('#');
        if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf('?');
        if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
                this.query = this.parse(this.query);
            }
            rest = rest.slice(0, qm);
        }
        else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = '';
            this.query = {};
        }
        if (rest) {
            this.pathname = rest;
        }
        if (Url.slashedProtocol[lowerProto] &&
            this.hostname && !this.pathname) {
            this.pathname = '/';
        }
        //to support http.request
        if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
        }
        // finally, reconstruct the href based on what has been validated.
        this.href = this.format();
        return this;
    }
    ;
    /**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
    toASCII(input) {
        return this.mapDomain(input, function (string) {
            return Url.regexNonASCII.test(string)
                ? 'xn--' + this.encode(string)
                : string;
        });
    }
    stringifyPrimitive(v) {
        switch (typeof v) {
            case 'string':
                return v;
            case 'boolean':
                return v ? 'true' : 'false';
            case 'number':
                return isFinite(v) ? v : '';
            default:
                return '';
        }
    }
    ;
    encode(obj, sep = null, eq = null, name = null) {
        sep = sep || '&';
        eq = eq || '=';
        if (obj === null) {
            obj = undefined;
        }
        if (typeof obj === 'object') {
            return Object.keys(obj).map(function (k) {
                var ks = encodeURIComponent(this.stringifyPrimitive(k)) + eq;
                if (Array.isArray(obj[k])) {
                    return obj[k].map(function (v) {
                        return ks + encodeURIComponent(this.stringifyPrimitive(v));
                    }).join(sep);
                }
                else {
                    return ks + encodeURIComponent(this.stringifyPrimitive(obj[k]));
                }
            }).join(sep);
        }
        if (!name) {
            return '';
        }
        return encodeURIComponent(this.stringifyPrimitive(name)) + eq +
            encodeURIComponent(this.stringifyPrimitive(obj));
    }
    ;
    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(Url.regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = this.map(labels, fn).join('.');
        return result + encoded;
    }
    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }
    format() {
        var auth = this.auth || '';
        if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
        }
        var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = false, query = '';
        if (this.host) {
            host = auth + this.host;
        }
        else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ?
                this.hostname :
                '[' + this.hostname + ']');
            if (this.port) {
                host += ':' + this.port;
            }
        }
        if (this.query &&
            UtilsSettings_1.UtilsSettings.util.isObject(this.query) &&
            Object.keys(this.query).length) {
            query = this.encode(this.query);
        }
        var search = this.search || (query && ('?' + query)) || '';
        if (protocol && protocol.substr(-1) !== ':') {
            protocol += ':';
        }
        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
        // unless they had them to begin with.
        if (this.slashes ||
            (!protocol || Url.slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/') {
                pathname = '/' + pathname;
            }
        }
        else if (!host) {
            host = '';
        }
        if (hash && hash.charAt(0) !== '#') {
            hash = '#' + hash;
        }
        if (search && search.charAt(0) !== '?') {
            search = '?' + search;
        }
        pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
        });
        search = search.replace('#', '%23');
        return protocol + host + pathname + search + hash;
    }
    ;
}
Url.regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
Url.portPattern = /:[0-9]*$/;
Url.simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
Url.protocolPattern = /^([a-z0-9.+-]+:)/i;
Url.regexNonASCII = /[^\x20-\x7E]/;
Url.hostlessProtocol = {
    'javascript': true,
    'javascript:': true
};
Url.slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
};
Url.hostEndingChars = ['/', '?', '#'];
Url.delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'];
Url.unwise = ['{', '}', '|', '\\', '^', '`'].concat(Url.delims);
Url.autoEscape = ['\''].concat(Url.unwise);
Url.nonHostChars = ['%', '/', '?', ';', '#'].concat(Url.autoEscape);
Url.hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
Url.hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
Url.hostnameMaxLen = 255;
Url.unsafeProtocol = {
    'javascript': true,
    'javascript:': true
};
exports.Url = Url;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/UtilsSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/UtilsSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class UtilsSettings {
    static removeItems(arr, startIdx, removeCount) {
        var length = arr.length;
        var i;
        if (startIdx >= length || removeCount === 0) {
            return;
        }
        removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);
        var len = length - removeCount;
        for (i = startIdx; i < len; ++i) {
            arr[i] = arr[i + removeCount];
        }
        arr.length = len;
    }
    static deepCopyProperties(target, source, propertyObj) {
        for (var prop in propertyObj) {
            if (Array.isArray(source[prop])) {
                target[prop] = source[prop].slice();
            }
            else {
                target[prop] = source[prop];
            }
        }
    }
    static areArraysEqual(array1, array2) {
        if (!Array.isArray(array1) || !Array.isArray(array2)) {
            return false;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for (var i = 0; i < array1.length; ++i) {
            if (array1[i] !== array2[i]) {
                return false;
            }
        }
        return true;
    }
    static unsafeEvalSupported() {
        if (typeof UtilsSettings.unsafeEval === 'boolean') {
            return UtilsSettings.unsafeEval;
        }
        try {
            var func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');
            UtilsSettings.unsafeEval = func({ a: 'b' }, 'a', 'b') === true;
        }
        catch (e) {
            UtilsSettings.unsafeEval = false;
        }
        return UtilsSettings.unsafeEval;
    }
    static isWebGLSupported() {
        var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };
        try {
            if (!window['WebGLRenderingContext']) {
                return false;
            }
            var canvas = document.createElement('canvas');
            var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
            var success = !!(gl && gl.getContextAttributes().stencil);
            if (gl) {
                var loseContext = gl.getExtension('WEBGL_lose_context');
                if (loseContext) {
                    loseContext.loseContext();
                }
            }
            gl = null;
            return success;
        }
        catch (e) {
            return false;
        }
    }
}
UtilsSettings.util = {
    isString: function (arg) {
        return typeof (arg) === 'string';
    },
    isObject: function (arg) {
        return typeof (arg) === 'object' && arg !== null;
    },
    isNull: function (arg) {
        return arg === null;
    },
    isNullOrUndefined: function (arg) {
        return arg == null;
    }
};
exports.UtilsSettings = UtilsSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/VideoResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/VideoResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class VideoResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options) {
        options = options || {};
        // throw "stop"
        if (!(source instanceof HTMLVideoElement)) {
            var videoElement = document.createElement('video');
            videoElement.setAttribute('webkit-playsinline', '');
            videoElement.setAttribute('playsinline', '');
            if (typeof source === 'string') {
                source = [source];
            }
            BaseImageResource_1.BaseImageResource.crossOrigin(videoElement, (source[0].src || source[0]), options.crossorigin);
            // array of objects or strings
            for (var i = 0; i < source.length; ++i) {
                var sourceElement = document.createElement('source');
                var ref = source[i];
                var src = ref.src;
                var mime = ref.mime;
                src = src || source[i];
                var baseSrc = src.split('?').shift().toLowerCase();
                var ext = baseSrc.substr(baseSrc.lastIndexOf('.') + 1);
                mime = mime || ("video/" + ext);
                sourceElement.src = src;
                sourceElement.type = mime;
                videoElement.appendChild(sourceElement);
            }
            // Override the source
            source = videoElement;
        }
        super(source);
        this.canUpload = false;
        this._autoUpdate = true;
        this._isAutoUpdating = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        /**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */
        this.autoPlay = options.autoPlay !== false;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        /**
         * Callback when completed with load.
         * @member {function}
         * @private
         */
        this._resolve = null;
        // Bind for listeners
        this._onCanPlay = this._onCanPlay.bind(this);
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * Trigger updating of the texture
     *
     * @param {number} [deltaTime=0] - time delta since last tick
     */
    update(deltaTime = 0) {
        if (!this.destroyed) {
            // account for if video has had its playbackRate changed
            var elapsedMS = Ticker_1.Ticker.shared.elapsedMS * this.source.playbackRate;
            // trace("elapsed: " + elapsedMS)
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
            if (!this._updateFPS || this._msToNextUpdate <= 0) {
                // trace("super update: " + deltaTime)
                super.update(deltaTime);
                this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;
            }
        }
    }
    ;
    /**
     * Start preloading the video resource.
     *
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    load() {
        Logger_1.trace("loading video");
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)
            && source.width && source.height) {
            source.complete = true;
        }
        source.addEventListener('play', this._onPlayStart.bind(this));
        source.addEventListener('pause', this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
            source.addEventListener('canplay', this._onCanPlay);
            source.addEventListener('canplaythrough', this._onCanPlay);
        }
        else {
            this._onCanPlay();
        }
        this._load = new Promise(function (resolve) {
            if (this$1.valid) {
                resolve(this$1);
            }
            else {
                this$1._resolve = resolve;
                source.load();
            }
        });
        return this._load;
    }
    ;
    /**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */
    _isSourcePlaying() {
        var source = this.source;
        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);
    }
    ;
    /**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */
    _isSourceReady() {
        return this.source.readyState === 3 || this.source.readyState === 4;
    }
    ;
    /**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */
    _onPlayStart() {
        // Just in case the video has not received its can play even yet..
        if (!this.valid) {
            this._onCanPlay();
        }
        if (!this._isAutoUpdating && this.autoUpdate) {
            Ticker_1.Ticker.shared.add(this.update, this);
            this._isAutoUpdating = true;
        }
    }
    ;
    /**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */
    _onPlayStop() {
        if (this._isAutoUpdating) {
            Ticker_1.Ticker.shared.remove(this.update, this);
            this._isAutoUpdating = false;
        }
    }
    ;
    /**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */
    _onCanPlay() {
        var ref = this;
        var source = ref.source;
        source.removeEventListener('canplay', this._onCanPlay);
        source.removeEventListener('canplaythrough', this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        // prevent multiple loaded dispatches..
        if (!valid && this._resolve) {
            this._resolve(this);
            this._resolve = null;
        }
        if (this._isSourcePlaying()) {
            this._onPlayStart();
        }
        else if (this.autoPlay) {
            source.play();
        }
    }
    ;
    /**
     * Destroys this texture
     * @override
     */
    dispose() {
        if (this._isAutoUpdating) {
            Ticker_1.Ticker.shared.remove(this.update, this);
        }
        if (this.source) {
            this.source.pause();
            this.source.src = '';
            this.source.load();
        }
        BaseImageResource_1.BaseImageResource.prototype.dispose.call(this);
    }
    ;
    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     */
    get autoUpdate() {
        return this._autoUpdate;
    }
    ;
    set autoUpdate(value) {
        if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isAutoUpdating) {
                Ticker_1.Ticker.shared.remove(this.update, this);
                this._isAutoUpdating = false;
            }
            else if (this._autoUpdate && !this._isAutoUpdating) {
                Ticker_1.Ticker.shared.add(this.update, this);
                this._isAutoUpdating = true;
            }
        }
    }
    ;
    /**
     * How many times a second to update the texture from the video. Leave at 0 to update at every render.
     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
     *
     * @member {number}
     */
    get updateFPS() {
        return this._updateFPS;
    }
    ;
    set updateFPS(value) {
        if (value !== this._updateFPS) {
            this._updateFPS = value;
        }
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     * @return {boolean} `true` if video source
     */
    static test(source, extension) {
        return (source instanceof HTMLVideoElement)
            || VideoResource.TYPES.indexOf(extension) > -1;
    }
    ;
}
VideoResource.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'];
exports.VideoResource = VideoResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/WebGLSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/WebGLSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class WebGLSettings {
    static createIndicesForQuads(size) {
        var totalIndices = size * 6;
        var indices = new Uint16Array(totalIndices);
        for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
            indices[i + 0] = j + 0;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;
            indices[i + 3] = j + 0;
            indices[i + 4] = j + 2;
            indices[i + 5] = j + 3;
        }
        return indices;
    }
    static canUploadSameBuffer() {
        return true;
    }
    static generateMultiTextureShader(gl, maxTextures) {
        if (!CacheSettings_1.CacheSettings.programCache[maxTextures]) {
            var sampleValues = new Int32Array(maxTextures);
            for (var i = 0; i < maxTextures; i++) {
                sampleValues[i] = i;
            }
            CacheSettings_1.CacheSettings.defaultGroupCache[maxTextures] = UniformGroup_1.UniformGroup.from({ uSamplers: sampleValues }, true);
            var fragmentSrc = WebGLSettings.fragTemplate$1;
            fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
            fragmentSrc = fragmentSrc.replace(/%forloop%/gi, WebGLSettings.generateSampleSrc(maxTextures));
            CacheSettings_1.CacheSettings.programCache[maxTextures] = new Program_1.Program(WebGLSettings.vertex$1, fragmentSrc);
        }
        var uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix_1.Matrix(),
            default: CacheSettings_1.CacheSettings.defaultGroupCache[maxTextures],
        };
        var shader = new Shader_1.Shader(CacheSettings_1.CacheSettings.programCache[maxTextures], uniforms);
        return shader;
    }
    static generateSampleSrc(maxTextures) {
        var src = '';
        src += '\n';
        src += '\n';
        for (var i = 0; i < maxTextures; i++) {
            if (i > 0) {
                src += '\nelse ';
            }
            if (i < maxTextures - 1) {
                src += "if(vTextureId < " + i + ".5)";
            }
            src += '\n{';
            src += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord);";
            src += '\n}';
        }
        src += '\n';
        src += '\n';
        return src;
    }
    static checkMaxIfStatementsInShader(maxIfs, gl) {
        if (maxIfs === 0) {
            throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
        }
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
        while (true) // eslint-disable-line no-constant-condition
         {
            var fragmentSrc = WebGLSettings.fragTemplate.replace(/%forloop%/gi, WebGLSettings.generateIfTestSrc(maxIfs));
            gl.shaderSource(shader, fragmentSrc);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                maxIfs = (maxIfs / 2) | 0;
            }
            else {
                // valid!
                break;
            }
        }
        return maxIfs;
    }
    static generateIfTestSrc(maxIfs) {
        var src = '';
        for (var i = 0; i < maxIfs; ++i) {
            if (i > 0) {
                src += '\nelse ';
            }
            if (i < maxIfs - 1) {
                src += "if(test == " + i + ".0){}";
            }
        }
        return src;
    }
    static maxRecommendedTextures(max) {
        var allowMax = true;
        var match = (navigator.userAgent).match(/OS (\d+)_(\d+)?/);
        if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion >= 11) {
                allowMax = true;
            }
        }
        var match$1 = (navigator.userAgent).match(/Android\s([0-9.]*)/);
        if (match$1) {
            var majorVersion$1 = parseInt(match$1[1], 10);
            if (majorVersion$1 >= 7) {
                allowMax = true;
            }
        }
        return allowMax ? max : 4;
    }
    static setPrecision(src, precision) {
        if (src.substring(0, 9) !== 'precision') // && src.substring(0, 1) !== '#')
         {
            return ("precision " + precision + " float;\n" + src);
        }
        return src;
    }
    static getTestContext() {
        if (!WebGLSettings.context) {
            var canvas = document.createElement('canvas');
            var gl;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV >= DisplaySettings_1.DisplaySettings.ENV.WEBGL2) {
                gl = canvas.getContext('webgl2', {});
            }
            if (!gl) {
                gl = canvas.getContext('webgl', {})
                    || canvas.getContext('experimental-webgl', {});
                if (!gl) {
                    // fail, not able to get a context
                    throw new Error('This browser does not support WebGL. Try using the canvas renderer');
                }
                else {
                    // for shader testing..
                    gl.getExtension('WEBGL_draw_buffers');
                }
            }
            WebGLSettings.context = gl;
            return gl;
        }
        return WebGLSettings.context;
    }
    static defaultValue(type, size) {
        switch (type) {
            case 'float':
                return 0;
            case 'vec2':
                return new Float32Array(2 * size);
            case 'vec3':
                return new Float32Array(3 * size);
            case 'vec4':
                return new Float32Array(4 * size);
            case 'int':
            case 'sampler2D':
            case 'sampler2DArray':
                return 0;
            case 'ivec2':
                return new Int32Array(2 * size);
            case 'ivec3':
                return new Int32Array(3 * size);
            case 'ivec4':
                return new Int32Array(4 * size);
            case 'bool':
                return false;
            case 'bvec2':
                return WebGLSettings.booleanArray(2 * size);
            case 'bvec3':
                return WebGLSettings.booleanArray(3 * size);
            case 'bvec4':
                return WebGLSettings.booleanArray(4 * size);
            case 'mat2':
                return new Float32Array([1, 0,
                    0, 1]);
            case 'mat3':
                return new Float32Array([1, 0, 0,
                    0, 1, 0,
                    0, 0, 1]);
            case 'mat4':
                return new Float32Array([1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1]);
        }
        return null;
    }
    static booleanArray(size) {
        var array = new Array(size);
        for (var i = 0; i < array.length; i++) {
            array[i] = false;
        }
        return array;
    }
    static mapType(gl, type) {
        if (!WebGLSettings.GL_TABLE) {
            var typeNames = Object.keys(WebGLSettings.GL_TO_GLSL_TYPES);
            WebGLSettings.GL_TABLE = {};
            for (var i = 0; i < typeNames.length; ++i) {
                var tn = typeNames[i];
                WebGLSettings.GL_TABLE[gl[tn]] = WebGLSettings.GL_TO_GLSL_TYPES[tn];
            }
        }
        return WebGLSettings.GL_TABLE[type];
    }
    static mapSize(type) {
        return WebGLSettings.GLSL_TO_SIZE[type];
    }
    static generateUniformsSync(group, uniformData) {
        var textureCount = 0;
        var func = "var v = null;\n    var cv = null\n    var gl = renderer.gl";
        for (var i in group.uniforms) {
            var data = uniformData[i];
            if (!data) {
                if (group.uniforms[i].group) {
                    func += "\n                    renderer.shader.syncUniformGroup(uv." + i + ");\n                ";
                }
                continue;
            }
            // TODO && uniformData[i].value !== 0 <-- do we still need this?
            if (data.type === 'float' && data.size === 1) {
                func += "\n            if(uv." + i + " !== ud." + i + ".value)\n            {\n                ud." + i + ".value = uv." + i + "\n                gl.uniform1f(ud." + i + ".location, uv." + i + ")\n            }\n";
            }
            /* eslint-disable max-len */
            else if ((data.type === 'sampler2D' || data.type === 'samplerCube' || data.type === 'sampler2DArray') && data.size === 1 && !data.isArray) 
            /* eslint-disable max-len */
            {
                func += "\n            renderer.texture.bind(uv." + i + ", " + textureCount + ");\n\n            if(ud." + i + ".value !== " + textureCount + ")\n            {\n                ud." + i + ".value = " + textureCount + ";\n                gl.uniform1i(ud." + i + ".location, " + textureCount + ");\n; // eslint-disable-line max-len\n            }\n";
                textureCount++;
            }
            else if (data.type === 'mat3' && data.size === 1) {
                if (group.uniforms[i].a !== undefined) {
                    // TODO and some smart caching dirty ids here!
                    func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ".toArray(true));\n                \n";
                }
                else {
                    func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ");\n                \n";
                }
            }
            else if (data.type === 'vec2' && data.size === 1) {
                // TODO - do we need both here?
                // maybe we can get away with only using points?
                if (group.uniforms[i].x !== undefined) {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud." + i + ".location, v.x, v.y);\n                }\n";
                }
                else {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud." + i + ".location, v[0], v[1]);\n                }\n                \n";
                }
            }
            else if (data.type === 'vec4' && data.size === 1) {
                // TODO - do we need both here?
                // maybe we can get away with only using points?
                if (group.uniforms[i].width !== undefined) {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud." + i + ".location, v.x, v.y, v.width, v.height)\n                }\n";
                }
                else {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud." + i + ".location, v[0], v[1], v[2], v[3])\n                }\n                \n";
                }
            }
            else {
                var templateType = (data.size === 1) ? WebGLSettings.GLSL_TO_SINGLE_SETTERS_CACHED : WebGLSettings.GLSL_TO_ARRAY_SETTERS;
                var template = templateType[data.type].replace('location', ("ud." + i + ".location"));
                func += "\n            cv = ud." + i + ".value;\n            v = uv." + i + ";\n            " + template + ";\n";
            }
        }
        return new Function('ud', 'uv', 'renderer', func); // eslint-disable-line no-new-func
    }
}
WebGLSettings.UPLOADS_PER_FRAME = 4;
WebGLSettings.GLSL_TO_ARRAY_SETTERS = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: 'gl.uniform4fv(location, v)',
    mat4: 'gl.uniformMatrix4fv(location, false, v)',
    mat3: 'gl.uniformMatrix3fv(location, false, v)',
    mat2: 'gl.uniformMatrix2fv(location, false, v)',
    int: 'gl.uniform1iv(location, v)',
    ivec2: 'gl.uniform2iv(location, v)',
    ivec3: 'gl.uniform3iv(location, v)',
    ivec4: 'gl.uniform4iv(location, v)',
    bool: 'gl.uniform1iv(location, v)',
    bvec2: 'gl.uniform2iv(location, v)',
    bvec3: 'gl.uniform3iv(location, v)',
    bvec4: 'gl.uniform4iv(location, v)',
    sampler2D: 'gl.uniform1iv(location, v)',
    samplerCube: 'gl.uniform1iv(location, v)',
    sampler2DArray: 'gl.uniform1iv(location, v)',
};
WebGLSettings.GLSL_TO_SINGLE_SETTERS_CACHED = {
    float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
    vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
    vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
    vec4: 'gl.uniform4f(location, v[0], v[1], v[2], v[3])',
    int: 'gl.uniform1i(location, v)',
    ivec2: 'gl.uniform2i(location, v[0], v[1])',
    ivec3: 'gl.uniform3i(location, v[0], v[1], v[2])',
    ivec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])',
    bool: 'gl.uniform1i(location, v)',
    bvec2: 'gl.uniform2i(location, v[0], v[1])',
    bvec3: 'gl.uniform3i(location, v[0], v[1], v[2])',
    bvec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])',
    mat2: 'gl.uniformMatrix2fv(location, false, v)',
    mat3: 'gl.uniformMatrix3fv(location, false, v)',
    mat4: 'gl.uniformMatrix4fv(location, false, v)',
    sampler2D: 'gl.uniform1i(location, v)',
    samplerCube: 'gl.uniform1i(location, v)',
    sampler2DArray: 'gl.uniform1i(location, v)',
};
WebGLSettings.GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1,
};
WebGLSettings.GL_TO_GLSL_TYPES = {
    FLOAT: 'float',
    FLOAT_VEC2: 'vec2',
    FLOAT_VEC3: 'vec3',
    FLOAT_VEC4: 'vec4',
    INT: 'int',
    INT_VEC2: 'ivec2',
    INT_VEC3: 'ivec3',
    INT_VEC4: 'ivec4',
    BOOL: 'bool',
    BOOL_VEC2: 'bvec2',
    BOOL_VEC3: 'bvec3',
    BOOL_VEC4: 'bvec4',
    FLOAT_MAT2: 'mat2',
    FLOAT_MAT3: 'mat3',
    FLOAT_MAT4: 'mat4',
    SAMPLER_2D: 'sampler2D',
    SAMPLER_CUBE: 'samplerCube',
    SAMPLER_2D_ARRAY: 'sampler2DArray',
};
WebGLSettings.GL_TABLE = null;
WebGLSettings.context = null;
WebGLSettings.PRECISION_FRAGMENT = 'highp';
WebGLSettings.PRECISION_VERTEX = 'highp';
WebGLSettings.fragTemplate = [
    'precision mediump float;',
    'void main(void){',
    'float test = 0.1;',
    '%forloop%',
    'gl_FragColor = vec4(0.0);',
    '}'
].join('\n');
WebGLSettings.vertex$1 = "precision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\nattribute float aTextureId;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform vec4 tint;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nvoid main(void){\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vTextureId = aTextureId;\r\n    vColor = aColor * tint;\r\n}\r\n";
WebGLSettings.fragTemplate$1 = [
    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',
    'varying float vTextureId;',
    'uniform sampler2D uSamplers[%count%];',
    'void main(void){',
    'vec4 color;',
    '%forloop%',
    'gl_FragColor = color * vColor;',
    '}'
].join('\n');
WebGLSettings.MIPMAP_TEXTURES = 1;
WebGLSettings.WRAP_MODE = 33071;
WebGLSettings.TARGETS = {
    TEXTURE_2D: 3553,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
};
WebGLSettings.FORMATS = {
    RGBA: 6408,
    RGB: 6407,
    ALPHA: 6406,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    DEPTH_COMPONENT: 6402,
    DEPTH_STENCIL: 34041,
};
WebGLSettings.TYPES = {
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_SHORT_5_6_5: 33635,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    FLOAT: 5126,
    HALF_FLOAT: 36193,
};
WebGLSettings.MIPMAP_MODES = {
    OFF: 0,
    POW2: 1,
    ON: 2,
};
WebGLSettings.SCALE_MODES = {
    LINEAR: 1,
    NEAREST: 0,
};
WebGLSettings.WRAP_MODES = {
    CLAMP: 33071,
    REPEAT: 10497,
    MIRRORED_REPEAT: 33648,
};
WebGLSettings.defaultBufferOptions = {
    scaleMode: WebGLSettings.SCALE_MODES.NEAREST,
    format: WebGLSettings.FORMATS.RGBA,
    premultiplyAlpha: false,
};
WebGLSettings.CAN_UPLOAD_SAME_BUFFER = WebGLSettings.canUploadSameBuffer();
WebGLSettings.SPRITE_MAX_TEXTURES = WebGLSettings.maxRecommendedTextures(32);
exports.WebGLSettings = WebGLSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/XMLParser.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/XMLParser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class XMLParser {
    static parse(value) {
        var parser = new DOMParser();
        var result = parser.parseFromString(value, "text/xml");
        return result;
    }
}
exports.XMLParser = XMLParser;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/settings.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/settings.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class settings {
    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    static digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    static error(type) {
        throw RangeError(settings.errors[type]);
    }
    /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
    static encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], 
        /** `inputLength` will hold the number of code points in `input`. */
        inputLength, 
        /** Cached calculation results */
        handledCPCountPlusOne, baseMinusT, qMinusT;
        // Convert the input in UCS-2 to Unicode
        input = settings.ucs2decode(input);
        // Cache the length
        inputLength = input.length;
        // Initialize the state
        n = settings.initialN;
        delta = 0;
        bias = settings.initialBias;
        // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
                output.push(settings.stringFromCharCode(currentValue));
            }
        }
        handledCPCount = basicLength = output.length;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
            output.push(settings.delimiter);
        }
        // Main encoding loop:
        while (handledCPCount < inputLength) {
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = settings.maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > settings.floor((settings.maxInt - delta) / handledCPCountPlusOne)) {
                settings.error('overflow');
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < n && ++delta > settings.maxInt) {
                    settings.error('overflow');
                }
                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = settings.base; /* no condition */; k += settings.base) {
                        t = k <= bias ? settings.tMin : (k >= bias + settings.tMax ? settings.tMax : k - bias);
                        if (q < t) {
                            break;
                        }
                        qMinusT = q - t;
                        baseMinusT = settings.base - t;
                        output.push(settings.stringFromCharCode(settings.digitToBasic(t + qMinusT % baseMinusT, 0)));
                        q = settings.floor(qMinusT / baseMinusT);
                    }
                    output.push(settings.stringFromCharCode(settings.digitToBasic(q, 0)));
                    bias = settings.adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }
            ++delta;
            ++n;
        }
        return output.join('');
    }
    /**
* Bias adaptation function as per section 3.4 of RFC 3492.
* http://tools.ietf.org/html/rfc3492#section-3.4
* @private
*/
    static adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? settings.floor(delta / settings.damp) : delta >> 1;
        delta += settings.floor(delta / numPoints);
        for ( /* no initialization */; delta > settings.baseMinusTMin * settings.tMax >> 1; k += settings.base) {
            delta = settings.floor(delta / settings.baseMinusTMin);
        }
        return settings.floor(k + (settings.baseMinusTMin + 1) * delta / (delta + settings.skew));
    }
    /**
* Creates an array containing the numeric code points of each Unicode
* character in the string. While JavaScript uses UCS-2 internally,
* this function will convert a pair of surrogate halves (each of which
* UCS-2 exposes as separate characters) into a single code point,
* matching UTF-16.
* @see `punycode.ucs2.encode`
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode.ucs2
* @name decode
* @param {String} string The Unicode input string (UCS-2).
* @returns {Array} The new array of code points.
*/
    static ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                }
                else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            }
            else {
                output.push(value);
            }
        }
        return output;
    }
    /**
 * Typedef for decomposeDataUri return object.
 *
 * @memberof PIXI.utils
 * @typedef {object} DecomposedDataUri
 * @property {string} mediaType Media type, eg. `image`
 * @property {string} subType Sub type, eg. `png`
 * @property {string} encoding Data encoding, eg. `base64`
 * @property {string} data The actual data
 */
    /**
     * Split a data URI into components. Returns undefined if
     * parameter `dataUri` is not a valid data URI.
     *
     * @memberof PIXI.utils
     * @function decomposeDataUri
     * @param {string} dataUri - the data URI to check
     * @return {PIXI.utils.DecomposedDataUri|undefined} The decomposed data uri or undefined
     */
    static decomposeDataUri(dataUri) {
        var dataUriMatch = settings.DATA_URI.exec(dataUri);
        if (dataUriMatch) {
            return {
                mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
                subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
                charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
                encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : undefined,
                data: dataUriMatch[5],
            };
        }
        return undefined;
    }
}
/**
 * Target frames per millisecond.
 *
 * @static
 * @name TARGET_FPMS
 * @memberof PIXI.settings
 * @type {number}
 * @default 0.06
 */
settings.TARGET_FPMS = 0.06;
/**
 * Default filter resolution.
 *
 * @static
 * @name FILTER_RESOLUTION
 * @memberof PIXI.settings
 * @type {number}
 * @default 1
 */
settings.FILTER_RESOLUTION = 1;
// TODO: maybe change to SPRITE.BATCH_SIZE: 2000
// TODO: maybe add PARTICLE.BATCH_SIZE: 15000
/**
 * The default sprite batch size.
 *
 * The default aims to balance desktop and mobile devices.
 *
 * @static
 * @name SPRITE_BATCH_SIZE
 * @memberof PIXI.settings
 * @type {number}
 * @default 4096
 */
settings.SPRITE_BATCH_SIZE = 4096;
/**
 * Default Garbage Collection mode.
 *
 * @static
 * @name GC_MODE
 * @memberof PIXI.settings
 * @type {PIXI.GC_MODES}
 * @default PIXI.GC_MODES.AUTO
 */
settings.GC_MODE = 0;
/**
 * Default Garbage Collection max idle.
 *
 * @static
 * @name GC_MAX_IDLE
 * @memberof PIXI.settings
 * @type {number}
 * @default 3600
 */
settings.GC_MAX_IDLE = 60 * 60;
/**
 * Default Garbage Collection maximum check count.
 *
 * @static
 * @name GC_MAX_CHECK_COUNT
 * @memberof PIXI.settings
 * @type {number}
 * @default 600
 */
settings.GC_MAX_CHECK_COUNT = 60 * 10;
/**
* The gc modes that are supported by pixi.
*
* The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO
* If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
* used for a specified period of time they will be removed from the GPU. They will of course
* be uploaded again when they are required. This is a silent behind the scenes process that
* should ensure that the GPU does not  get filled up.
*
* Handy for mobile devices!
* This property only affects WebGL.
*
* @name GC_MODES
* @enum {number}
* @static
* @memberof PIXI
* @property {number} AUTO - Garbage collection will happen periodically automatically
* @property {number} MANUAL - Garbage collection will need to be called manually
*/
settings.GC_MODES = {
    AUTO: 0,
    MANUAL: 1,
};
/**
 * Constants that specify float precision in shaders.
 *
 * @name PRECISION
 * @memberof PIXI
 * @static
 * @enum {string}
 * @constant
 * @property {string} LOW='lowp'
 * @property {string} MEDIUM='mediump'
 * @property {string} HIGH='highp'
 */
settings.PRECISION = {
    LOW: 'lowp',
    MEDIUM: 'mediump',
    HIGH: 'highp',
};
/**
* Graphics curves resolution settings. If `adaptive` flag is set to `true`,
* the resolution is calculated based on the curve's length to ensure better visual quality.
* Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.
*
* @static
* @constant
* @memberof PIXI
* @name GRAPHICS_CURVES
* @type {object}
* @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive
* @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)
* @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)
* @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)
*/
settings.GRAPHICS_CURVES = {
    adaptive: true,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    _segmentsCount: function _segmentsCount(length, defaultSegments = null) {
        if (defaultSegments === void 0) {
            defaultSegments = 20;
        }
        if (!this.adaptive) {
            return defaultSegments;
        }
        var result = Math.ceil(length / this.maxLength);
        if (result < this.minSegments) {
            result = this.minSegments;
        }
        else if (result > this.maxSegments) {
            result = this.maxSegments;
        }
        return result;
    },
};
settings.initialN = 128;
settings.initialBias = 72;
settings.stringFromCharCode = String.fromCharCode;
settings.delimiter = '-';
settings.maxInt = 2147483647;
settings.floor = Math.floor;
settings.base = 36;
settings.tMin = 1;
settings.tMax = 26;
/** Error messages */
settings.errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
};
settings.damp = 700;
settings.baseMinusTMin = settings.base - settings.tMin;
settings.skew = 38;
/**
* Regexp for data URI.
* Based on: {@link https://github.com/ragingwind/data-uri-regex}
*
* @static
* @constant {RegExp|string} DATA_URI
* @memberof PIXI
* @example data:image/png;base64
*/
settings.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
// Taken from the bit-twiddle package
settings.defaultVertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}";
settings.defaultFilterVertex = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n}\r\n";
exports.settings = settings;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9BZHZhbmNlZENhcmQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9BZHZhbmNlZFNsb3RzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvQWR2YW5jZWRUcmFpbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0FkdmFuY2VkV2FycC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0Jhc2VFeGFtcGxlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvQmFzaWNCbGVuZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0Jhc2ljQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvQmFzaWNQYXJ0aWNsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9CYXNpY1RpbnRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9GaWx0ZXJCbGVuZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlckJsdXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9GaWx0ZXJDb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlckNyYXdsaWVzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyQ3VzdG9tLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyRmxhZy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlclNoYWRvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0dyYXBoaWNzQWR2YW5jZWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9HcmFwaGljc0R5bmFtaWMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9HcmFwaGljc1NpbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ludGVyYWN0aW9uQ2xpY2suanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9JbnRlcmFjdGlvbkRyYWdnaW5nLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvSW50ZXJhY3Rpb25JY29uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvSW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWFza0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01hc2tHcmFwaGljcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01hc2tTcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoQWR2YW5jZWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoQmFzaWMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoQ29sb3JlZFRyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaEdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hUZXh0dXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hUcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hVbmlmb3Jtcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1Nwcml0ZUJhc2ljLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlRXhwbG9zaW9uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlU3BlZWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9TcHJpdGVTd2FwLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlVGlsaW5nLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlVmlkZW8uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9TcHJpdGVqZXQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0QmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1RleHRCaXRtYXAuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0V2ViRm9udC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1RleHR1cmVBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1RleHR1cmVHcmFkaWVudEJhc2ljLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0dXJlUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvVGV4dHVyZVJvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL2NvbnRyb2xzL0V4YW1wbGVEaXNwbGF5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvY29udHJvbHMvRXhhbXBsZUxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9mbC1wYWNrYWdlL0J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2luZGV4LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQWJzdHJhY3RSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0FjY2Vzc2liaWxpdHlNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQW5pbWF0ZWRTcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BcHBsaWNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0FyY1V0aWxzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQXJyYXlSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0F0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0Jhc2VJbWFnZVJlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmFzZVByZXBhcmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXNlUmVuZGVyVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmF0Y2hCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXRjaERyYXdDYWxsLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmF0Y2hHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JhdGNoUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXRjaFN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JlemllclV0aWxzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQml0bWFwVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JsZW5kTW9kZXNTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JsdXJGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CbHVyRmlsdGVyUGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JvdW5kcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0J1ZmZlclJlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ2FjaGVTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NhbnZhc1JlbmRlclRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NhbnZhc1Jlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ2FudmFzU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DaXJjbGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DbGVhblVwU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Db2xvck1hdHJpeEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NvbG9yU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Db250ZXh0U3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ291bnRMaW1pdGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ3ViZVJlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRGVwdGhSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0Rpc3BsYWNlbWVudEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0Rpc3BsYXlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9EaXNwbGF5U2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9EcmF3TW9kZVNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRWxsaXBzZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0V2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRXZlbnREaXNwYXRjaGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRXh0cmFjdC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZpbGxTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZpbHRlclN0YXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRmlsdGVyU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRmxhc2hCYXNlT2JqZWN0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRm9udE1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GcmFtZWJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZyYW1lYnVmZmVyU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvR0xCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HTFByb2dyYW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HTFRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dlb21ldHJ5U3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvR3JhcGhpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HcmFwaGljc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HcmFwaGljc0dlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvR3JvdXBEOC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0lPRXJyb3JFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ltYWdlUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9JbnRlcmFjdGlvbkRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9JbnRlcmFjdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvSW50ZXJhY3Rpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9MaW5lU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Mb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NYXNrU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWF0aFNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWF0cml4LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL01lc2hCYXRjaFV2cy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL01lc2hHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL01lc2hNYXRlcmlhbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL01vdXNlRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9OZXR3b3JrU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9PYmplY3RSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL09ic2VydmFibGVQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1BhcnRpY2xlQnVmZmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUGFydGljbGVDb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9QYXJ0aWNsZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Byb2dyYW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Qcm9ncmVzc0V2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUHJvamVjdGlvblN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1F1YWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9RdWFkVXYuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9RdWFkcmF0aWNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SZW5kZXJUZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUmVzb3VyY2VTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JvcGVHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JvdW5kZWRSZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SdW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TVkdSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYWRlclN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYXBlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TaW1wbGVSb3BlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3ByaXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3ByaXRlTWFza0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Nwcml0ZXNoZWV0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3RhZ2VPcHRpb25zLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3Rhci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1N0YXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3RhdGVTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TdGVuY2lsU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dFNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dFN0eWxlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHR1cmVHQ1N5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHR1cmVNYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9UZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dHVyZVV2cy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RpY2tlckxpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGlsaW5nU3ByaXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGlsaW5nU3ByaXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9UcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9VUkxMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9VUkxSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVVJMUmVxdWVzdE1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1VuaWZvcm1Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1VybC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1V0aWxzU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9WaWRlb1Jlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvV2ViR0xTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1hNTFBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL3NldHRpbmdzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFhYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLHNEQUFXO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUNBQWlDO0FBQ3ZGO0FBQ0EsaURBQWlELGtDQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxrQkFBa0I7QUFDakMsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxR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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9CQUFvQixPQUFPLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxtQkFBbUI7QUFDbEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QWUsT0FBTztBQUN0QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFlBQVk7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUNBQW1DO0FBQ2xELGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBMkU7QUFDMUYsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMkJBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDBCQUEwQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdjlCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9EYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLGtFQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVTtBQUNuQyx1QkFBdUIsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDL0Msc0JBQXNCLG1CQUFPLENBQUMsOERBQWU7QUFDN0Msd0JBQXdCLG1CQUFPLENBQUMsa0VBQWlCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLGtEQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLGtFQUFpQjtBQUNqRCwyQkFBMkIsbUJBQU8sQ0FBQyx3RUFBb0I7QUFDdkQsd0JBQXdCLG1CQUFPLENBQUMsa0VBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBMkU7QUFDMUYsZUFBZSxlQUFlO0FBQzlCLGVBQWUsZUFBZTtBQUM5QixlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBMkU7QUFDMUYsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4QkFBOEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0NBQWdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0JBQStCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNB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QUN6QyxvQkFBb0IsbUJBQU8sQ0FBQywwREFBYTtBQUN6QywwQkFBMEIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsUUFBUTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3p2QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDL0RhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsb0JBQW9CLG1CQUFPLENBQUMsMERBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtB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QkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBLGlCQUFpQixN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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQSx5REFBeUQsaUNBQWlDLHNDQUFzQyxtQ0FBbUMsNEJBQTRCLHlGQUF5RixzQ0FBc0MsS0FBSztBQUNuVSwrREFBK0Qsc0NBQXNDLG1DQUFtQywrQkFBK0IsNkJBQTZCLDhDQUE4Qyx5RkFBeUYsK0VBQStFLEtBQUssNENBQTRDLGlFQUFpRSxLQUFLLDRCQUE0Qiw2Q0FBNkMsNkNBQTZDLEtBQUs7QUFDNW9CIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9qcy1jb21waWxlL2luZGV4LmpzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZW5kZXJUZXh0dXJlXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBBZHZhbmNlZENhcmQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucm90YXRldHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5icnVzaCA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICB0aGlzLmJydXNoLmJlZ2luRmlsbCgweGZmZmZmZik7XG4gICAgICAgICAgICB0aGlzLmJydXNoLmRyYXdDaXJjbGUoMCwgMCwgNTApO1xuICAgICAgICAgICAgdGhpcy5icnVzaC5lbmRGaWxsKCk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmdyYXNzdHh0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIGJhY2tncm91bmQuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlVG9SZXZlYWwgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucm90YXRldHh0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoaW1hZ2VUb1JldmVhbCk7XG4gICAgICAgICAgICBpbWFnZVRvUmV2ZWFsLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIGltYWdlVG9SZXZlYWwuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZSh0aGlzLnNpemV3LCB0aGlzLnNpemVoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlclRleHR1cmVTcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucmVuZGVyVGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHJlbmRlclRleHR1cmVTcHJpdGUpO1xuICAgICAgICAgICAgaW1hZ2VUb1JldmVhbC5tYXNrID0gcmVuZGVyVGV4dHVyZVNwcml0ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5wb2ludGVyRG93bik7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5wb2ludGVyVXApO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSwgdGhpcy5wb2ludGVyTW92ZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2gucG9zaXRpb24uY29weUZyb20oZXZlbnQuZGF0YS5nbG9iYWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnJlbmRlcih0aGlzLmJydXNoLCB0aGlzLnJlbmRlclRleHR1cmUsIGZhbHNlLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyTW92ZShldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ3Jhc3N0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19yb3RhdGUuanBnXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19ncmFzcy5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5zdGFnZS5yZW1vdmVFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5wb2ludGVyRG93bik7XG4gICAgICAgIHRoaXMuc3RhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQLCB0aGlzLnBvaW50ZXJVcCk7XG4gICAgICAgIHRoaXMuc3RhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX01PVkUsIHRoaXMucG9pbnRlck1vdmUpO1xuICAgICAgICB0aGlzLmJydXNoLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZ3Jhc3N0eHQuZGVzdHJveShudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLkFkdmFuY2VkQ2FyZCA9IEFkdmFuY2VkQ2FyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IEJsdXJGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CbHVyRmlsdGVyXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcbmNvbnN0IFRleHRTdHlsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRTdHlsZVwiKTtcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0XCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBBZHZhbmNlZFNsb3RzIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWdnTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVnZ1R4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2Zsb3dlclRvcC5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUZsb3dlckxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRmxvd2VyTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsb3dlclR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2hlbG1sb2sucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVIZWxtTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIZWxtTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhlbG1UeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9za3VsbHkucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVTa3VsbExvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2t1bGxMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2t1bGxUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBSRUVMX1dJRFRIID0gMTYwO1xuICAgICAgICAgICAgdGhpcy5TWU1CT0xfU0laRSA9IDE1MDtcbiAgICAgICAgICAgIHRoaXMuc2xvdFRleHR1cmVzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuZWdnVHh0LFxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd2VyVHh0LFxuICAgICAgICAgICAgICAgIHRoaXMuaGVsbVR4dCxcbiAgICAgICAgICAgICAgICB0aGlzLnNrdWxsVHh0LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHRoaXMucmVlbHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlZWxDb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIHJjLnggPSBpICogUkVFTF9XSURUSDtcbiAgICAgICAgICAgICAgICByZWVsQ29udGFpbmVyLmFkZENoaWxkKHJjKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWVsID0ge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHJjLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IG5ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcigpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVlbC5ibHVyLmJsdXJYID0gMDtcbiAgICAgICAgICAgICAgICByZWVsLmJsdXIuYmx1clkgPSAwO1xuICAgICAgICAgICAgICAgIHJjLmZpbHRlcnMgPSBbcmVlbC5ibHVyXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuc2xvdFRleHR1cmVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuc2xvdFRleHR1cmVzLmxlbmd0aCldKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnkgPSBqICogdGhpcy5TWU1CT0xfU0laRTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnNjYWxlLnggPSBzeW1ib2wuc2NhbGUueSA9IE1hdGgubWluKHRoaXMuU1lNQk9MX1NJWkUgLyBzeW1ib2wud2lkdGgsIHRoaXMuU1lNQk9MX1NJWkUgLyBzeW1ib2wuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnggPSBNYXRoLnJvdW5kKCh0aGlzLlNZTUJPTF9TSVpFIC0gc3ltYm9sLndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICByZWVsLnN5bWJvbHMucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICByYy5hZGRDaGlsZChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZWxzLnB1c2gocmVlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChyZWVsQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJnaW4gPSAodGhpcy5zaXplaCAtIHRoaXMuU1lNQk9MX1NJWkUgKiAzKSAvIDI7XG4gICAgICAgICAgICAgICAgcmVlbENvbnRhaW5lci55ID0gbWFyZ2luO1xuICAgICAgICAgICAgICAgIHJlZWxDb250YWluZXIueCA9IE1hdGgucm91bmQodGhpcy5zaXpldyAtIFJFRUxfV0lEVEggKiA1KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICAgICAgICAgIHRvcC5iZWdpbkZpbGwoMCwgMSk7XG4gICAgICAgICAgICAgICAgdG9wLmRyYXdSZWN0KDAsIDAsIHRoaXMuc2l6ZXcsIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgICAgICAgICBib3R0b20uYmVnaW5GaWxsKDAsIDEpO1xuICAgICAgICAgICAgICAgIGJvdHRvbS5kcmF3UmVjdCgwLCB0aGlzLlNZTUJPTF9TSVpFICogMyArIG1hcmdpbiwgdGhpcy5zaXpldywgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG5ldyBUZXh0U3R5bGVfMS5UZXh0U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMzYsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogWycjZmZmZmZmJywgJyMwMGZmOTknXSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzRhMTg1MCcsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVRoaWNrbmVzczogNSxcbiAgICAgICAgICAgICAgICAgICAgZHJvcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHJvcFNoYWRvd0NvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIGRyb3BTaGFkb3dCbHVyOiA0LFxuICAgICAgICAgICAgICAgICAgICBkcm9wU2hhZG93QW5nbGU6IE1hdGguUEkgLyA2LFxuICAgICAgICAgICAgICAgICAgICBkcm9wU2hhZG93RGlzdGFuY2U6IDYsXG4gICAgICAgICAgICAgICAgICAgIHdvcmRXcmFwOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3b3JkV3JhcFdpZHRoOiA0NDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxheVRleHQgPSBuZXcgVGV4dF8xLlRleHQoJ1NwaW4gdGhlIHdoZWVscyEnLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgcGxheVRleHQueCA9IE1hdGgucm91bmQoKGJvdHRvbS53aWR0aCAtIHBsYXlUZXh0LndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgIHBsYXlUZXh0LnkgPSB0aGlzLnNpemVoIC0gbWFyZ2luICsgTWF0aC5yb3VuZCgobWFyZ2luIC0gcGxheVRleHQuaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgICAgIGJvdHRvbS5hZGRDaGlsZChwbGF5VGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyVGV4dCA9IG5ldyBUZXh0XzEuVGV4dCgnUElYSSBNT05TVEVSIFNMT1RTIScsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJUZXh0LnggPSBNYXRoLnJvdW5kKCh0b3Aud2lkdGggLSBoZWFkZXJUZXh0LndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgIGhlYWRlclRleHQueSA9IE1hdGgucm91bmQoKG1hcmdpbiAtIGhlYWRlclRleHQuaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgICAgIHRvcC5hZGRDaGlsZChoZWFkZXJUZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChib3R0b20pO1xuICAgICAgICAgICAgICAgIGJvdHRvbS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYm90dG9tLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJvdHRvbS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5zdGFydFBsYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnR3ZWVuKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRQbGF5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucnVubmluZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMucmVlbHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSByLnBvc2l0aW9uICsgMTAgKyBpICogNSArIGV4dHJhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSAyNTAwICsgaSAqIDYwMCArIGV4dHJhICogNjAwO1xuICAgICAgICAgICAgICAgIHRoaXMudHdlZW5UbyhyLCAncG9zaXRpb24nLCB0YXJnZXQsIHRpbWUsIHRoaXMuYmFja291dCgwLjUpLCBudWxsLCBpID09PSB0aGlzLnJlZWxzLmxlbmd0aCAtIDEgPyB0aGlzLnJlZWxzQ29tcGxldGUgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWVsc0NvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMucmVlbHNbaV07XG4gICAgICAgICAgICAgICAgci5ibHVyLmJsdXJZID0gKHIucG9zaXRpb24gLSByLnByZXZpb3VzUG9zaXRpb24pICogODtcbiAgICAgICAgICAgICAgICByLnByZXZpb3VzUG9zaXRpb24gPSByLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgci5zeW1ib2xzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByLnN5bWJvbHNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZ5ID0gcy55O1xuICAgICAgICAgICAgICAgICAgICBzLnkgPSAoKHIucG9zaXRpb24gKyBqKSAlIHIuc3ltYm9scy5sZW5ndGgpICogdGhpcy5TWU1CT0xfU0laRSAtIHRoaXMuU1lNQk9MX1NJWkU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnkgPCAwICYmIHByZXZ5ID4gdGhpcy5TWU1CT0xfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy50ZXh0dXJlID0gdGhpcy5zbG90VGV4dHVyZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zbG90VGV4dHVyZXMubGVuZ3RoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNjYWxlLnggPSBzLnNjYWxlLnkgPSBNYXRoLm1pbih0aGlzLlNZTUJPTF9TSVpFIC8gcy50ZXh0dXJlLndpZHRoLCB0aGlzLlNZTUJPTF9TSVpFIC8gcy50ZXh0dXJlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnggPSBNYXRoLnJvdW5kKCh0aGlzLlNZTUJPTF9TSVpFIC0gcy53aWR0aCkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50d2VlbiA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnR3ZWVuaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMudHdlZW5pbmdbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcGhhc2UgPSBNYXRoLm1pbigxLCAobm93IC0gdC5zdGFydCkgLyB0LnRpbWUpO1xuICAgICAgICAgICAgICAgIHQub2JqZWN0W3QucHJvcGVydHldID0gdGhpcy5sZXJwKHQucHJvcGVydHlCZWdpblZhbHVlLCB0LnRhcmdldCwgdC5lYXNpbmcocGhhc2UpKTtcbiAgICAgICAgICAgICAgICBpZiAodC5jaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHQuY2hhbmdlKHQpO1xuICAgICAgICAgICAgICAgIGlmIChwaGFzZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0Lm9iamVjdFt0LnByb3BlcnR5XSA9IHQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5jb21wbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuY29tcGxldGUodCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50d2VlbmluZy5zcGxpY2UodGhpcy50d2VlbmluZy5pbmRleE9mKHJlbW92ZVtpXSksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnR3ZWVuaW5nID0gW107XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2VnZ0hlYWQucG5nXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUVnZ0xvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgdHdlZW5UbyhvYmplY3QsIHByb3BlcnR5LCB0YXJnZXQsIHRpbWUsIGVhc2luZywgb25jaGFuZ2UsIG9uY29tcGxldGUpIHtcbiAgICAgICAgY29uc3QgdHdlZW4gPSB7XG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHByb3BlcnR5QmVnaW5WYWx1ZTogb2JqZWN0W3Byb3BlcnR5XSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICBjaGFuZ2U6IG9uY2hhbmdlLFxuICAgICAgICAgICAgY29tcGxldGU6IG9uY29tcGxldGUsXG4gICAgICAgICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50d2VlbmluZy5wdXNoKHR3ZWVuKTtcbiAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgIH1cbiAgICBsZXJwKGExLCBhMiwgdCkge1xuICAgICAgICByZXR1cm4gYTEgKiAoMSAtIHQpICsgYTIgKiB0O1xuICAgIH1cbiAgICBiYWNrb3V0KGFtb3VudCkge1xuICAgICAgICByZXR1cm4gdCA9PiAoLS10ICogdCAqICgoYW1vdW50ICsgMSkgKiB0ICsgYW1vdW50KSArIDEpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnR3ZWVuLCBudWxsKTtcbiAgICAgICAgdGhpcy5lZ2dUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5mbG93ZXJUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5oZWxtVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuc2t1bGxUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5zbG90VGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnR3ZWVuaW5nID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkFkdmFuY2VkU2xvdHMgPSBBZHZhbmNlZFNsb3RzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qb2ludFwiKTtcbmNvbnN0IFNpbXBsZVJvcGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaW1wbGVSb3BlXCIpO1xuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xuY2xhc3MgQWR2YW5jZWRUcmFpbCBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWlsVGV4dHVyZSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVggPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVkgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVNpemUgPSAyMDtcbiAgICAgICAgICAgIHRoaXMucm9wZVNpemUgPSAxMDA7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmhpc3RvcnlTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnlYLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaXN0b3J5WS5wdXNoKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvcGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50cy5wdXNoKG5ldyBQb2ludF8xLlBvaW50KDAsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvcGUgPSBuZXcgU2ltcGxlUm9wZV8xLlNpbXBsZVJvcGUodGhpcy50cmFpbFRleHR1cmUsIHRoaXMucG9pbnRzKTtcbiAgICAgICAgICAgIHJvcGUuYmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkFERDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQocm9wZSk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW91c2Vwb3NpdGlvbiA9IHRoaXMuYXBwLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb24ubW91c2UuZ2xvYmFsO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5WC5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVgudW5zaGlmdChtb3VzZXBvc2l0aW9uLngpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5WS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeVkudW5zaGlmdChtb3VzZXBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvcGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gdGhpcy5wb2ludHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgaXggPSB0aGlzLmN1YmljSW50ZXJwb2xhdGlvbih0aGlzLmhpc3RvcnlYLCBpIC8gdGhpcy5yb3BlU2l6ZSAqIHRoaXMuaGlzdG9yeVNpemUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl5ID0gdGhpcy5jdWJpY0ludGVycG9sYXRpb24odGhpcy5oaXN0b3J5WSwgaSAvIHRoaXMucm9wZVNpemUgKiB0aGlzLmhpc3RvcnlTaXplKTtcbiAgICAgICAgICAgICAgICBwLnggPSBpeDtcbiAgICAgICAgICAgICAgICBwLnkgPSBpeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAweDAwMDM3ODtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvdHJhaWwucG5nXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBjbGlwSW5wdXQoaywgYXJyKSB7XG4gICAgICAgIGlmIChrIDwgMClcbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICBpZiAoayA+IGFyci5sZW5ndGggLSAxKVxuICAgICAgICAgICAgayA9IGFyci5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYXJyW2tdO1xuICAgIH1cbiAgICBnZXRUYW5nZW50KGssIGZhY3RvciwgYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvciAqICh0aGlzLmNsaXBJbnB1dChrICsgMSwgYXJyYXkpIC0gdGhpcy5jbGlwSW5wdXQoayAtIDEsIGFycmF5KSkgLyAyO1xuICAgIH1cbiAgICBjdWJpY0ludGVycG9sYXRpb24oYXJyYXksIHQsIHRhbmdlbnRGYWN0b3IgPSAxKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLmZsb29yKHQpO1xuICAgICAgICBjb25zdCBtID0gW3RoaXMuZ2V0VGFuZ2VudChrLCB0YW5nZW50RmFjdG9yLCBhcnJheSksIHRoaXMuZ2V0VGFuZ2VudChrICsgMSwgdGFuZ2VudEZhY3RvciwgYXJyYXkpXTtcbiAgICAgICAgY29uc3QgcCA9IFt0aGlzLmNsaXBJbnB1dChrLCBhcnJheSksIHRoaXMuY2xpcElucHV0KGsgKyAxLCBhcnJheSldO1xuICAgICAgICB0IC09IGs7XG4gICAgICAgIGNvbnN0IHQyID0gdCAqIHQ7XG4gICAgICAgIGNvbnN0IHQzID0gdCAqIHQyO1xuICAgICAgICByZXR1cm4gKDIgKiB0MyAtIDMgKiB0MiArIDEpICogcFswXSArICh0MyAtIDIgKiB0MiArIHQpICogbVswXSArICgtMiAqIHQzICsgMyAqIHQyKSAqIHBbMV0gKyAodDMgLSB0MikgKiBtWzFdO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaXN0b3J5WSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGlzdG9yeVggPSBudWxsO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMudHJhaWxUZXh0dXJlLmRlc3Ryb3kobnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5BZHZhbmNlZFRyYWlsID0gQWR2YW5jZWRUcmFpbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNsYXNzIEFkdmFuY2VkV2FycCBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXJUZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5zdGFyQW1vdW50ID0gMTAwMDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhWiA9IDA7XG4gICAgICAgICAgICB0aGlzLmZvdiA9IDIwO1xuICAgICAgICAgICAgdGhpcy5iYXNlU3BlZWQgPSAwLjAyNTtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy53YXJwU3BlZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGFyU3RyZXRjaCA9IDU7XG4gICAgICAgICAgICB0aGlzLnN0YXJCYXNlU2l6ZSA9IDAuMDU7XG4gICAgICAgICAgICB0aGlzLnN0YXJzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhckFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhciA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlOiBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuc3RhclRleHR1cmUpLFxuICAgICAgICAgICAgICAgICAgICB6OiAwLFxuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3Rhci5zcHJpdGUuYW5jaG9yLnggPSAwLjU7XG4gICAgICAgICAgICAgICAgc3Rhci5zcHJpdGUuYW5jaG9yLnkgPSAwLjc7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5kb21pemVTdGFyKHN0YXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc3Rhci5zcHJpdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnMucHVzaChzdGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcnBTcGVlZCA9IHRoaXMud2FycFNwZWVkID4gMCA/IDAgOiAxO1xuICAgICAgICAgICAgfSwgNTAwMCk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgKz0gKHRoaXMud2FycFNwZWVkIC0gdGhpcy5zcGVlZCkgLyAyMDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhWiArPSBkZWx0YSAqIDEwICogKHRoaXMuc3BlZWQgKyB0aGlzLmJhc2VTcGVlZCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhckFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhciA9IHRoaXMuc3RhcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXIueiA8IHRoaXMuY2FtZXJhWilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5kb21pemVTdGFyKHN0YXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBzdGFyLnogLSB0aGlzLmNhbWVyYVo7XG4gICAgICAgICAgICAgICAgc3Rhci5zcHJpdGUueCA9IHN0YXIueCAqICh0aGlzLmZvdiAvIHopICogdGhpcy5zaXpldyArIHRoaXMuc2l6ZXcgLyAyO1xuICAgICAgICAgICAgICAgIHN0YXIuc3ByaXRlLnkgPSBzdGFyLnkgKiAodGhpcy5mb3YgLyB6KSAqIHRoaXMuc2l6ZXcgKyB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBkeENlbnRlciA9IHN0YXIuc3ByaXRlLnggLSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBkeUNlbnRlciA9IHN0YXIuc3ByaXRlLnkgLSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZUNlbnRlciA9IE1hdGguc3FydChkeENlbnRlciAqIGR4Q2VudGVyICsgZHlDZW50ZXIgKyBkeUNlbnRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VTY2FsZSA9IE1hdGgubWF4KDAsICgyMDAwIC0geikgLyAyMDAwKTtcbiAgICAgICAgICAgICAgICBzdGFyLnNwcml0ZS5zY2FsZS54ID0gZGlzdGFuY2VTY2FsZSAqIHRoaXMuc3RhckJhc2VTaXplO1xuICAgICAgICAgICAgICAgIHN0YXIuc3ByaXRlLnNjYWxlLnkgPSBkaXN0YW5jZVNjYWxlICogdGhpcy5zdGFyQmFzZVNpemUgKyBkaXN0YW5jZVNjYWxlICogdGhpcy5zcGVlZCAqIHRoaXMuc3RhclN0cmV0Y2ggKiBkaXN0YW5jZUNlbnRlciAvIHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICAgICAgc3Rhci5zcHJpdGUucm90YXRpb24gPSBNYXRoLmF0YW4yKGR5Q2VudGVyLCBkeENlbnRlcikgKyBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAweDAwMDAwMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvc3Rhci5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIHJhbmRvbWl6ZVN0YXIoc3RhciwgaW5pdGlhbCA9IHRydWUpIHtcbiAgICAgICAgc3Rhci56ID0gaW5pdGlhbCA/IE1hdGgucmFuZG9tKCkgKiAyMDAwIDogdGhpcy5jYW1lcmFaICsgTWF0aC5yYW5kb20oKSAqIDEwMDAgKyAyMDAwO1xuICAgICAgICBjb25zdCBkZWcgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5yYW5kb20oKSAqIDUwICsgMTtcbiAgICAgICAgc3Rhci54ID0gTWF0aC5jb3MoZGVnKSAqIGRpc3RhbmNlO1xuICAgICAgICBzdGFyLnkgPSBNYXRoLnNpbihkZWcpICogZGlzdGFuY2U7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5zdGFycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5zdGFyVGV4dHVyZS5kZXN0cm95KG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWR2YW5jZWRXYXJwID0gQWR2YW5jZWRXYXJwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNsYXNzIEJhc2VFeGFtcGxlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAweDk2OTY5NjtcbiAgICAgICAgdGhpcy5zaXpldyA9IHdpZHRoO1xuICAgICAgICB0aGlzLnNpemVoID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5zdGFnZSA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICB9XG4gICAgYWN0aXZhdGVNYXNrKCkge1xuICAgICAgICB0aGlzLnN0YWdlTWFzayA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuc3RhZ2VNYXNrLmJlZ2luRmlsbCgwKTtcbiAgICAgICAgdGhpcy5zdGFnZU1hc2suZHJhd1JlY3QoMCwgMCwgdGhpcy5zaXpldywgdGhpcy5zaXplaCk7XG4gICAgICAgIHRoaXMuc3RhZ2UubWFzayA9IHRoaXMuc3RhZ2VNYXNrO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YWdlLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgICAgIGlmICh0aGlzLnN0YWdlTWFzaykge1xuICAgICAgICAgICAgdGhpcy5zdGFnZU1hc2suZGVzdHJveShudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGFtcGxlUmVhZHkoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ09NUExFVEUpKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VFeGFtcGxlID0gQmFzZUV4YW1wbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZWN0YW5nbGVcIik7XG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jbGFzcyBCYXNpY0JsZW5kIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0eHQpO1xuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvZmxvd2VyVG9wLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRmxvd2VyTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVGbG93ZXJMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmR1ZGVBcnJheSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdG90YWxkdWRlcyA9IDIwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbGR1ZGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gbmV3IEV4dGVuZGVkU3ByaXRlKHR4dCk7XG4gICAgICAgICAgICAgICAgZHVkZS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgZHVkZS5zY2FsZS5zZXQoMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuMyk7XG4gICAgICAgICAgICAgICAgZHVkZS54ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXpldyk7XG4gICAgICAgICAgICAgICAgZHVkZS55ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXplaCk7XG4gICAgICAgICAgICAgICAgZHVkZS5ibGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREO1xuICAgICAgICAgICAgICAgIGR1ZGUuZGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIGR1ZGUudHVybmluZ1NwZWVkID0gTWF0aC5yYW5kb20oKSAtIDAuODtcbiAgICAgICAgICAgICAgICBkdWRlLnNwZWVkID0gMiArIE1hdGgucmFuZG9tKCkgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuZHVkZUFycmF5LnB1c2goZHVkZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChkdWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR1ZGVCb3VuZHNQYWRkaW5nID0gMTAwO1xuICAgICAgICAgICAgdGhpcy5kdWRlQm91bmRzID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgtZHVkZUJvdW5kc1BhZGRpbmcsIC1kdWRlQm91bmRzUGFkZGluZywgdGhpcy5zaXpldyArIGR1ZGVCb3VuZHNQYWRkaW5nICogMiwgdGhpcy5zaXplaCArIGR1ZGVCb3VuZHNQYWRkaW5nICogMik7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kdWRlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gdGhpcy5kdWRlQXJyYXlbaV07XG4gICAgICAgICAgICAgICAgZHVkZS5kaXJlY3Rpb24gKz0gZHVkZS50dXJuaW5nU3BlZWQgKiAwLjAxO1xuICAgICAgICAgICAgICAgIGR1ZGUueCArPSBNYXRoLnNpbihkdWRlLmRpcmVjdGlvbikgKiBkdWRlLnNwZWVkO1xuICAgICAgICAgICAgICAgIGR1ZGUueSArPSBNYXRoLmNvcyhkdWRlLmRpcmVjdGlvbikgKiBkdWRlLnNwZWVkO1xuICAgICAgICAgICAgICAgIGR1ZGUucm90YXRpb24gPSAtZHVkZS5kaXJlY3Rpb24gLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoZHVkZS54IDwgdGhpcy5kdWRlQm91bmRzLngpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS54ICs9IHRoaXMuZHVkZUJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHVkZS54ID4gdGhpcy5kdWRlQm91bmRzLnggKyB0aGlzLmR1ZGVCb3VuZHMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS54IC09IHRoaXMuZHVkZUJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR1ZGUueSA8IHRoaXMuZHVkZUJvdW5kcy55KSB7XG4gICAgICAgICAgICAgICAgICAgIGR1ZGUueSArPSB0aGlzLmR1ZGVCb3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkdWRlLnkgPiB0aGlzLmR1ZGVCb3VuZHMueSArIHRoaXMuZHVkZUJvdW5kcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS55IC09IHRoaXMuZHVkZUJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4RkZGRkZGO1xuICAgICAgICB0aGlzLmFjdGl2YXRlTWFzaygpO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9lZ2dIZWFkLnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuZHVkZUFycmF5ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2ljQmxlbmQgPSBCYXNpY0JsZW5kO1xuY2xhc3MgRXh0ZW5kZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY2xhc3MgQmFzaWNDb250YWluZXIgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1bm55ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0eHQpO1xuICAgICAgICAgICAgICAgIGJ1bm55LmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgICAgICBidW5ueS54ID0gKGkgJSA1KSAqIDQwO1xuICAgICAgICAgICAgICAgIGJ1bm55LnkgPSBNYXRoLmZsb29yKGkgLyA1KSAqIDQwO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKGJ1bm55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnggPSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnkgPSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBpdm90LnggPSB0aGlzLmNvbnRhaW5lci53aWR0aCAvIDI7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5waXZvdC55ID0gdGhpcy5jb250YWluZXIuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucm90YXRpb24gLT0gMC4wMSAqIGRlbHRhO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2ljQ29udGFpbmVyID0gQmFzaWNDb250YWluZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBQYXJ0aWNsZUNvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1BhcnRpY2xlQ29udGFpbmVyXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVjdGFuZ2xlXCIpO1xuY2xhc3MgQmFzaWNQYXJ0aWNsZXMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHNwcml0ZXMgPSBuZXcgUGFydGljbGVDb250YWluZXJfMS5QYXJ0aWNsZUNvbnRhaW5lcigxMDAwMCwgeyBzY2FsZTogdHJ1ZSwgcG9zaXRpb246IHRydWUsIHJvdGF0aW9uOiB0cnVlLCB1dnM6IHRydWUsIGFscGhhOiB0cnVlLCB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc3ByaXRlcyk7XG4gICAgICAgICAgICB0aGlzLm1hZ2dvdHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsU3ByaXRlcyA9IDEwMDAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFNwcml0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1ZGUgPSBuZXcgRXh0ZW5kZWRTcHJpdGUodHh0KTtcbiAgICAgICAgICAgICAgICBkdWRlLnRpbnQgPSBNYXRoLnJhbmRvbSgpICogMHhFOEQ0Q0Q7XG4gICAgICAgICAgICAgICAgZHVkZS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgZHVkZS5zY2FsZS5zZXQoMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuMyk7XG4gICAgICAgICAgICAgICAgZHVkZS54ID0gTWF0aC5yYW5kb20oKSAqIHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICAgICAgZHVkZS55ID0gTWF0aC5yYW5kb20oKSAqIHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICAgICAgZHVkZS50aW50ID0gTWF0aC5yYW5kb20oKSAqIDB4ODA4MDgwO1xuICAgICAgICAgICAgICAgIGR1ZGUuZGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIGR1ZGUudHVybmluZ1NwZWVkID0gTWF0aC5yYW5kb20oKSAtIDAuODtcbiAgICAgICAgICAgICAgICBkdWRlLnNwZWVkID0gKDIgKyBNYXRoLnJhbmRvbSgpICogMikgKiAwLjI7XG4gICAgICAgICAgICAgICAgZHVkZS5vZmZzZXQgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRoaXMubWFnZ290cy5wdXNoKGR1ZGUpO1xuICAgICAgICAgICAgICAgIHNwcml0ZXMuYWRkQ2hpbGQoZHVkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkdWRlQm91bmRzUGFkZGluZyA9IDEwMDtcbiAgICAgICAgICAgIHRoaXMuZHVkZUJvdW5kcyA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoLWR1ZGVCb3VuZHNQYWRkaW5nLCAtZHVkZUJvdW5kc1BhZGRpbmcsIHRoaXMuc2l6ZXcgKyBkdWRlQm91bmRzUGFkZGluZyAqIDIsIHRoaXMuc2l6ZWggKyBkdWRlQm91bmRzUGFkZGluZyAqIDIpO1xuICAgICAgICAgICAgdGhpcy50aWNrID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hZ2dvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gdGhpcy5tYWdnb3RzW2ldO1xuICAgICAgICAgICAgICAgIGR1ZGUuc2NhbGUueSA9IDAuOTUgKyBNYXRoLnNpbih0aGlzLnRpY2sgKyBkdWRlLm9mZnNldCkgKiAwLjA1O1xuICAgICAgICAgICAgICAgIGR1ZGUuZGlyZWN0aW9uICs9IGR1ZGUudHVybmluZ1NwZWVkICogMC4wMTtcbiAgICAgICAgICAgICAgICBkdWRlLnggKz0gTWF0aC5zaW4oZHVkZS5kaXJlY3Rpb24pICogKGR1ZGUuc3BlZWQgKiBkdWRlLnNjYWxlLnkpO1xuICAgICAgICAgICAgICAgIGR1ZGUueSArPSBNYXRoLmNvcyhkdWRlLmRpcmVjdGlvbikgKiAoZHVkZS5zcGVlZCAqIGR1ZGUuc2NhbGUueSk7XG4gICAgICAgICAgICAgICAgZHVkZS5yb3RhdGlvbiA9IC1kdWRlLmRpcmVjdGlvbiArIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgaWYgKGR1ZGUueCA8IHRoaXMuZHVkZUJvdW5kcy54KSB7XG4gICAgICAgICAgICAgICAgICAgIGR1ZGUueCArPSB0aGlzLmR1ZGVCb3VuZHMud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR1ZGUueCA+IHRoaXMuZHVkZUJvdW5kcy54ICsgdGhpcy5kdWRlQm91bmRzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1ZGUueCAtPSB0aGlzLmR1ZGVCb3VuZHMud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkdWRlLnkgPCB0aGlzLmR1ZGVCb3VuZHMueSkge1xuICAgICAgICAgICAgICAgICAgICBkdWRlLnkgKz0gdGhpcy5kdWRlQm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHVkZS55ID4gdGhpcy5kdWRlQm91bmRzLnkgKyB0aGlzLmR1ZGVCb3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGR1ZGUueSAtPSB0aGlzLmR1ZGVCb3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGljayArPSAwLjE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL21hZ2dvdF90aW55LnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMubWFnZ290cyA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY1BhcnRpY2xlcyA9IEJhc2ljUGFydGljbGVzO1xuY2xhc3MgRXh0ZW5kZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVjdGFuZ2xlXCIpO1xuY2xhc3MgQmFzaWNUaW50aW5nIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmFsaWVucyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdG90YWxEdWRlcyA9IDIwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbER1ZGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gbmV3IEV4dGVuZGVkU3ByaXRlKHR4dCk7XG4gICAgICAgICAgICAgICAgZHVkZS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgZHVkZS5zY2FsZS5zZXQoMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuMyk7XG4gICAgICAgICAgICAgICAgZHVkZS54ID0gTWF0aC5yYW5kb20oKSAqIHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICAgICAgZHVkZS55ID0gTWF0aC5yYW5kb20oKSAqIHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICAgICAgZHVkZS50aW50ID0gTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGO1xuICAgICAgICAgICAgICAgIGR1ZGUuZGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIGR1ZGUudHVybmluZ1NwZWVkID0gTWF0aC5yYW5kb20oKSAtIDAuODtcbiAgICAgICAgICAgICAgICBkdWRlLnNwZWVkID0gMiArIE1hdGgucmFuZG9tKCkgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxpZW5zLnB1c2goZHVkZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChkdWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR1ZGVCb3VuZHNQYWRkaW5nID0gMTAwO1xuICAgICAgICAgICAgdGhpcy5kdWRlQm91bmRzID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgtZHVkZUJvdW5kc1BhZGRpbmcsIC1kdWRlQm91bmRzUGFkZGluZywgdGhpcy5zaXpldyArIGR1ZGVCb3VuZHNQYWRkaW5nICogMiwgdGhpcy5zaXplaCArIGR1ZGVCb3VuZHNQYWRkaW5nICogMik7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbGllbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gdGhpcy5hbGllbnNbaV07XG4gICAgICAgICAgICAgICAgZHVkZS5kaXJlY3Rpb24gKz0gZHVkZS50dXJuaW5nU3BlZWQgKiAwLjAxO1xuICAgICAgICAgICAgICAgIGR1ZGUueCArPSBNYXRoLnNpbihkdWRlLmRpcmVjdGlvbikgKiBkdWRlLnNwZWVkO1xuICAgICAgICAgICAgICAgIGR1ZGUueSArPSBNYXRoLmNvcyhkdWRlLmRpcmVjdGlvbikgKiBkdWRlLnNwZWVkO1xuICAgICAgICAgICAgICAgIGR1ZGUucm90YXRpb24gPSAtZHVkZS5kaXJlY3Rpb24gLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoZHVkZS54IDwgdGhpcy5kdWRlQm91bmRzLngpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS54ICs9IHRoaXMuZHVkZUJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHVkZS54ID4gdGhpcy5kdWRlQm91bmRzLnggKyB0aGlzLmR1ZGVCb3VuZHMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS54IC09IHRoaXMuZHVkZUJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR1ZGUueSA8IHRoaXMuZHVkZUJvdW5kcy55KSB7XG4gICAgICAgICAgICAgICAgICAgIGR1ZGUueSArPSB0aGlzLmR1ZGVCb3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkdWRlLnkgPiB0aGlzLmR1ZGVCb3VuZHMueSArIHRoaXMuZHVkZUJvdW5kcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS55IC09IHRoaXMuZHVkZUJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4RkZGMDAwO1xuICAgICAgICB0aGlzLmFjdGl2YXRlTWFzaygpO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9lZ2dIZWFkLnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuYWxpZW5zID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2ljVGludGluZyA9IEJhc2ljVGludGluZztcbmNsYXNzIEV4dGVuZGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlXzEuU3ByaXRlIHtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlY3RhbmdsZVwiKTtcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0ZpbHRlclwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUG9pbnRcIik7XG5jbGFzcyBGaWx0ZXJCbGVuZGluZyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmR0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmJhY2tncm91bmR0eHQpO1xuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgY29uc3Qgc2hhZGVyRnJhZyA9IGBcbiAgICAgICAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIG1vdXNlO1xuICAgICAgICAgICAgdW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdGltZTtcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIHZlYzIgc2NyZWVuUG9zID0gdlRleHR1cmVDb29yZCAqIGlucHV0U2l6ZS54eSArIG91dHB1dEZyYW1lLnh5O1xuICAgICAgICAgICAgaWYgKGxlbmd0aChtb3VzZSAtIHNjcmVlblBvcykgPCAyNS4wKSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgxLjAsIDEuMCwgMC4wLCAxLjApICogMC43OyAvL3llbGxvdyBjaXJjbGUsIGFscGhhPTAuN1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBzaW4odGltZSksIChtb3VzZS54eSAtIG91dHB1dEZyYW1lLnh5KSAvIG91dHB1dEZyYW1lLnp3LCAxLjApICogMC41OyAvLyBibGVuZCB3aXRoIHVuZGVybHlpbmcgaW1hZ2UsIGFscGhhPTAuNVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5maWx0ZXJBcmVhID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgxMDAsIDEwMCwgdGhpcy5zaXpldyAtIDIwMCwgdGhpcy5zaXplaCAtIDIwMCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBGaWx0ZXJfMS5GaWx0ZXIobnVsbCwgc2hhZGVyRnJhZywge1xuICAgICAgICAgICAgICAgIG1vdXNlOiBuZXcgUG9pbnRfMS5Qb2ludCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5maWx0ZXJzID0gW3RoaXMuZmlsdGVyXTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIudW5pZm9ybXMubW91c2UuY29weUZyb20odGhpcy5hcHAucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbi5tb3VzZS5nbG9iYWwpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19ncmFzcy5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kdHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZHR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJCbGVuZGluZyA9IEZpbHRlckJsZW5kaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgQmx1ckZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0JsdXJGaWx0ZXJcIik7XG5jbGFzcyBGaWx0ZXJCbHVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTW9ieUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb2J5VHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgYmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZGVwdGhUeHQpO1xuICAgICAgICAgICAgYmcud2lkdGggPSB0aGlzLnNpemV3O1xuICAgICAgICAgICAgYmcuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYmcpO1xuICAgICAgICAgICAgY29uc3QgbGl0dGxlRHVkZXMgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZHVkZXNUeHQpO1xuICAgICAgICAgICAgbGl0dGxlRHVkZXMueCA9ICh0aGlzLnNpemV3IC8gMikgLSAzMTU7XG4gICAgICAgICAgICBsaXR0bGVEdWRlcy55ID0gMjAwO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChsaXR0bGVEdWRlcyk7XG4gICAgICAgICAgICBjb25zdCBsaXR0bGVSb2JvdCA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5tb2J5VHh0KTtcbiAgICAgICAgICAgIGxpdHRsZVJvYm90LnggPSAodGhpcy5zaXpldyAvIDIpIC0gMjAwO1xuICAgICAgICAgICAgbGl0dGxlUm9ib3QueSA9IDEwMDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQobGl0dGxlUm9ib3QpO1xuICAgICAgICAgICAgdGhpcy5ibHVyRmlsdGVyMSA9IG5ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcigpO1xuICAgICAgICAgICAgdGhpcy5ibHVyRmlsdGVyMiA9IG5ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcigpO1xuICAgICAgICAgICAgbGl0dGxlRHVkZXMuZmlsdGVycyA9IFt0aGlzLmJsdXJGaWx0ZXIxXTtcbiAgICAgICAgICAgIGxpdHRsZVJvYm90LmZpbHRlcnMgPSBbdGhpcy5ibHVyRmlsdGVyMl07XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAwLjAwNTtcbiAgICAgICAgICAgIGNvbnN0IGJsdXJBbW91bnQgPSBNYXRoLmNvcyh0aGlzLmNvdW50KTtcbiAgICAgICAgICAgIGNvbnN0IGJsdXJBbW91bnQyID0gTWF0aC5zaW4odGhpcy5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLmJsdXJGaWx0ZXIxLmJsdXIgPSAyMCAqIChibHVyQW1vdW50KTtcbiAgICAgICAgICAgIHRoaXMuYmx1ckZpbHRlcjIuYmx1ciA9IDIwICogKGJsdXJBbW91bnQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEdWRlc0xvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kdWRlc1R4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9kZXB0aF9ibHVyX21vYnkuanBnXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVNb2J5TG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEZXB0aExvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZXB0aFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9kZXB0aF9ibHVyX2R1ZGVzLmpwZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRHVkZXNMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvYmdfZGVwdGhfYmx1ci5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRGVwdGhMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIxLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5ibHVyRmlsdGVyMSA9IG51bGw7XG4gICAgICAgIHRoaXMuYmx1ckZpbHRlcjIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2J5VHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubW9ieVR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHVkZXNUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kdWRlc1R4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVwdGhUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kZXB0aFR4dCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJCbHVyID0gRmlsdGVyQmx1cjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IENvbG9yTWF0cml4RmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29sb3JNYXRyaXhGaWx0ZXJcIik7XG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xuY2xhc3MgRmlsdGVyQ29sb3IgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYW5kYUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYW5kYVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuYmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucm90YXRlVHh0KTtcbiAgICAgICAgICAgIHRoaXMuYmcuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5iZy54ID0gdGhpcy5zaXpldyAvIDI7XG4gICAgICAgICAgICB0aGlzLmJnLnkgPSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IENvbG9yTWF0cml4RmlsdGVyXzEuQ29sb3JNYXRyaXhGaWx0ZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci54ID0gdGhpcy5zaXpldyAvIDI7XG4gICAgICAgICAgICBjb250YWluZXIueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy5iZ0Zyb250ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnNjZW5lcm90YXRlVHh0KTtcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udC5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcy5iZ0Zyb250KTtcbiAgICAgICAgICAgIHRoaXMubGlnaHQyID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmxpZ2h0cm90YXRlMlR4dCk7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0Mi5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcy5saWdodDIpO1xuICAgICAgICAgICAgdGhpcy5saWdodDEgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMubGlnaHRyb3RhdGUxVHh0KTtcbiAgICAgICAgICAgIHRoaXMubGlnaHQxLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmxpZ2h0MSk7XG4gICAgICAgICAgICB0aGlzLnBhbmRhID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnBhbmRhVHh0KTtcbiAgICAgICAgICAgIHRoaXMucGFuZGEuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMucGFuZGEpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5maWx0ZXJzID0gW3RoaXMuZmlsdGVyXTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1RBUCwgdGhpcy5oYW5kbGVQb2ludGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGhlbHAgPSBuZXcgVGV4dF8xLlRleHQoJ0NsaWNrIG9yIHRhcCB0byB0dXJuIGZpbHRlcnMgb24gLyBvZmYuJywge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoZWxwLnkgPSB0aGlzLnNpemVoIC0gMjU7XG4gICAgICAgICAgICBoZWxwLnggPSAxMDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoaGVscCk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmcucm90YXRpb24gKz0gMC4wMTtcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udC5yb3RhdGlvbiAtPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy5saWdodDEucm90YXRpb24gKz0gMC4wMjtcbiAgICAgICAgICAgIHRoaXMubGlnaHQyLnJvdGF0aW9uICs9IDAuMDE7XG4gICAgICAgICAgICB0aGlzLnBhbmRhLnNjYWxlLnggPSAxICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAwLjA0O1xuICAgICAgICAgICAgdGhpcy5wYW5kYS5zY2FsZS55ID0gMSArIE1hdGguY29zKHRoaXMuY291bnQpICogMC4wNDtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xuICAgICAgICAgICAgY29uc3QgeyBtYXRyaXggfSA9IHRoaXMuZmlsdGVyO1xuICAgICAgICAgICAgbWF0cml4WzFdID0gTWF0aC5zaW4odGhpcy5jb3VudCkgKiAzO1xuICAgICAgICAgICAgbWF0cml4WzJdID0gTWF0aC5jb3ModGhpcy5jb3VudCk7XG4gICAgICAgICAgICBtYXRyaXhbM10gPSBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDEuNTtcbiAgICAgICAgICAgIG1hdHJpeFs0XSA9IE1hdGguc2luKHRoaXMuY291bnQgLyAzKSAqIDI7XG4gICAgICAgICAgICBtYXRyaXhbNV0gPSBNYXRoLnNpbih0aGlzLmNvdW50IC8gMik7XG4gICAgICAgICAgICBtYXRyaXhbNl0gPSBNYXRoLnNpbih0aGlzLmNvdW50IC8gNCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuZmlsdGVycyA9IHRoaXMuZW5hYmxlZCA/IFt0aGlzLmZpbHRlcl0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saWdodHJvdGF0ZTFUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9saWdodF9yb3RhdGVfMS5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVNjZW5lUm90YXRlTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY2VuZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2VuZXJvdGF0ZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2xpZ2h0X3JvdGF0ZV8yLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlTGlnaHRSb3RhdGUyTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVMaWdodFJvdGF0ZTJMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlnaHRyb3RhdGUyVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGFuZGEucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVQYW5kYUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZU1hc2soKTtcbiAgICAgICAgdGhpcy5zdGFnZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYmcuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5iZyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmdGcm9udC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmJnRnJvbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0Mi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmxpZ2h0MiA9IG51bGw7XG4gICAgICAgIHRoaXMucGFuZGEuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5wYW5kYSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlnaHQxLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubGlnaHQxID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWx0ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmZpbHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5yb3RhdGVUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5yb3RhdGVUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLnNjZW5lcm90YXRlVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuc2NlbmVyb3RhdGVUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMlR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMlR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUxVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUxVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYW5kYVR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnBhbmRhVHh0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlckNvbG9yID0gRmlsdGVyQ29sb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlY3RhbmdsZVwiKTtcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUG9pbnRcIik7XG5jb25zdCBEaXNwbGFjZW1lbnRGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9EaXNwbGFjZW1lbnRGaWx0ZXJcIik7XG5jbGFzcyBGaWx0ZXJDcmF3bGllcyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdyYXNzVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSAxMDA7XG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoLXBhZGRpbmcsIC1wYWRkaW5nLCB0aGlzLnNpemV3ICsgcGFkZGluZyAqIDIsIHRoaXMuc2l6ZWggKyBwYWRkaW5nICogMik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWdnb3QgPSBuZXcgRXh0ZW5kZWRTcHJpdGUodGhpcy5tYWdnb3RUeHQpO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQobWFnZ290KTtcbiAgICAgICAgICAgICAgICBtYWdnb3QuZGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC5zcGVlZCA9IDE7XG4gICAgICAgICAgICAgICAgbWFnZ290LnR1cm5TcGVlZCA9IE1hdGgucmFuZG9tKCkgLSAwLjg7XG4gICAgICAgICAgICAgICAgbWFnZ290LnggPSBNYXRoLnJhbmRvbSgpICogdGhpcy5ib3VuZHMud2lkdGg7XG4gICAgICAgICAgICAgICAgbWFnZ290LnkgPSBNYXRoLnJhbmRvbSgpICogdGhpcy5ib3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIG1hZ2dvdC5zY2FsZS5zZXQoMSArIE1hdGgucmFuZG9tKCkgKiAwLjMpO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC5vcmlnaW5hbCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XG4gICAgICAgICAgICAgICAgbWFnZ290Lm9yaWdpbmFsLmNvcHlGcm9tKG1hZ2dvdC5zY2FsZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYWdnb3RzLnB1c2gobWFnZ290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmRpc3BsYWNlbWVudFR4dCk7XG4gICAgICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnRGaWx0ZXIgPSBuZXcgRGlzcGxhY2VtZW50RmlsdGVyXzEuRGlzcGxhY2VtZW50RmlsdGVyKHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmlsdGVycyA9IFtkaXNwbGFjZW1lbnRGaWx0ZXJdO1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50RmlsdGVyLnNjYWxlLnggPSAxMTA7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIuc2NhbGUueSA9IDExMDtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMucmluZyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5yaW5nVHh0KTtcbiAgICAgICAgICAgIHRoaXMucmluZy5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLnJpbmcudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnJpbmcpO1xuICAgICAgICAgICAgY29uc3QgYmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZ3Jhc3NUeHQpO1xuICAgICAgICAgICAgYmcud2lkdGggPSB0aGlzLnNpemV3O1xuICAgICAgICAgICAgYmcuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIGJnLmFscGhhID0gMC40O1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQoYmcpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX01PVkUsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfTU9WRSwgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTWFnZ290TG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hZ2dvdFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KCdleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnJykpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSaW5nTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJpbmdUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCgnZXhhbXBsZXMvYXNzZXRzL21hZ2dvdC5wbmcnKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlTWFnZ290TG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEaXNwbGFjZW1lbnRMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50VHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoJ2V4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvcmluZy5wbmcnKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUmluZ0xvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hZ2dvdFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KCdleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2Rpc3BsYWNlLnBuZycpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVEaXNwbGFjZW1lbnRMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmluZy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnBvc2l0aW9uLnNldChldmVudC5kYXRhLmdsb2JhbC54IC0gMjUsIGV2ZW50LmRhdGEuZ2xvYmFsLnkpO1xuICAgICAgICAgICAgdGhpcy5yaW5nLnBvc2l0aW9uLmNvcHlGcm9tKHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnBvc2l0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ICs9IDAuMDU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFnZ290cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hZ2dvdCA9IHRoaXMubWFnZ290c1tpXTtcbiAgICAgICAgICAgICAgICBtYWdnb3QuZGlyZWN0aW9uICs9IG1hZ2dvdC50dXJuU3BlZWQgKiAwLjAxO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC54ICs9IE1hdGguc2luKG1hZ2dvdC5kaXJlY3Rpb24pICogbWFnZ290LnNwZWVkO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC55ICs9IE1hdGguY29zKG1hZ2dvdC5kaXJlY3Rpb24pICogbWFnZ290LnNwZWVkO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC5yb3RhdGlvbiA9IC1tYWdnb3QuZGlyZWN0aW9uIC0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICAgICAgbWFnZ290LnNjYWxlLnggPSBtYWdnb3Qub3JpZ2luYWwueCArIE1hdGguc2luKHRoaXMuY291bnQpICogMC4yO1xuICAgICAgICAgICAgICAgIGlmIChtYWdnb3QueCA8IHRoaXMuYm91bmRzLngpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFnZ290LnggKz0gdGhpcy5ib3VuZHMud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hZ2dvdC54ID4gdGhpcy5ib3VuZHMueCArIHRoaXMuYm91bmRzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hZ2dvdC54IC09IHRoaXMuYm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFnZ290LnkgPCB0aGlzLmJvdW5kcy55KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hZ2dvdC55ICs9IHRoaXMuYm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFnZ290LnkgPiB0aGlzLmJvdW5kcy55ICsgdGhpcy5ib3VuZHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hZ2dvdC55IC09IHRoaXMuYm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLm1hZ2dvdHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFnZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMubWFnZ290VHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubWFnZ290VHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLnJpbmdUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5yaW5nVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncmFzc1R4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmdyYXNzVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYWdnb3RzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yaW5nLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMucmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJDcmF3bGllcyA9IEZpbHRlckNyYXdsaWVzO1xuY2xhc3MgRXh0ZW5kZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRmlsdGVyXCIpO1xuY2xhc3MgRmlsdGVyQ3VzdG9tIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ3Jhc3N0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZ3Jhc3N0eHQpO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5oZWlnaHQgPSB0aGlzLnNpemVoO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmJhY2tncm91bmQpO1xuICAgICAgICAgICAgdGhpcy51cmxsb2FkZXIgPSBuZXcgVVJMTG9hZGVyXzEuVVJMTG9hZGVyKCk7XG4gICAgICAgICAgICB0aGlzLnVybGxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRnJhZ0xvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLnVybGxvYWRlci5sb2FkKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvc2hhZGVyLmZyYWdcIikpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBmcmFnZGF0YSA9IHRoaXMudXJsbG9hZGVyLmRhdGE7XG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBGaWx0ZXJfMS5GaWx0ZXIobnVsbCwgZnJhZ2RhdGEsIHtcbiAgICAgICAgICAgICAgICBjdXN0b21Vbmlmb3JtOiAwLjBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmZpbHRlcnMgPSBbdGhpcy5maWx0ZXJdO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5jdXN0b21Vbmlmb3JtICs9IDAuMDQgKiBkZWx0YTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5ncmFzc3R4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmdyYXNzdHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVyQ3VzdG9tID0gRmlsdGVyQ3VzdG9tO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBEaXNwbGFjZW1lbnRGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9EaXNwbGFjZW1lbnRGaWx0ZXJcIik7XG5jbGFzcyBGaWx0ZXJGbGFnIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRGlzcGxhY2VtZW50TG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZmxhZ1R4dCk7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQoZmxhZyk7XG4gICAgICAgICAgICBmbGFnLnggPSAxMDA7XG4gICAgICAgICAgICBmbGFnLnkgPSAxMDA7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5yZXBlYXRUeHQpO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUudGV4dHVyZS5iYXNlVGV4dHVyZS53cmFwTW9kZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLldSQVBfTU9ERVMuUkVQRUFUO1xuICAgICAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50RmlsdGVyID0gbmV3IERpc3BsYWNlbWVudEZpbHRlcl8xLkRpc3BsYWNlbWVudEZpbHRlcih0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIucGFkZGluZyA9IDEwO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUucG9zaXRpb24gPSBmbGFnLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XG4gICAgICAgICAgICBmbGFnLmZpbHRlcnMgPSBbZGlzcGxhY2VtZW50RmlsdGVyXTtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEZpbHRlci5zY2FsZS54ID0gMzA7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIuc2NhbGUueSA9IDYwO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZS54Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUueCA+IHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUueCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsYWdUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCgnZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9kaXNwbGFjZW1lbnRfbWFwX3JlcGVhdC5qcGcnKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRGlzcGxhY2VtZW50TG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFnZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9mbGFnLnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5mbGFnVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZmxhZ1R4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVwZWF0VHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMucmVwZWF0VHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJGbGFnID0gRmlsdGVyRmxhZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZXNoZWV0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlc2hlZXRcIik7XG5jb25zdCBBbmltYXRlZFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0FuaW1hdGVkU3ByaXRlXCIpO1xuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRmlsdGVyXCIpO1xuY2xhc3MgRmlsdGVyU2hhZG93IGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMub25BbmltYXRpb25QYXJzZWQgPSAodGV4dHVyZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBpIDwgMTAgPyBgMCR7aX1gIDogaTtcbiAgICAgICAgICAgICAgICBmcmFtZXMucHVzaCh0ZXh0dXJlc1tgcm9sbFNlcXVlbmNlMDAke3ZhbH0ucG5nYF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbmltID0gbmV3IEFuaW1hdGVkU3ByaXRlXzEuQW5pbWF0ZWRTcHJpdGUoZnJhbWVzKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbS54ID0gdGhpcy5zaXpldyAvIDI7XG4gICAgICAgICAgICB0aGlzLmFuaW0ueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy5hbmltLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5hbmltYXRpb25TcGVlZCA9IDAuNTtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuYW5pbSk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBGaWx0ZXJfMS5GaWx0ZXIoRmlsdGVyU2hhZG93Lm15VmVydGV4LCBGaWx0ZXJTaGFkb3cubXlGcmFnbWVudCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5zaGFkb3dEaXJlY3Rpb24gPSBbMC4xLCAwLjVdO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIudW5pZm9ybXMuZmxvb3JZID0gdGhpcy5hbmltLmhlaWdodCAqIDI7XG4gICAgICAgICAgICB0aGlzLmZpbHRlci5wYWRkaW5nID0gMjAwO1xuICAgICAgICAgICAgdGhpcy5hbmltLmZpbHRlcnMgPSBbdGhpcy5maWx0ZXJdO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5mbG9vclkgPSB0aGlzLmFwcC5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uLm1vdXNlLmdsb2JhbC55O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUpzb25Mb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuanNvbmRhdGEgPSBKU09OLnBhcnNlKHRoaXMudXJsbG9hZGVyLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvc3ByaXRlc2hlZXQvZmlnaHRlci5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IG5ldyBTcHJpdGVzaGVldF8xLlNwcml0ZXNoZWV0KHRoaXMudHh0LCB0aGlzLmpzb25kYXRhKTtcbiAgICAgICAgICAgIHNwcml0ZXNoZWV0LnBhcnNlKHRoaXMub25BbmltYXRpb25QYXJzZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVybGxvYWRlciA9IG5ldyBVUkxMb2FkZXJfMS5VUkxMb2FkZXIoKTtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUpzb25Mb2FkZWQpO1xuICAgICAgICB0aGlzLnVybGxvYWRlci5sb2FkKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zcHJpdGVzaGVldC9maWdodGVyLmpzb25cIikpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy50eHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50eHQgPSBudWxsO1xuICAgICAgICB0aGlzLmFuaW0uZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5hbmltID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWx0ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmZpbHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuanNvbmRhdGEgPSBudWxsO1xuICAgIH1cbn1cbkZpbHRlclNoYWRvdy5teVZlcnRleCA9IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB9XG4gICAgYDtcbkZpbHRlclNoYWRvdy5teUZyYWdtZW50ID0gYFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgICAgIHVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG4gICAgICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHNoYWRvd0RpcmVjdGlvbjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBmbG9vclk7XG4gICAgICAgIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgICAgICAgICAvLzEuIGdldCB0aGUgc2NyZWVuIGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHZlYzIgc2NyZWVuQ29vcmQgPSB2VGV4dHVyZUNvb3JkICogaW5wdXRTaXplLnh5ICsgb3V0cHV0RnJhbWUueHk7XG4gICAgICAgICAgICAvLzIuIGNhbGN1bGF0ZSBZIHNoaWZ0IG9mIG91ciBkaW1lbnNpb24gdmVjdG9yXG4gICAgICAgICAgICB2ZWMyIHNoYWRvdztcbiAgICAgICAgICAgIC8vc2hhZG93IGNvb3JkaW5hdGUgc3lzdGVtIGlzIGEgYml0IHNrZXdlZCwgYnV0IGl0IGhhcyB0byBiZSB0aGUgc2FtZSBmb3Igc2NyZWVuQ29vcmQueSA9IGZsb29yWVxuICAgICAgICAgICAgZmxvYXQgcGFyYW1ZID0gKHNjcmVlbkNvb3JkLnkgLSBmbG9vclkpIC8gc2hhZG93RGlyZWN0aW9uLnk7XG4gICAgICAgICAgICBzaGFkb3cueSA9IHBhcmFtWSArIGZsb29yWTtcbiAgICAgICAgICAgIHNoYWRvdy54ID0gc2NyZWVuQ29vcmQueCArIHBhcmFtWSAqIHNoYWRvd0RpcmVjdGlvbi54O1xuICAgICAgICAgICAgdmVjMiBib2R5RmlsdGVyQ29vcmQgPSAoc2hhZG93IC0gb3V0cHV0RnJhbWUueHkpICogaW5wdXRTaXplLnp3OyAvLyBzYW1lIGFzIC8gaW5wdXRTaXplLnh5XG4gICAgICAgICAgICB2ZWM0IG9yaWdpbmFsQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICAgICAgdmVjNCBzaGFkb3dDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgYm9keUZpbHRlckNvb3JkKTtcbiAgICAgICAgICAgIHNoYWRvd0NvbG9yLnJnYiA9IHZlYzMoMC4wKTtcbiAgICAgICAgICAgIHNoYWRvd0NvbG9yLmEgKj0gMC41O1xuICAgICAgICAgICAgLy8gbm9ybWFsIGJsZW5kIG1vZGUgY29lZmZpY2llbnRzICgxLCAxLXNyY19hbHBoYSlcbiAgICAgICAgICAgIC8vIHNoYWRvdyBpcyBkZXN0aW5hdGlvbiAoYmFja2Ryb3ApLCBvcmlnaW5hbCBpcyBzb3VyY2VcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IG9yaWdpbmFsQ29sb3IgKyBzaGFkb3dDb2xvciAqICgxLjAgLSBvcmlnaW5hbENvbG9yLmEpO1xuICAgICAgICB9XG4gICAgYDtcbmV4cG9ydHMuRmlsdGVyU2hhZG93ID0gRmlsdGVyU2hhZG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcbmNsYXNzIEdyYXBoaWNzQWR2YW5jZWQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodHh0KTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxQYXRoID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgICAgIHJlYWxQYXRoLmxpbmVTdHlsZSgyLCAweEZGRkZGRiwgMSk7XG4gICAgICAgICAgICByZWFsUGF0aC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICByZWFsUGF0aC5saW5lVG8oMTAwLCAyMDApO1xuICAgICAgICAgICAgcmVhbFBhdGgubGluZVRvKDIwMCwgMjAwKTtcbiAgICAgICAgICAgIHJlYWxQYXRoLmxpbmVUbygyNDAsIDEwMCk7XG4gICAgICAgICAgICByZWFsUGF0aC5wb3NpdGlvbi54ID0gNTA7XG4gICAgICAgICAgICByZWFsUGF0aC5wb3NpdGlvbi55ID0gNTA7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHJlYWxQYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJlemllciA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICBiZXppZXIubGluZVN0eWxlKDUsIDB4QUEwMDAwLCAxKTtcbiAgICAgICAgICAgIGJlemllci5iZXppZXJDdXJ2ZVRvKDEwMCwgMjAwLCAyMDAsIDIwMCwgMjQwLCAxMDApO1xuICAgICAgICAgICAgYmV6aWVyLnBvc2l0aW9uLnggPSA1MDtcbiAgICAgICAgICAgIGJlemllci5wb3NpdGlvbi55ID0gNTA7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJlemllcik7XG4gICAgICAgICAgICBjb25zdCByZWFsUGF0aDIgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICAgICAgcmVhbFBhdGgyLmxpbmVTdHlsZSgyLCAweEZGRkZGRiwgMSk7XG4gICAgICAgICAgICByZWFsUGF0aDIubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgcmVhbFBhdGgyLmxpbmVUbygwLCAtMTAwKTtcbiAgICAgICAgICAgIHJlYWxQYXRoMi5saW5lVG8oMTUwLCAxNTApO1xuICAgICAgICAgICAgcmVhbFBhdGgyLmxpbmVUbygyNDAsIDEwMCk7XG4gICAgICAgICAgICByZWFsUGF0aDIucG9zaXRpb24ueCA9IDMyMDtcbiAgICAgICAgICAgIHJlYWxQYXRoMi5wb3NpdGlvbi55ID0gMTUwO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChyZWFsUGF0aDIpO1xuICAgICAgICAgICAgY29uc3QgYmV6aWVyMiA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICBiZXppZXIyLmxpbmVUZXh0dXJlU3R5bGUoMTAsIHNwcml0ZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGJlemllcjIuYmV6aWVyQ3VydmVUbygwLCAtMTAwLCAxNTAsIDE1MCwgMjQwLCAxMDApO1xuICAgICAgICAgICAgYmV6aWVyMi5wb3NpdGlvbi54ID0gMzIwO1xuICAgICAgICAgICAgYmV6aWVyMi5wb3NpdGlvbi55ID0gMTUwO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChiZXppZXIyKTtcbiAgICAgICAgICAgIGNvbnN0IGFyYyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICBhcmMubGluZVN0eWxlKDUsIDB4QUEwMEJCLCAxKTtcbiAgICAgICAgICAgIGFyYy5hcmMoNjAwLCAxMDAsIDUwLCBNYXRoLlBJLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGFyYyk7XG4gICAgICAgICAgICBjb25zdCBhcmMyID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgICAgIGFyYzIubGluZVN0eWxlKDYsIDB4MzMzM0RELCAxKTtcbiAgICAgICAgICAgIGFyYzIuYXJjKDY1MCwgMjcwLCA2MCwgMiAqIE1hdGguUEksIDMgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGFyYzIpO1xuICAgICAgICAgICAgY29uc3QgYXJjMyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICBhcmMzLmxpbmVUZXh0dXJlU3R5bGUoMjAsIHNwcml0ZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGFyYzMuYXJjKDY1MCwgNDIwLCA2MCwgMiAqIE1hdGguUEksIDIuNSAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYXJjMyk7XG4gICAgICAgICAgICBjb25zdCByZWN0QW5kSG9sZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICByZWN0QW5kSG9sZS5iZWdpbkZpbGwoMHgwMEZGMDApO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZHJhd1JlY3QoMzUwLCAzNTAsIDE1MCwgMTUwKTtcbiAgICAgICAgICAgIHJlY3RBbmRIb2xlLmJlZ2luSG9sZSgpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZHJhd0NpcmNsZSgzNzUsIDM3NSwgMjUpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZHJhd0NpcmNsZSg0MjUsIDQyNSwgMjUpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZHJhd0NpcmNsZSg0NzUsIDQ3NSwgMjUpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZW5kSG9sZSgpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZW5kRmlsbCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChyZWN0QW5kSG9sZSk7XG4gICAgICAgICAgICBjb25zdCBiZWF0aWZ1bFJlY3QgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICAgICAgYmVhdGlmdWxSZWN0LmxpbmVUZXh0dXJlU3R5bGUoMjAsIHNwcml0ZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGJlYXRpZnVsUmVjdC5iZWdpbkZpbGwoMHhGRjAwMDApO1xuICAgICAgICAgICAgYmVhdGlmdWxSZWN0LmRyYXdSZWN0KDgwLCAzNTAsIDE1MCwgMTUwKTtcbiAgICAgICAgICAgIGJlYXRpZnVsUmVjdC5lbmRGaWxsKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJlYXRpZnVsUmVjdCk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19yb3RhdGUuanBnXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhcGhpY3NBZHZhbmNlZCA9IEdyYXBoaWNzQWR2YW5jZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNsYXNzIEdyYXBoaWNzRHluYW1pYyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xuICAgICAgICAgICAgdGhpcy50aGluZy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lU3R5bGUoMTAsIDB4ZmYwMDAwLCAxKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcuYmVnaW5GaWxsKDB4ZmZGRjAwLCAwLjUpO1xuICAgICAgICAgICAgdGhpcy50aGluZy5tb3ZlVG8oLTEyMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjAsIC0xMDAgKyBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDIwKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcubGluZVRvKDEyMCArIE1hdGguY29zKHRoaXMuY291bnQpICogMjAsIC0xMDAgKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDIwKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcubGluZVRvKDEyMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjAsIDEwMCArIE1hdGguY29zKHRoaXMuY291bnQpICogMjApO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lVG8oLTEyMCArIE1hdGguY29zKHRoaXMuY291bnQpICogMjAsIDEwMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjApO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lVG8oLTEyMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjAsIC0xMDAgKyBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDIwKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcucm90YXRpb24gPSB0aGlzLmNvdW50ICogMC4xO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlckRvd24gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZShNYXRoLnJhbmRvbSgpICogMzAsIE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRiwgMSk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyhNYXRoLnJhbmRvbSgpICogODAwLCBNYXRoLnJhbmRvbSgpICogNjAwKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYmV6aWVyQ3VydmVUbyhNYXRoLnJhbmRvbSgpICogODAwLCBNYXRoLnJhbmRvbSgpICogNjAwLCBNYXRoLnJhbmRvbSgpICogODAwLCBNYXRoLnJhbmRvbSgpICogNjAwLCBNYXRoLnJhbmRvbSgpICogODAwLCBNYXRoLnJhbmRvbSgpICogNjAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXBwLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuYmVnaW5GaWxsKDB4RkYzMzAwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lU3R5bGUoMTAsIDB4ZmZkOTAwLCAxKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5tb3ZlVG8oNTAsIDUwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oMjUwLCA1MCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKDEwMCwgMTAwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oMjUwLCAyMjApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVUbyg1MCwgMjIwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oNTAsIDUwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKDEwLCAweEZGMDAwMCwgMC44KTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoMHhGRjcwMEIsIDEpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbygyMTAsIDMwMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKDQ1MCwgMzIwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oNTcwLCAzNTApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLnF1YWRyYXRpY0N1cnZlVG8oNjAwLCAwLCA0ODAsIDEwMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKDMzMCwgMTIwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oNDEwLCAyMDApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVUbygyMTAsIDMwMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSgyLCAweDAwMDBGRiwgMSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoNTAsIDI1MCwgMTAwLCAxMDApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSgwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoMHhGRkZGMEIsIDAuNSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd0NpcmNsZSg0NzAsIDIwMCwgMTAwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKDIwLCAweDMzRkYwMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubW92ZVRvKDMwLCAzMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKDYwMCwgMzAwKTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmdyYXBoaWNzKTtcbiAgICAgICAgdGhpcy50aGluZyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50aGluZyk7XG4gICAgICAgIHRoaXMudGhpbmcueCA9IDgwMCAvIDI7XG4gICAgICAgIHRoaXMudGhpbmcueSA9IDYwMCAvIDI7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICBhcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICB0aGlzLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5vblBvaW50ZXJEb3duKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGhpbmcuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50aGluZyA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljc0R5bmFtaWMgPSBHcmFwaGljc0R5bmFtaWM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XG5jbGFzcyBHcmFwaGljc1NpbXBsZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDA7XG4gICAgICAgIGNvbnN0IGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4REUzMjQ5KTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoNTAsIDUwLCAxMDAsIDEwMCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDIsIDB4RkVFQjc3LCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4NjUwQTVBKTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoMjAwLCA1MCwgMTAwLCAxMDApO1xuICAgICAgICBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgxMCwgMHhGRkJEMDEsIDEpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHhDMzQyODgpO1xuICAgICAgICBncmFwaGljcy5kcmF3UmVjdCgzNTAsIDUwLCAxMDAsIDEwMCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDIsIDB4RkZGRkZGLCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4QUE0RjA4KTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoNTMwLCA1MCwgMTQwLCAxMDApO1xuICAgICAgICBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgwKTsgLy8gZHJhdyBhIGNpcmNsZSwgc2V0IHRoZSBsaW5lU3R5bGUgdG8gemVybyBzbyB0aGUgY2lyY2xlIGRvZXNuJ3QgaGF2ZSBhbiBvdXRsaW5lXG4gICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweERFMzI0OSwgMSk7XG4gICAgICAgIGdyYXBoaWNzLmRyYXdDaXJjbGUoMTAwLCAyNTAsIDUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMiwgMHhGRUVCNzcsIDEpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHg2NTBBNUEsIDEpO1xuICAgICAgICBncmFwaGljcy5kcmF3Q2lyY2xlKDI1MCwgMjUwLCA1MCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDEwLCAweEZGQkQwMSwgMSk7XG4gICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweEMzNDI4OCwgMSk7XG4gICAgICAgIGdyYXBoaWNzLmRyYXdDaXJjbGUoNDAwLCAyNTAsIDUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMiwgMHhGRkZGRkYsIDEpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHhBQTRGMDgsIDEpO1xuICAgICAgICBncmFwaGljcy5kcmF3RWxsaXBzZSg2MDAsIDI1MCwgODAsIDUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHhGRjMzMDApO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoNCwgMHhmZmQ5MDAsIDEpO1xuICAgICAgICBncmFwaGljcy5tb3ZlVG8oNTAsIDM1MCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVUbygyNTAsIDM1MCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVUbygxMDAsIDQwMCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVUbyg1MCwgMzUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMiwgMHhGRjAwRkYsIDEpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHg2NTBBNUEsIDAuMjUpO1xuICAgICAgICBncmFwaGljcy5kcmF3Um91bmRlZFJlY3QoNTAsIDQ0MCwgMTAwLCAxMDAsIDE2KTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMiwgMHhGRkZGRkYpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHgzNUNDNUEsIDEpO1xuICAgICAgICBncmFwaGljcy5kcmF3U3RhcigzNjAsIDM3MCwgNSwgNTApO1xuICAgICAgICBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgyLCAweEZGRkZGRik7XG4gICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweEZGQ0M1QSwgMSk7XG4gICAgICAgIGdyYXBoaWNzLmRyYXdTdGFyKDI4MCwgNTEwLCA3LCA1MCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDQsIDB4RkZGRkZGKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4NTUzMzVBLCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1N0YXIoNDcwLCA0NTAsIDQsIDUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBjb25zdCBwYXRoID0gWzYwMCwgMzcwLCA3MDAsIDQ2MCwgNzgwLCA0MjAsIDczMCwgNTcwLCA1OTAsIDUyMF07XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgwKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4MzUwMEZBLCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1BvbHlnb24ocGF0aCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChncmFwaGljcyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljc1NpbXBsZSA9IEdyYXBoaWNzU2ltcGxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNsYXNzIEludGVyYWN0aW9uQ2xpY2sgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuU0NBTEVfTU9ERSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlNDQUxFX01PREVTLk5FQVJFU1Q7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodHh0KTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnggPSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04sIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuc3ByaXRlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUueCAqPSAxLjI1O1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUueSAqPSAxLjI1O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idW5ueS5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuc3ByaXRlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkludGVyYWN0aW9uQ2xpY2sgPSBJbnRlcmFjdGlvbkNsaWNrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNsYXNzIEludGVyYWN0aW9uRHJhZ2dpbmcgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGUgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5ORUFSRVNUO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCdW5ueShNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemV3KSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXplaCksIHRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkRyYWdTdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBidXR0b24uYWxwaGEgPSAwLjU7XG4gICAgICAgICAgICBidXR0b24uZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRHJhZ0VuZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uYWxwaGEgPSAxO1xuICAgICAgICAgICAgYnV0dG9uLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBidXR0b24uZGF0YSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25EcmFnTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBidXR0b24uZGF0YS5nZXRMb2NhbFBvc2l0aW9uKGJ1dHRvbi5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi54ID0gbmV3UG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICBidXR0b24ueSA9IG5ld1Bvc2l0aW9uLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGNyZWF0ZUJ1bm55KHgsIHksIHRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgYnVubnkgPSBuZXcgRXh0ZW5kZWRTcHJpdGUodGV4dHVyZSk7XG4gICAgICAgIGJ1bm55LmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgYnVubnkuYnV0dG9uTW9kZSA9IHRydWU7XG4gICAgICAgIGJ1bm55LmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgYnVubnkuc2NhbGUuc2V0KDMpO1xuICAgICAgICBidW5ueS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICAgIGJ1bm55LmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgICBidW5ueS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVBfT1VUU0lERSwgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgICBidW5ueS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSwgdGhpcy5vbkRyYWdNb3ZlKTtcbiAgICAgICAgLy8gRm9yIG1vdXNlLW9ubHkgZXZlbnRzXG4gICAgICAgIC8vIC5vbignbW91c2Vkb3duJywgb25EcmFnU3RhcnQpXG4gICAgICAgIC8vIC5vbignbW91c2V1cCcsIG9uRHJhZ0VuZClcbiAgICAgICAgLy8gLm9uKCdtb3VzZXVwb3V0c2lkZScsIG9uRHJhZ0VuZClcbiAgICAgICAgLy8gLm9uKCdtb3VzZW1vdmUnLCBvbkRyYWdNb3ZlKTtcbiAgICAgICAgLy8gRm9yIHRvdWNoLW9ubHkgZXZlbnRzXG4gICAgICAgIC8vIC5vbigndG91Y2hzdGFydCcsIG9uRHJhZ1N0YXJ0KVxuICAgICAgICAvLyAub24oJ3RvdWNoZW5kJywgb25EcmFnRW5kKVxuICAgICAgICAvLyAub24oJ3RvdWNoZW5kb3V0c2lkZScsIG9uRHJhZ0VuZClcbiAgICAgICAgLy8gLm9uKCd0b3VjaG1vdmUnLCBvbkRyYWdNb3ZlKTtcbiAgICAgICAgYnVubnkueCA9IHg7XG4gICAgICAgIGJ1bm55LnkgPSB5O1xuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJ1bm55KTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyYWN0aW9uRHJhZ2dpbmcgPSBJbnRlcmFjdGlvbkRyYWdnaW5nO1xuY2xhc3MgRXh0ZW5kZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBJbnRlcmFjdGlvbkljb24gZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25PdmVyTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVCdXR0b25PdmVyID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9ucyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uUG9zaXRpb25zID0gW1xuICAgICAgICAgICAgICAgIDE3NSwgNzUsXG4gICAgICAgICAgICAgICAgNjU1LCA3NSxcbiAgICAgICAgICAgICAgICA0MTAsIDMyNSxcbiAgICAgICAgICAgICAgICAxNTAsIDQ2NSxcbiAgICAgICAgICAgICAgICA2ODUsIDQ0NSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IG5ldyBFeHRlbmRlZFNwcml0ZSh0aGlzLnRleHR1cmVCdXR0b24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnggPSBidXR0b25Qb3NpdGlvbnNbaSAqIDJdO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi55ID0gYnV0dG9uUG9zaXRpb25zW2kgKiAyICsgMV07XG4gICAgICAgICAgICAgICAgYnV0dG9uLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBidXR0b24uYnV0dG9uTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOLCB0aGlzLm9uQnV0dG9uRG93bik7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5vbkJ1dHRvblVwKTtcbiAgICAgICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQX09VVFNJREUsIHRoaXMub25CdXR0b25VcCk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVkVSLCB0aGlzLm9uQnV0dG9uT3Zlcik7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVVQsIHRoaXMub25CdXR0b25PdXQpO1xuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2Vkb3duJywgb25CdXR0b25Eb3duKVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2V1cCcsIG9uQnV0dG9uVXApXG4gICAgICAgICAgICAgICAgLy8gYnV0dG9uLm9uKCdtb3VzZXVwb3V0c2lkZScsIG9uQnV0dG9uVXApXG4gICAgICAgICAgICAgICAgLy8gYnV0dG9uLm9uKCdtb3VzZW92ZXInLCBvbkJ1dHRvbk92ZXIpXG4gICAgICAgICAgICAgICAgLy8gYnV0dG9uLm9uKCdtb3VzZW91dCcsIG9uQnV0dG9uT3V0KVxuICAgICAgICAgICAgICAgIC8vIFVzZSB0b3VjaC1vbmx5IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIC5vbigndG91Y2hzdGFydCcsIG9uQnV0dG9uRG93bilcbiAgICAgICAgICAgICAgICAvLyAub24oJ3RvdWNoZW5kJywgb25CdXR0b25VcClcbiAgICAgICAgICAgICAgICAvLyAub24oJ3RvdWNoZW5kb3V0c2lkZScsIG9uQnV0dG9uVXApXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChidXR0b24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnV0dG9uc1swXS5zY2FsZS5zZXQoMS4yKTtcbiAgICAgICAgICAgIGJ1dHRvbnNbMl0ucm90YXRpb24gPSBNYXRoLlBJIC8gMTA7XG4gICAgICAgICAgICBidXR0b25zWzNdLnNjYWxlLnNldCgwLjgpO1xuICAgICAgICAgICAgYnV0dG9uc1s0XS5zY2FsZS5zZXQoMC44LCAxLjIpO1xuICAgICAgICAgICAgYnV0dG9uc1s0XS5yb3RhdGlvbiA9IE1hdGguUEk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQnV0dG9uRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uaXNkb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uRG93bjtcbiAgICAgICAgICAgIGJ1dHRvbi5hbHBoYSA9IDE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25CdXR0b25VcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uaXNkb3duID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLmlzT3Zlcikge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uT3ZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQnV0dG9uT3ZlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uaXNPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChidXR0b24uaXNkb3duKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnV0dG9uLnRleHR1cmUgPSB0aGlzLnRleHR1cmVCdXR0b25PdmVyO1xuICAgICAgICAgICAgdGhpcy5hcHAucmVuZGVyZXIudmlldy5zdHlsZS5jdXJzb3IgPSBcInVybCgnZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZycpLCBwb2ludGVyXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25CdXR0b25PdXQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYnV0dG9uLmlzT3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbi5pc2Rvd24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidXR0b24udGV4dHVyZSA9IHRoaXMudGV4dHVyZUJ1dHRvbjtcbiAgICAgICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnZpZXcuc3R5bGUuY3Vyc29yID0gXCJ1cmwoJ2V4YW1wbGVzL2Fzc2V0cy9idW5ueS5wbmcnKSwgcG9pbnRlclwiO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvbkRvd25Mb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbkRvd24gPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idXR0b25fb3Zlci5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUJ1dHRvbk92ZXJMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvbkxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnV0dG9uX2Rvd24ucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVCdXR0b25Eb3duTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0eHQpO1xuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnV0dG9uLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlQnV0dG9uTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVmYXVsdEljb24gPSBcInVybCgnZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZycpLGF1dG87XCI7XG4gICAgICAgIGNvbnN0IGhvdmVySWNvbiA9IFwidXJsKCdleGFtcGxlcy9hc3NldHMvYnVubnlfc2F0dXJhdGVkLnBuZycpLGF1dG87XCI7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX2J1dHRvbi5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRleHR1cmVCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVCdXR0b25PdmVyLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbk92ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVCdXR0b25Eb3duLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbkRvd24gPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJhY3Rpb25JY29uID0gSW50ZXJhY3Rpb25JY29uO1xuY2xhc3MgRXh0ZW5kZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBJbnRlcmFjdGlvbkludGVyYWN0aXZpdHkgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25PdmVyTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVCdXR0b25PdmVyID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9ucyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uUG9zaXRpb25zID0gW1xuICAgICAgICAgICAgICAgIDE3NSwgNzUsXG4gICAgICAgICAgICAgICAgNjU1LCA3NSxcbiAgICAgICAgICAgICAgICA0MTAsIDMyNSxcbiAgICAgICAgICAgICAgICAxNTAsIDQ2NSxcbiAgICAgICAgICAgICAgICA2ODUsIDQ0NSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IG5ldyBFeHRlbmRlZFNwcml0ZSh0aGlzLnRleHR1cmVCdXR0b24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b25Nb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBidXR0b24uYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi54ID0gYnV0dG9uUG9zaXRpb25zW2kgKiAyXTtcbiAgICAgICAgICAgICAgICBidXR0b24ueSA9IGJ1dHRvblBvc2l0aW9uc1tpICogMiArIDFdO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5vbkJ1dHRvbkRvd24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVAsIHRoaXMub25CdXR0b25VcCk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUF9PVVRTSURFLCB0aGlzLm9uQnV0dG9uVXApO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1ZFUiwgdGhpcy5vbkJ1dHRvbk92ZXIpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1VULCB0aGlzLm9uQnV0dG9uT3V0KTtcbiAgICAgICAgICAgICAgICAvLyBidXR0b24ub24oJ21vdXNlZG93bicsIG9uQnV0dG9uRG93bilcbiAgICAgICAgICAgICAgICAvLyBidXR0b24ub24oJ21vdXNldXAnLCBvbkJ1dHRvblVwKVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2V1cG91dHNpZGUnLCBvbkJ1dHRvblVwKVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2VvdmVyJywgb25CdXR0b25PdmVyKVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2VvdXQnLCBvbkJ1dHRvbk91dClcbiAgICAgICAgICAgICAgICAvLyBVc2UgdG91Y2gtb25seSBldmVudHNcbiAgICAgICAgICAgICAgICAvLyAub24oJ3RvdWNoc3RhcnQnLCBvbkJ1dHRvbkRvd24pXG4gICAgICAgICAgICAgICAgLy8gLm9uKCd0b3VjaGVuZCcsIG9uQnV0dG9uVXApXG4gICAgICAgICAgICAgICAgLy8gLm9uKCd0b3VjaGVuZG91dHNpZGUnLCBvbkJ1dHRvblVwKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goYnV0dG9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbnNbMF0uc2NhbGUuc2V0KDEuMik7XG4gICAgICAgICAgICBidXR0b25zWzJdLnJvdGF0aW9uID0gTWF0aC5QSSAvIDEwO1xuICAgICAgICAgICAgYnV0dG9uc1szXS5zY2FsZS5zZXQoMC44KTtcbiAgICAgICAgICAgIGJ1dHRvbnNbNF0uc2NhbGUuc2V0KDAuOCwgMS4yKTtcbiAgICAgICAgICAgIGJ1dHRvbnNbNF0ucm90YXRpb24gPSBNYXRoLlBJO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkJ1dHRvbkRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYnV0dG9uLmlzZG93biA9IHRydWU7XG4gICAgICAgICAgICBidXR0b24udGV4dHVyZSA9IHRoaXMudGV4dHVyZUJ1dHRvbkRvd247XG4gICAgICAgICAgICBidXR0b24uYWxwaGEgPSAxO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQnV0dG9uVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYnV0dG9uLmlzZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbi5pc092ZXIpIHtcbiAgICAgICAgICAgICAgICBidXR0b24udGV4dHVyZSA9IHRoaXMudGV4dHVyZUJ1dHRvbk92ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidXR0b24udGV4dHVyZSA9IHRoaXMudGV4dHVyZUJ1dHRvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkJ1dHRvbk92ZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYnV0dG9uLmlzT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLmlzZG93bikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uT3ZlcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkJ1dHRvbk91dCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uaXNPdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLmlzZG93bikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvbkRvd25Mb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbkRvd24gPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idXR0b25fb3Zlci5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUJ1dHRvbk92ZXJMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvbkxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnV0dG9uX2Rvd24ucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVCdXR0b25Eb3duTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0eHQpO1xuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnV0dG9uLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlQnV0dG9uTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfYnV0dG9uLmpwZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbiA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbk92ZXIuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uT3ZlciA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbkRvd24uZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uRG93biA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmFjdGlvbkludGVyYWN0aXZpdHkgPSBJbnRlcmFjdGlvbkludGVyYWN0aXZpdHk7XG5jbGFzcyBFeHRlbmRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZV8xLlNwcml0ZSB7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgQmx1ckZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0JsdXJGaWx0ZXJcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZWN0YW5nbGVcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvV2ViR0xTZXR0aW5nc1wiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xuY2xhc3MgTWFza0ZpbHRlciBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mbGFnVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gMTAwO1xuICAgICAgICAgICAgY29uc3QgYmx1clNpemUgPSAzMjtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZmxhZ1R4dCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICBjb25zdCBjaXJjbGUgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpXG4gICAgICAgICAgICAgICAgLmJlZ2luRmlsbCgweEZGMDAwMClcbiAgICAgICAgICAgICAgICAuZHJhd0NpcmNsZShyYWRpdXMgKyBibHVyU2l6ZSwgcmFkaXVzICsgYmx1clNpemUsIHJhZGl1cylcbiAgICAgICAgICAgICAgICAuZW5kRmlsbCgpO1xuICAgICAgICAgICAgY2lyY2xlLmZpbHRlcnMgPSBbbmV3IEJsdXJGaWx0ZXJfMS5CbHVyRmlsdGVyKGJsdXJTaXplKV07XG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIChyYWRpdXMgKyBibHVyU2l6ZSkgKiAyLCAocmFkaXVzICsgYmx1clNpemUpICogMik7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5hcHAucmVuZGVyZXIuZ2VuZXJhdGVUZXh0dXJlKGNpcmNsZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuU0NBTEVfTU9ERVMuTkVBUkVTVCwgMSwgYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRleHR1cmUpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmZvY3VzKTtcbiAgICAgICAgICAgIGJhY2tncm91bmQubWFzayA9IHRoaXMuZm9jdXM7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9NT1ZFLCB0aGlzLnBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucG9pbnRlck1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMucG9zaXRpb24ueCA9IGV2ZW50LmRhdGEuZ2xvYmFsLnggLSB0aGlzLmZvY3VzLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuZm9jdXMucG9zaXRpb24ueSA9IGV2ZW50LmRhdGEuZ2xvYmFsLnkgLSB0aGlzLmZvY3VzLmhlaWdodCAvIDI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmZsYWdUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5mbGFnVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5mb2N1cy5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLk1hc2tGaWx0ZXIgPSBNYXNrRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xuY29uc3QgVGV4dF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRcIik7XG5jbGFzcyBNYXNrR3JhcGhpY3MgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYW5kYUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYW5kYVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuYmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucm90YXRlVHh0KTtcbiAgICAgICAgICAgIHRoaXMuYmcuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5iZy54ID0gdGhpcy5zaXpldyAvIDI7XG4gICAgICAgICAgICB0aGlzLmJnLnkgPSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5iZyk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnggPSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnkgPSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udCA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5zY2VuZXJvdGF0ZVR4dCk7XG4gICAgICAgICAgICB0aGlzLmJnRnJvbnQuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5saWdodDIgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMubGlnaHRyb3RhdGUyVHh0KTtcbiAgICAgICAgICAgIHRoaXMubGlnaHQyLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMubGlnaHQxID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmxpZ2h0cm90YXRlMVR4dCk7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0MS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLnBhbmRhID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnBhbmRhVHh0KTtcbiAgICAgICAgICAgIHRoaXMucGFuZGEuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQodGhpcy5iZ0Zyb250KTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKHRoaXMubGlnaHQyKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKHRoaXMubGlnaHQxKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKHRoaXMucGFuZGEpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLnRoaW5nID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50aGluZyk7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLnggPSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgIHRoaXMudGhpbmcueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lU3R5bGUoMCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5tYXNrID0gdGhpcy50aGluZztcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVEFQLCB0aGlzLmhhbmRsZVN0YWdlVGFwKTtcbiAgICAgICAgICAgIGNvbnN0IGhlbHAgPSBuZXcgVGV4dF8xLlRleHQoJ0NsaWNrIG9yIHRhcCB0byB0dXJuIG1hc2tpbmcgb24gLyBvZmYuJywge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoZWxwLnkgPSB0aGlzLmFwcC5zY3JlZW4uaGVpZ2h0IC0gMzU7XG4gICAgICAgICAgICBoZWxwLnggPSAxNTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoaGVscCk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmcucm90YXRpb24gKz0gMC4wMTtcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udC5yb3RhdGlvbiAtPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy5saWdodDEucm90YXRpb24gKz0gMC4wMjtcbiAgICAgICAgICAgIHRoaXMubGlnaHQyLnJvdGF0aW9uICs9IDAuMDE7XG4gICAgICAgICAgICB0aGlzLnBhbmRhLnNjYWxlLnggPSAxICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAwLjA0O1xuICAgICAgICAgICAgdGhpcy5wYW5kYS5zY2FsZS55ID0gMSArIE1hdGguY29zKHRoaXMuY291bnQpICogMC4wNDtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xuICAgICAgICAgICAgdGhpcy50aGluZy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy50aGluZy5iZWdpbkZpbGwoMHg4YmM1ZmYsIDAuNCk7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLm1vdmVUbygtMTIwICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAyMCwgLTEwMCArIE1hdGguY29zKHRoaXMuY291bnQpICogMjApO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lVG8oMTIwICsgTWF0aC5jb3ModGhpcy5jb3VudCkgKiAyMCwgLTEwMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjApO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lVG8oMTIwICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAyMCwgMTAwICsgTWF0aC5jb3ModGhpcy5jb3VudCkgKiAyMCk7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLmxpbmVUbygtMTIwICsgTWF0aC5jb3ModGhpcy5jb3VudCkgKiAyMCwgMTAwICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAyMCk7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLnJvdGF0aW9uID0gdGhpcy5jb3VudCAqIDAuMTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTdGFnZVRhcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lci5tYXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIubWFzayA9IHRoaXMudGhpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5tYXNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVMaWdodFJvdGF0ZTFMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlnaHRyb3RhdGUxVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvbGlnaHRfcm90YXRlXzEucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVMaWdodFJvdGF0ZTFMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yb3RhdGVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19zY2VuZV9yb3RhdGUuanBnXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVTY2VuZVJvdGF0ZUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2NlbmVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2NlbmVyb3RhdGVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9saWdodF9yb3RhdGVfMi5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMkxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlTGlnaHRSb3RhdGUyTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMlR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3BhbmRhLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUGFuZGFMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDA7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIGFwcC5zdGFnZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5wYW5kYS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnBhbmRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5yb3RhdGVUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5yb3RhdGVUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLnNjZW5lcm90YXRlVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuc2NlbmVyb3RhdGVUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMlR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMlR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUxVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUxVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYW5kYVR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnBhbmRhVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250YWluZXIuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRoaW5nLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudGhpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLmJnLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuYmcgPSBudWxsO1xuICAgICAgICB0aGlzLmJnRnJvbnQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5iZ0Zyb250ID0gbnVsbDtcbiAgICAgICAgdGhpcy5saWdodDIuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5saWdodDIgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0MS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmxpZ2h0MSA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5NYXNrR3JhcGhpY3MgPSBNYXNrR3JhcGhpY3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1BvaW50XCIpO1xuY2xhc3MgTWFza1Nwcml0ZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZUZsb3dlckxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mbG93ZXJUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBiZyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5wbGFuZVR4dCk7XG4gICAgICAgICAgICBiZy53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICBiZy5oZWlnaHQgPSB0aGlzLnNpemVoO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChiZyk7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5jZWxsVHh0KTtcbiAgICAgICAgICAgIGNlbGxzLnNjYWxlLnNldCgxLjUpO1xuICAgICAgICAgICAgdGhpcy5tYXNrID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmZsb3dlclR4dCk7XG4gICAgICAgICAgICB0aGlzLm1hc2suYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5tYXNrLnggPSAzMTA7XG4gICAgICAgICAgICB0aGlzLm1hc2sueSA9IDE5MDtcbiAgICAgICAgICAgIGNlbGxzLm1hc2sgPSB0aGlzLm1hc2s7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMubWFzayk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGNlbGxzKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gbmV3IFBvaW50XzEuUG9pbnQoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXNrLnggKz0gKHRoaXMudGFyZ2V0LnggLSB0aGlzLm1hc2sueCkgKiAwLjE7XG4gICAgICAgICAgICB0aGlzLm1hc2sueSArPSAodGhpcy50YXJnZXQueSAtIHRoaXMubWFzay55KSAqIDAuMTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLm1hc2sueCAtIHRoaXMudGFyZ2V0LngpIDwgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDZWxsTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNlbGxUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9mbG93ZXJUb3AucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVGbG93ZXJMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsYW5lVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvY2VsbHMucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVDZWxsTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZU1hc2soKTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfcGxhbmUuanBnXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy50YXJnZXQueCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDU1MCk7XG4gICAgICAgIHRoaXMudGFyZ2V0LnkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzMDApO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5tYXNrLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubWFzayA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhbmVUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2VsbFR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmNlbGxUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLmZsb3dlclR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmZsb3dlclR4dCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5NYXNrU3ByaXRlID0gTWFza1Nwcml0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUG9pbnRcIik7XG5jb25zdCBTaW1wbGVSb3BlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2ltcGxlUm9wZVwiKTtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XG5jbGFzcyBNZXNoQWR2YW5jZWQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ICs9IDAuMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpXS55ID0gTWF0aC5zaW4oKGkgKiAwLjUpICsgdGhpcy5jb3VudCkgKiAzMDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpXS54ID0gaSAqIHRoaXMucm9wZUxlbmd0aCArIE1hdGguY29zKChpICogMC4zKSArIHRoaXMuY291bnQpICogMjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbmRlclBvaW50cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsYW5lVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJvcGVMZW5ndGggPSAzMDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50cy5wdXNoKG5ldyBQb2ludF8xLlBvaW50KGkgKiB0aGlzLnJvcGVMZW5ndGgsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gbmV3IFNpbXBsZVJvcGVfMS5TaW1wbGVSb3BlKHRoaXMucGxhbmVUeHQsIHRoaXMucG9pbnRzKTtcbiAgICAgICAgICAgIHN0cmlwLnggPSAyMDtcbiAgICAgICAgICAgIHN0cmlwLnkgPSAzMDA7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHN0cmlwKTtcbiAgICAgICAgICAgIHRoaXMuZyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICB0aGlzLmcueCA9IHN0cmlwLng7XG4gICAgICAgICAgICB0aGlzLmcueSA9IHN0cmlwLnk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuZyk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zbmFrZS5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIHJlbmRlclBvaW50cygpIHtcbiAgICAgICAgdGhpcy5nLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZy5saW5lU3R5bGUoMiwgMHhmZmMyYzIpO1xuICAgICAgICB0aGlzLmcubW92ZVRvKHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmcubGluZVRvKHRoaXMucG9pbnRzW2ldLngsIHRoaXMucG9pbnRzW2ldLnkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZy5iZWdpbkZpbGwoMHhmZjAwMjIpO1xuICAgICAgICAgICAgdGhpcy5nLmRyYXdDaXJjbGUodGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSwgMTApO1xuICAgICAgICAgICAgdGhpcy5nLmVuZEZpbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5wbGFuZVR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnBsYW5lVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5nLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZyA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLk1lc2hBZHZhbmNlZCA9IE1lc2hBZHZhbmNlZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUG9pbnRcIik7XG5jb25zdCBTaW1wbGVSb3BlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2ltcGxlUm9wZVwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNsYXNzIE1lc2hCYXNpYyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLnkgPSBNYXRoLnNpbigoaSAqIDAuNSkgKyB0aGlzLmNvdW50KSAqIDMwO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLnggPSBpICogdGhpcy5yb3BlTGVuZ3RoICsgTWF0aC5jb3MoKGkgKiAwLjMpICsgdGhpcy5jb3VudCkgKiAyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5yb3BlTGVuZ3RoID0gOTE4IC8gMjA7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChuZXcgUG9pbnRfMS5Qb2ludChpICogdGhpcy5yb3BlTGVuZ3RoLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJpcCA9IG5ldyBTaW1wbGVSb3BlXzEuU2ltcGxlUm9wZSh0aGlzLnBsYW5lVHh0LCB0aGlzLnBvaW50cyk7XG4gICAgICAgICAgICBzdHJpcC54ID0gLTQ1OTtcbiAgICAgICAgICAgIGNvbnN0IHNuYWtlQ29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICAgICAgc25ha2VDb250YWluZXIueCA9IDQwMDtcbiAgICAgICAgICAgIHNuYWtlQ29udGFpbmVyLnkgPSAzMDA7XG4gICAgICAgICAgICBzbmFrZUNvbnRhaW5lci5zY2FsZS5zZXQoODAwIC8gMTEwMCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHNuYWtlQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHNuYWtlQ29udGFpbmVyLmFkZENoaWxkKHN0cmlwKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3NuYWtlLnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMucGxhbmVUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLk1lc2hCYXNpYyA9IE1lc2hCYXNpYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2hhZGVyXCIpO1xuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XG5jbGFzcyBNZXNoQ29sb3JlZFRyaWFuZ2xlIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgIFstMTAwLCAtNTAsXG4gICAgICAgICAgICAxMDAsIC01MCxcbiAgICAgICAgICAgIDAuMCwgMTAwLjBdLCAvLyB4LCB5XG4gICAgICAgIDIpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYUNvbG9yJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgIFsxLCAwLCAwLFxuICAgICAgICAgICAgMCwgMSwgMCxcbiAgICAgICAgICAgIDAsIDAsIDFdLCAvLyByLCBnLCBiXG4gICAgICAgIDMpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgIGxldCB2eCA9IGBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzMgYUNvbG9yOyAgICBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OyAgICBcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7ICAgIFxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcbiAgICAgICAgICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsgICAgXG4gICAgICAgICAgICB9YDtcbiAgICAgICAgbGV0IGZ4ID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZDb2xvcjsgICAgXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIDEuMCk7XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgYDtcbiAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngsIGZ4KTtcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCBudWxsKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlLnNjYWxlLnNldCgyKTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLk1lc2hDb2xvcmVkVHJpYW5nbGUgPSBNZXNoQ29sb3JlZFRyaWFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XG5jbGFzcyBNZXNoR2VvbWV0cnkgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVUeHQzTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnR4dDMgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgWy0xMDAsIC0xMDAsXG4gICAgICAgICAgICAgICAgMTAwLCAtMTAwLFxuICAgICAgICAgICAgICAgIDEwMCwgMTAwXSwgLy8geCwgeVxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGUgICAgXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FVdnMnLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIFswLCAwLFxuICAgICAgICAgICAgICAgIDEsIDAsXG4gICAgICAgICAgICAgICAgMSwgMV0sIC8vIHUsIHZcbiAgICAgICAgICAgIDIpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlICAgIFxuICAgICAgICAgICAgY29uc3QgcHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20oYCAgICBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICBcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7ICAgIFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7ICAgIFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcbiAgICAgICAgICAgICAgICB2VXZzID0gYVV2cztcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOyAgICBcbiAgICAgICAgICAgIH1gLCBgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgIFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXJUZXh0dXJlOyAgICBcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyVGV4dHVyZSwgdlV2cyk7XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICBgKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwge1xuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQxLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwge1xuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQyLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTMgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwge1xuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQzLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5zY2FsZS5zZXQoMik7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMi5wb3NpdGlvbi5zZXQoMjAwLCAxMDApO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTMucG9zaXRpb24uc2V0KDUwMCwgNDAwKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUzLnNjYWxlLnNldCgzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZTMpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlMik7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUpO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnJvdGF0aW9uICs9IDAuMDE7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMi5yb3RhdGlvbiAtPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTMucm90YXRpb24gLT0gMC4wMDU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVHh0MkxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQyID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZGlzcGxhY2VtZW50LmpwZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0M0xvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQxID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfcm90YXRlLmpwZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MkxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMudHh0MS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDEgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlMy5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlMyA9IG51bGw7XG4gICAgICAgIHRoaXMudHJpYW5nbGUyLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUyID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmlhbmdsZS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy50eHQzLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHh0MyA9IG51bGw7XG4gICAgICAgIHRoaXMudHh0Mi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDIgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzaEdlb21ldHJ5ID0gTWVzaEdlb21ldHJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2hhZGVyXCIpO1xuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XG5jbGFzcyBNZXNoU2hhZGVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQxID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnlfMS5HZW9tZXRyeSgpO1xuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIFstMTAwLCAtMTAwLFxuICAgICAgICAgICAgICAgIDEwMCwgLTEwMCxcbiAgICAgICAgICAgICAgICAxMDAsIDEwMF0pOyAvLyB4LCB5XG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FVdnMnLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIFswLCAwLFxuICAgICAgICAgICAgICAgIDEsIDAsXG4gICAgICAgICAgICAgICAgMSwgMV0pOyAvLyB1LCB2XG4gICAgICAgICAgICBsZXQgdnggPSBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZVdnMgPSBhVXZzO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGxldCBmeCA9IGBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzO1xuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXIyO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcjIsIHZVdnMpO1xuICAgICAgICAgICAgfSAgICAgICAgXG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngsIGZ4KTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgeyB1U2FtcGxlcjI6IHRoaXMudHh0MSB9KTtcbiAgICAgICAgICAgIGxldCB2eDIgPSBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsgICAgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVXZzOyAgICBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OyAgICBcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzOyAgICBcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXG4gICAgICAgICAgICAgICAgdlV2cyA9IGFVdnM7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsgICAgXG4gICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGxldCBmeDIgPSBgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2czsgICAgXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7ICAgIFxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIyLCB2VXZzKTtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAoYWJzKHNpbihnbF9GcmFnQ29vcmQueCAqIDAuMDYpKSAqIDAuNSkgKiAyLjtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IuZyArPSAoYWJzKGNvcyhnbF9GcmFnQ29vcmQueSAqIDAuMDYpKSAqIDAuNSkgKiAyLjtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgbGV0IHByb2dyYW0yID0gbmV3IFByb2dyYW1fMS5Qcm9ncmFtKHZ4MiwgZngyKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlcjIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0yLCB7IHVTYW1wbGVyMjogdGhpcy50eHQxIH0pO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBzaGFkZXIyKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUuc2NhbGUuc2V0KDIpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIucG9zaXRpb24uc2V0KDUwMCwgNDAwKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyLnNjYWxlLnNldCgzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZTIpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIucm90YXRpb24gLT0gMC4wMDU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMudHh0MS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDEgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlMi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlMiA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNoU2hhZGVyID0gTWVzaFNoYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR2VvbWV0cnlcIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUHJvZ3JhbVwiKTtcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NoYWRlclwiKTtcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9NZXNoXCIpO1xuY2xhc3MgTWVzaFRleHR1cmVkIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGxhbmVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgWy0xMDAsIC0xMDAsXG4gICAgICAgICAgICAgICAgMTAwLCAtMTAwLFxuICAgICAgICAgICAgICAgIDEwMCwgMTAwXSwgLy8geCwgeVxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYUNvbG9yJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICBbMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAwLCAxLCAwLFxuICAgICAgICAgICAgICAgIDAsIDAsIDFdLCAvLyByLCBnLCBiXG4gICAgICAgICAgICAzKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVXZzJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICBbMCwgMCxcbiAgICAgICAgICAgICAgICAxLCAwLFxuICAgICAgICAgICAgICAgIDEsIDFdLCAvLyB1LCB2XG4gICAgICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgY29uc3QgdmVydGV4U3JjID0gYFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhQ29sb3I7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVXZzO1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2cztcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgdlV2cyA9IGFVdnM7XG4gICAgICAgICAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50U3JjID0gYFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdkNvbG9yO1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7XG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyMiwgdlV2cykgKiB2ZWM0KHZDb2xvciwgMS4wKTtcbiAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgY29uc3QgdW5pZm9ybXMgPSB7IHVTYW1wbGVyMjogdGhpcy5wbGFuZVR4dCB9O1xuICAgICAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odmVydGV4U3JjLCBmcmFnbWVudFNyYyk7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIHNoYWRlcik7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnBvc2l0aW9uLnNldCg0MDAsIDMwMCk7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnNjYWxlLnNldCgyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZSk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucm90YXRpb24gKz0gMC4wMTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfc2NlbmVfcm90YXRlLmpwZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhbmVUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNoVGV4dHVyZWQgPSBNZXNoVGV4dHVyZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR2VvbWV0cnlcIik7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUHJvZ3JhbVwiKTtcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9NZXNoXCIpO1xuY2xhc3MgTWVzaFRyaWFuZ2xlIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgWy0xMDAsIC01MCwgMTAwLCAtNTAsIDAsIDEwMF0pO1xuICAgICAgICBsZXQgdnggPSBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9YDtcbiAgICAgICAgbGV0IGZ4ID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngsIGZ4KTtcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCBudWxsKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzaFRyaWFuZ2xlID0gTWVzaFRyaWFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBNZXNoXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTWVzaFwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dlb21ldHJ5XCIpO1xuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Byb2dyYW1cIik7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XG5jbGFzcyBNZXNoVW5pZm9ybXMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5XzEuR2VvbWV0cnkoKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICBbLTEwMCwgLTEwMCxcbiAgICAgICAgICAgICAgICAxMDAsIC0xMDAsXG4gICAgICAgICAgICAgICAgMTAwLCAxMDAsXG4gICAgICAgICAgICAgICAgLTEwMCwgMTAwXSwgLy8geCwgeVxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVV2cycsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgWzAsIDAsXG4gICAgICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgIDAsIDFdLCAvLyB1LCB2XG4gICAgICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkSW5kZXgoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleFNyYyA9IGBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICBcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7ICAgIFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7ICAgIFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcbiAgICAgICAgICAgICAgICB2VXZzID0gYVV2cztcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOyAgICBcbiAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnRTcmMgPSBgICAgIFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgIFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXIyO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lOyAgICBcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyMiwgdlV2cyArIHNpbiggKHRpbWUgKyAodlV2cy54KSAqIDE0LikgKSAqIDAuMSApO1xuICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgICAgICB1U2FtcGxlcjI6IHRoaXMucGxhbmVUeHQsXG4gICAgICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtXzEuUHJvZ3JhbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUuc2NhbGUuc2V0KDIpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5zaGFkZXIudW5pZm9ybXMudGltZSArPSAwLjE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLnBsYW5lVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMucGxhbmVUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzaFVuaWZvcm1zID0gTWVzaFVuaWZvcm1zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY2xhc3MgU3ByaXRlQmFzaWMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDApIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5idW5ueSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLmJ1bm55LmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMuYnVubnkueCA9IHRoaXMuc2l6ZXcgLyAyO1xuICAgICAgICAgICAgdGhpcy5idW5ueS55ID0gdGhpcy5zaXplaCAvIDI7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuYnVubnkpO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1bm55LnJvdGF0aW9uICs9IDAuMSAqIGRlbHRhO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4RkZGMDAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idW5ueS5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5idW5ueS5kZXN0cm95KG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ByaXRlQmFzaWMgPSBTcHJpdGVCYXNpYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZXNoZWV0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlc2hlZXRcIik7XG5jb25zdCBBbmltYXRlZFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0FuaW1hdGVkU3ByaXRlXCIpO1xuY2xhc3MgU3ByaXRlRXhwbG9zaW9uIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMub25BbmltYXRpb25QYXJzZWQgPSAodGV4dHVyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGxvc2lvblRleHR1cmVzID0gW107XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRleHR1cmVzW2BFeHBsb3Npb25fU2VxdWVuY2VfQSAke2kgKyAxfS5wbmdgXTtcbiAgICAgICAgICAgICAgICBleHBsb3Npb25UZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDUwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBsb3Npb24gPSBuZXcgQW5pbWF0ZWRTcHJpdGVfMS5BbmltYXRlZFNwcml0ZShleHBsb3Npb25UZXh0dXJlcyk7XG4gICAgICAgICAgICAgICAgZXhwbG9zaW9uLnggPSBNYXRoLnJhbmRvbSgpICogdGhpcy5zaXpldztcbiAgICAgICAgICAgICAgICBleHBsb3Npb24ueSA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemVoO1xuICAgICAgICAgICAgICAgIGV4cGxvc2lvbi5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgZXhwbG9zaW9uLnJvdGF0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgZXhwbG9zaW9uLnNjYWxlLnNldCgwLjc1ICsgTWF0aC5yYW5kb20oKSAqIDAuNSk7XG4gICAgICAgICAgICAgICAgZXhwbG9zaW9uLmdvdG9BbmRQbGF5KE1hdGgucmFuZG9tKCkgKiAyNyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChleHBsb3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVKc29uTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmpzb25kYXRhID0gSlNPTi5wYXJzZSh0aGlzLnVybGxvYWRlci5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0L21jLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgbGV0IHNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0XzEuU3ByaXRlc2hlZXQodGhpcy50eHQsIHRoaXMuanNvbmRhdGEpO1xuICAgICAgICAgICAgc3ByaXRlc2hlZXQucGFyc2UodGhpcy5vbkFuaW1hdGlvblBhcnNlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMHgwMDAwMDA7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyID0gbmV3IFVSTExvYWRlcl8xLlVSTExvYWRlcigpO1xuICAgICAgICB0aGlzLnVybGxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlSnNvbkxvYWRlZCk7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmxvYWQobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0L21jLmpzb25cIikpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMudHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5qc29uZGF0YSA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5TcHJpdGVFeHBsb3Npb24gPSBTcHJpdGVFeHBsb3Npb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFVSTExvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTExvYWRlclwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEFuaW1hdGVkU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQW5pbWF0ZWRTcHJpdGVcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlc2hlZXRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVzaGVldFwiKTtcbmNsYXNzIFNwcml0ZVNwZWVkIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMub25BbmltYXRpb25QYXJzZWQgPSAobG9hZGVkdGV4dHVyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVzID0gW107XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWVrZXkgPSBgMDEyMzQ1Njc4OSAke2l9LmFzZWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IGxvYWRlZHRleHR1cmVzW2ZyYW1la2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5zcHJpdGVzaGVldC5kYXRhLmZyYW1lc1tmcmFtZWtleV0uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgdGV4dHVyZXMucHVzaCh7IHRleHR1cmUsIHRpbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY2FsaW5nID0gNDtcbiAgICAgICAgICAgIGNvbnN0IHNsb3cgPSBuZXcgQW5pbWF0ZWRTcHJpdGVfMS5BbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XG4gICAgICAgICAgICBzbG93LmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHNsb3cuc2NhbGUuc2V0KHNjYWxpbmcpO1xuICAgICAgICAgICAgc2xvdy5hbmltYXRpb25TcGVlZCA9IDAuNTtcbiAgICAgICAgICAgIHNsb3cueCA9ICh0aGlzLnNpemV3IC0gc2xvdy53aWR0aCkgLyAyO1xuICAgICAgICAgICAgc2xvdy55ID0gdGhpcy5zaXplaCAvIDI7XG4gICAgICAgICAgICBzbG93LnBsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHNsb3cpO1xuICAgICAgICAgICAgY29uc3QgZmFzdCA9IG5ldyBBbmltYXRlZFNwcml0ZV8xLkFuaW1hdGVkU3ByaXRlKHRleHR1cmVzKTtcbiAgICAgICAgICAgIGZhc3QuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgZmFzdC5zY2FsZS5zZXQoc2NhbGluZyk7XG4gICAgICAgICAgICBmYXN0LnggPSAodGhpcy5zaXpldyArIGZhc3Qud2lkdGgpIC8gMjtcbiAgICAgICAgICAgIGZhc3QueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgZmFzdC5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGZhc3QpO1xuICAgICAgICAgICAgLy8gdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVKc29uTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmpzb25kYXRhID0gSlNPTi5wYXJzZSh0aGlzLnVybGxvYWRlci5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0LzAxMjM0NTY3ODkucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0XzEuU3ByaXRlc2hlZXQodGhpcy50eHQsIHRoaXMuanNvbmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGVzaGVldC5wYXJzZSh0aGlzLm9uQW5pbWF0aW9uUGFyc2VkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAweDU3QUFDQztcbiAgICAgICAgdGhpcy51cmxsb2FkZXIgPSBuZXcgVVJMTG9hZGVyXzEuVVJMTG9hZGVyKCk7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVKc29uTG9hZGVkKTtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIubG9hZChuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvc3ByaXRlc2hlZXQvMDEyMzQ1Njc4OS5qc29uXCIpKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuc3ByaXRlc2hlZXQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5zcHJpdGVzaGVldCA9IG51bGw7XG4gICAgICAgIHRoaXMudHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbmltLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuYW5pbSA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5TcHJpdGVTcGVlZCA9IFNwcml0ZVNwZWVkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBTcHJpdGVTd2FwIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnR4dDEgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9lZ2dIZWFkLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlMkxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlMkxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQyID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5kdWRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnR4dDEpO1xuICAgICAgICAgICAgdGhpcy5kdWRlLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMuZHVkZS54ID0gdGhpcy5zaXpldyAvIDI7XG4gICAgICAgICAgICB0aGlzLmR1ZGUueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmR1ZGUpO1xuICAgICAgICAgICAgdGhpcy5kdWRlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHVkZS5idXR0b25Nb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZHVkZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5oYW5kbGVEb3duKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ib2wgPSAhdGhpcy5ib2w7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2wpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR1ZGUudGV4dHVyZSA9IHRoaXMudHh0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHVkZS50ZXh0dXJlID0gdGhpcy50eHQxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHVkZS5yb3RhdGlvbiArPSAwLjE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2Zsb3dlclRvcC5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5kdWRlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZHVkZSA9IG51bGw7XG4gICAgICAgIHRoaXMudHh0MS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDEgPSBudWxsO1xuICAgICAgICB0aGlzLnR4dDIuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50eHQyID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlNwcml0ZVN3YXAgPSBTcHJpdGVTd2FwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgVGlsaW5nU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGlsaW5nU3ByaXRlXCIpO1xuY2xhc3MgU3ByaXRlVGlsaW5nIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnR4dDEgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1Nwcml0ZSA9IG5ldyBUaWxpbmdTcHJpdGVfMS5UaWxpbmdTcHJpdGUodGhpcy50eHQxLCB0aGlzLnNpemV3LCB0aGlzLnNpemVoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50aWxpbmdTcHJpdGUpO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4wMDU7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1Nwcml0ZS50aWxlU2NhbGUueCA9IDIgKyBNYXRoLnNpbih0aGlzLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nU3ByaXRlLnRpbGVTY2FsZS55ID0gMiArIE1hdGguY29zKHRoaXMuY291bnQpO1xuICAgICAgICAgICAgdGhpcy50aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLnggKz0gMTtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nU3ByaXRlLnRpbGVQb3NpdGlvbi55ICs9IDE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3AyLmpwZWdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy50aWxpbmdTcHJpdGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50aWxpbmdTcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnR4dDEuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50eHQxID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlNwcml0ZVRpbGluZyA9IFNwcml0ZVRpbGluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY2xhc3MgU3ByaXRlVmlkZW8gZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5vblBsYXlWaWRlbyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b24uZGVzdHJveShudWxsKTtcbiAgICAgICAgICAgIHRoaXMudmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLnZpZGVvKSk7XG4gICAgICAgICAgICBjb25zdCB2aWRlb1Nwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAgICB2aWRlb1Nwcml0ZS53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICB2aWRlb1Nwcml0ZS5oZWlnaHQgPSB0aGlzLnNpemVoO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh2aWRlb1Nwcml0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYnV0dG9uID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKVxuICAgICAgICAgICAgLmJlZ2luRmlsbCgweDAsIDAuNSlcbiAgICAgICAgICAgIC5kcmF3Um91bmRlZFJlY3QoMCwgMCwgMTAwLCAxMDAsIDEwKVxuICAgICAgICAgICAgLmVuZEZpbGwoKVxuICAgICAgICAgICAgLmJlZ2luRmlsbCgweGZmZmZmZilcbiAgICAgICAgICAgIC5tb3ZlVG8oMzYsIDMwKVxuICAgICAgICAgICAgLmxpbmVUbygzNiwgNzApXG4gICAgICAgICAgICAubGluZVRvKDcwLCA1MCk7XG4gICAgICAgIHRoaXMuYnV0dG9uLnggPSAodGhpcy5zaXpldyAtIHRoaXMuYnV0dG9uLndpZHRoKSAvIDI7XG4gICAgICAgIHRoaXMuYnV0dG9uLnkgPSAodGhpcy5zaXplaCAtIHRoaXMuYnV0dG9uLmhlaWdodCkgLyAyO1xuICAgICAgICB0aGlzLmJ1dHRvbi5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYnV0dG9uLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuYnV0dG9uKTtcbiAgICAgICAgdGhpcy52aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ2aWRlb1wiKTtcbiAgICAgICAgdGhpcy52aWRlb1sndHlwZSddID0gXCJ2aWRlby9tcDRcIjtcbiAgICAgICAgdGhpcy52aWRlby5zcmMgPSBcImV4YW1wbGVzL2Fzc2V0cy92aWRlby5tcDRcIjtcbiAgICAgICAgdGhpcy52aWRlby5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1RBUCwgdGhpcy5vblBsYXlWaWRlbyk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLnZpZGVvID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlNwcml0ZVZpZGVvID0gU3ByaXRlVmlkZW87XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFVSTExvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTExvYWRlclwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBTcHJpdGVzaGVldF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZXNoZWV0XCIpO1xuY29uc3QgQW5pbWF0ZWRTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9BbmltYXRlZFNwcml0ZVwiKTtcbmNsYXNzIFNwcml0ZWpldCBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLm9uQW5pbWF0aW9uUGFyc2VkID0gKHRleHR1cmVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzA7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGkgPCAxMCA/IGAwJHtpfWAgOiBpO1xuICAgICAgICAgICAgICAgIGZyYW1lcy5wdXNoKHRleHR1cmVzW2Byb2xsU2VxdWVuY2UwMCR7dmFsfS5wbmdgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFuaW0gPSBuZXcgQW5pbWF0ZWRTcHJpdGVfMS5BbmltYXRlZFNwcml0ZShmcmFtZXMpO1xuICAgICAgICAgICAgdGhpcy5hbmltLnggPSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgIHRoaXMuYW5pbS55ID0gdGhpcy5zaXplaCAvIDI7XG4gICAgICAgICAgICB0aGlzLmFuaW0uYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5hbmltLmFuaW1hdGlvblNwZWVkID0gMC41O1xuICAgICAgICAgICAgdGhpcy5hbmltLnBsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5hbmltKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hbmltLnJvdGF0aW9uICs9IDAuMDE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlSnNvbkxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5qc29uZGF0YSA9IEpTT04ucGFyc2UodGhpcy51cmxsb2FkZXIuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zcHJpdGVzaGVldC9maWdodGVyLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgbGV0IHNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0XzEuU3ByaXRlc2hlZXQodGhpcy50eHQsIHRoaXMuanNvbmRhdGEpO1xuICAgICAgICAgICAgc3ByaXRlc2hlZXQucGFyc2UodGhpcy5vbkFuaW1hdGlvblBhcnNlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMHg5Njk2OTY7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyID0gbmV3IFVSTExvYWRlcl8xLlVSTExvYWRlcigpO1xuICAgICAgICB0aGlzLnVybGxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlSnNvbkxvYWRlZCk7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmxvYWQobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0L2ZpZ2h0ZXIuanNvblwiKSk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLmFuaW0uZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5hbmltID0gbnVsbDtcbiAgICAgICAgdGhpcy50eHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50eHQgPSBudWxsO1xuICAgICAgICB0aGlzLmpzb25kYXRhID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlNwcml0ZWpldCA9IFNwcml0ZWpldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVGV4dF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRcIik7XG5jb25zdCBUZXh0U3R5bGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0U3R5bGVcIik7XG5jbGFzcyBUZXh0QmFzZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBiYXNpY1RleHQgPSBuZXcgVGV4dF8xLlRleHQoJ0Jhc2ljIHRleHQgaW4gcGl4aScpO1xuICAgICAgICBiYXNpY1RleHQueCA9IDUwO1xuICAgICAgICBiYXNpY1RleHQueSA9IDEwMDtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChiYXNpY1RleHQpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IG5ldyBUZXh0U3R5bGVfMS5UZXh0U3R5bGUoe1xuICAgICAgICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAzNixcbiAgICAgICAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYycsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICBmaWxsOiBbJyNmZmZmZmYnLCAnIzAwZmY5OSddLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzRhMTg1MCcsXG4gICAgICAgICAgICBzdHJva2VUaGlja25lc3M6IDUsXG4gICAgICAgICAgICBkcm9wU2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgZHJvcFNoYWRvd0NvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBkcm9wU2hhZG93Qmx1cjogNCxcbiAgICAgICAgICAgIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXG4gICAgICAgICAgICBkcm9wU2hhZG93RGlzdGFuY2U6IDYsXG4gICAgICAgICAgICB3b3JkV3JhcDogdHJ1ZSxcbiAgICAgICAgICAgIHdvcmRXcmFwV2lkdGg6IDQ0MCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJpY2hUZXh0ID0gbmV3IFRleHRfMS5UZXh0KCdSaWNoIHRleHQgd2l0aCBhIGxvdCBvZiBvcHRpb25zIGFuZCBhY3Jvc3MgbXVsdGlwbGUgbGluZXMnLCBzdHlsZSk7XG4gICAgICAgIHJpY2hUZXh0LnggPSA1MDtcbiAgICAgICAgcmljaFRleHQueSA9IDI1MDtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChyaWNoVGV4dCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0QmFzZSA9IFRleHRCYXNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBGb250TWFuYWdlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0ZvbnRNYW5hZ2VyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IEJpdG1hcFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CaXRtYXBUZXh0XCIpO1xuY2xhc3MgVGV4dEJpdG1hcCBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZUZvbnRMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJpdG1hcEZvbnRUZXh0ID0gbmV3IEJpdG1hcFRleHRfMS5CaXRtYXBUZXh0KCdiaXRtYXAgZm9udHMgYXJlIHN1cHBvcnRlZCFcXG5Xb28geWF5IScpO1xuICAgICAgICAgICAgYml0bWFwRm9udFRleHQuZm9udFNpemUgPSA1NTtcbiAgICAgICAgICAgIGJpdG1hcEZvbnRUZXh0LmZvbnQgPSBcIkRlc3lyZWxcIjtcbiAgICAgICAgICAgIGJpdG1hcEZvbnRUZXh0LmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgYml0bWFwRm9udFRleHQueCA9IDUwO1xuICAgICAgICAgICAgYml0bWFwRm9udFRleHQueSA9IDIwMDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYml0bWFwRm9udFRleHQpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxvYWRlciA9IEZvbnRNYW5hZ2VyXzEuRm9udE1hbmFnZXIubG9hZEJpdG1hcEZvbnQoXCJleGFtcGxlcy9hc3NldHMvYml0bWFwLWZvbnQvZGVzeXJlbC54bWxcIik7XG4gICAgICAgIGxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRm9udExvYWRlZCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0Qml0bWFwID0gVGV4dEJpdG1hcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgRm9udE1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Gb250TWFuYWdlclwiKTtcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0XCIpO1xuY2xhc3MgVGV4dFdlYkZvbnQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVXZWJGb250TG9hZGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dFNhbXBsZSA9IG5ldyBUZXh0XzEuVGV4dCgnUGl4aS5qcyB0ZXh0IHVzaW5nIHRoZVxcbmN1c3RvbSBcIlNuaXBwZXRcIiBXZWJmb250Jywge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdTbmlwcGV0JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogNTAsXG4gICAgICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICBhbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0ZXh0U2FtcGxlLnBvc2l0aW9uLnNldCg1MCwgMjAwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGV4dFNhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICBGb250TWFuYWdlcl8xLkZvbnRNYW5hZ2VyLm9uV2ViRm9udGxvYWRlZCA9IHRoaXMuaGFuZGxlV2ViRm9udExvYWRlZDtcbiAgICAgICAgRm9udE1hbmFnZXJfMS5Gb250TWFuYWdlci5XZWJGb250Q29uZmlnID0ge1xuICAgICAgICAgICAgZ29vZ2xlOiB7XG4gICAgICAgICAgICAgICAgZmFtaWxpZXM6IFsnU25pcHBldCcsICdBcnZvOjcwMGl0YWxpYycsICdQb2Rrb3ZhOjcwMCddLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGV4dFdlYkZvbnQgPSBUZXh0V2ViRm9udDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY2xhc3MgVGV4dHVyZUFkdmFuY2VkIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaXRlbS5yb3RhdGlvbiArPSAwLjE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvdW50ICs9IDAuMDE7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gdGhpcy5yZW5kZXJUZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gdGhpcy5yZW5kZXJUZXh0dXJlMjtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZTIgPSB0ZW1wO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRTcHJpdGUudGV4dHVyZSA9IHRoaXMucmVuZGVyVGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuc3R1ZmZDb250YWluZXIucm90YXRpb24gLT0gMC4wMTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3ByaXRlLnNjYWxlLnNldCgxICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAwLjIpO1xuICAgICAgICAgICAgdGhpcy5hcHAucmVuZGVyZXIucmVuZGVyKHRoaXMuc3RhZ2UsIHRoaXMucmVuZGVyVGV4dHVyZTIsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuZnJ1aXRzLnB1c2godHh0KTtcbiAgICAgICAgICAgIHRoaXMubG9hZEFzc2V0cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUodGhpcy5zaXpldywgdGhpcy5zaXplaCk7XG4gICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZTIgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUodGhpcy5zaXpldywgdGhpcy5zaXplaCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0dXJlID0gdGhpcy5yZW5kZXJUZXh0dXJlO1xuICAgICAgICB0aGlzLm91dHB1dFNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUoY3VycmVudFRleHR1cmUpO1xuICAgICAgICB0aGlzLm91dHB1dFNwcml0ZS54ID0gNDAwO1xuICAgICAgICB0aGlzLm91dHB1dFNwcml0ZS55ID0gMzAwO1xuICAgICAgICB0aGlzLm91dHB1dFNwcml0ZS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5vdXRwdXRTcHJpdGUpO1xuICAgICAgICB0aGlzLnN0dWZmQ29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLnN0dWZmQ29udGFpbmVyLnggPSA0MDA7XG4gICAgICAgIHRoaXMuc3R1ZmZDb250YWluZXIueSA9IDMwMDtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnN0dWZmQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5mcnVpdHNsaW5rcyA9IFtcbiAgICAgICAgICAgICdleGFtcGxlcy9hc3NldHMvcnRfb2JqZWN0XzAxLnBuZycsXG4gICAgICAgICAgICAnZXhhbXBsZXMvYXNzZXRzL3J0X29iamVjdF8wMi5wbmcnLFxuICAgICAgICAgICAgJ2V4YW1wbGVzL2Fzc2V0cy9ydF9vYmplY3RfMDMucG5nJyxcbiAgICAgICAgICAgICdleGFtcGxlcy9hc3NldHMvcnRfb2JqZWN0XzA0LnBuZycsXG4gICAgICAgICAgICAnZXhhbXBsZXMvYXNzZXRzL3J0X29iamVjdF8wNS5wbmcnLFxuICAgICAgICAgICAgJ2V4YW1wbGVzL2Fzc2V0cy9ydF9vYmplY3RfMDYucG5nJyxcbiAgICAgICAgICAgICdleGFtcGxlcy9hc3NldHMvcnRfb2JqZWN0XzA3LnBuZycsXG4gICAgICAgICAgICAnZXhhbXBsZXMvYXNzZXRzL3J0X29iamVjdF8wOC5wbmcnLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmZydWl0cyA9IFtdO1xuICAgICAgICB0aGlzLmxvYWRBc3NldHMoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZnJ1aXRzW2kgJSB0aGlzLmZydWl0cy5sZW5ndGhdKTtcbiAgICAgICAgICAgIGl0ZW0ueCA9IE1hdGgucmFuZG9tKCkgKiA0MDAgLSAyMDA7XG4gICAgICAgICAgICBpdGVtLnkgPSBNYXRoLnJhbmRvbSgpICogNDAwIC0gMjAwO1xuICAgICAgICAgICAgaXRlbS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLnN0dWZmQ29udGFpbmVyLmFkZENoaWxkKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgfVxuICAgIGxvYWRBc3NldHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5mcnVpdHNsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KHRoaXMuZnJ1aXRzbGlua3MucG9wKCkpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5zdHVmZkNvbnRhaW5lci5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnN0dWZmQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5vdXRwdXRTcHJpdGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLml0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcnVpdHNsaW5rcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJ1aXRzID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlRleHR1cmVBZHZhbmNlZCA9IFRleHR1cmVBZHZhbmNlZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jbGFzcyBUZXh0dXJlR3JhZGllbnRCYXNpYyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBncmFkVGV4dHVyZSA9IHRoaXMuY3JlYXRlR3JhZFRleHR1cmUoKTtcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZShncmFkVGV4dHVyZSk7XG4gICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoMTAwLCAxMDApO1xuICAgICAgICBzcHJpdGUucm90YXRpb24gPSBNYXRoLlBJIC8gODtcbiAgICAgICAgc3ByaXRlLndpZHRoID0gNTAwO1xuICAgICAgICBzcHJpdGUuaGVpZ2h0ID0gNTA7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgY3JlYXRlR3JhZFRleHR1cmUoKSB7XG4gICAgICAgIGNvbnN0IHF1YWxpdHkgPSAyNTY7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBxdWFsaXR5O1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnN0IGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBxdWFsaXR5LCAwKTtcbiAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgwLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjApJyk7XG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMC4zLCAnY3lhbicpO1xuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAuNywgJ3JlZCcpO1xuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDEsICdncmVlbicpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JkO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgcXVhbGl0eSwgMSk7XG4gICAgICAgIHJldHVybiBUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKGNhbnZhcyk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0dXJlR3JhZGllbnRCYXNpYyA9IFRleHR1cmVHcmFkaWVudEJhc2ljO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY2xhc3MgVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZ3JhZEJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUobmV3IEdyYWRpZW50UmVzb3VyY2UoKSk7XG4gICAgICAgIGdyYWRCYXNlVGV4dHVyZS5zZXRTaXplKDUwMCwgNTApO1xuICAgICAgICBjb25zdCBncmFkVGV4dHVyZSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShncmFkQmFzZVRleHR1cmUpO1xuICAgICAgICBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKGdyYWRUZXh0dXJlKTtcbiAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCgxMDAsIDEwMCk7XG4gICAgICAgIHNwcml0ZS5yb3RhdGlvbiA9IE1hdGguUEkgLyA4O1xuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHNwcml0ZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0dXJlR3JhZGllbnRSZXNvdXJjZSA9IFRleHR1cmVHcmFkaWVudFJlc291cmNlO1xuY2xhc3MgR3JhZGllbnRSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlXzEuUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyNTYsIDEwMCk7XG4gICAgICAgIHRoaXMuY2FuVXBsb2FkID0gdHJ1ZTtcbiAgICB9XG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IHRoaXM7IC8vIGRlZmF1bHQgc2l6ZSBvciBmcm9tIGJhc2VUZXh0dXJlP1xuICAgICAgICBjb25zdCB7IGhlaWdodCB9ID0gdGhpczsgLy8geW91ciBjaG9pY2UuXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5zb3VyY2Uud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5zb3VyY2UuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLnNvdXJjZS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjb25zdCBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDApO1xuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMCknKTtcbiAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgwLjMsICdjeWFuJyk7XG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMC43LCAncmVkJyk7XG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMSwgJ2dyZWVuJyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IHsgZ2wgfSA9IHJlbmRlcmVyO1xuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHRoaXMuc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBCYXNlUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VSZW5kZXJUZXh0dXJlXCIpO1xuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmVcIik7XG5jbGFzcyBUZXh0dXJlUmVuZGVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVubnkgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHR4dCk7XG4gICAgICAgICAgICAgICAgYnVubnkueCA9IChpICUgNSkgKiAzMDtcbiAgICAgICAgICAgICAgICBidW5ueS55ID0gTWF0aC5mbG9vcihpIC8gNSkgKiAzMDtcbiAgICAgICAgICAgICAgICBidW5ueS5yb3RhdGlvbiA9IE1hdGgucmFuZG9tKCkgKiAoTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKGJ1bm55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJydCA9IG5ldyBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKDMwMCwgMzAwLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5MSU5FQVIsIDEpO1xuICAgICAgICAgICAgdGhpcy5ydCA9IG5ldyBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZShicnQpO1xuICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnJ0KTtcbiAgICAgICAgICAgIHNwcml0ZS54ID0gNDUwO1xuICAgICAgICAgICAgc3ByaXRlLnkgPSA2MDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnggPSAxMDA7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci55ID0gNjA7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnJlbmRlcih0aGlzLmNvbnRhaW5lciwgdGhpcy5ydCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5ydC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnJ0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlRleHR1cmVSZW5kZXIgPSBUZXh0dXJlUmVuZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR3JvdXBEOF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyb3VwRDhcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZWN0YW5nbGVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFwiKTtcbmNsYXNzIFRleHR1cmVSb3RhdGUgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVzID0gW3R4dF07XG4gICAgICAgICAgICBjb25zdCBEOCA9IEdyb3VwRDhfMS5Hcm91cEQ4O1xuICAgICAgICAgICAgZm9yIChsZXQgcm90YXRlID0gMTsgcm90YXRlIDwgMTY7IHJvdGF0ZSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IEQ4LmlzVmVydGljYWwocm90YXRlKSA/IHR4dC5mcmFtZS53aWR0aCA6IHR4dC5mcmFtZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IEQ4LmlzVmVydGljYWwocm90YXRlKSA/IHR4dC5mcmFtZS5oZWlnaHQgOiB0eHQuZnJhbWUud2lkdGg7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcmFtZSB9ID0gdHh0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyb3AgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHR4dC5mcmFtZS54LCB0eHQuZnJhbWUueSwgdywgaCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbSA9IGNyb3A7XG4gICAgICAgICAgICAgICAgbGV0IHJvdGF0ZWRUZXh0dXJlO1xuICAgICAgICAgICAgICAgIGlmIChyb3RhdGUgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZWRUZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKHR4dC5iYXNlVGV4dHVyZSwgZnJhbWUsIGNyb3AsIHRyaW0sIHJvdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3RhdGVkVGV4dHVyZSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZSh0eHQuYmFzZVRleHR1cmUsIGZyYW1lLCBjcm9wLCB0cmltLCByb3RhdGUgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlZFRleHR1cmUucm90YXRlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHR1cmVzLnB1c2gocm90YXRlZFRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IHRoaXMuc2l6ZXcgLyAxNiB8IDA7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gdGhpcy5zaXplaCAvIDggfCAwO1xuICAgICAgICAgICAgY29uc3QgZ3JpZFcgPSB0aGlzLnNpemV3IC8gNCB8IDA7XG4gICAgICAgICAgICBjb25zdCBncmlkSCA9IHRoaXMuc2l6ZWggLyA1IHwgMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1ZGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRleHR1cmVzW2kgPCA4ID8gaSAqIDIgOiAoaSAtIDgpICogMiArIDFdKTtcbiAgICAgICAgICAgICAgICBkdWRlLnNjYWxlLnggPSAwLjU7XG4gICAgICAgICAgICAgICAgZHVkZS5zY2FsZS55ID0gMC41O1xuICAgICAgICAgICAgICAgIGR1ZGUueCA9IG9mZnNldFggKyBncmlkVyAqIChpICUgNCk7XG4gICAgICAgICAgICAgICAgZHVkZS55ID0gb2Zmc2V0WSArIGdyaWRIICogKGkgLyA0IHwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChkdWRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHRfMS5UZXh0KGByb3RhdGUgPSAke2R1ZGUudGV4dHVyZS5yb3RhdGV9YCwge1xuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnQ291cmllciBOZXcnLCBmb250U2l6ZTogJzEycHgnLCBmaWxsOiAnd2hpdGUnLCBhbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHQueCA9IGR1ZGUueDtcbiAgICAgICAgICAgICAgICB0ZXh0LnkgPSBkdWRlLnkgLSAyMDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvZmxvd2VyVG9wLnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG59XG5leHBvcnRzLlRleHR1cmVSb3RhdGUgPSBUZXh0dXJlUm90YXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgRXhhbXBsZUxpc3RfMSA9IHJlcXVpcmUoXCIuL0V4YW1wbGVMaXN0XCIpO1xuY29uc3QgQWR2YW5jZWRDYXJkXzEgPSByZXF1aXJlKFwiLi4vQWR2YW5jZWRDYXJkXCIpO1xuY29uc3QgQWR2YW5jZWRTbG90c18xID0gcmVxdWlyZShcIi4uL0FkdmFuY2VkU2xvdHNcIik7XG5jb25zdCBBZHZhbmNlZFRyYWlsXzEgPSByZXF1aXJlKFwiLi4vQWR2YW5jZWRUcmFpbFwiKTtcbmNvbnN0IEFkdmFuY2VkV2FycF8xID0gcmVxdWlyZShcIi4uL0FkdmFuY2VkV2FycFwiKTtcbmNvbnN0IEJhc2ljQmxlbmRfMSA9IHJlcXVpcmUoXCIuLi9CYXNpY0JsZW5kXCIpO1xuY29uc3QgSW50ZXJhY3Rpb25JY29uXzEgPSByZXF1aXJlKFwiLi4vSW50ZXJhY3Rpb25JY29uXCIpO1xuY29uc3QgU3ByaXRlVmlkZW9fMSA9IHJlcXVpcmUoXCIuLi9TcHJpdGVWaWRlb1wiKTtcbmNvbnN0IFRleHR1cmVSb3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9UZXh0dXJlUm90YXRlXCIpO1xuY29uc3QgQmFzaWNDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNpY0NvbnRhaW5lclwiKTtcbmNvbnN0IEJhc2ljVGludGluZ18xID0gcmVxdWlyZShcIi4uL0Jhc2ljVGludGluZ1wiKTtcbmNvbnN0IEJhc2ljUGFydGljbGVzXzEgPSByZXF1aXJlKFwiLi4vQmFzaWNQYXJ0aWNsZXNcIik7XG5jb25zdCBHcmFwaGljc1NpbXBsZV8xID0gcmVxdWlyZShcIi4uL0dyYXBoaWNzU2ltcGxlXCIpO1xuY29uc3QgR3JhcGhpY3NBZHZhbmNlZF8xID0gcmVxdWlyZShcIi4uL0dyYXBoaWNzQWR2YW5jZWRcIik7XG5jb25zdCBHcmFwaGljc0R5bmFtaWNfMSA9IHJlcXVpcmUoXCIuLi9HcmFwaGljc0R5bmFtaWNcIik7XG5jb25zdCBUZXh0dXJlUmVuZGVyXzEgPSByZXF1aXJlKFwiLi4vVGV4dHVyZVJlbmRlclwiKTtcbmNvbnN0IFRleHR1cmVBZHZhbmNlZF8xID0gcmVxdWlyZShcIi4uL1RleHR1cmVBZHZhbmNlZFwiKTtcbmNvbnN0IFRleHR1cmVHcmFkaWVudEJhc2ljXzEgPSByZXF1aXJlKFwiLi4vVGV4dHVyZUdyYWRpZW50QmFzaWNcIik7XG5jb25zdCBUZXh0dXJlR3JhZGllbnRSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4uL1RleHR1cmVHcmFkaWVudFJlc291cmNlXCIpO1xuY29uc3QgVGV4dEJhc2VfMSA9IHJlcXVpcmUoXCIuLi9UZXh0QmFzZVwiKTtcbmNvbnN0IFRleHRCaXRtYXBfMSA9IHJlcXVpcmUoXCIuLi9UZXh0Qml0bWFwXCIpO1xuY29uc3QgVGV4dFdlYkZvbnRfMSA9IHJlcXVpcmUoXCIuLi9UZXh0V2ViRm9udFwiKTtcbmNvbnN0IE1hc2tHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL01hc2tHcmFwaGljc1wiKTtcbmNvbnN0IE1hc2tTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9NYXNrU3ByaXRlXCIpO1xuY29uc3QgRmlsdGVyQmx1cl8xID0gcmVxdWlyZShcIi4uL0ZpbHRlckJsdXJcIik7XG5jb25zdCBGaWx0ZXJDb2xvcl8xID0gcmVxdWlyZShcIi4uL0ZpbHRlckNvbG9yXCIpO1xuY29uc3QgRmlsdGVyQ3Jhd2xpZXNfMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJDcmF3bGllc1wiKTtcbmNvbnN0IEZpbHRlckZsYWdfMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJGbGFnXCIpO1xuY29uc3QgTWFza0ZpbHRlcl8xID0gcmVxdWlyZShcIi4uL01hc2tGaWx0ZXJcIik7XG5jb25zdCBJbnRlcmFjdGlvbkNsaWNrXzEgPSByZXF1aXJlKFwiLi4vSW50ZXJhY3Rpb25DbGlja1wiKTtcbmNvbnN0IEludGVyYWN0aW9uSW50ZXJhY3Rpdml0eV8xID0gcmVxdWlyZShcIi4uL0ludGVyYWN0aW9uSW50ZXJhY3Rpdml0eVwiKTtcbmNvbnN0IEludGVyYWN0aW9uRHJhZ2dpbmdfMSA9IHJlcXVpcmUoXCIuLi9JbnRlcmFjdGlvbkRyYWdnaW5nXCIpO1xuY29uc3QgU3ByaXRlQmFzaWNfMSA9IHJlcXVpcmUoXCIuLi9TcHJpdGVCYXNpY1wiKTtcbmNvbnN0IFNwcml0ZVN3YXBfMSA9IHJlcXVpcmUoXCIuLi9TcHJpdGVTd2FwXCIpO1xuY29uc3QgU3ByaXRlVGlsaW5nXzEgPSByZXF1aXJlKFwiLi4vU3ByaXRlVGlsaW5nXCIpO1xuY29uc3QgU3ByaXRlRXhwbG9zaW9uXzEgPSByZXF1aXJlKFwiLi4vU3ByaXRlRXhwbG9zaW9uXCIpO1xuY29uc3QgU3ByaXRlamV0XzEgPSByZXF1aXJlKFwiLi4vU3ByaXRlamV0XCIpO1xuY29uc3QgU3ByaXRlU3BlZWRfMSA9IHJlcXVpcmUoXCIuLi9TcHJpdGVTcGVlZFwiKTtcbmNvbnN0IEZpbHRlckJsZW5kaW5nXzEgPSByZXF1aXJlKFwiLi4vRmlsdGVyQmxlbmRpbmdcIik7XG5jb25zdCBGaWx0ZXJDdXN0b21fMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJDdXN0b21cIik7XG5jb25zdCBGaWx0ZXJTaGFkb3dfMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJTaGFkb3dcIik7XG5jb25zdCBNZXNoQmFzaWNfMSA9IHJlcXVpcmUoXCIuLi9NZXNoQmFzaWNcIik7XG5jb25zdCBNZXNoQWR2YW5jZWRfMSA9IHJlcXVpcmUoXCIuLi9NZXNoQWR2YW5jZWRcIik7XG5jb25zdCBNZXNoVHJpYW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9NZXNoVHJpYW5nbGVcIik7XG5jb25zdCBNZXNoQ29sb3JlZFRyaWFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vTWVzaENvbG9yZWRUcmlhbmdsZVwiKTtcbmNvbnN0IE1lc2hUZXh0dXJlZF8xID0gcmVxdWlyZShcIi4uL01lc2hUZXh0dXJlZFwiKTtcbmNvbnN0IE1lc2hVbmlmb3Jtc18xID0gcmVxdWlyZShcIi4uL01lc2hVbmlmb3Jtc1wiKTtcbmNvbnN0IE1lc2hHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4uL01lc2hHZW9tZXRyeVwiKTtcbmNvbnN0IE1lc2hTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9NZXNoU2hhZGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNsYXNzIEV4YW1wbGVEaXNwbGF5IGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIGRpc3BsYXlXaWR0aCwgZGlzcGxheWhlaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhhbmRsZUV4YW1wbGVSZXF1ZXN0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldEV4YW1wbGUodGhpcy5saXN0LnNlbGVjdGVkQ2xhc3MpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNvbXBsZXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNIQU5HRSwgdGhpcy5oYW5kbGVFeGFtcGxlUmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250cm9sU2l6ZSA9IDIwMDtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaEJhY2tncm91bmQoMHg5Njk2OTYpO1xuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5iYWNrZ3JvdW5kKTtcbiAgICAgICAgdGhpcy5zdGFnZUxheWVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5zdGFnZUxheWVyKTtcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IEV4YW1wbGVMaXN0XzEuRXhhbXBsZUxpc3QoY29udHJvbFNpemUsIGRpc3BsYXloZWlnaHQpO1xuICAgICAgICB0aGlzLmxpc3QueCA9IGRpc3BsYXlXaWR0aCAtIGNvbnRyb2xTaXplO1xuICAgICAgICBkaXNwbGF5V2lkdGggPSBkaXNwbGF5V2lkdGggLSBjb250cm9sU2l6ZTtcbiAgICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMubGlzdCk7XG4gICAgICAgIHRoaXMuY29udHJvbExheWVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250cm9sTGF5ZXIpO1xuICAgICAgICB0aGlzLmZyYW1lc2l6ZSA9IDU7XG4gICAgICAgIHRoaXMuZXhhbXBsZVdpZHRoID0gZGlzcGxheVdpZHRoOyAvLyhkaXNwbGF5V2lkdGggLSBjb250cm9sU2l6ZSkgLSAodGhpcy5mcmFtZXNpemUgLyAyKVxuICAgICAgICB0aGlzLmV4YW1wbGVoZWlnaHQgPSBkaXNwbGF5aGVpZ2h0IC0gKHRoaXMuZnJhbWVzaXplIC8gMik7XG4gICAgICAgIHRoaXMuZnJhbWUgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLmZyYW1lLmJlZ2luRmlsbCgweDAwMEZGRik7XG4gICAgICAgIHRoaXMuZnJhbWUuZHJhd1JlY3QoMCwgMCwgdGhpcy5mcmFtZXNpemUsIGRpc3BsYXloZWlnaHQpO1xuICAgICAgICB0aGlzLmZyYW1lLmRyYXdSZWN0KGRpc3BsYXlXaWR0aCAtIHRoaXMuZnJhbWVzaXplLCAwLCA1LCBkaXNwbGF5aGVpZ2h0KTtcbiAgICAgICAgdGhpcy5mcmFtZS5kcmF3UmVjdCh0aGlzLmZyYW1lc2l6ZSwgMCwgZGlzcGxheVdpZHRoIC0gKHRoaXMuZnJhbWVzaXplICogMiksIHRoaXMuZnJhbWVzaXplKTtcbiAgICAgICAgdGhpcy5mcmFtZS5kcmF3UmVjdCh0aGlzLmZyYW1lc2l6ZSwgZGlzcGxheWhlaWdodCAtIHRoaXMuZnJhbWVzaXplLCBkaXNwbGF5V2lkdGggLSAodGhpcy5mcmFtZXNpemUgKiAyKSwgdGhpcy5mcmFtZXNpemUpO1xuICAgICAgICB0aGlzLmNvbnRyb2xMYXllci5hZGRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgQmFzaWNcIiwgU3ByaXRlQmFzaWNfMS5TcHJpdGVCYXNpYyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIFJldmVhbFwiLCBBZHZhbmNlZENhcmRfMS5BZHZhbmNlZENhcmQpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBTbG90c1wiLCBBZHZhbmNlZFNsb3RzXzEuQWR2YW5jZWRTbG90cyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIFRyYWlsXCIsIEFkdmFuY2VkVHJhaWxfMS5BZHZhbmNlZFRyYWlsKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgV2FycFwiLCBBZHZhbmNlZFdhcnBfMS5BZHZhbmNlZFdhcnApO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBCbGVuZFwiLCBCYXNpY0JsZW5kXzEuQmFzaWNCbGVuZCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIFRpbnRpbmdcIiwgQmFzaWNUaW50aW5nXzEuQmFzaWNUaW50aW5nKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgVmlkZW9cIiwgU3ByaXRlVmlkZW9fMS5TcHJpdGVWaWRlbyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIFRpbGluZ1wiLCBTcHJpdGVUaWxpbmdfMS5TcHJpdGVUaWxpbmcpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBBbmltYXRpb25cIiwgU3ByaXRlRXhwbG9zaW9uXzEuU3ByaXRlRXhwbG9zaW9uKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgQW5pbWF0aW9uIDJcIiwgU3ByaXRlamV0XzEuU3ByaXRlamV0KTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgQW5pbWF0aW9uIDNcIiwgU3ByaXRlU3BlZWRfMS5TcHJpdGVTcGVlZCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiR3JhcGhpY3MgQmFzaWNcIiwgR3JhcGhpY3NTaW1wbGVfMS5HcmFwaGljc1NpbXBsZSk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiR3JhcGhpY3MgQWR2YW5jZWRcIiwgR3JhcGhpY3NBZHZhbmNlZF8xLkdyYXBoaWNzQWR2YW5jZWQpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkdyYXBoaWNzIER5bmFtaWNcIiwgR3JhcGhpY3NEeW5hbWljXzEuR3JhcGhpY3NEeW5hbWljKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJDb250YWluZXJcIiwgQmFzaWNDb250YWluZXJfMS5CYXNpY0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWFzayBHcmFwaGljc1wiLCBNYXNrR3JhcGhpY3NfMS5NYXNrR3JhcGhpY3MpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1hc2sgU3ByaXRlXCIsIE1hc2tTcHJpdGVfMS5NYXNrU3ByaXRlKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJQYXJ0aWNsZXNcIiwgQmFzaWNQYXJ0aWNsZXNfMS5CYXNpY1BhcnRpY2xlcyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dFwiLCBUZXh0QmFzZV8xLlRleHRCYXNlKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0IEJpdG1hcFwiLCBUZXh0Qml0bWFwXzEuVGV4dEJpdG1hcCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dCBXZWJGb250XCIsIFRleHRXZWJGb250XzEuVGV4dFdlYkZvbnQpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkludGVyYWN0aW9uXCIsIEludGVyYWN0aW9uSW50ZXJhY3Rpdml0eV8xLkludGVyYWN0aW9uSW50ZXJhY3Rpdml0eSk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiSW50ZXJhY3Rpb24gQ2xpY2tcIiwgSW50ZXJhY3Rpb25DbGlja18xLkludGVyYWN0aW9uQ2xpY2spO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkludGVyYWN0aW9uIERyYWdcIiwgSW50ZXJhY3Rpb25EcmFnZ2luZ18xLkludGVyYWN0aW9uRHJhZ2dpbmcpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkludGVyYWN0aW9uIEljb25cIiwgSW50ZXJhY3Rpb25JY29uXzEuSW50ZXJhY3Rpb25JY29uKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJ0ZXh0dXJlIFN3YXBcIiwgU3ByaXRlU3dhcF8xLlNwcml0ZVN3YXApO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHR1cmUgQWR2YW5jZWRcIiwgVGV4dHVyZUFkdmFuY2VkXzEuVGV4dHVyZUFkdmFuY2VkKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0dXJlIEdyYWRpZW50XCIsIFRleHR1cmVHcmFkaWVudEJhc2ljXzEuVGV4dHVyZUdyYWRpZW50QmFzaWMpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHR1cmUgR3JhZGllbnQgMlwiLCBUZXh0dXJlR3JhZGllbnRSZXNvdXJjZV8xLlRleHR1cmVHcmFkaWVudFJlc291cmNlKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0dXJlIFJvdGF0ZVwiLCBUZXh0dXJlUm90YXRlXzEuVGV4dHVyZVJvdGF0ZSk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dHVyZSBSZW5kZXJcIiwgVGV4dHVyZVJlbmRlcl8xLlRleHR1cmVSZW5kZXIpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBCbHVyXCIsIEZpbHRlckJsdXJfMS5GaWx0ZXJCbHVyKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgQ29sb3JNYXRyaXhcIiwgRmlsdGVyQ29sb3JfMS5GaWx0ZXJDb2xvcik7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIERpc3BsYWNlbWVudFwiLCBGaWx0ZXJDcmF3bGllc18xLkZpbHRlckNyYXdsaWVzKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgRGlzcGxhY2VtZW50IDJcIiwgRmlsdGVyRmxhZ18xLkZpbHRlckZsYWcpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBCbHVyIDJcIiwgTWFza0ZpbHRlcl8xLk1hc2tGaWx0ZXIpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBCbGVuZGluZ1wiLCBGaWx0ZXJCbGVuZGluZ18xLkZpbHRlckJsZW5kaW5nKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgQ3VzdG9tXCIsIEZpbHRlckN1c3RvbV8xLkZpbHRlckN1c3RvbSk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIFNoYWRvd1wiLCBGaWx0ZXJTaGFkb3dfMS5GaWx0ZXJTaGFkb3cpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggQmFzaWNcIiwgTWVzaEJhc2ljXzEuTWVzaEJhc2ljKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJNZXNoIFRyaWFuZ2xlXCIsIE1lc2hUcmlhbmdsZV8xLk1lc2hUcmlhbmdsZSk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBUcmlhbmdsZSAyXCIsIE1lc2hDb2xvcmVkVHJpYW5nbGVfMS5NZXNoQ29sb3JlZFRyaWFuZ2xlKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJNZXNoIFRleHR1cmVcIiwgTWVzaFRleHR1cmVkXzEuTWVzaFRleHR1cmVkKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJNZXNoIEFkdmFuY2VkXCIsIE1lc2hBZHZhbmNlZF8xLk1lc2hBZHZhbmNlZCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBVbmlmb3Jtc1wiLCBNZXNoVW5pZm9ybXNfMS5NZXNoVW5pZm9ybXMpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggR2VvbWV0cnlcIiwgTWVzaEdlb21ldHJ5XzEuTWVzaEdlb21ldHJ5KTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJNZXNoIFNoYWRlclwiLCBNZXNoU2hhZGVyXzEuTWVzaFNoYWRlcik7XG4gICAgICAgIHRoaXMuc2V0RXhhbXBsZShTcHJpdGVCYXNpY18xLlNwcml0ZUJhc2ljKTtcbiAgICB9XG4gICAgc2V0RXhhbXBsZShrZXljbGFzcykge1xuICAgICAgICB0aGlzLmxpc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNIQU5HRSwgdGhpcy5oYW5kbGVFeGFtcGxlUmVxdWVzdCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRFeGFtcGxlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRFeGFtcGxlLmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRFeGFtcGxlID0gbmV3IGtleWNsYXNzKHRoaXMuYXBwLCB0aGlzLmV4YW1wbGVXaWR0aCwgdGhpcy5leGFtcGxlaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdXJyZW50RXhhbXBsZS5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlQ29tcGxldGUpO1xuICAgICAgICAvLyB0aGlzLmN1cnJlbnRFeGFtcGxlLnN0YWdlLnggPSB0aGlzLmN1cnJlbnRFeGFtcGxlLnN0YWdlLnkgPSB0aGlzLmZyYW1lc2l6ZTtcbiAgICAgICAgdGhpcy5zdGFnZUxheWVyLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuc3RhZ2VMYXllci5hZGRDaGlsZCh0aGlzLmN1cnJlbnRFeGFtcGxlLnN0YWdlKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoQmFja2dyb3VuZCh0aGlzLmN1cnJlbnRFeGFtcGxlLmJhY2tDb2xvcik7XG4gICAgfVxuICAgIHJlZnJlc2hCYWNrZ3JvdW5kKGNvbG9yKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5jbGVhcigpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQuYmVnaW5GaWxsKGNvbG9yKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmRyYXdSZWN0KDAsIDAsIHRoaXMuZXhhbXBsZVdpZHRoLCB0aGlzLmV4YW1wbGVoZWlnaHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhhbXBsZURpc3BsYXkgPSBFeGFtcGxlRGlzcGxheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xuY29uc3QgQnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vZmwtcGFja2FnZS9CdXR0b25cIik7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY2xhc3MgRXhhbXBsZUxpc3QgZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGRpc3BsYXlXaWR0aCwgZGlzcGxheWhlaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0Q29udGFpbmVyLnkgPSB0aGlzLnNjcm9sbC50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25UYXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkQ2xhc3MgPSB0aGlzLmNsYXNzUmVmZXJlbmNlW2V2ZW50LmN1cnJlbnRUYXJnZXQubmFtZV07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNIQU5HRSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJ1dHRvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbGFzc1JlZmVyZW5jZSA9IHt9O1xuICAgICAgICB0aGlzLml0ZW1HYXAgPSAyO1xuICAgICAgICB0aGlzLnNpZGVHYXAgPSAyO1xuICAgICAgICB0aGlzLmxpc3RDb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5saXN0Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5saXN0bWFzayA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMubGlzdG1hc2suYmVnaW5GaWxsKDApO1xuICAgICAgICB0aGlzLmxpc3RtYXNrLmRyYXdSZWN0KDAsIDAsIGRpc3BsYXlXaWR0aCwgZGlzcGxheWhlaWdodCk7XG4gICAgICAgIHRoaXMubGlzdENvbnRhaW5lci5tYXNrID0gdGhpcy5saXN0bWFzaztcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmxpc3RtYXNrKTtcbiAgICAgICAgbGV0IGdyID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgZ3IuYmVnaW5GaWxsKDB4QUFBMEFBKTtcbiAgICAgICAgZ3IuZHJhd1JlY3QoMCwgMCwgMjUsIGRpc3BsYXloZWlnaHQpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKGdyKTtcbiAgICAgICAgZ3IueCA9IGRpc3BsYXlXaWR0aCAtIDI1O1xuICAgICAgICB0aGlzLmJ1dHRvbldpZHRoID0gZGlzcGxheVdpZHRoIC0gMjUgLSAodGhpcy5zaWRlR2FwICogMik7XG4gICAgICAgIHRoaXMuYnV0dG9uaGVpZ2h0ID0gNDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsID0gbmV3IFNjcm9sbEJhcigpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuc2Nyb2xsKTtcbiAgICAgICAgdGhpcy5zY3JvbGwueCA9IGRpc3BsYXlXaWR0aCAtIDI1O1xuICAgICAgICB0aGlzLnNjcm9sbC5zY3JvbGxBcmVhID0gZGlzcGxheWhlaWdodDtcbiAgICAgICAgdGhpcy5zY3JvbGwuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNIQU5HRSwgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ2xhc3M7XG4gICAgfVxuICAgIGFkZEV4YW1wbGUoa2V5bmFtZSwga2V5Y2xhc3MpIHtcbiAgICAgICAgbGV0IGJ1dHRvbiA9IG5ldyBCdXR0b25fMS5CdXR0b24oa2V5bmFtZSwgdGhpcy5idXR0b25XaWR0aCwgdGhpcy5idXR0b25oZWlnaHQpO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1RBUCwgdGhpcy5oYW5kbGVCdXR0b25UYXApO1xuICAgICAgICB0aGlzLmJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgICBidXR0b24ubmFtZSA9IGtleW5hbWU7XG4gICAgICAgIGJ1dHRvbi54ID0gdGhpcy5zaWRlR2FwO1xuICAgICAgICB0aGlzLmxpc3RDb250YWluZXIuYWRkQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5jbGFzc1JlZmVyZW5jZVtrZXluYW1lXSA9IGtleWNsYXNzO1xuICAgICAgICB0aGlzLnJlZnJlc2hMaXN0KCk7XG4gICAgfVxuICAgIHJlZnJlc2hMaXN0KCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLml0ZW1HYXA7XG4gICAgICAgIGZvciAobGV0IGJ1dHRvbiBvZiB0aGlzLmJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGJ1dHRvbi55ID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCArPSBidXR0b24uaGVpZ2h0ICsgdGhpcy5pdGVtR2FwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsLnNjcm9sbERpc3RhbmNlID0gc3RhcnQ7XG4gICAgfVxufVxuZXhwb3J0cy5FeGFtcGxlTGlzdCA9IEV4YW1wbGVMaXN0O1xuY2xhc3MgU2Nyb2xsQmFyIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVIYW5kbGVVcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhhbmRsZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5ldmVudERhdGEuZ2V0TG9jYWxQb3NpdGlvbih0aGlzLl9oYW5kbGUucGFyZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUueSA9IG5ld1Bvc2l0aW9uLnkgLSAodGhpcy5faGFuZGxlLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGUueSA+IHRoaXMuX3Njcm9sbEFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLnkgPSB0aGlzLl9zY3JvbGxBcmVhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9oYW5kbGUueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLnkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFyZWFQZXJjZW50ID0gdGhpcy5faGFuZGxlLnkgLyB0aGlzLl9zY3JvbGxBcmVhO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFBvc2l0aW9uID0gKHRoaXMuX3Njcm9sbERpc3RhbmNlIC0gdGhpcy5fdmlzaWJsZUFyZWEpICogdGhpcy5hcmVhUGVyY2VudCAqIC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ0hBTkdFKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlSGFuZGxlRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5iZWdpbkZpbGwoMHg2MzYzNjMpO1xuICAgICAgICB0aGlzLl9oYW5kbGUuZHJhd1JlY3QoMCwgMCwgMjUsIDI1KTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLl9oYW5kbGUpO1xuICAgICAgICB0aGlzLl9oYW5kbGUuYnV0dG9uTW9kZSA9IHRoaXMuX2hhbmRsZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5oYW5kbGVIYW5kbGVEb3duKTtcbiAgICAgICAgdGhpcy5faGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5oYW5kbGVIYW5kbGVVcCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVBfT1VUU0lERSwgdGhpcy5oYW5kbGVIYW5kbGVVcCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSwgdGhpcy5oYW5kbGVIYW5kbGVNb3ZlKTtcbiAgICB9XG4gICAgZ2V0IHRhcmdldFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0UG9zaXRpb247XG4gICAgfVxuICAgIHNldCBzY3JvbGxEaXN0YW5jZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxEaXN0YW5jZSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXQgc2Nyb2xsQXJlYSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxBcmVhID0gdmFsdWUgLSAyNTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZUFyZWEgPSB2YWx1ZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0XCIpO1xuY29uc3QgVGV4dFN0eWxlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFN0eWxlXCIpO1xuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYXB0aW9uLCBidXR0b25XaWR0aCA9IDE1MCwgYnV0dG9uaGVpZ2h0ID0gNDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVPdXQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uZ3JhcGhpYy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlT3ZlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVVcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idXR0b25ncmFwaGljID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLmJlZ2luRmlsbCgweDk2OTY5Nik7XG4gICAgICAgIHRoaXMuYnV0dG9uZ3JhcGhpYy5kcmF3Um91bmRlZFJlY3QoMCwgMCwgYnV0dG9uV2lkdGgsIGJ1dHRvbmhlaWdodCwgMTApO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuYnV0dG9uZ3JhcGhpYyk7XG4gICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLmJ1dHRvbm92ZXJncmFwaGljLmJlZ2luRmlsbCgweEI5QjlCOSk7XG4gICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMuZHJhd1JvdW5kZWRSZWN0KDAsIDAsIGJ1dHRvbldpZHRoLCBidXR0b25oZWlnaHQsIDEwKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmJ1dHRvbm92ZXJncmFwaGljKTtcbiAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLmJlZ2luRmlsbCgweDYzNjM2Myk7XG4gICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMuZHJhd1JvdW5kZWRSZWN0KDAsIDAsIGJ1dHRvbldpZHRoLCBidXR0b25oZWlnaHQsIDEwKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmJ1dHRvbmRvd25ncmFwaGljKTtcbiAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGxldCBzdHlsZSA9IG5ldyBUZXh0U3R5bGVfMS5UZXh0U3R5bGUoe30pO1xuICAgICAgICBzdHlsZS5mb250U2l6ZSA9IDE2O1xuICAgICAgICBzdHlsZS5hbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHN0eWxlLmZvbnRGYW1pbHkgPSBcIkFyaWFsXCI7XG4gICAgICAgIHRoaXMubGFiZWwgPSBuZXcgVGV4dF8xLlRleHQoY2FwdGlvbiwgc3R5bGUpO1xuICAgICAgICB0aGlzLmxhYmVsLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFiZWwueSA9IChidXR0b25oZWlnaHQgLSAodGhpcy5sYWJlbC5oZWlnaHQpKSAvIDI7XG4gICAgICAgIHRoaXMubGFiZWwueCA9IChidXR0b25XaWR0aCAvIDIgLSB0aGlzLmxhYmVsLndpZHRoIC8gMik7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5sYWJlbCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04sIHRoaXMuaGFuZGxlRG93bik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09WRVIsIHRoaXMuaGFuZGxlT3Zlcik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQLCB0aGlzLmhhbmRsZVVwKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1VULCB0aGlzLmhhbmRsZU91dCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQX09VVFNJREUsIHRoaXMuaGFuZGxlT3V0KTtcbiAgICB9XG59XG5leHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBwbGljYXRpb25fMSA9IHJlcXVpcmUoXCIuL3Jhdy1waXhpLXRzL0FwcGxpY2F0aW9uXCIpO1xuY29uc3QgU3RhZ2VPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9yYXctcGl4aS10cy9TdGFnZU9wdGlvbnNcIik7XG5jb25zdCBFeGFtcGxlRGlzcGxheV8xID0gcmVxdWlyZShcIi4vZXhhbXBsZXMvY29udHJvbHMvRXhhbXBsZURpc3BsYXlcIik7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgIHZhciBvcHRpb25zID0gbmV3IFN0YWdlT3B0aW9uc18xLlN0YWdlT3B0aW9ucygpO1xuICAgIG9wdGlvbnMud2lkdGggPSAxMDAwO1xuICAgIG9wdGlvbnMuaGVpZ2h0ID0gNjAwO1xuICAgIG9wdGlvbnMuYXV0b1Jlc2l6ZSA9IGZhbHNlO1xuICAgIG9wdGlvbnMuYmFja2dyb3VuZENvbG9yID0gMHgwMDAwMDAwMDtcbiAgICBvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyID0gdHJ1ZTtcbiAgICBvcHRpb25zLnJlc29sdXRpb24gPSAxO1xuICAgIG9wdGlvbnMuYXV0b1N0YXJ0ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICBvcHRpb25zLmFudGlhbGlhcyA9IHRydWU7XG4gICAgb3B0aW9ucy52aWV3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmYWtlY2FudmFzXCIpO1xuICAgIHZhciBhcHAgPSBuZXcgQXBwbGljYXRpb25fMS5BcHBsaWNhdGlvbihvcHRpb25zKTtcbiAgICBsZXQgZGlzcGxheSA9IG5ldyBFeGFtcGxlRGlzcGxheV8xLkV4YW1wbGVEaXNwbGF5KGFwcCwgMTAyNCwgNzY4KTtcbiAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQoZGlzcGxheSk7XG4gICAgLy8gY3JlYXRlIGEgdmlldyBjbGFzcyB3aXRoIGZyYW1lXG4gICAgLy8gY3JlYXRlIGEgY29udHJvbCBjbGFzcyB3aXRoIGJ1dHRvbnNcbiAgICAvLyBlYWNoIGJ1dHRvbiBjbGljayBjaGFuZ2UgY29udGVudCBvZiBjbGFzcyBmcmFtZVxuICAgIC8vIGxldCBidXR0b246QnV0dG9uID0gbmV3IEJ1dHRvbihcIlRlc3RcIiwgMjAwLCA0MCk7XG4gICAgLy8gYXBwLnN0YWdlLmFkZENoaWxkKGJ1dHRvbik7XG4gICAgLy8gYnV0dG9uLnggPSA4MDA7XG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNDYWNoZSA9IG5ldyBCYXNpY0NhY2hlKGFwcCk7IE5PVCBXT1JLSU5HXG4gICAgLy8gbGV0IGV4YW1wbGU6SW50ZXJhY3Rpb25JY29uID0gbmV3IEludGVyYWN0aW9uSWNvbihhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZVZpZGVvID0gbmV3IFNwcml0ZVZpZGVvKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6QWR2YW5jZWRTbG90cyA9IG5ldyBBZHZhbmNlZFNsb3RzKGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOlRleHR1cmVSb3RhdGUgPSBuZXcgVGV4dHVyZVJvdGF0ZShhcHApOyBcbiAgICAvLyBsZXQgZXhhbXBsZTpCYXNpY0NvbnRhaW5lciA9IG5ldyBCYXNpY0NvbnRhaW5lcihhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOkJhc2ljQmFja2dyb3VuZCA9IG5ldyBCYXNpY0JhY2tncm91bmQoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpCYXNpY1RpbnRpbmcgPSBuZXcgQmFzaWNUaW50aW5nKGFwcCk7ICAgIFxuICAgIC8vIGxldCBleGFtcGxlOkJhc2ljUGFydGljbGVzID0gbmV3IEJhc2ljUGFydGljbGVzKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNCbGVuZCA9IG5ldyBCYXNpY0JsZW5kKGFwcCk7ICAgIFxuICAgIC8vIGxldCBleGFtcGxlOkdyYXBoaWNzU2ltcGxlID0gbmV3IEdyYXBoaWNzU2ltcGxlKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6R3JhcGhpY3NBZHZhbmNlZCA9IG5ldyBHcmFwaGljc0FkdmFuY2VkKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6R3JhcGhpY3NEeW5hbWljID0gbmV3IEdyYXBoaWNzRHluYW1pYyhhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOlRleHR1cmVSZW5kZXIgPSBuZXcgVGV4dHVyZVJlbmRlcihhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOlRleHR1cmVBZHZhbmNlZCA9IG5ldyBUZXh0dXJlQWR2YW5jZWQoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0dXJlR3JhZGllbnRCYXNpYyA9IG5ldyBUZXh0dXJlR3JhZGllbnRCYXNpYyhhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOlRleHR1cmVHcmFkaWVudFJlc291cmNlID0gbmV3IFRleHR1cmVHcmFkaWVudFJlc291cmNlKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dEJhc2UgPSBuZXcgVGV4dEJhc2UoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0Qml0bWFwID0gbmV3IFRleHRCaXRtYXAoYXBwKTsgXG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dFdlYkZvbnQgPSBuZXcgVGV4dFdlYkZvbnQoYXBwKTsgXG4gICAgLy8gbGV0IGV4YW1wbGU6TWFza0dyYXBoaWNzID0gbmV3IE1hc2tHcmFwaGljcyhhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOk1hc2tTcHJpdGUgPSBuZXcgTWFza1Nwcml0ZShhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlckJsdXIgPSBuZXcgRmlsdGVyQmx1cihhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlckNvbG9yID0gbmV3IEZpbHRlckNvbG9yKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQ3Jhd2xpZXMgPSBuZXcgRmlsdGVyQ3Jhd2xpZXMoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpGaWx0ZXJGbGFnID0gbmV3IEZpbHRlckZsYWcoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpNYXNrRmlsdGVyID0gbmV3IE1hc2tGaWx0ZXIoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpJbnRlcmFjdGlvbkNsaWNrID0gbmV3IEludGVyYWN0aW9uQ2xpY2soYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpJbnRlcmFjdGlvbkludGVyYWN0aXZpdHkgPSBuZXcgSW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5KGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6SW50ZXJhY3Rpb25EcmFnZ2luZyA9IG5ldyBJbnRlcmFjdGlvbkRyYWdnaW5nKGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZUJhc2ljID0gbmV3IFNwcml0ZUJhc2ljKGFwcCk7ICBcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVTd2FwID0gbmV3IFNwcml0ZVN3YXAoYXBwKTsgICAgXG4gICAgLy8gbGV0IGV4YW1wbGU6U3ByaXRlVGlsaW5nID0gbmV3IFNwcml0ZVRpbGluZyhhcHApOyAgICBcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVFeHBsb3Npb24gPSBuZXcgU3ByaXRlRXhwbG9zaW9uKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6U3ByaXRlamV0ID0gbmV3IFNwcml0ZWpldChhcHApOyBcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVTcGVlZCA9IG5ldyBTcHJpdGVTcGVlZChhcHApOyBcbiAgICAvLyBsZXQgZXhhbXBsZTpBZHZhbmNlZENhcmQgPSBuZXcgQWR2YW5jZWRDYXJkKGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOkFkdmFuY2VkVHJhaWwgPSBuZXcgQWR2YW5jZWRUcmFpbChhcHApOyBcbiAgICAvLyBsZXQgZXhhbXBsZTpBZHZhbmNlZFdhcnAgPSBuZXcgQWR2YW5jZWRXYXJwKGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlckJsZW5kaW5nID0gbmV3IEZpbHRlckJsZW5kaW5nKGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlckN1c3RvbSA9IG5ldyBGaWx0ZXJDdXN0b20oYXBwKTsgXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyU2hhZG93ID0gbmV3IEZpbHRlclNoYWRvdyhhcHApOyBcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoQmFzaWMgPSBuZXcgTWVzaEJhc2ljKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6TWVzaEFkdmFuY2VkID0gbmV3IE1lc2hBZHZhbmNlZChhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOk1lc2hUcmlhbmdsZSA9IG5ldyBNZXNoVHJpYW5nbGUoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoQ29sb3JlZFRyaWFuZ2xlID0gbmV3IE1lc2hDb2xvcmVkVHJpYW5nbGUoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoVGV4dHVyZWQgPSBuZXcgTWVzaFRleHR1cmVkKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6TWVzaFVuaWZvcm1zID0gbmV3IE1lc2hVbmlmb3JtcyhhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOk1lc2hHZW9tZXRyeSA9IG5ldyBNZXNoR2VvbWV0cnkoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoU2hhZGVyID0gbmV3IE1lc2hTaGFkZXIoYXBwKTtcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBSZW5kZXJUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcbmNsYXNzIEFic3RyYWN0UmVuZGVyZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHN5c3RlbSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAob3B0aW9ucy5yb3VuZFBpeGVscykge1xuICAgICAgICAgICAgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJPVU5EX1BJWEVMUyA9IG9wdGlvbnMucm91bmRQaXhlbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy50eXBlID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFTkRFUkVSX1RZUEUuVU5LTk9XTjtcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy52aWV3ID0gb3B0aW9ucy52aWV3IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb24gfHwgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSBvcHRpb25zLnRyYW5zcGFyZW50O1xuICAgICAgICB0aGlzLmF1dG9EZW5zaXR5ID0gb3B0aW9ucy5hdXRvRGVuc2l0eSB8fCBvcHRpb25zLmF1dG9SZXNpemUgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XG4gICAgICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSAweDAwMDAwMDtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gJyMwMDAwMDAnO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgICAgICAgdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXMgPSAwO1xuICAgIH1cbiAgICByZXNpemUoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xuICAgICAgICB0aGlzLnNjcmVlbi53aWR0aCA9IHNjcmVlbldpZHRoO1xuICAgICAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSBzY3JlZW5IZWlnaHQ7XG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHNjcmVlbldpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLnZpZXcuaGVpZ2h0ID0gc2NyZWVuSGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVuc2l0eSkge1xuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gc2NyZWVuV2lkdGggKyBcInB4XCI7XG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUuaGVpZ2h0ID0gc2NyZWVuSGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcud2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LmhlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIGdlbmVyYXRlVGV4dHVyZShkaXNwbGF5T2JqZWN0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24sIHJlZ2lvbikge1xuICAgICAgICByZWdpb24gPSByZWdpb24gfHwgZGlzcGxheU9iamVjdC5nZXRMb2NhbEJvdW5kcygpO1xuICAgICAgICBpZiAocmVnaW9uLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICByZWdpb24ud2lkdGggPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpb24uaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZWdpb24uaGVpZ2h0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZShyZWdpb24ud2lkdGggfCAwLCByZWdpb24uaGVpZ2h0IHwgMCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKTtcbiAgICAgICAgQWJzdHJhY3RSZW5kZXJlci50ZW1wTWF0cml4LnR4ID0gLXJlZ2lvbi54O1xuICAgICAgICBBYnN0cmFjdFJlbmRlcmVyLnRlbXBNYXRyaXgudHkgPSAtcmVnaW9uLnk7XG4gICAgICAgIHRoaXMucmVuZGVyKGRpc3BsYXlPYmplY3QsIHJlbmRlclRleHR1cmUsIGZhbHNlLCBBYnN0cmFjdFJlbmRlcmVyLnRlbXBNYXRyaXgsICEhZGlzcGxheU9iamVjdC5wYXJlbnQpO1xuICAgICAgICByZXR1cm4gcmVuZGVyVGV4dHVyZTtcbiAgICB9XG4gICAgO1xuICAgIHJlbmRlcihkaXNwbGF5T2JqZWN0LCByZW5kZXJUZXh0dXJlLCBiLCBtLCBwYXJlbnQpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVyeXRoaW5nIGZyb20gdGhlIHJlbmRlcmVyIGFuZCBvcHRpb25hbGx5IHJlbW92ZXMgdGhlIENhbnZhcyBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZVZpZXc9ZmFsc2VdIC0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgICAqL1xuICAgIGRlc3Ryb3kocmVtb3ZlVmlldykge1xuICAgICAgICAvLyBmb3IgKHZhciBvIGluIHRoaXMucGx1Z2lucylcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdGhpcy5wbHVnaW5zW29dLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gICAgIHRoaXMucGx1Z2luc1tvXSA9IG51bGw7XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKHJlbW92ZVZpZXcgJiYgdGhpcy52aWV3LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudmlldyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5wbHVnaW5zID0gbnVsbDtcbiAgICAgICAgdGhpcy50eXBlID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFTkRFUkVSX1RZUEUuVU5LTk9XTjtcbiAgICAgICAgdGhpcy52aWV3ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBudWxsO1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSAwO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0RlbnNpdHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSAwO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0T2JqZWN0UmVuZGVyZWQgPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCBpZiBub3QgdHJhbnNwYXJlbnRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgYmFja2dyb3VuZENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGJhY2tncm91bmRDb2xvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLmhleDJzdHJpbmcodmFsdWUpO1xuICAgICAgICBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5oZXgycmdiKHZhbHVlLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhKTtcbiAgICB9XG4gICAgO1xufVxuQWJzdHJhY3RSZW5kZXJlci50ZW1wTWF0cml4ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuZXhwb3J0cy5BYnN0cmFjdFJlbmRlcmVyID0gQWJzdHJhY3RSZW5kZXJlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tICcuL3NldHRpbmdzJztcbmNvbnN0IFV0aWxzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1V0aWxzU2V0dGluZ3NcIik7XG5jbGFzcyBBY2Nlc3NpYmlsaXR5TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHR5cGUgez9IVE1MRWxlbWVudH1cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ob29rRGl2ID0gbnVsbDtcbiAgICAgICAgLy8gaWYgKHNldHRpbmdzLmlzTW9iaWxlX21pbi50YWJsZXQgfHwgc2V0dGluZ3MuaXNNb2JpbGVfbWluLnBob25lKVxuICAgICAgICAvLyB7XG4gICAgICAgIHRoaXMuY3JlYXRlVG91Y2hIb29rKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZmlyc3Qgd2UgY3JlYXRlIGEgZGl2IHRoYXQgd2lsbCBzaXQgb3ZlciB0aGUgUGl4aUpTIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgdGhlIGRpdiBvdmVybGF5cyB3aWxsIGdvLlxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9TSVpFICsgXCJweFwiO1xuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1NJWkUgKyBcInB4XCI7XG4gICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGRpdi5zdHlsZS50b3AgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfUE9TX1ggKyBcInB4XCI7XG4gICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1BPU19ZICsgXCJweFwiO1xuICAgICAgICBkaXYuc3R5bGUuekluZGV4ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1pJTkRFWC50b1N0cmluZygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZG9tIGVsZW1lbnQgdGhhdCB3aWxsIHNpdCBvdmVyIHRoZSBQaXhpSlMgZWxlbWVudC4gVGhpcyBpcyB3aGVyZSB0aGUgZGl2IG92ZXJsYXlzIHdpbGwgZ28uXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGl2ID0gZGl2O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzaW1wbGUgcG9vbCBmb3Igc3RvcmluZyBkaXZzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Kn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9vbCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBhIHRpY2sgdXNlZCB0byBjaGVjayBpZiBhbiBvYmplY3QgaXMgbm8gbG9uZ2VyIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJJZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgdG8gdHJ1ZSB3aWxsIHZpc3VhbGx5IHNob3cgdGhlIGRpdnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlbmRlcmVyIHRoaXMgYWNjZXNzaWJpbGl0eSBtYW5hZ2VyIHdvcmtzIGZvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5BYnN0cmFjdFJlbmRlcmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSBhY3RpdmUgYWNjZXNzaWJsZSBpdGVtcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8Kj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcmUtYmluZCB0aGUgZnVuY3Rpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uS2V5RG93biA9IHRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogcHJlLWJpbmQgdGhlIGZ1bmN0aW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWdcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gZmFsc2U7XG4gICAgICAgIC8vIGxldCBsaXN0ZW4gZm9yIHRhYi4uIG9uY2UgcHJlc3NlZCB3ZSBjYW4gZmlyZSB1cCBhbmQgc2hvdyB0aGUgYWNjZXNzaWJpbGl0eSBsYXllclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSB0b3VjaCBob29rcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlVG91Y2hIb29rKCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgdmFyIGhvb2tEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgaG9va0Rpdi5zdHlsZS53aWR0aCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1NJWkUgKyBcInB4XCI7XG4gICAgICAgIGhvb2tEaXYuc3R5bGUuaGVpZ2h0ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfU0laRSArIFwicHhcIjtcbiAgICAgICAgaG9va0Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGhvb2tEaXYuc3R5bGUudG9wID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfUE9TX1ggKyBcInB4XCI7XG4gICAgICAgIGhvb2tEaXYuc3R5bGUubGVmdCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1BPU19ZICsgXCJweFwiO1xuICAgICAgICBob29rRGl2LnN0eWxlLnpJbmRleCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1pJTkRFWC50b1N0cmluZygpO1xuICAgICAgICBob29rRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRkYwMDAwJztcbiAgICAgICAgaG9va0Rpdi50aXRsZSA9ICdIT09LIERJVic7XG4gICAgICAgIGhvb2tEaXYuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzJDEuaXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMkMS5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgdGhpcyQxLmRlc3Ryb3lUb3VjaEhvb2soKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaG9va0Rpdik7XG4gICAgICAgIHRoaXMuX2hvb2tEaXYgPSBob29rRGl2O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIHRvdWNoIGhvb2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkZXN0cm95VG91Y2hIb29rKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hvb2tEaXYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuX2hvb2tEaXYpO1xuICAgICAgICB0aGlzLl9ob29rRGl2ID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFjdGl2YXRpbmcgd2lsbCBjYXVzZSB0aGUgQWNjZXNzaWJpbGl0eSBsYXllciB0byBiZSBzaG93bi5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBwcmVzc2VzIHRoZSB0YWIga2V5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhY3RpdmF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vbigncG9zdHJlbmRlcicsIHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIudmlldy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnZpZXcucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmRpdik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlYWN0aXZhdGluZyB3aWxsIGNhdXNlIHRoZSBBY2Nlc3NpYmlsaXR5IGxheWVyIHRvIGJlIGhpZGRlbi5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBtb3ZlcyB0aGUgbW91c2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSB8fCB0aGlzLmlzTW9iaWxlQWNjZXNzaWJpbGl0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vZmYoJ3Bvc3RyZW5kZXInLCB0aGlzLnVwZGF0ZSk7XG4gICAgICAgIGlmICh0aGlzLmRpdi5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZGl2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhpcyByZWN1cnNpdmUgZnVuY3Rpb24gd2lsbCBydW4gdGhyb3VnaCB0aGUgc2NlbmUgZ3JhcGggYW5kIGFkZCBhbnkgbmV3IGFjY2Vzc2libGUgb2JqZWN0cyB0byB0aGUgRE9NIGxheWVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBkaXNwbGF5T2JqZWN0IC0gVGhlIERpc3BsYXlPYmplY3QgdG8gY2hlY2suXG4gICAgICovXG4gICAgdXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoZGlzcGxheU9iamVjdCkge1xuICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGUgJiYgZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QucmVuZGVySWQgPSB0aGlzLnJlbmRlcklkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBCZWZvcmUgZWFjaCByZW5kZXIgdGhpcyBmdW5jdGlvbiB3aWxsIGVuc3VyZSB0aGF0IGFsbCBkaXZzIGFyZSBtYXBwZWQgY29ycmVjdGx5IHRvIHRoZWlyIERpc3BsYXlPYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBjaGlsZHJlbi4uLlxuICAgICAgICB0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCk7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5yZW5kZXJlci52aWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgc3ggPSByZWN0LndpZHRoIC8gdGhpcy5yZW5kZXJlci53aWR0aDtcbiAgICAgICAgdmFyIHN5ID0gcmVjdC5oZWlnaHQgLyB0aGlzLnJlbmRlcmVyLmhlaWdodDtcbiAgICAgICAgdmFyIGRpdiA9IHRoaXMuZGl2O1xuICAgICAgICBkaXYuc3R5bGUubGVmdCA9IChyZWN0LmxlZnQpICsgXCJweFwiO1xuICAgICAgICBkaXYuc3R5bGUudG9wID0gKHJlY3QudG9wKSArIFwicHhcIjtcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gKHRoaXMucmVuZGVyZXIud2lkdGgpICsgXCJweFwiO1xuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gKHRoaXMucmVuZGVyZXIuaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnJlbmRlcklkICE9PSB0aGlzLnJlbmRlcklkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2FjY2Vzc2libGVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5yZW1vdmVDaGlsZChjaGlsZC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgICAgICAgICAgdGhpcy5wb29sLnB1c2goY2hpbGQuX2FjY2Vzc2libGVEaXYpO1xuICAgICAgICAgICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlRGl2ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG1hcCBkaXYgdG8gZGlzcGxheS4uXG4gICAgICAgICAgICAgICAgZGl2ID0gY2hpbGQuX2FjY2Vzc2libGVEaXY7XG4gICAgICAgICAgICAgICAgdmFyIGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xuICAgICAgICAgICAgICAgIHZhciB3dCA9IGNoaWxkLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5oaXRBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gKCh3dC50eCArIChoaXRBcmVhLnggKiB3dC5hKSkgKiBzeCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSAoKHd0LnR5ICsgKGhpdEFyZWEueSAqIHd0LmQpKSAqIHN5KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gKGhpdEFyZWEud2lkdGggKiB3dC5hICogc3gpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gKGhpdEFyZWEuaGVpZ2h0ICogd3QuZCAqIHN5KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhpdEFyZWEgPSBjaGlsZC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXBIaXRBcmVhKGhpdEFyZWEpO1xuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9IChoaXRBcmVhLnggKiBzeCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSAoaGl0QXJlYS55ICogc3kpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSAoaGl0QXJlYS53aWR0aCAqIHN4KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IChoaXRBcmVhLmhlaWdodCAqIHN5KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGJ1dHRvbiB0aXRsZXMgYW5kIGhpbnRzIGlmIHRoZXkgZXhpc3QgYW5kIHRoZXkndmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2LnRpdGxlICE9PSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgJiYgY2hpbGQuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYudGl0bGUgPSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdi5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSAhPT0gY2hpbGQuYWNjZXNzaWJsZUhpbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGNoaWxkLmFjY2Vzc2libGVIaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgY2hpbGQuYWNjZXNzaWJsZUhpbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgcmVuZGVyIGlkLi5cbiAgICAgICAgdGhpcy5yZW5kZXJJZCsrO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBoaXQgYXJlYSBiYXNlZCBvbiB0aGUgYm91bmRzIG9mIGEgZGlzcGxheSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBoaXRBcmVhIC0gQm91bmRzIG9mIHRoZSBjaGlsZFxuICAgICAqL1xuICAgIGNhcEhpdEFyZWEoaGl0QXJlYSkge1xuICAgICAgICBpZiAoaGl0QXJlYS54IDwgMCkge1xuICAgICAgICAgICAgaGl0QXJlYS53aWR0aCArPSBoaXRBcmVhLng7XG4gICAgICAgICAgICBoaXRBcmVhLnggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaXRBcmVhLnkgPCAwKSB7XG4gICAgICAgICAgICBoaXRBcmVhLmhlaWdodCArPSBoaXRBcmVhLnk7XG4gICAgICAgICAgICBoaXRBcmVhLnkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaXRBcmVhLnggKyBoaXRBcmVhLndpZHRoID4gdGhpcy5yZW5kZXJlci53aWR0aCkge1xuICAgICAgICAgICAgaGl0QXJlYS53aWR0aCA9IHRoaXMucmVuZGVyZXIud2lkdGggLSBoaXRBcmVhLng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpdEFyZWEueSArIGhpdEFyZWEuaGVpZ2h0ID4gdGhpcy5yZW5kZXJlci5oZWlnaHQpIHtcbiAgICAgICAgICAgIGhpdEFyZWEuaGVpZ2h0ID0gdGhpcy5yZW5kZXJlci5oZWlnaHQgLSBoaXRBcmVhLnk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBEaXNwbGF5T2JqZWN0IHRvIHRoZSBhY2Nlc3NpYmlsaXR5IG1hbmFnZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtEaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0IC0gVGhlIGNoaWxkIHRvIG1ha2UgYWNjZXNzaWJsZS5cbiAgICAgKi9cbiAgICBhZGRDaGlsZChkaXNwbGF5T2JqZWN0KSB7XG4gICAgICAgIC8vdGhpcy5hY3RpdmF0ZSgpO1xuICAgICAgICB2YXIgZGl2ID0gdGhpcy5wb29sLnBvcCgpO1xuICAgICAgICBpZiAoIWRpdikge1xuICAgICAgICAgICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfU0laRSArIFwicHhcIjtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfU0laRSArIFwicHhcIjtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRlYnVnID8gJ3JnYmEoMjU1LDAsMCwwLjUpJyA6ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9aSU5ERVg7XG4gICAgICAgICAgICBkaXYuc3R5bGUuYm9yZGVyU3R5bGUgPSAnbm9uZSc7XG4gICAgICAgICAgICAvLyBBUklBIGF0dHJpYnV0ZXMgZW5zdXJlIHRoYXQgYnV0dG9uIHRpdGxlIGFuZCBoaW50IHVwZGF0ZXMgYXJlIGFubm91bmNlZCBwcm9wZXJseVxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIGRvZXNuJ3QgbmVlZCBhcmlhLWxpdmUgdG8gd29yayBhcyBpbnRlbmRlZDsgaW4gZmFjdCBpdCBqdXN0IGdldHMgbW9yZSBjb25mdXNlZC5cbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvcnY6LipHZWNrb1xcLy8pKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlyZUZveCBuZWVkcyB0aGlzIHRvIGFubm91bmNlIG9ubHkgdGhlIG5ldyBidXR0b24gbmFtZVxuICAgICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVsZXZhbnQnLCAnYWRkaXRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCBieSBJRSwgb3RoZXIgYnJvd3NlcnMgZG9uJ3QgbXVjaCBjYXJlXG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1yZWxldmFudCcsICd0ZXh0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX29uRm9jdXNPdXQuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICYmIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXYudGl0bGUgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludFxuICAgICAgICAgICAgfHwgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGl2LnRpdGxlID0gXCJkaXNwbGF5T2JqZWN0IFwiICsgKGRpc3BsYXlPYmplY3QudGFiSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50XG4gICAgICAgICAgICAmJiBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZUFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYgPSBkaXY7XG4gICAgICAgIGRpdi5kaXNwbGF5T2JqZWN0ID0gZGlzcGxheU9iamVjdDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGRpc3BsYXlPYmplY3QpO1xuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2KTtcbiAgICAgICAgZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdi50YWJJbmRleCA9IGRpc3BsYXlPYmplY3QudGFiSW5kZXg7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNYXBzIHRoZSBkaXYgYnV0dG9uIHByZXNzIHRvIHBpeGkncyAgKGNsaWNrKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGUgLSBUaGUgY2xpY2sgZXZlbnQuXG4gICAgICovXG4gICAgX29uQ2xpY2soZSkge1xuICAgICAgICB2YXIgaW50ZXJhY3Rpb25NYW5hZ2VyID0gdGhpcy5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uO1xuICAgICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLnRhcmdldC5kaXNwbGF5T2JqZWN0LCAnY2xpY2snLCBpbnRlcmFjdGlvbk1hbmFnZXIuZXZlbnREYXRhKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIGRpdiBmb2N1cyBldmVudHMgdG8gcGl4aSdzICAobW91c2VvdmVyKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGUgLSBUaGUgZm9jdXMgZXZlbnQuXG4gICAgICovXG4gICAgX29uRm9jdXMoZSkge1xuICAgICAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdhc3NlcnRpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJhY3Rpb25NYW5hZ2VyID0gdGhpcy5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uO1xuICAgICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLnRhcmdldC5kaXNwbGF5T2JqZWN0LCAnbW91c2VvdmVyJywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNYXBzIHRoZSBkaXYgZm9jdXMgZXZlbnRzIHRvIHBpeGkncyAgKG1vdXNlb3V0KVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGUgLSBUaGUgZm9jdXNvdXQgZXZlbnQuXG4gICAgICovXG4gICAgX29uRm9jdXNPdXQoZSkge1xuICAgICAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpKSB7XG4gICAgICAgICAgICBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJhY3Rpb25NYW5hZ2VyID0gdGhpcy5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uO1xuICAgICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLnRhcmdldC5kaXNwbGF5T2JqZWN0LCAnbW91c2VvdXQnLCBpbnRlcmFjdGlvbk1hbmFnZXIuZXZlbnREYXRhKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIElzIGNhbGxlZCB3aGVuIGEga2V5IGlzIHByZXNzZWRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlIC0gVGhlIGtleWRvd24gZXZlbnQuXG4gICAgICovXG4gICAgX29uS2V5RG93bihlKSB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgIT09IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLktFWV9DT0RFX1RBQikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIF9vbk1vdXNlTW92ZShlKSB7XG4gICAgICAgIGlmIChlLm1vdmVtZW50WCA9PT0gMCAmJiBlLm1vdmVtZW50WSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlclxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95VG91Y2hIb29rKCk7XG4gICAgICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLmRpdiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24pO1xuICAgICAgICB0aGlzLnBvb2wgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1NJWkUgPSAxO1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfUE9TX1ggPSAtMTAwMDtcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1BPU19ZID0gLTEwMDA7XG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19aSU5ERVggPSAyO1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIuS0VZX0NPREVfVEFCID0gOTtcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9TSVpFID0gMTAwO1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1BPU19YID0gMDtcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9QT1NfWSA9IDA7XG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfWklOREVYID0gMjtcbmV4cG9ydHMuQWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi9TcHJpdGVcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgVGlja2VyXzEgPSByZXF1aXJlKFwiLi9UaWNrZXJcIik7XG5jbGFzcyBBbmltYXRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZV8xLlNwcml0ZSB7XG4gICAgY29uc3RydWN0b3IodGV4dHVyZXMsIGF1dG9VcGRhdGUgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKHRleHR1cmVzWzBdIGluc3RhbmNlb2YgVGV4dHVyZV8xLlRleHR1cmUgPyB0ZXh0dXJlc1swXSA6IHRleHR1cmVzWzBdLnRleHR1cmUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1BJWEkuVGV4dHVyZVtdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzO1xuICAgICAgICAvKipcbiAgICAgICAgICogYHRydWVgIHVzZXMgUElYSS5UaWNrZXIuc2hhcmVkIHRvIGF1dG8gdXBkYXRlIGFuaW1hdGlvbiB0aW1lLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IGF1dG9VcGRhdGUgIT09IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNwZWVkIHRoYXQgdGhlIEFuaW1hdGVkU3ByaXRlIHdpbGwgcGxheSBhdC4gSGlnaGVyIGlzIGZhc3RlciwgbG93ZXIgaXMgc2xvd2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGFuaW1hdGUgc3ByaXRlIHJlcGVhdHMgYWZ0ZXIgcGxheWluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhbmNob3IgdG8gW1RleHR1cmUncyBkZWZhdWx0QW5jaG9yXXtAbGluayBQSVhJLlRleHR1cmUjZGVmYXVsdEFuY2hvcn0gd2hlbiBmcmFtZSBjaGFuZ2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2VmdWwgd2l0aCBbc3ByaXRlIHNoZWV0IGFuaW1hdGlvbnNde0BsaW5rIFBJWEkuU3ByaXRlc2hlZXQjYW5pbWF0aW9uc30gY3JlYXRlZCB3aXRoIHRvb2xzLlxuICAgICAgICAgKiBDaGFuZ2luZyBhbmNob3IgZm9yIGVhY2ggZnJhbWUgYWxsb3dzIHRvIHBpbiBzcHJpdGUgb3JpZ2luIHRvIGNlcnRhaW4gbW92aW5nIGZlYXR1cmVcbiAgICAgICAgICogb2YgdGhlIGZyYW1lIChlLmcuIGxlZnQgZm9vdCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGU6IEVuYWJsaW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgcHJldmlvdXNseSBzZXQgYGFuY2hvcmAgb24gZWFjaCBmcmFtZSBjaGFuZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZUFuY2hvciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgQW5pbWF0ZWRTcHJpdGUgZmluaXNoZXMgcGxheWluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgQW5pbWF0ZWRTcHJpdGUgY2hhbmdlcyB3aGljaCB0ZXh0dXJlIGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25GcmFtZUNoYW5nZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYGxvb3BgIGlzIHRydWUsIGFuZCBhbiBBbmltYXRlZFNwcml0ZSBpcyBwbGF5ZWQgYW5kIGxvb3BzIGFyb3VuZCB0byBzdGFydCBhZ2Fpbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uTG9vcCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbGFwc2VkIHRpbWUgc2luY2UgYW5pbWF0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHVzZWQgaW50ZXJuYWxseSB0byBkaXNwbGF5IGN1cnJlbnQgdGV4dHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIGlmIHRoZSBBbmltYXRlZFNwcml0ZSBpcyBjdXJyZW50bHkgcGxheWluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlLlxuICAgICAqXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9VcGRhdGUpIHtcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUGxheXMgdGhlIEFuaW1hdGVkU3ByaXRlLlxuICAgICAqXG4gICAgICovXG4gICAgcGxheSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGxheWluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxheWluZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcywgVGlja2VyXzEuVGlja2VyLlVQREFURV9QUklPUklUWS5ISUdIKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlIGFuZCBnb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJhbWVOdW1iZXIgLSBGcmFtZSBpbmRleCB0byBzdG9wIGF0LlxuICAgICAqL1xuICAgIGdvdG9BbmRTdG9wKGZyYW1lTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB2YXIgcHJldmlvdXNGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IGZyYW1lTnVtYmVyO1xuICAgICAgICBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUgYW5kIGJlZ2lucyBwbGF5aW5nIHRoZSBBbmltYXRlZFNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcmFtZU51bWJlciAtIEZyYW1lIGluZGV4IHRvIHN0YXJ0IGF0LlxuICAgICAqL1xuICAgIGdvdG9BbmRQbGF5KGZyYW1lTnVtYmVyKSB7XG4gICAgICAgIHZhciBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gZnJhbWVOdW1iZXI7XG4gICAgICAgIGlmIChwcmV2aW91c0ZyYW1lICE9PSB0aGlzLmN1cnJlbnRGcmFtZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIHNpbmNlIGxhc3QgdGljay5cbiAgICAgKi9cbiAgICB1cGRhdGUoZGVsdGFUaW1lKSB7XG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5hbmltYXRpb25TcGVlZCAqIGRlbHRhVGltZTtcbiAgICAgICAgdmFyIHByZXZpb3VzRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICAgICAgaWYgKHRoaXMuX2R1cmF0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxhZyA9IHRoaXMuX2N1cnJlbnRUaW1lICUgMSAqIHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgICAgICAgICBsYWcgKz0gZWxhcHNlZCAvIDYwICogMTAwMDtcbiAgICAgICAgICAgIHdoaWxlIChsYWcgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUtLTtcbiAgICAgICAgICAgICAgICBsYWcgKz0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWUpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBNYXRoLmZsb29yKHRoaXMuX2N1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIHdoaWxlIChsYWcgPj0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXSkge1xuICAgICAgICAgICAgICAgIGxhZyAtPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdICogc2lnbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBzaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gbGFnIC8gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IGVsYXBzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUaW1lIDwgMCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICAgICAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRUaW1lID49IHRoaXMuX3RleHR1cmVzLmxlbmd0aCAmJiAhdGhpcy5sb29wKSB7XG4gICAgICAgICAgICB0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzRnJhbWUgIT09IHRoaXMuY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sb29wICYmIHRoaXMub25Mb29wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uU3BlZWQgPiAwICYmIHRoaXMuY3VycmVudEZyYW1lIDwgcHJldmlvdXNGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTG9vcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFuaW1hdGlvblNwZWVkIDwgMCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA+IHByZXZpb3VzRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxvb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgZGlzcGxheWVkIHRleHR1cmUgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgZnJhbWUgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRleHR1cmUoKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgICAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XG4gICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xuICAgICAgICB0aGlzLnV2cyA9IHRoaXMuX3RleHR1cmUuX3V2cy51dnNGbG9hdDMyO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVBbmNob3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvci5jb3B5KHRoaXMuX3RleHR1cmUuZGVmYXVsdEFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25GcmFtZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vbkZyYW1lQ2hhbmdlKHRoaXMuY3VycmVudEZyYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlIGFuZCBkZXN0cm95cyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gSWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyIGRlc3Ryb3lcbiAgICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgU3ByaXRlXzEuU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMub25GcmFtZUNoYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMub25Mb29wID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYSBtb3ZpZWNsaXAgZnJvbSBhbiBhcnJheSBvZiBmcmFtZSBpZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZnJhbWVzIC0gVGhlIGFycmF5IG9mIGZyYW1lcyBpZHMgdGhlIG1vdmllY2xpcCB3aWxsIHVzZSBhcyBpdHMgdGV4dHVyZSBmcmFtZXMuXG4gICAgICogQHJldHVybiB7QW5pbWF0ZWRTcHJpdGV9IFRoZSBuZXcgYW5pbWF0ZWQgc3ByaXRlIHdpdGggdGhlIHNwZWNpZmllZCBmcmFtZXMuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21GcmFtZXMoZnJhbWVzKSB7XG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGV4dHVyZXMucHVzaChUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKGZyYW1lc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0ZWRTcHJpdGUodGV4dHVyZXMpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIG1vdmllY2xpcCBmcm9tIGFuIGFycmF5IG9mIGltYWdlIGlkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBpbWFnZXMgLSBUaGUgYXJyYXkgb2YgaW1hZ2UgdXJscyB0aGUgbW92aWVjbGlwIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lcy5cbiAgICAgKiBAcmV0dXJuIHtBbmltYXRlZFNwcml0ZX0gVGhlIG5ldyBhbmltYXRlIHNwcml0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW1hZ2VzIGFzIGZyYW1lcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUltYWdlcyhpbWFnZXMpIHtcbiAgICAgICAgdmFyIHRleHR1cmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKFRleHR1cmVfMS5UZXh0dXJlLmZyb20oaW1hZ2VzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGZyYW1lcyBpbiB0aGUgQW5pbWF0ZWRTcHJpdGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgbnVtYmVyIG9mIHRleHR1cmVzXG4gICAgICogYXNzaWduZWQgdG8gdGhlIEFuaW1hdGVkU3ByaXRlLlxuICAgICAqXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBnZXQgdG90YWxGcmFtZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJyYXkgb2YgdGV4dHVyZXMgdXNlZCBmb3IgdGhpcyBBbmltYXRlZFNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZVtdfVxuICAgICAqL1xuICAgIGdldCB0ZXh0dXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHR1cmVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZVswXSBpbnN0YW5jZW9mIFRleHR1cmVfMS5UZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKHZhbHVlW2ldLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9ucy5wdXNoKHZhbHVlW2ldLnRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ290b0FuZFN0b3AoMCk7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgKiBUaGUgQW5pbWF0ZWRTcHJpdGVzIGN1cnJlbnQgZnJhbWUgaW5kZXguXG4gICAgKlxuICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICogQHJlYWRvbmx5XG4gICAgKi9cbiAgICBnZXQgY3VycmVudEZyYW1lKCkge1xuICAgICAgICB2YXIgY3VycmVudEZyYW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSkgJSB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgIGlmIChjdXJyZW50RnJhbWUgPCAwKSB7XG4gICAgICAgICAgICBjdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50RnJhbWU7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQW5pbWF0ZWRTcHJpdGUgPSBBbmltYXRlZFNwcml0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vUmVuZGVyZXJcIik7XG5jb25zdCBTdGFnZU9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL1N0YWdlT3B0aW9uc1wiKTtcbmNvbnN0IFRpY2tlcl8xID0gcmVxdWlyZShcIi4vVGlja2VyXCIpO1xuY29uc3QgQWNjZXNzaWJpbGl0eU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0FjY2Vzc2liaWxpdHlNYW5hZ2VyXCIpO1xuY29uc3QgRXh0cmFjdF8xID0gcmVxdWlyZShcIi4vRXh0cmFjdFwiKTtcbmNvbnN0IEludGVyYWN0aW9uTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xuY29uc3QgUGFydGljbGVSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vUGFydGljbGVSZW5kZXJlclwiKTtcbmNvbnN0IFByZXBhcmVfMSA9IHJlcXVpcmUoXCIuL1ByZXBhcmVcIik7XG5jb25zdCBCYXRjaFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9CYXRjaFJlbmRlcmVyXCIpO1xuY29uc3QgVGlsaW5nU3ByaXRlUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL1RpbGluZ1Nwcml0ZVJlbmRlcmVyXCIpO1xuY2xhc3MgQXBwbGljYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZVRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZVRvID09PSB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZXNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh0aGlzLl9yZXNpemVUb1snY2xpZW50V2lkdGgnXSwgdGhpcy5fcmVzaXplVG9bJ2NsaWVudEhlaWdodCddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG5ldyBTdGFnZU9wdGlvbnNfMS5TdGFnZU9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBSZW5kZXJlcl8xLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdhY2Nlc3NpYmlsaXR5JywgQWNjZXNzaWJpbGl0eU1hbmFnZXJfMS5BY2Nlc3NpYmlsaXR5TWFuYWdlcik7XG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2V4dHJhY3QnLCBFeHRyYWN0XzEuRXh0cmFjdCk7XG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2ludGVyYWN0aW9uJywgSW50ZXJhY3Rpb25NYW5hZ2VyXzEuSW50ZXJhY3Rpb25NYW5hZ2VyKTtcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbigncGFydGljbGUnLCBQYXJ0aWNsZVJlbmRlcmVyXzEuUGFydGljbGVSZW5kZXJlcik7XG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3ByZXBhcmUnLCBQcmVwYXJlXzEuUHJlcGFyZSk7XG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2JhdGNoJywgQmF0Y2hSZW5kZXJlcl8xLkJhdGNoUmVuZGVyZXIpO1xuICAgICAgICBSZW5kZXJlcl8xLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCd0aWxpbmdTcHJpdGUnLCBUaWxpbmdTcHJpdGVSZW5kZXJlcl8xLlRpbGluZ1Nwcml0ZVJlbmRlcmVyKTtcbiAgICAgICAgLy8gdGhpcy5sb2FkZXIgPSAvKm9wdGlvbnMuc2hhcmVkTG9hZGVyID8gTG9hZGVyLnNoYXJlZCA6ICovbmV3IExvYWRlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyXzEuUmVuZGVyZXIob3B0aW9ucyk7IC8vQXBwbGljYXRpb24uYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zdGFnZSA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy50aWNrZXIgPSBvcHRpb25zLnNoYXJlZFRpY2tlciA/IFRpY2tlcl8xLlRpY2tlci5zaGFyZWQgOiBuZXcgVGlja2VyXzEuVGlja2VyKCk7XG4gICAgICAgIHRoaXMucmVzaXplVG8gPSB3aW5kb3c7XG4gICAgICAgIC8vIERpc3BsYXlPYmplY3QubWl4aW4oaW50ZXJhY3RpdmVUYXJnZXQpO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdGlja2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGlja2VyO1xuICAgIH1cbiAgICBzZXQgdGlja2VyKHRpY2tlcikge1xuICAgICAgICBpZiAodGhpcy5fdGlja2VyKSB7XG4gICAgICAgICAgICB0aGlzLl90aWNrZXIucmVtb3ZlKHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aWNrZXIgPSB0aWNrZXI7XG4gICAgICAgIGlmICh0aWNrZXIpIHtcbiAgICAgICAgICAgIHRpY2tlci5hZGQodGhpcy5yZW5kZXIsIHRoaXMsIFRpY2tlcl8xLlRpY2tlci5VUERBVEVfUFJJT1JJVFkuTE9XKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5fdGlja2VyLnN0YXJ0KCk7XG4gICAgfVxuICAgIDtcbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHJlc2l6ZVRvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzaXplVG87XG4gICAgfVxuICAgIHNldCByZXNpemVUbyh2YWx1ZSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUpO1xuICAgICAgICB0aGlzLl9yZXNpemVUbyA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5fc3RhZ2UpO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHN0YWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhZ2U7XG4gICAgfVxuICAgIGdldCB2aWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci52aWV3O1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHNjcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuc2NyZWVuO1xuICAgIH1cbiAgICA7XG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9zdGFnZS5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9zdGFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICAgICAgICAvLyBpZiAodGhpcy5sb2FkZXIpXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gICAgIHRoaXMubG9hZGVyID0gbnVsbDtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkFwcGxpY2F0aW9uID0gQXBwbGljYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY2xhc3MgQXJjVXRpbHMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cbiAgICBzdGF0aWMgY3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzLCBwb2ludHMpIHtcbiAgICAgICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGExID0gZnJvbVkgLSB5MTtcbiAgICAgICAgdmFyIGIxID0gZnJvbVggLSB4MTtcbiAgICAgICAgdmFyIGEyID0geTIgLSB5MTtcbiAgICAgICAgdmFyIGIyID0geDIgLSB4MTtcbiAgICAgICAgdmFyIG1tID0gTWF0aC5hYnMoKGExICogYjIpIC0gKGIxICogYTIpKTtcbiAgICAgICAgaWYgKG1tIDwgMS4wZS04IHx8IHJhZGl1cyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gIT09IHgxIHx8IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gIT09IHkxKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goeDEsIHkxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZCA9IChhMSAqIGExKSArIChiMSAqIGIxKTtcbiAgICAgICAgdmFyIGNjID0gKGEyICogYTIpICsgKGIyICogYjIpO1xuICAgICAgICB2YXIgdHQgPSAoYTEgKiBhMikgKyAoYjEgKiBiMik7XG4gICAgICAgIHZhciBrMSA9IHJhZGl1cyAqIE1hdGguc3FydChkZCkgLyBtbTtcbiAgICAgICAgdmFyIGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tO1xuICAgICAgICB2YXIgajEgPSBrMSAqIHR0IC8gZGQ7XG4gICAgICAgIHZhciBqMiA9IGsyICogdHQgLyBjYztcbiAgICAgICAgdmFyIGN4ID0gKGsxICogYjIpICsgKGsyICogYjEpO1xuICAgICAgICB2YXIgY3kgPSAoazEgKiBhMikgKyAoazIgKiBhMSk7XG4gICAgICAgIHZhciBweCA9IGIxICogKGsyICsgajEpO1xuICAgICAgICB2YXIgcHkgPSBhMSAqIChrMiArIGoxKTtcbiAgICAgICAgdmFyIHF4ID0gYjIgKiAoazEgKyBqMik7XG4gICAgICAgIHZhciBxeSA9IGEyICogKGsxICsgajIpO1xuICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIocHkgLSBjeSwgcHggLSBjeCk7XG4gICAgICAgIHZhciBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjeDogKGN4ICsgeDEpLFxuICAgICAgICAgICAgY3k6IChjeSArIHkxKSxcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcbiAgICAgICAgICAgIGFudGljbG9ja3dpc2U6IChiMSAqIGEyID4gYjIgKiBhMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJjIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSAodXNlZCB0byBjcmVhdGUgY2lyY2xlcywgb3IgcGFydHMgb2YgY2lyY2xlcykuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFggLSBTdGFydCB4IGxvY2F0aW9uIG9mIGFyY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFkgLSBTdGFydCB5IGxvY2F0aW9uIG9mIGFyY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvblxuICAgICAqICBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmRBbmdsZSAtIFRoZSBlbmRpbmcgYW5nbGUsIGluIHJhZGlhbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFudGljbG9ja3dpc2UgLSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmVcbiAgICAgKiAgY291bnRlci1jbG9ja3dpc2Ugb3IgY2xvY2t3aXNlLiBGYWxzZSBpcyBkZWZhdWx0LCBhbmQgaW5kaWNhdGVzIGNsb2Nrd2lzZSwgd2hpbGUgdHJ1ZVxuICAgICAqICBpbmRpY2F0ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBOdW1iZXIgb2Ygc2VnbWVudHNcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBDb2xsZWN0aW9uIG9mIHBvaW50cyB0byBhZGQgdG9cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJjKHN0YXJ0WCwgc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHBvaW50cykge1xuICAgICAgICB2YXIgc3dlZXAgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBuID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HUkFQSElDU19DVVJWRVMuX3NlZ21lbnRzQ291bnQoTWF0aC5hYnMoc3dlZXApICogcmFkaXVzLCBNYXRoLmNlaWwoTWF0aC5hYnMoc3dlZXApIC8gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLlBJXzIpICogNDApO1xuICAgICAgICB2YXIgdGhldGEgPSAoc3dlZXApIC8gKG4gKiAyKTtcbiAgICAgICAgdmFyIHRoZXRhMiA9IHRoZXRhICogMjtcbiAgICAgICAgdmFyIGNUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgdmFyIHNUaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgdmFyIHNlZ01pbnVzID0gbiAtIDE7XG4gICAgICAgIHZhciByZW1haW5kZXIgPSAoc2VnTWludXMgJSAxKSAvIHNlZ01pbnVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzZWdNaW51czsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcmVhbCA9IGkgKyAocmVtYWluZGVyICogaSk7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSAoKHRoZXRhKSArIHN0YXJ0QW5nbGUgKyAodGhldGEyICogcmVhbCkpO1xuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICB2YXIgcyA9IC1NYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICBwb2ludHMucHVzaCgoKChjVGhldGEgKiBjKSArIChzVGhldGEgKiBzKSkgKiByYWRpdXMpICsgY3gsICgoKGNUaGV0YSAqIC1zKSArIChzVGhldGEgKiBjKSkgKiByYWRpdXMpICsgY3kpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQXJjVXRpbHMgPSBBcmNVdGlscztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgUmVzb3VyY2VTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vUmVzb3VyY2VTZXR0aW5nc1wiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBBcnJheVJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2VfMS5SZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgdXJscztcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgdXJscyA9IHNvdXJjZTtcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIob3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiByZXNvdXJjZXMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5PFBJWEkuQmFzZVRleHR1cmU+fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpcnR5IElEcyBmb3IgZWFjaCBwYXJ0XG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5PG51bWJlcj59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtRGlydHlJZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnRUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUoKTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChwYXJ0VGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLml0ZW1EaXJ0eUlkcy5wdXNoKC0xKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGVsZW1lbnRzIGluIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb21pc2Ugd2hlbiBsb2FkaW5nXG4gICAgICAgICAqIEBtZW1iZXIge1Byb21pc2V9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgICAgICBpZiAodXJscykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmVzb3VyY2VBdChSZXNvdXJjZVNldHRpbmdzXzEuUmVzb3VyY2VTZXR0aW5ncy5hdXRvRGV0ZWN0UmVzb3VyY2UodXJsc1tpJDFdLCBvcHRpb25zKSwgaSQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoaXMgQmFzZUltYWdlUmVzb3VyY2VcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXRlbURpcnR5SWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgYSByZXNvdXJjZSBieSBJRFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLnJlc291cmNlcy5SZXNvdXJjZX0gcmVzb3VyY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBaZXJvLWJhc2VkIGluZGV4IG9mIHJlc291cmNlIHRvIHNldFxuICAgICAqIEByZXR1cm4ge1BJWEkucmVzb3VyY2VzLkFycmF5UmVzb3VyY2V9IEluc3RhbmNlIGZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIGFkZFJlc291cmNlQXQocmVzb3VyY2UsIGluZGV4KSB7XG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRoaXMuaXRlbXNbaW5kZXhdO1xuICAgICAgICBpZiAoIWJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIGlzIG91dCBvZiBib3VuZHNcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaGVyaXQgdGhlIGZpcnN0IHJlc291cmNlIGRpbWVuc2lvbnNcbiAgICAgICAgaWYgKHJlc291cmNlLnZhbGlkICYmICF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZShyZXNvdXJjZS53aWR0aCwgcmVzb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5zZXRSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBwYXJlbnQgYmFzZSB0ZXh0dXJlXG4gICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZX1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBiaW5kKGJhc2VUZXh0dXJlKSB7XG4gICAgICAgIHN1cGVyLmJpbmQoYmFzZVRleHR1cmUpO1xuICAgICAgICBiYXNlVGV4dHVyZS50YXJnZXQgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UQVJHRVRTLlRFWFRVUkVfMkRfQVJSQVk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5vbigndXBkYXRlJywgYmFzZVRleHR1cmUudXBkYXRlLCBiYXNlVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVuc2V0IHRoZSBwYXJlbnQgYmFzZSB0ZXh0dXJlXG4gICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZX1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICAgICAgc3VwZXIudW5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLm9mZigndXBkYXRlJywgYmFzZVRleHR1cmUudXBkYXRlLCBiYXNlVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIExvYWQgYWxsIHRoZSByZXNvdXJjZXMgc2ltdWx0YW5lb3VzbHlcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSBXaGVuIGxvYWQgaXMgcmVzb2x2ZWRcbiAgICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXNvdXJjZXMgPSB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5yZXNvdXJjZTsgfSk7XG4gICAgICAgIC8vIFRPRE86IGFsc28gaW1wbGVtZW50IGxvYWQgcGFydC1ieS1wYXJ0IHN0cmF0ZWd5XG4gICAgICAgIHZhciBwcm9taXNlcyA9IHJlc291cmNlcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ubG9hZCgpOyB9KTtcbiAgICAgICAgdGhpcy5fbG9hZCA9IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlZiA9IHJlc291cmNlc1swXTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWYuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcyQxLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyQxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkIHRoZSByZXNvdXJjZXMgdG8gdGhlIEdQVS5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtQSVhJLkdMVGV4dHVyZX0gZ2xUZXh0dXJlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGV4dHVyZSB3YXMgdXBsb2FkZWRcbiAgICAgKi9cbiAgICB1cGxvYWQocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGxlbmd0aCA9IHJlZi5sZW5ndGg7XG4gICAgICAgIHZhciBpdGVtRGlydHlJZHMgPSByZWYuaXRlbURpcnR5SWRzO1xuICAgICAgICB2YXIgaXRlbXMgPSByZWYuaXRlbXM7XG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuICAgICAgICBpZiAoZ2xUZXh0dXJlLmRpcnR5SWQgPCAwKSB7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTNEKGdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIHRleHR1cmUuZm9ybWF0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBsZW5ndGgsIDAsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLnR5cGUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoaXRlbURpcnR5SWRzW2ldIDwgaXRlbS5kaXJ0eUlkKSB7XG4gICAgICAgICAgICAgICAgaXRlbURpcnR5SWRzW2ldID0gaXRlbS5kaXJ0eUlkO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnRleFN1YkltYWdlM0QoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgMCwgLy8geG9mZnNldFxuICAgICAgICAgICAgICAgICAgICAwLCAvLyB5b2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIGksIC8vIHpvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5yZXNvdXJjZS53aWR0aCwgaXRlbS5yZXNvdXJjZS5oZWlnaHQsIDEsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLnR5cGUsIGl0ZW0ucmVzb3VyY2Uuc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQXJyYXlSZXNvdXJjZSA9IEFycmF5UmVzb3VyY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vL0xvZ2dlclwiKTtcbmNsYXNzIEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBzaXplLCBub3JtYWxpemVkID0gZmFsc2UsIHR5cGUgPSA1MTI2LCBzdHJpZGUgPSB1bmRlZmluZWQsIHN0YXJ0ID0gdW5kZWZpbmVkLCBpbnN0YW5jZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fc3RyaWRlID0gc3RyaWRlO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBzdHJpZGUodmFsdWUpIHtcbiAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJzZXQgdG8gXCIgKyB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3N0cmlkZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgc3RyaWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaWRlO1xuICAgIH1cbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9SZXNvdXJjZVwiKTtcbmNvbnN0IE5ldHdvcmtTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTmV0d29ya1NldHRpbmdzXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jbGFzcyBCYXNlSW1hZ2VSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlXzEuUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGNyb3NzIG9yaWdpbiBiYXNlZCBkZXRlY3RpbmcgdGhlIHVybCBhbmQgdGhlIGNyb3Nzb3JpZ2luXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IGNyb3NzT3JpZ2luXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFVSTCB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IFtjcm9zc29yaWdpbj10cnVlXSAtIENyb3NzIG9yaWdpbiB2YWx1ZSB0byB1c2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY3Jvc3NPcmlnaW4oZWxlbWVudCwgdXJsLCBjcm9zc29yaWdpbikge1xuICAgICAgICBpZiAoY3Jvc3NvcmlnaW4gPT09IHVuZGVmaW5lZCAmJiB1cmwuaW5kZXhPZignZGF0YTonKSAhPT0gMCkge1xuICAgICAgICAgICAgZWxlbWVudC5jcm9zc09yaWdpbiA9IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5kZXRlcm1pbmVDcm9zc09yaWdpbih1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNyb3Nzb3JpZ2luICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZWxlbWVudC5jcm9zc09yaWdpbiA9IHR5cGVvZiBjcm9zc29yaWdpbiA9PT0gJ3N0cmluZycgPyBjcm9zc29yaWdpbiA6ICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWQgdGhlIHRleHR1cmUgdG8gdGhlIEdQVS5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIFVwbG9hZCB0byB0aGUgcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIFJlZmVyZW5jZSB0byBwYXJlbnQgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7UElYSS5HTFRleHR1cmV9IGdsVGV4dHVyZVxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fFNWR0VsZW1lbnR9IFtzb3VyY2VdIChvcHRpb25hbClcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAgICovXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlLCBzb3VyY2UgPSBudWxsKSB7XG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuICAgICAgICB2YXIgd2lkdGggPSBiYXNlVGV4dHVyZS5yZWFsV2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2UgfHwgdGhpcy5zb3VyY2U7XG4gICAgICAgIExvZ2dlcl8xLnRyYWNlKFwidXBkYXRlIHVwbG9hZCBcIiArIGJhc2VUZXh0dXJlLnR5cGUpO1xuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuICAgICAgICBpZiAoYmFzZVRleHR1cmUudGFyZ2V0ID09PSBnbC5URVhUVVJFXzJEICYmIGdsVGV4dHVyZS53aWR0aCA9PT0gd2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0cmFjZShcInVwZGF0ZSB1cGxvYWQgXCIgKyBnbFRleHR1cmUud2lkdGggKyBcIjpcIiArIGdsVGV4dHVyZS5oZWlnaHQpXG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKFwiZmlyc3QgdXBsb2FkIFwiICsgd2lkdGggKyBcIjpcIiArIGhlaWdodCk7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoaXMgQmFzZUltYWdlUmVzb3VyY2VcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IFtmcm9tVGV4dHVyZV0gT3B0aW9uYWwgYmFzZSB0ZXh0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gRGVzdHJveSB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5CYXNlSW1hZ2VSZXNvdXJjZSA9IEJhc2VJbWFnZVJlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgVGV4dFN0eWxlXzEgPSByZXF1aXJlKFwiLi9UZXh0U3R5bGVcIik7XG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi9UZXh0XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFRleHRNZXRyaWNzXzEgPSByZXF1aXJlKFwiLi9UZXh0TWV0cmljc1wiKTtcbmNvbnN0IENvdW50TGltaXRlcl8xID0gcmVxdWlyZShcIi4vQ291bnRMaW1pdGVyXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNsYXNzIEJhc2VQcmVwYXJlIC8vZXh0ZW5kcyBSZW5kZXJlclxuIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICAvLyBzdXBlcihudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaW1pdGVyIHRvIGJlIHVzZWQgdG8gY29udHJvbCBob3cgcXVpY2tseSBpdGVtcyBhcmUgcHJlcGFyZWQuXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLnByZXBhcmUuQ291bnRMaW1pdGVyfFBJWEkucHJlcGFyZS5UaW1lTGltaXRlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGltaXRlciA9IG5ldyBDb3VudExpbWl0ZXJfMS5Db3VudExpbWl0ZXIoV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVVBMT0FEU19QRVJfRlJBTUUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlci5cbiAgICAgICAgICogQHR5cGUge1BJWEkuQWJzdHJhY3RSZW5kZXJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9ubHkgcmVhbCBkaWZmZXJlbmNlIGJldHdlZW4gQ2FudmFzUHJlcGFyZSBhbmQgV2ViR0xQcmVwYXJlIGlzIHdoYXQgdGhleSBwYXNzXG4gICAgICAgICAqIHRvIHVwbG9hZCBob29rcy4gVGhhdCBkaWZmZXJlbnQgcGFyYW1ldGVyIGlzIHN0b3JlZCBoZXJlLlxuICAgICAgICAgKiBAdHlwZSB7UElYSS5wcmVwYXJlLkNhbnZhc1ByZXBhcmV8UElYSS5SZW5kZXJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZHMgYXQgb25jZS5cbiAgICAgICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBhZGRpdGlvbmFsIGhvb2tzIGZvciBmaW5kaW5nIGFzc2V0cy5cbiAgICAgICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkSG9va3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgYWRkaXRpb25hbCBob29rcyBmb3IgcHJvY2Vzc2luZyBhc3NldHMuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxGdW5jdGlvbj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwbG9hZEhvb2tzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB0byBjYWxsIGFmdGVyIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcGxldGVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwcmVwYXJlIGlzIHRpY2tpbmcgKHJ1bm5pbmcpLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogJ2JvdW5kJyBjYWxsIGZvciBwcmVwYXJlSXRlbXMoKS5cbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxheWVkVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHVubGlrZWx5LCBidXQgaW4gY2FzZSB3ZSB3ZXJlIGRlc3Ryb3llZCBiZXR3ZWVuIHRpY2soKSBhbmQgZGVsYXllZFRpY2soKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVwYXJlSXRlbXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaG9va3MgdG8gZmluZCB0aGUgY29ycmVjdCB0ZXh0dXJlXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kVGV4dCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kVGV4dFN0eWxlKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKEJhc2VQcmVwYXJlLmZpbmRNdWx0aXBsZUJhc2VUZXh0dXJlcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kQmFzZVRleHR1cmUpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soQmFzZVByZXBhcmUuZmluZFRleHR1cmUpO1xuICAgICAgICAvLyB1cGxvYWQgaG9va3NcbiAgICAgICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soQmFzZVByZXBhcmUuZHJhd1RleHQpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayhCYXNlUHJlcGFyZS5jYWxjdWxhdGVUZXh0U3R5bGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYWxsIHRoZSB0ZXh0dXJlcyBhbmQgZ3JhcGhpY3MgdG8gdGhlIEdQVS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuQ29udGFpbmVyfFBJWEkuQmFzZVRleHR1cmV8UElYSS5UZXh0dXJlfFBJWEkuR3JhcGhpY3N8UElYSS5UZXh0fSBpdGVtIC1cbiAgICAgKiAgICBFaXRoZXIgdGhlIGNvbnRhaW5lciBvciBkaXNwbGF5IG9iamVjdCB0byBzZWFyY2ggZm9yIGl0ZW1zIHRvIHVwbG9hZCwgdGhlIGl0ZW1zIHRvIHVwbG9hZCB0aGVtc2VsdmVzLFxuICAgICAqICAgIG9yIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgaWYgaXRlbXMgaGF2ZSBiZWVuIGFkZGVkIHVzaW5nIGBwcmVwYXJlLmFkZGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIC0gT3B0aW9uYWwgY2FsbGJhY2sgd2hlbiBhbGwgcXVldWVkIHVwbG9hZHMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICB1cGxvYWQoaXRlbSwgZG9uZSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRvbmUgPSBpdGVtO1xuICAgICAgICAgICAgaXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBkaXNwbGF5IG9iamVjdCwgc2VhcmNoIGZvciBpdGVtc1xuICAgICAgICAvLyB0aGF0IHdlIGNvdWxkIHVwbG9hZFxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hZGQoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBpdGVtcyBmb3IgdXBsb2FkIGZyb20gdGhlIGRpc3BsYXlcbiAgICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVzLnB1c2goZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMudGlja2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMudGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnN5c3RlbS5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgVGlja2VyXzEuVGlja2VyLlVQREFURV9QUklPUklUWS5VVElMSVRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aWNrIHVwZGF0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aWNrKCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZGVsYXllZFRpY2ssIDApO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWN0dWFsbHkgcHJlcGFyZSBpdGVtcy4gVGhpcyBpcyBoYW5kbGVkIG91dHNpZGUgb2YgdGhlIHRpY2sgYmVjYXVzZSBpdCB3aWxsIHRha2UgYSB3aGlsZVxuICAgICAqIGFuZCB3ZSBkbyBOT1Qgd2FudCB0byBibG9jayB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUgZnJvbSByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByZXBhcmVJdGVtcygpIHtcbiAgICAgICAgdGhpcy5saW1pdGVyLmJlZ2luRnJhbWUoKTtcbiAgICAgICAgLy8gVXBsb2FkIHRoZSBncmFwaGljc1xuICAgICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggJiYgdGhpcy5saW1pdGVyLmFsbG93ZWRUb1VwbG9hZCgpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMucXVldWVbMF07XG4gICAgICAgICAgICB2YXIgdXBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmICFpdGVtLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy51cGxvYWRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51cGxvYWRIb29rc1tpXSh0aGlzLnVwbG9hZEhvb2tIZWxwZXIsIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXBsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29tcGxldGVzID0gdGhpcy5jb21wbGV0ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGVuJDEgPSBjb21wbGV0ZXMubGVuZ3RoOyBpJDEgPCBsZW4kMTsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXNbaSQxXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBmaW5pc2hlZCwgb24gdGhlIG5leHQgckFGIGRvIHRoaXMgYWdhaW5cbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zeXN0ZW0uYWRkT25jZSh0aGlzLnRpY2ssIHRoaXMsIFRpY2tlcl8xLlRpY2tlci5VUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgaG9va3MgZm9yIGZpbmRpbmcgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZGRIb29rIC0gRnVuY3Rpb24gY2FsbCB0aGF0IHRha2VzIHR3byBwYXJhbWV0ZXJzOiBgaXRlbToqLCBxdWV1ZTpBcnJheWBcbiAgICAgKiAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBhZGQgaXRlbSB0byB0aGUgcXVldWUuXG4gICAgICogQHJldHVybiB7UElYSS5wcmVwYXJlLkJhc2VQcmVwYXJlfSBJbnN0YW5jZSBvZiBwbHVnaW4gZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyRmluZEhvb2soYWRkSG9vaykge1xuICAgICAgICBpZiAoYWRkSG9vaykge1xuICAgICAgICAgICAgdGhpcy5hZGRIb29rcy5wdXNoKGFkZEhvb2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkcyBob29rcyBmb3IgdXBsb2FkaW5nIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBsb2FkSG9vayAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYHByZXBhcmU6Q2FudmFzUHJlcGFyZSwgaXRlbToqYCBhbmRcbiAgICAgKiAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBoYW5kbGUgdXBsb2FkIG9mIGl0ZW0uXG4gICAgICogQHJldHVybiB7UElYSS5wcmVwYXJlLkJhc2VQcmVwYXJlfSBJbnN0YW5jZSBvZiBwbHVnaW4gZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRIb29rKSB7XG4gICAgICAgIGlmICh1cGxvYWRIb29rKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZEhvb2tzLnB1c2godXBsb2FkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBhZGQgYW4gaXRlbSB0byB0aGUgdXBsb2FkaW5nIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5Db250YWluZXJ8UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV8UElYSS5HcmFwaGljc3xQSVhJLlRleHR8Kn0gaXRlbSAtIE9iamVjdCB0b1xuICAgICAqICAgIGFkZCB0byB0aGUgcXVldWVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLnByZXBhcmUuQmFzZVByZXBhcmV9IEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgaG9va3MgZm9yIGZpbmRpbmcgZWxlbWVudHMgb24gc3BlY2lhbFxuICAgICAgICAvLyB0eXBlcyBvZiBvYmplY3RzIHRoYXRcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYWRkSG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZEhvb2tzW2ldKGl0ZW0sIHRoaXMucXVldWUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGNoaWxkcmVuIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSBpdGVtLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGl0ZW0uY2hpbGRyZW5baSQxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnRpY2tpbmcpIHtcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMudGljaywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkSG9va3MgPSBudWxsO1xuICAgICAgICB0aGlzLnVwbG9hZEhvb2tzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGxldGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGltaXRlciA9IG51bGw7XG4gICAgICAgIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gZmluZCBUZXh0IG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHF1ZXVlIC0gQ29sbGVjdGlvbiBvZiBpdGVtcyB0byB1cGxvYWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGEgUElYSS5UZXh0IG9iamVjdCB3YXMgZm91bmQuXG4gKi9cbiAgICBzdGF0aWMgZmluZFRleHQoaXRlbSwgcXVldWUpIHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0XzEuVGV4dCkge1xuICAgICAgICAgICAgLy8gcHVzaCB0aGUgdGV4dCBzdHlsZSB0byBwcmVwYXJlIGl0IC0gdGhpcyBjYW4gYmUgcmVhbGx5IGV4cGVuc2l2ZVxuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbS5zdHlsZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChpdGVtLnN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsc28gcHVzaCB0aGUgdGV4dCBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmVuZGVyIGl0ICh0byBjYW52YXMvdGV4dHVyZSkgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAocXVldWUuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWxzbyBwdXNoIHRoZSBUZXh0J3MgdGV4dHVyZSBmb3IgdXBsb2FkIHRvIEdQVVxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YodGV4dHVyZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgVGV4dFN0eWxlIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgYSBQSVhJLlRleHRTdHlsZSBvYmplY3Qgd2FzIGZvdW5kLlxuICovXG4gICAgc3RhdGljIGZpbmRUZXh0U3R5bGUoaXRlbSwgcXVldWUpIHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0U3R5bGVfMS5UZXh0U3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICogQnVpbHQtaW4gaG9vayB0byBmaW5kIG11bHRpcGxlIHRleHR1cmVzIGZyb20gb2JqZWN0cyBsaWtlIEFuaW1hdGVkU3ByaXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgYSBQSVhJLlRleHR1cmUgb2JqZWN0IHdhcyBmb3VuZC5cbiAqL1xuICAgIHN0YXRpYyBmaW5kTXVsdGlwbGVCYXNlVGV4dHVyZXMoaXRlbSwgcXVldWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAvLyBPYmplY3RzIHdpdGggbXVsdGlwbGUgdGV4dHVyZXNcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5fdGV4dHVyZXMgJiYgaXRlbS5fdGV4dHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW0uX3RleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uX3RleHR1cmVzW2ldIGluc3RhbmNlb2YgVGV4dHVyZV8xLlRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gaXRlbS5fdGV4dHVyZXNbaV0uYmFzZVRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGJhc2VUZXh0dXJlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goYmFzZVRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gZmluZCBCYXNlVGV4dHVyZXMgZnJvbSBTcHJpdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIERpc3BsYXkgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dHVyZSBvYmplY3Qgd2FzIGZvdW5kLlxuICovXG4gICAgc3RhdGljIGZpbmRCYXNlVGV4dHVyZShpdGVtLCBxdWV1ZSkge1xuICAgICAgICAvLyBPYmplY3RzIHdpdGggdGV4dHVyZXMsIGxpa2UgU3ByaXRlcy9UZXh0XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgdGV4dHVyZXMgZnJvbSBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIERpc3BsYXkgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dHVyZSBvYmplY3Qgd2FzIGZvdW5kLlxuICovXG4gICAgc3RhdGljIGZpbmRUZXh0dXJlKGl0ZW0sIHF1ZXVlKSB7XG4gICAgICAgIGlmIChpdGVtLl90ZXh0dXJlICYmIGl0ZW0uX3RleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSkge1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YodGV4dHVyZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbHQtaW4gaG9vayB0byBkcmF3IFBJWEkuVGV4dCB0byBpdHMgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfFBJWEkuQ2FudmFzUHJlcGFyZX0gaGVscGVyIC0gTm90IHVzZWQgYnkgdGhpcyB1cGxvYWQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gSXRlbSB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGl0ZW0gd2FzIHVwbG9hZGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBkcmF3VGV4dChoZWxwZXIsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0XzEuVGV4dCkge1xuICAgICAgICAgICAgLy8gdXBkYXRpbmcgdGV4dCB3aWxsIHJldHVybiBlYXJseSBpZiBpdCBpcyBub3QgZGlydHlcbiAgICAgICAgICAgIGl0ZW0udXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gKiBCdWlsdC1pbiBob29rIHRvIGNhbGN1bGF0ZSBhIHRleHQgc3R5bGUgZm9yIGEgUElYSS5UZXh0IG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfFBJWEkuQ2FudmFzUHJlcGFyZX0gaGVscGVyIC0gTm90IHVzZWQgYnkgdGhpcyB1cGxvYWQgaGFuZGxlclxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBJdGVtIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiBpdGVtIHdhcyB1cGxvYWRlZC5cbiAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUZXh0U3R5bGUoaGVscGVyLCBpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgZm9udCA9IGl0ZW0udG9Gb250U3RyaW5nKCk7XG4gICAgICAgICAgICBUZXh0TWV0cmljc18xLlRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVByZXBhcmUgPSBCYXNlUHJlcGFyZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgRnJhbWVidWZmZXJfMSA9IHJlcXVpcmUoXCIuL0ZyYW1lYnVmZmVyXCIpO1xuY2xhc3MgQmFzZVJlbmRlclRleHR1cmUgZXh0ZW5kcyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcmcxID0gbnVsbCwgYXJnMiA9IG51bGwsIGFyZzQgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgb2Ygc2lnbmF0dXJlXG4gICAgICAgICAgICB2YXIgd2lkdGgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBzY2FsZU1vZGUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHdpZHRoOiB3aWR0aCQxLCBoZWlnaHQ6IGhlaWdodCQxLCBzY2FsZU1vZGU6IHNjYWxlTW9kZSwgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiB9O1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVmLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgICAgIHRoaXMubWlwbWFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGgpIHx8IDEwMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KSB8fCAxMDA7XG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyByZW5kZXIgdGFyZ2V0ICh3ZSBvbmx5IG5lZWQgb25lIGFzIHRoaXMgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgcmVuZGVyZXJzKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NhbnZhc1JlbmRlclRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcl8xLkZyYW1lYnVmZmVyKHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb24sIHRoaXMuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKVxuICAgICAgICAgICAgLmFkZENvbG9yVGV4dHVyZSgwLCB0aGlzKVxuICAgICAgICAgICAgLmVuYWJsZVN0ZW5jaWwoKTtcbiAgICAgICAgLy8gVE9ETyAtIGNvdWxkIHRoaXMgYmUgYWRkZWQgdGhlIHN5c3RlbXM/XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIHRoZSBzdGVuY2lsIG1hc2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGhlIGZpbHRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBbe31dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBCYXNlUmVuZGVyVGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCB0byByZXNpemUgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgdG8gcmVzaXplIHRvLlxuICAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKHdpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRnJlZXMgdGhlIHRleHR1cmUgYW5kIGZyYW1lYnVmZmVyIGZyb20gV2ViR0wgbWVtb3J5IHdpdGhvdXQgZGVzdHJveWluZyB0aGlzIHRleHR1cmUgb2JqZWN0LlxuICAgICAqIFRoaXMgbWVhbnMgeW91IGNhbiBzdGlsbCB1c2UgdGhlIHRleHR1cmUgbGF0ZXIgd2hpY2ggd2lsbCB1cGxvYWQgaXQgdG8gR1BVXG4gICAgICogbWVtb3J5IGFnYWluLlxuICAgICAqXG4gICAgICogQGZpcmVzIFBJWEkuQmFzZVRleHR1cmUjZGlzcG9zZVxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIuZGlzcG9zZSgpO1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5CYXNlUmVuZGVyVGV4dHVyZSA9IEJhc2VSZW5kZXJUZXh0dXJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcbmNvbnN0IFJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9SZXNvdXJjZVwiKTtcbmNvbnN0IEJ1ZmZlclJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJSZXNvdXJjZVwiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcbmNvbnN0IFJlc291cmNlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlU2V0dGluZ3NcIik7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNsYXNzIEJhc2VUZXh0dXJlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvdXJjZSA9IG51bGwsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFJlYWxTaXplKHRoaXMucmVzb3VyY2Uud2lkdGgsIHRoaXMucmVzb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgcHJlbXVsdGlwbHlBbHBoYSA9IG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgdmFyIG1pcG1hcCA9IG9wdGlvbnMubWlwbWFwO1xuICAgICAgICB2YXIgc2NhbGVNb2RlID0gb3B0aW9ucy5zY2FsZU1vZGU7XG4gICAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgdmFyIHdyYXBNb2RlID0gb3B0aW9ucy53cmFwTW9kZTtcbiAgICAgICAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICAgICAgICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IG9wdGlvbnMucmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIHJlc291cmNlT3B0aW9ucyA9IG9wdGlvbnMucmVzb3VyY2VPcHRpb25zO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSByZXNvdXJjZSB0byBhIFJlc291cmNlIG9iamVjdFxuICAgICAgICBpZiAocmVzb3VyY2UgJiYgcmVzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc291cmNlICYmICEocmVzb3VyY2UgaW5zdGFuY2VvZiBSZXNvdXJjZV8xLlJlc291cmNlKSkge1xuICAgICAgICAgICAgcmVzb3VyY2UgPSBSZXNvdXJjZVNldHRpbmdzXzEuUmVzb3VyY2VTZXR0aW5ncy5hdXRvRGV0ZWN0UmVzb3VyY2UocmVzb3VyY2UsIHJlc291cmNlT3B0aW9ucyk7XG4gICAgICAgICAgICBMb2dnZXJfMS5yZXZlYWwocmVzb3VyY2UpO1xuICAgICAgICAgICAgcmVzb3VyY2UuaW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBiYXNlIHRleHR1cmUgc2V0IHdoZW4gdGhlIGltYWdlIGhhcyBsb2FkZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuUkVTT0xVVElPTlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1pcG1hcCBtb2RlIG9mIHRoZSB0ZXh0dXJlLCBhZmZlY3RzIGRvd25zY2FsZWQgaW1hZ2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTUlQTUFQX01PREVTfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLk1JUE1BUF9URVhUVVJFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taXBtYXAgPSBtaXBtYXAgIT09IHVuZGVmaW5lZCA/IG1pcG1hcCA6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLk1JUE1BUF9URVhUVVJFUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyB0aGUgdGV4dHVyZSB3cmFwc1xuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBNb2RlID0gd3JhcE1vZGUgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjYWxlIG1vZGUgdG8gYXBwbHkgd2hlbiBzY2FsaW5nIHRoaXMgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNDQUxFX01PREVTfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLlNDQUxFX01PREVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlICE9PSB1bmRlZmluZWQgPyBzY2FsZU1vZGUgOiBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuU0NBTEVfTU9ERTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GT1JNQVRTfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLkZPUk1BVFMuUkdCQVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuRk9STUFUUy5SR0JBO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgcmVzb3VyY2UgZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRZUEVTfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlRZUEVTLlVOU0lHTkVEX0JZVEVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YXJnZXQgdHlwZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRBUkdFVFN9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuVEFSR0VUUy5URVhUVVJFXzJEXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UQVJHRVRTLlRFWFRVUkVfMkQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgcHJlLW11bHRpcGxpZWQgYWxwaGFcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gcHJlbXVsdGlwbHlBbHBoYSAhPT0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHbG9iYWwgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgQmFzZVRleHR1cmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpZCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy51aWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgYnkgYXV0b21hdGljIHRleHR1cmUgR2FyYmFnZSBDb2xsZWN0aW9uLCBzdG9yZXMgbGFzdCBHQyB0aWNrIHdoZW4gaXQgd2FzIGJvdW5kXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b3VjaGVkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0ZXh0dXJlIGlzIGEgcG93ZXIgb2YgdHdvLCB0cnkgdG8gdXNlIHBvd2VyIG9mIHR3byB0ZXh0dXJlcyBhcyBtdWNoXG4gICAgICAgICAqIGFzIHlvdSBjYW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUG93ZXJPZlR3byA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWFwIG9mIHJlbmRlciBjb250ZXh0IHRleHR1cmVzIHdoZXJlIHRoaXMgaXMgYm91bmRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2xUZXh0dXJlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBieSBUZXh0dXJlU3lzdGVtIHRvIG9ubHkgdXBkYXRlIHRleHR1cmUgdG8gdGhlIEdQVSB3aGVuIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpcnR5SWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBieSBUZXh0dXJlU3lzdGVtIHRvIG9ubHkgdXBkYXRlIHRleHR1cmUgc3R5bGUgd2hlbiBuZWVkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5IGRlZmF1bHQgY2FjaGUgSUQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVJZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmFsbHkgc3BlYWtpbmcgbWVhbnMgd2hlbiByZXNvdXJjZSBpcyBsb2FkZWQuXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgYWx0ZXJuYXRpdmUgY2FjaGUgaWRzLCBzaW5jZSBzb21lIEJhc2VUZXh0dXJlc1xuICAgICAgICAgKiBjYW4gaGF2ZSBtb3JlIHRoYW4gb25lIElELCBzaG9ydCBuYW1lIGFuZCBsb25nZXIgZnVsbCBVUkxcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8c3RyaW5nPn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBpZiBCYXNlVGV4dHVyZSBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNvdXJjZSB1c2VkIGJ5IHRoaXMgQmFzZVRleHR1cmUsIHRoZXJlIGNhbiBvbmx5XG4gICAgICAgICAqIGJlIG9uZSByZXNvdXJjZSBwZXIgQmFzZVRleHR1cmUsIGJ1dCB0ZXh0dXJlcyBjYW4gc2hhcmVcbiAgICAgICAgICogcmVzb3VyY2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLnJlc291cmNlcy5SZXNvdXJjZX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiB0aGUgdGV4dHVyZSBiYXRjaCwgdXNlZCBieSBtdWx0aS10ZXh0dXJlIHJlbmRlcmVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iYXRjaEVuYWJsZWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZpbmlzaGVzIGxvYWRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjbG9hZGVkXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBSZXNvdXJjZSBsb2FkZWQuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZhaWxzIHRvIGxvYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjZXJyb3JcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFJlc291cmNlIGVycm9yZWQuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBCYXNlVGV4dHVyZSBpcyB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI2xvYWRlZFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUmVzb3VyY2UgbG9hZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI2Vycm9yXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBSZXNvdXJjZSBlcnJvcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgdXBkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSN1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIEluc3RhbmNlIG9mIHRleHR1cmUgYmVpbmcgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIEJhc2VUZXh0dXJlIGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSNkaXNwb3NlXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBJbnN0YW5jZSBvZiB0ZXh0dXJlIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgICAgICovXG4gICAgICAgIC8vIFNldCB0aGUgcmVzb3VyY2VcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpeGVsIHdpZHRoIG9mIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHJlYWxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb247XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQaXhlbCBoZWlnaHQgb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcmVhbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBzdHlsZSBvcHRpb25zIG9mIEJhc2VUZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU0NBTEVfTU9ERVN9IFtzY2FsZU1vZGVdIC0gUGl4aSBzY2FsZW1vZGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuTUlQTUFQX01PREVTfSBbbWlwbWFwXSAtIGVuYWJsZSBtaXBtYXBzXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXG4gICAgICovXG4gICAgQnNldFN0eWxlKHNjYWxlTW9kZSwgbWlwbWFwKSB7XG4gICAgICAgIHZhciBkaXJ0eTtcbiAgICAgICAgaWYgKHNjYWxlTW9kZSAhPT0gdW5kZWZpbmVkICYmIHNjYWxlTW9kZSAhPT0gdGhpcy5zY2FsZU1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlO1xuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaXBtYXAgIT09IHVuZGVmaW5lZCAmJiBtaXBtYXAgIT09IHRoaXMubWlwbWFwKSB7XG4gICAgICAgICAgICB0aGlzLm1pcG1hcCA9IG1pcG1hcDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHcvaC9yZXNvbHV0aW9uLiBUZXh0dXJlIGJlY29tZXMgdmFsaWQgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZ3JlYXRlciB0aGFuIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVmlzdWFsIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBWaXN1YWwgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uXSBPcHRpb25hbGx5IHNldCByZXNvbHV0aW9uXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXG4gICAgICovXG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uID0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHRoaXMucmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgcmVhbCBzaXplIG9mIGJhc2VUZXh0dXJlLCBwcmVzZXJ2ZXMgY3VycmVudCByZXNvbHV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlYWxXaWR0aCBGdWxsIHJlbmRlcmVkIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlYWxIZWlnaHQgRnVsbCByZW5kZXJlZCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25dIE9wdGlvbmFsbHkgc2V0IHJlc29sdXRpb25cbiAgICAgKiBAcmV0dXJucyB7QmFzZVRleHR1cmV9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRSZWFsU2l6ZShyZWFsV2lkdGgsIHJlYWxIZWlnaHQsIHJlc29sdXRpb24gPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLndpZHRoID0gcmVhbFdpZHRoIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHJlYWxIZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZWZyZXNoIGNoZWNrIGZvciBpc1Bvd2VyT2ZUd28gdGV4dHVyZSBiYXNlZCBvbiBzaXplXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWZyZXNoUE9UKCkge1xuICAgICAgICB0aGlzLmlzUG93ZXJPZlR3byA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5pc1BvdzIodGhpcy5yZWFsV2lkdGgpICYmIE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5pc1BvdzIodGhpcy5yZWFsSGVpZ2h0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgcmVzb2x1dGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uXSByZXNcbiAgICAgKiBAcmV0dXJucyB7QmFzZVRleHR1cmV9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICAgICAgdmFyIG9sZFJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIGlmIChvbGRSZXNvbHV0aW9uID09PSByZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggKiBvbGRSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBvbGRSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlc291cmNlIGlmIGl0IHdhc24ndCBzZXQuIFRocm93cyBlcnJvciBpZiByZXNvdXJjZSBhbHJlYWR5IHByZXNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5yZXNvdXJjZXMuUmVzb3VyY2V9IHJlc291cmNlIC0gdGhhdCBpcyBtYW5hZ2luZyB0aGlzIEJhc2VUZXh0dXJlXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXG4gICAgICovXG4gICAgc2V0UmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNvdXJjZSBjYW4gYmUgc2V0IG9ubHkgb25jZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICAgICAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVhbFNpemUodGhpcy5yZXNvdXJjZS53aWR0aCwgdGhpcy5yZXNvdXJjZS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMuaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgICAgIHJlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJzZXRSZWFsU2l6ZVwiLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnNldFJlYWxTaXplKHRoaXMucmVzb3VyY2Uud2lkdGgsIHRoaXMucmVzb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHRoZSBvYmplY3QuIFRleHR1cmUgYmVjb21lcyB2YWxpZCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gemVyby5cbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPiAwICYmIHRoaXMuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwibG9hZGVkXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcInVwZGF0ZVwiKSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCdsb2FkZWQnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgICAgICAgICB0aGlzLmRpcnR5U3R5bGVJZCsrO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIikpO1xuICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBiYXNlIHRleHR1cmUuXG4gICAgICogVGhlIG1ldGhvZCBzdG9wcyBpZiByZXNvdXJjZSBkb2Vzbid0IHdhbnQgdGhpcyB0ZXh0dXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgKiBSZW1vdmVzIHRleHR1cmUgZnJvbSBhbGwgY2FjaGVzLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbmQgZGVzdHJveSB0aGUgcmVzb3VyY2VcbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2UudW5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgLy8gb25seSBkZXN0cm95IHJlc291cmNlZCBjcmVhdGVkIGludGVybmFsbHlcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc291cmNlLmludGVybmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYWNoZUlkKSB7XG4gICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVt0aGlzLmNhY2hlSWRdO1xuICAgICAgICAgICAgZGVsZXRlIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVt0aGlzLmNhY2hlSWRdO1xuICAgICAgICAgICAgdGhpcy5jYWNoZUlkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5hbGx5IGxldCB0aGUgV2ViR0wgcmVuZGVyZXIga25vdy4uXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICBCYXNlVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRnJlZXMgdGhlIHRleHR1cmUgZnJvbSBXZWJHTCBtZW1vcnkgd2l0aG91dCBkZXN0cm95aW5nIHRoaXMgdGV4dHVyZSBvYmplY3QuXG4gICAgICogVGhpcyBtZWFucyB5b3UgY2FuIHN0aWxsIHVzZSB0aGUgdGV4dHVyZSBsYXRlciB3aGljaCB3aWxsIHVwbG9hZCBpdCB0byBHUFVcbiAgICAgKiBtZW1vcnkgYWdhaW4uXG4gICAgICpcbiAgICAgKiBAZmlyZXMgUElYSS5CYXNlVGV4dHVyZSNkaXNwb3NlXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJkaXNwb3NlXCIpKTtcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdkaXNwb3NlJywgdGhpcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAgICogVGhlIHNvdXJjZSBjYW4gYmUgLSBpbWFnZSB1cmwsIGltYWdlIGVsZW1lbnQsIGNhbnZhcyBlbGVtZW50LiBJZiB0aGVcbiAgICAgKiBzb3VyY2UgaXMgYW4gaW1hZ2UgdXJsIG9yIGFuIGltYWdlIGVsZW1lbnQgYW5kIG5vdCBpbiB0aGUgYmFzZSB0ZXh0dXJlXG4gICAgICogY2FjaGUsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8U1ZHRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBzb3VyY2UgLSBUaGVcbiAgICAgKiAgICAgICAgc291cmNlIHRvIGNyZWF0ZSBiYXNlIHRleHR1cmUgZnJvbS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFNlZSB7QGxpbmsgUElYSS5CYXNlVGV4dHVyZX0ncyBjb25zdHJ1Y3RvciBmb3Igb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIG5ldyBiYXNlIHRleHR1cmUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjYWNoZUlkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYWNoZUlkID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX3BpeGlJZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5fcGl4aUlkID0gXCJwaXhpaWRfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlSWQgPSBzb3VyY2UuX3BpeGlJZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xuICAgICAgICBpZiAoIWJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYmFzZVRleHR1cmUuY2FjaGVJZCA9IGNhY2hlSWQ7XG4gICAgICAgICAgICBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKGJhc2VUZXh0dXJlLCBjYWNoZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRleHR1cmU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQmFzZVRleHR1cmUgd2l0aCBhIEJ1ZmZlclJlc291cmNlIGZyb20gYSBGbG9hdDMyQXJyYXkuXG4gICAgICogUkdCQSB2YWx1ZXMgYXJlIGZsb2F0cyBmcm9tIDAgdG8gMS5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8VWludDhBcnJheX0gYnVmZmVyIFRoZSBvcHRpb25hbCBhcnJheSB0byB1c2UsIGlmIG5vIGRhdGFcbiAgICAgKiAgICAgICAgaXMgcHJvdmlkZWQsIGEgbmV3IEZsb2F0MzJBcnJheSBpcyBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSByZXNvdXJjZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIHJlc3VsdGluZyBuZXcgQmFzZVRleHR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgdmFyIHJlc291cmNlID0gbmV3IEJ1ZmZlclJlc291cmNlXzEuQnVmZmVyUmVzb3VyY2UoYnVmZmVyLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgIHZhciB0eXBlID0gYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQgOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFO1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VUZXh0dXJlKHJlc291cmNlLCBPYmplY3QuYXNzaWduKFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmRlZmF1bHRCdWZmZXJPcHRpb25zLCBvcHRpb25zIHx8IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdHlwZTogdHlwZSB9KSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgQmFzZVRleHR1cmUgdG8gdGhlIGdsb2JhbCBCYXNlVGV4dHVyZUNhY2hlLiBUaGlzIGNhY2hlIGlzIHNoYXJlZCBhY3Jvc3MgdGhlIHdob2xlIFBJWEkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBUaGUgQmFzZVRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdGhhdCB0aGUgQmFzZVRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVG9DYWNoZShiYXNlVGV4dHVyZSwgaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBpZiAoYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKChcIkJhc2VUZXh0dXJlIGFkZGVkIHRvIHRoZSBjYWNoZSB3aXRoIGFuIGlkIFtcIiArIGlkICsgXCJdIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtpZF0gPSBiYXNlVGV4dHVyZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgQmFzZVRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIEJhc2VUZXh0dXJlQ2FjaGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBpZCBvZiBhIEJhc2VUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgQmFzZVRleHR1cmUgaW5zdGFuY2UgaXRzZWxmLlxuICAgICAqIEByZXR1cm4ge1BJWEkuQmFzZVRleHR1cmV8bnVsbH0gVGhlIEJhc2VUZXh0dXJlIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUZyb21DYWNoZShiYXNlVGV4dHVyZSkge1xuICAgICAgICBpZiAodHlwZW9mIGJhc2VUZXh0dXJlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlRnJvbUNhY2hlID0gQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZV07XG4gICAgICAgICAgICBpZiAoYmFzZVRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZihiYXNlVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVRleHR1cmVGcm9tQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmFzZVRleHR1cmUgJiYgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuLyoqXG4gKiBHbG9iYWwgbnVtYmVyIG9mIHRoZSB0ZXh0dXJlIGJhdGNoLCB1c2VkIGJ5IG11bHRpLXRleHR1cmUgcmVuZGVyZXJzXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlciB7bnVtYmVyfSBuZXcgdGV4dHVyZSBiYXRjaCBudW1iZXJcbiAqL1xuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gMDtcbmV4cG9ydHMuQmFzZVRleHR1cmUgPSBCYXNlVGV4dHVyZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQmF0Y2hCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgRmxvYXQzMkFycmF5IGZvciBwb3NpdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0aWNlcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWaWV3IG9uIHRoZSB2ZXJ0aWNlcyBhcyBhIFVpbnQzMkFycmF5IGZvciB1dnNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmVydGljZXMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbG9hdDMyVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMudWludDMyVmlldyA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmF0Y2hCdWZmZXIgPSBCYXRjaEJ1ZmZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQmF0Y2hEcmF3Q2FsbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZHMgPSBbXTtcbiAgICAgICAgdGhpcy5ibGVuZCA9IDA7XG4gICAgICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IDQ7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmF0Y2hEcmF3Q2FsbCA9IEJhdGNoRHJhd0NhbGw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcbmNvbnN0IEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNsYXNzIEJhdGNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeV8xLkdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcihfc3RhdGljID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciB1c2VkIGZvciBwb3NpdGlvbiwgY29sb3IsIHRleHR1cmUgSURzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKG51bGwsIF9zdGF0aWMsIGZhbHNlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IGJ1ZmZlciBkYXRhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIobnVsbCwgX3N0YXRpYywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCB0aGlzLl9idWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FUZXh0dXJlQ29vcmQnLCB0aGlzLl9idWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FDb2xvcicsIHRoaXMuX2J1ZmZlciwgNCwgdHJ1ZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSlcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FUZXh0dXJlSWQnLCB0aGlzLl9idWZmZXIsIDEsIHRydWUsIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLkZMT0FUKVxuICAgICAgICAgICAgLmFkZEluZGV4KHRoaXMuX2luZGV4QnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnRzLkJhdGNoR2VvbWV0cnkgPSBCYXRjaEdlb21ldHJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBPYmplY3RSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vT2JqZWN0UmVuZGVyZXJcIik7XG5jb25zdCBCYXRjaEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9CYXRjaEdlb21ldHJ5XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgQmF0Y2hEcmF3Q2FsbF8xID0gcmVxdWlyZShcIi4vQmF0Y2hEcmF3Q2FsbFwiKTtcbmNvbnN0IFN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVwiKTtcbmNvbnN0IEJhdGNoQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CYXRjaEJ1ZmZlclwiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY2xhc3MgQmF0Y2hSZW5kZXJlciBleHRlbmRzIE9iamVjdFJlbmRlcmVyXzEuT2JqZWN0UmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBiZWZvcmUgdGhlIHJlbmRlcmVyIHN0YXJ0cyByZW5kZXJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uUHJlcmVuZGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiB2YWx1ZXMgc2VudCBpbiB0aGUgdmVydGV4IGJ1ZmZlci5cbiAgICAgICAgICogYVZlcnRleFBvc2l0aW9uKDIpLCBhVGV4dHVyZUNvb3JkKDEpLCBhQ29sb3IoMSksIGFUZXh0dXJlSWQoMSkgPSA1XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVydFNpemUgPSA2O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgb2YgdGhlIHZlcnRleCBpbmZvcm1hdGlvbiBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0Qnl0ZVNpemUgPSB0aGlzLnZlcnRTaXplICogNDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIGluIHRoZSBTcHJpdGVSZW5kZXJlciBiZWZvcmUgaXQgZmx1c2hlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gMjAwMCAqIDQ7IC8vIHNldHRpbmdzLlNQUklURV9CQVRDSF9TSVpFOyAvLyAyMDAwIGlzIGEgbmljZSBiYWxhbmNlIGJldHdlZW4gbW9iaWxlIC8gZGVza3RvcFxuICAgICAgICB0aGlzLmN1cnJlbnRTaXplID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXhTaXplID0gMDtcbiAgICAgICAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBpbiBvdXIgYmF0Y2hcbiAgICAgICAgLy8gbGV0IG51bVZlcnRzID0gdGhpcy5zaXplICogNCAqIHRoaXMudmVydEJ5dGVTaXplO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5hQnVmZmVycyA9IHt9O1xuICAgICAgICB0aGlzLmlCdWZmZXJzID0ge307XG4gICAgICAgIC8vICAgICB0aGlzLmRlZnVhbHRTcHJpdGVJbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHRoaXMuc2l6ZSksIHRydWUsIHRydWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgdGhlIGRlZnVhbHQgaW5kaWNlcyBvZiB0aGUgZ2VvbWV0cnkgKHF1YWRzKSB0byBkcmF3XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gY29uc3QgaW5kaWNpZXMgPSBjcmVhdGVJbmRpY2VzRm9yUXVhZHModGhpcy5zaXplKTtcbiAgICAgICAgLy8gIHRoaXMuZGVmYXVsdFF1YWRJbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoaW5kaWNpZXMsIHRydWUsIHRydWUpO1xuICAgICAgICB0aGlzLm9ubHlTcHJpdGVzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzaGFkZXJzIHRoYXQgaXMgdXNlZCBpZiBhIHNwcml0ZSBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cbiAgICAgICAgICogdGhlcmUgaXMgYSBzaGFkZXIgZm9yIGVhY2ggbnVtYmVyIG9mIHRleHR1cmVzIHRoYXQgY2FuIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKiBUaGVzZSBzaGFkZXJzIHdpbGwgYWxzbyBiZSBnZW5lcmF0ZWQgb24gdGhlIGZseSBhcyByZXF1aXJlZC5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuc2l6ZSAvIDQ7IGsrKykge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNba10gPSBuZXcgQmF0Y2hEcmF3Q2FsbF8xLkJhdGNoRHJhd0NhbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMudmFvcyA9IFtdO1xuICAgICAgICB0aGlzLnZhb01heCA9IDI7XG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwcmVyZW5kZXJcIiwgdGhpcy5vblByZXJlbmRlcik7XG4gICAgICAgIC8vIHRoaXMucmVuZGVyZXIub24oJ3ByZXJlbmRlcicsIHRoaXMub25QcmVyZW5kZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGVfMS5TdGF0ZS5mb3IyZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPT09IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0xfTEVHQUNZKSB7XG4gICAgICAgICAgICB0aGlzLk1BWF9URVhUVVJFUyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzdGVwIDE6IGZpcnN0IGNoZWNrIG1heCB0ZXh0dXJlcyB0aGUgR1BVIGNhbiBoYW5kbGUuXG4gICAgICAgICAgICB0aGlzLk1BWF9URVhUVVJFUyA9IE1hdGgubWluKGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlNQUklURV9NQVhfVEVYVFVSRVMpO1xuICAgICAgICAgICAgLy8gc3RlcCAyOiBjaGVjayB0aGUgbWF4aW11bSBudW1iZXIgb2YgaWYgc3RhdGVtZW50cyB0aGUgc2hhZGVyIGNhbiBoYXZlIHRvby4uXG4gICAgICAgICAgICB0aGlzLk1BWF9URVhUVVJFUyA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIodGhpcy5NQVhfVEVYVFVSRVMsIGdsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZW5lcmF0ZSBnZW5lcmF0ZU11bHRpVGV4dHVyZVByb2dyYW0sIG1heSBiZSBhIGJldHRlciBtb3ZlP1xuICAgICAgICB0aGlzLnNoYWRlciA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmdlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyKGdsLCB0aGlzLk1BWF9URVhUVVJFUyk7XG4gICAgICAgIC8vIHdlIHVzZSB0aGUgc2Vjb25kIHNoYWRlciBhcyB0aGUgZmlyc3Qgb25lIGRlcGVuZGluZyBvbiB5b3VyIGJyb3dzZXIgbWF5IG9taXQgYVRleHR1cmVJZFxuICAgICAgICAvLyBhcyBpdCBpcyBub3QgdXNlZCBieSB0aGUgc2hhZGVyIHNvIGlzIG9wdGltaXplZCBvdXQuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YW9NYXg7IGkrKykge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAgICAgdGhpcy52YW9zW2ldID0gbmV3IEJhdGNoR2VvbWV0cnlfMS5CYXRjaEdlb21ldHJ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHNwcml0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSB0aGUgc3ByaXRlIHRvIHJlbmRlciB3aGVuIHVzaW5nIHRoaXMgc3ByaXRlYmF0Y2hcbiAgICAgKi9cbiAgICByZW5kZXIoZWxlbWVudCkge1xuICAgICAgICAvLyB0cmFjZShcInJlbmRlcmluZyBlbGVtZW50OiBcIiArIGVsZW1lbnQuX3RleHR1cmUudmFsaWQpXG4gICAgICAgIGlmICghZWxlbWVudC5fdGV4dHVyZS52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTaXplICsgKGVsZW1lbnQudmVydGV4RGF0YS5sZW5ndGggLyAyKSA+IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudHNbdGhpcy5jdXJyZW50SW5kZXgrK10gPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmN1cnJlbnRTaXplICs9IGVsZW1lbnQudmVydGV4RGF0YS5sZW5ndGggLyAyO1xuICAgICAgICAvLyB0cmFjZShcImN1cnJlbnRTaXplOiBcIiArIHRoaXMuY3VycmVudFNpemUpXG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4U2l6ZSArPSBlbGVtZW50LmluZGljZXMubGVuZ3RoO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0SW5kZXhCdWZmZXIoc2l6ZSkge1xuICAgICAgICAvLyAxMiBpbmRpY2VzIGlzIGVub3VnaCBmb3IgMiBxdWFkc1xuICAgICAgICB2YXIgcm91bmRlZFAyID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLm5leHRQb3cyKE1hdGguY2VpbChzaXplIC8gMTIpKTtcbiAgICAgICAgdmFyIHJvdW5kZWRTaXplSW5kZXggPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MubG9nMihyb3VuZGVkUDIpO1xuICAgICAgICB2YXIgcm91bmRlZFNpemUgPSByb3VuZGVkUDIgKiAxMjtcbiAgICAgICAgaWYgKHRoaXMuaUJ1ZmZlcnMubGVuZ3RoIDw9IHJvdW5kZWRTaXplSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuaUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuaUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF07XG4gICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlCdWZmZXJzW3JvdW5kZWRTaXplSW5kZXhdID0gYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KHJvdW5kZWRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0QXR0cmlidXRlQnVmZmVyKHNpemUpIHtcbiAgICAgICAgLy8gOCB2ZXJ0aWNlcyBpcyBlbm91Z2ggZm9yIDIgcXVhZHNcbiAgICAgICAgdmFyIHJvdW5kZWRQMiA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5uZXh0UG93MihNYXRoLmNlaWwoc2l6ZSAvIDgpKTtcbiAgICAgICAgdmFyIHJvdW5kZWRTaXplSW5kZXggPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MubG9nMihyb3VuZGVkUDIpO1xuICAgICAgICB2YXIgcm91bmRlZFNpemUgPSByb3VuZGVkUDIgKiA4O1xuICAgICAgICBpZiAodGhpcy5hQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5pQnVmZmVycy5sZW5ndGggPSByb3VuZGVkU2l6ZUluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5hQnVmZmVyc1tyb3VuZGVkU2l6ZV07XG4gICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLmFCdWZmZXJzW3JvdW5kZWRTaXplXSA9IGJ1ZmZlciA9IG5ldyBCYXRjaEJ1ZmZlcl8xLkJhdGNoQnVmZmVyKHJvdW5kZWRTaXplICogdGhpcy52ZXJ0Qnl0ZVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjb250ZW50IGFuZCBlbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgICAqXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIC8vIHRyYWNlKFwiQmF0Y2hSZW5kZXIgZmx1c2ggXCIgKyB0aGlzLmN1cnJlbnRTaXplKVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciBNQVhfVEVYVFVSRVMgPSB0aGlzLk1BWF9URVhUVVJFUztcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyKHRoaXMuY3VycmVudFNpemUpO1xuICAgICAgICAvLyByZXZlYWwoYnVmZmVyKTtcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleEJ1ZmZlcih0aGlzLmN1cnJlbnRJbmRleFNpemUpO1xuICAgICAgICAvLyByZXZlYWwoaW5kZXhCdWZmZXIpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIHZhciBmbG9hdDMyVmlldyA9IGJ1ZmZlci5mbG9hdDMyVmlldztcbiAgICAgICAgLy8gcmV2ZWFsKGZsb2F0MzJWaWV3KTtcbiAgICAgICAgdmFyIHVpbnQzMlZpZXcgPSBidWZmZXIudWludDMyVmlldztcbiAgICAgICAgLy8gcmV2ZWFsKHVpbnQzMlZpZXcpO1xuICAgICAgICB2YXIgdG91Y2ggPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVHQy5jb3VudDtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGluZGV4Q291bnQgPSAwO1xuICAgICAgICB2YXIgbmV4dFRleHR1cmU7XG4gICAgICAgIHZhciBjdXJyZW50VGV4dHVyZTtcbiAgICAgICAgdmFyIGdyb3VwQ291bnQgPSAwO1xuICAgICAgICB2YXIgdGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IGdyb3Vwc1swXTtcbiAgICAgICAgLy8gcmV2ZWFsKGN1cnJlbnRHcm91cCk7XG4gICAgICAgIHZhciBibGVuZE1vZGUgPSAtMTsgLy8gcHJlbXVsdGlwbHlCbGVuZE1vZGVbZWxlbWVudHNbMF0uX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IDAgOiBdW2VsZW1lbnRzWzBdLmJsZW5kTW9kZV07XG4gICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQgPSAwO1xuICAgICAgICBjdXJyZW50R3JvdXAuc3RhcnQgPSAwO1xuICAgICAgICBjdXJyZW50R3JvdXAuYmxlbmQgPSBibGVuZE1vZGU7XG4gICAgICAgIHZhciBUSUNLID0gKytCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmN1cnJlbnRJbmRleDsgKytpKSB7XG4gICAgICAgICAgICAvLyB1cGxvYWQgdGhlIHNwcml0ZSBlbGVtZW50cy4uLlxuICAgICAgICAgICAgLy8gdGhleSBoYXZlIGFsbCByZWFkeSBiZWVuIGNhbGN1bGF0ZWQgc28gd2UganVzdCBuZWVkIHRvIHB1c2ggdGhlbSBpbnRvIHRoZSBidWZmZXIuXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBlbGVtZW50c1tpXSA9IG51bGw7XG4gICAgICAgICAgICBuZXh0VGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgICAgIC8vIHJldmVhbChuZXh0VGV4dHVyZSk7XG4gICAgICAgICAgICB2YXIgc3ByaXRlQmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLnByZW11bHRpcGx5QmxlbmRNb2RlW25leHRUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPyAxIDogMF1bc3ByaXRlLmJsZW5kTW9kZV07XG4gICAgICAgICAgICBpZiAoYmxlbmRNb2RlICE9PSBzcHJpdGVCbGVuZE1vZGUpIHtcbiAgICAgICAgICAgICAgICBibGVuZE1vZGUgPSBzcHJpdGVCbGVuZE1vZGU7XG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdGhlIGJhdGNoIHRvIGJyZWFrIVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSBNQVhfVEVYVFVSRVM7XG4gICAgICAgICAgICAgICAgVElDSysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbmV4dFRleHR1cmU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRUZXh0dXJlLl9iYXRjaEVuYWJsZWQgIT09IFRJQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmVDb3VudCA9PT0gTUFYX1RFWFRVUkVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBUSUNLKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSBpbmRleENvdW50IC0gY3VycmVudEdyb3VwLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwID0gZ3JvdXBzW2dyb3VwQ291bnQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5ibGVuZCA9IGJsZW5kTW9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IGluZGV4Q291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUudG91Y2hlZCA9IHRvdWNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkID0gVElDSztcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUuX2lkID0gdGV4dHVyZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZXNbY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCsrXSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXZlYWwoY3VycmVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV2ZWFsKG5leHRUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWNrR2VvbWV0cnkoc3ByaXRlLCBmbG9hdDMyVmlldywgdWludDMyVmlldywgaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRleENvdW50KTsgLy8gYXJnYiwgbmV4dFRleHR1cmUuX2lkLCBmbG9hdDMyVmlldywgdWludDMyVmlldywgaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRleENvdW50KTtcbiAgICAgICAgICAgIC8vIEhFUkUgXG4gICAgICAgICAgICAvLyBwdXNoIGEgZ3JhcGhpY3MuLlxuICAgICAgICAgICAgaW5kZXggKz0gKHNwcml0ZS52ZXJ0ZXhEYXRhLmxlbmd0aCAvIDIpICogdGhpcy52ZXJ0U2l6ZTtcbiAgICAgICAgICAgIGluZGV4Q291bnQgKz0gc3ByaXRlLmluZGljZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gVElDSztcbiAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSBpbmRleENvdW50IC0gY3VycmVudEdyb3VwLnN0YXJ0O1xuICAgICAgICAvLyAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICAgICAgaWYgKCFXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5DQU5fVVBMT0FEX1NBTUVfQlVGRkVSKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHN0aWxsIG5lZWRlZCBmb3IgSU9TIHBlcmZvcm1hbmNlLi5cbiAgICAgICAgICAgIC8vIGl0IHJlYWxseSBkb2VzIG5vdCBsaWtlIHVwbG9hZGluZyB0byB0aGUgc2FtZSBidWZmZXIgaW4gYSBzaW5nbGUgZnJhbWUhXG4gICAgICAgICAgICBpZiAodGhpcy52YW9NYXggPD0gdGhpcy52ZXJ0ZXhDb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFvTWF4Kys7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAgICAgICAgIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XSA9IG5ldyBCYXRjaEdlb21ldHJ5XzEuQmF0Y2hHZW9tZXRyeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdLl9idWZmZXIudXBkYXRlKGJ1ZmZlci52ZXJ0aWNlcywgMCk7XG4gICAgICAgICAgICB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0uX2luZGV4QnVmZmVyLnVwZGF0ZShpbmRleEJ1ZmZlciwgMCk7XG4gICAgICAgICAgICAvLyAgIHRoaXMudmVydGV4QnVmZmVyc1t0aGlzLnZlcnRleENvdW50XS51cGRhdGUoYnVmZmVyLnZlcnRpY2VzLCAwKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5nZW9tZXRyeS51cGRhdGVCdWZmZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnZlcnRleENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBsZXRzIHVzZSB0aGUgZmFzdGVyIG9wdGlvbiwgYWx3YXlzIHVzZSBidWZmZXIgbnVtYmVyIDBcbiAgICAgICAgICAgIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5fYnVmZmVyLnVwZGF0ZShidWZmZXIudmVydGljZXMsIDApO1xuICAgICAgICAgICAgdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdLl9pbmRleEJ1ZmZlci51cGRhdGUoaW5kZXhCdWZmZXIsIDApO1xuICAgICAgICAgICAgLy8gICBpZiAodHJ1ZSkvLyB0aGlzLnNwcml0ZU9ubHkpXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0uaW5kZXhCdWZmZXIgPSB0aGlzLmRlZnVhbHRTcHJpdGVJbmRleEJ1ZmZlcjtcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5idWZmZXJzWzFdID0gdGhpcy5kZWZ1YWx0U3ByaXRlSW5kZXhCdWZmZXI7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbMF0uYXR0cmlidXRlcy5hQ29sb3Iuc3RyaWRlID0gMjRcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1swXS5hdHRyaWJ1dGVzLmFDb2xvci5zdGFydCA9IDE2XG4gICAgICAgICAgICAvLyBOT1QgU0VUXG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbMF0uYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLnN0cmlkZSA9IDI0XG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbMF0uYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLnN0YXJ0ID0gOFxuICAgICAgICAgICAgLy8gTk9UIFNFVFxuICAgICAgICAgICAgLy8gdGhpcy52YW9zWzBdLmF0dHJpYnV0ZXMuYVZlcnRleFBvc2l0aW9uLnN0cmlkZSA9IDI0XG4gICAgICAgICAgICAvLyBOT1QgU0VUXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKTtcbiAgICAgICAgICAgIC8vICAgIFxuICAgICAgICB9XG4gICAgICAgIC8vICAgdGhpcy5yZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIHZhciB0ZXh0dXJlU3lzdGVtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlO1xuICAgICAgICB2YXIgc3RhdGVTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLnN0YXRlO1xuICAgICAgICAvLyBlLmxvZyhncm91cENvdW50KTtcbiAgICAgICAgLy8gLyByZW5kZXIgdGhlIGdyb3Vwcy4uXG4gICAgICAgIC8vICAgIHRyYWNlKFwiZ3JvdXBjb3VudDogXCIgKyBncm91cENvdW50KVxuICAgICAgICAvLyB0cmFjZShcIkJhdGNoUmVuZGVyZXIgY291bnQ6IFwiICsgZ3JvdXBDb3VudClcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICAgICAgdmFyIGdyb3VwVGV4dHVyZUNvdW50ID0gZ3JvdXAudGV4dHVyZUNvdW50O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cFRleHR1cmVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhY2UoXCJwb3NzaWJsZSB0ZXh0dXJlU3lzdGVtIGJpbmQgY2FsbCAoQmF0aFJlbmRlcmVyKVwiKVxuICAgICAgICAgICAgICAgIC8vIHRyYWNlKFwiYmluZGluZzogXCIgKyBncm91cC50ZXh0dXJlc1tqXSArIFwiIHRvIFwiICsgailcbiAgICAgICAgICAgICAgICB0ZXh0dXJlU3lzdGVtLmJpbmQoZ3JvdXAudGV4dHVyZXNbal0sIGopO1xuICAgICAgICAgICAgICAgIGdyb3VwLnRleHR1cmVzW2pdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gZ3JvdXAuYmxlbmQ7XG4gICAgICAgICAgICAvLyB0aGlzLnN0YXRlLmJsZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIuc3RhdGUuc2V0U3RhdGUodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGJsZW5kIG1vZGUuLlxuICAgICAgICAgICAgc3RhdGVTeXN0ZW0uc2V0QmxlbmRNb2RlKGdyb3VwLmJsZW5kKTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhncm91cC50eXBlLCBncm91cC5zaXplLCBnbC5VTlNJR05FRF9TSE9SVCwgZ3JvdXAuc3RhcnQgKiAyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCBlbGVtZW50cyBmb3IgdGhlIG5leHQgZmx1c2hcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRTaXplID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXhTaXplID0gMDtcbiAgICB9XG4gICAgO1xuICAgIHBhY2tHZW9tZXRyeShlbGVtZW50LCBmbG9hdDMyVmlldywgdWludDMyVmlldywgaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRleENvdW50KSB7XG4gICAgICAgIHZhciBwID0gaW5kZXggLyB0aGlzLnZlcnRTaXplOyAvLyBmbG9hdDMyVmlldy5sZW5ndGggLyA2IC8gMjtcbiAgICAgICAgdmFyIHV2cyA9IGVsZW1lbnQudXZzO1xuICAgICAgICB2YXIgaW5kaWNpZXMgPSBlbGVtZW50LmluZGljZXM7IC8vIGdlb21ldHJ5LmdldEluZGV4KCkuZGF0YTsvLyBpbmRpY2llcztcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSBlbGVtZW50LnZlcnRleERhdGE7XG4gICAgICAgIHZhciB0ZXh0dXJlSWQgPSBlbGVtZW50Ll90ZXh0dXJlLmJhc2VUZXh0dXJlLl9pZDtcbiAgICAgICAgdmFyIGFscGhhID0gTWF0aC5taW4oZWxlbWVudC53b3JsZEFscGhhLCAxLjApO1xuICAgICAgICB2YXIgYXJnYiA9IGFscGhhIDwgMS4wICYmIGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludChlbGVtZW50Ll90aW50UkdCLCBhbHBoYSlcbiAgICAgICAgICAgIDogZWxlbWVudC5fdGludFJHQiArIChhbHBoYSAqIDI1NSA8PCAyNCk7XG4gICAgICAgIC8vIGxldHMgbm90IHdvcnJ5IGFib3V0IHRpbnQhIGZvciBub3cuLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4KytdID0gdmVydGV4RGF0YVtpXTtcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4KytdID0gdmVydGV4RGF0YVtpICsgMV07XG4gICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCsrXSA9IHV2c1tpXTtcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4KytdID0gdXZzW2kgKyAxXTtcbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXgrK10gPSBhcmdiO1xuICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXgrK10gPSB0ZXh0dXJlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaW5kaWNpZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhDb3VudCsrXSA9IHAgKyBpbmRpY2llc1tpJDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgc3ByaXRlIGJhdGNoLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnN0YXRlLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuc2hhZGVyKTtcbiAgICAgICAgaWYgKFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLkNBTl9VUExPQURfU0FNRV9CVUZGRVIpIHtcbiAgICAgICAgICAgIC8vIGJpbmQgYnVmZmVyICMwLCB3ZSBkb24ndCBuZWVkIG90aGVyc1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuZCBmbHVzaGVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgICAqXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIFNwcml0ZVJlbmRlcmVyLlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhb01heDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBpZiAodGhpcy52ZXJ0ZXhCdWZmZXJzW2ldKVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMudmVydGV4QnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAodGhpcy52YW9zW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YW9zW2ldLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlcmVuZGVyJywgdGhpcy5vblByZXJlbmRlcik7XG4gICAgICAgIGlmICh0aGlzLnNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zaGFkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMudmVydGV4QnVmZmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNwcml0ZXMgPSBudWxsO1xuICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7ICsraSlcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdGhpcy5idWZmZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmF0Y2hSZW5kZXJlciA9IEJhdGNoUmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xuY29uc3QgT2JqZWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL09iamVjdFJlbmRlcmVyXCIpO1xuY2xhc3MgQmF0Y2hTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVtcHR5IHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9iamVjdFJlbmRlcmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbXB0eVJlbmRlcmVyID0gbmV3IE9iamVjdFJlbmRlcmVyXzEuT2JqZWN0UmVuZGVyZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgT2JqZWN0UmVuZGVyZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JqZWN0UmVuZGVyZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IHRoaXMuZW1wdHlSZW5kZXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCByZW5kZXJlciB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk9iamVjdFJlbmRlcmVyfSBvYmplY3RSZW5kZXJlciAtIFRoZSBvYmplY3QgcmVuZGVyZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHNldE9iamVjdFJlbmRlcmVyKG9iamVjdFJlbmRlcmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciA9PT0gb2JqZWN0UmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gb2JqZWN0UmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaWYgeW91IHdpc2ggdG8gZG8gc29tZSBjdXN0b20gcmVuZGVyaW5nXG4gICAgICogSXQgd2lsbCBiYXNpY2FsbHkgcmVuZGVyIGFueXRoaW5nIHRoYXQgbWF5IGJlIGJhdGNoZWQgdXAgc3VjaCBhcyBzcHJpdGVzXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIHRoaXMuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5lbXB0eVJlbmRlcmVyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBzeXN0ZW0gdG8gYW4gZW1wdHkgcmVuZGVyZXJcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zZXRPYmplY3RSZW5kZXJlcih0aGlzLmVtcHR5UmVuZGVyZXIpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkJhdGNoU3lzdGVtID0gQmF0Y2hTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcbmNsYXNzIEJlemllclV0aWxzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG4gICAgc3RhdGljIGN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XG4gICAgICAgIHZhciBuID0gMTA7XG4gICAgICAgIHZhciByZXN1bHQgPSAwLjA7XG4gICAgICAgIHZhciB0ID0gMC4wO1xuICAgICAgICB2YXIgdDIgPSAwLjA7XG4gICAgICAgIHZhciB0MyA9IDAuMDtcbiAgICAgICAgdmFyIG50ID0gMC4wO1xuICAgICAgICB2YXIgbnQyID0gMC4wO1xuICAgICAgICB2YXIgbnQzID0gMC4wO1xuICAgICAgICB2YXIgeCA9IDAuMDtcbiAgICAgICAgdmFyIHkgPSAwLjA7XG4gICAgICAgIHZhciBkeCA9IDAuMDtcbiAgICAgICAgdmFyIGR5ID0gMC4wO1xuICAgICAgICB2YXIgcHJldlggPSBmcm9tWDtcbiAgICAgICAgdmFyIHByZXZZID0gZnJvbVk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSkge1xuICAgICAgICAgICAgdCA9IGkgLyBuO1xuICAgICAgICAgICAgdDIgPSB0ICogdDtcbiAgICAgICAgICAgIHQzID0gdDIgKiB0O1xuICAgICAgICAgICAgbnQgPSAoMS4wIC0gdCk7XG4gICAgICAgICAgICBudDIgPSBudCAqIG50O1xuICAgICAgICAgICAgbnQzID0gbnQyICogbnQ7XG4gICAgICAgICAgICB4ID0gKG50MyAqIGZyb21YKSArICgzLjAgKiBudDIgKiB0ICogY3BYKSArICgzLjAgKiBudCAqIHQyICogY3BYMikgKyAodDMgKiB0b1gpO1xuICAgICAgICAgICAgeSA9IChudDMgKiBmcm9tWSkgKyAoMy4wICogbnQyICogdCAqIGNwWSkgKyAoMyAqIG50ICogdDIgKiBjcFkyKSArICh0MyAqIHRvWSk7XG4gICAgICAgICAgICBkeCA9IHByZXZYIC0geDtcbiAgICAgICAgICAgIGR5ID0gcHJldlkgLSB5O1xuICAgICAgICAgICAgcHJldlggPSB4O1xuICAgICAgICAgICAgcHJldlkgPSB5O1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGguc3FydCgoZHggKiBkeCkgKyAoZHkgKiBkeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAgICpcbiAgICAgKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBQYXRoIGFycmF5IHRvIHB1c2ggcG9pbnRzIGludG9cbiAgICAgKi9cbiAgICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHBvaW50cykge1xuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBwb2ludHMubGVuZ3RoIC09IDI7XG4gICAgICAgIHZhciBuID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HUkFQSElDU19DVVJWRVMuX3NlZ21lbnRzQ291bnQoQmV6aWVyVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpKTtcbiAgICAgICAgdmFyIGR0ID0gMDtcbiAgICAgICAgdmFyIGR0MiA9IDA7XG4gICAgICAgIHZhciBkdDMgPSAwO1xuICAgICAgICB2YXIgdDIgPSAwO1xuICAgICAgICB2YXIgdDMgPSAwO1xuICAgICAgICBwb2ludHMucHVzaChmcm9tWCwgZnJvbVkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgaiA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgICAgICBqID0gaSAvIG47XG4gICAgICAgICAgICBkdCA9ICgxIC0gaik7XG4gICAgICAgICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgICAgICAgZHQzID0gZHQyICogZHQ7XG4gICAgICAgICAgICB0MiA9IGogKiBqO1xuICAgICAgICAgICAgdDMgPSB0MiAqIGo7XG4gICAgICAgICAgICBwb2ludHMucHVzaCgoZHQzICogZnJvbVgpICsgKDMgKiBkdDIgKiBqICogY3BYKSArICgzICogZHQgKiB0MiAqIGNwWDIpICsgKHQzICogdG9YKSwgKGR0MyAqIGZyb21ZKSArICgzICogZHQyICogaiAqIGNwWSkgKyAoMyAqIGR0ICogdDIgKiBjcFkyKSArICh0MyAqIHRvWSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmV6aWVyVXRpbHMgPSBCZXppZXJVdGlscztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBPYnNlcnZhYmxlUG9pbnRfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVQb2ludFwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4vU3ByaXRlXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xuY29uc3QgRmxhc2hCYXNlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9GbGFzaEJhc2VPYmplY3RcIik7XG5jb25zdCBGb250TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vRm9udE1hbmFnZXJcIik7XG5jbGFzcyBCaXRtYXBUZXh0IGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFzRm9udCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJpdG1hcGZvbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZXh0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fZ2x5cGhzID0gW107XG4gICAgICAgIHRoaXMuX2ZvbnQgPSBuZXcgQml0bWFwRm9udFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5fZm9udC5hbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICB0aGlzLl9mb250LnNpemUgPSAxNjtcbiAgICAgICAgdGhpcy5fZm9udC50aW50ID0gMHhGRkZGRkY7XG4gICAgICAgIHRoaXMuZm9udCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLl9tYXhXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX21heExpbmVIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gMDtcbiAgICAgICAgdGhpcy5fYW5jaG9yID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludChmdW5jdGlvbiAoKSB7IHRoaXMuZGlydHkgPSB0cnVlOyB9LCB0aGlzLCAwLCAwKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdW5kUGl4ZWxzID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJPVU5EX1BJWEVMUztcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgfVxuICAgIGdldCBmb250KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udC5uYW1lO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZvbnQodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSB0aGlzLl9mb250Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb250Lm5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJpdG1hcGZvbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYml0bWFwZm9udCA9IEZvbnRNYW5hZ2VyXzEuRm9udE1hbmFnZXIuZ2V0Qml0bWFwRm9udCh0aGlzLl9mb250Lm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJpdG1hcGZvbnQgJiYgIXRoaXMuaGFzRm9udCkge1xuICAgICAgICAgICAgdGhpcy5oYXNGb250ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIHVwZGF0ZVRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5iaXRtYXBmb250KSB7XG4gICAgICAgICAgICB0aGlzLmJpdG1hcGZvbnQgPSBGb250TWFuYWdlcl8xLkZvbnRNYW5hZ2VyLmdldEJpdG1hcEZvbnQodGhpcy5fZm9udC5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NhbGUgPSB0aGlzLl9mb250LmZvbnRTaXplIC8gdGhpcy5iaXRtYXBmb250LnNpemU7XG4gICAgICAgIGlmIChzY2FsZSA8PSAwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvcyA9IG5ldyBQb2ludF8xLlBvaW50KCk7XG4gICAgICAgIGxldCBjaGFycyA9IFtdO1xuICAgICAgICBsZXQgbGluZVdpZHRocyA9IFtdO1xuICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX3RleHQucmVwbGFjZSgvKD86XFxyXFxufFxccikvZywgJ1xcbicpIHx8ICcgJztcbiAgICAgICAgbGV0IHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IG1heFdpZHRoID0gdGhpcy5fbWF4V2lkdGggKiB0aGlzLmJpdG1hcGZvbnQuc2l6ZSAvIHRoaXMuX2ZvbnQuc2l6ZTtcbiAgICAgICAgbGV0IHByZXZDaGFyQ29kZSA9IG51bGw7XG4gICAgICAgIGxldCBsYXN0TGluZVdpZHRoID0gMDtcbiAgICAgICAgbGV0IG1heExpbmVXaWR0aCA9IDA7XG4gICAgICAgIGxldCBsaW5lID0gMDtcbiAgICAgICAgbGV0IGxhc3RCcmVha1BvcyA9IC0xO1xuICAgICAgICBsZXQgbGFzdEJyZWFrV2lkdGggPSAwO1xuICAgICAgICBsZXQgc3BhY2VzUmVtb3ZlZCA9IDA7XG4gICAgICAgIGxldCBtYXhMaW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGxldCBjaGFyID0gdGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoKC8oPzpcXHMpLykudGVzdChjaGFyKSkge1xuICAgICAgICAgICAgICAgIGxhc3RCcmVha1BvcyA9IGk7XG4gICAgICAgICAgICAgICAgbGFzdEJyZWFrV2lkdGggPSBsYXN0TGluZVdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICdcXHInIHx8IGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdExpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgKytsaW5lO1xuICAgICAgICAgICAgICAgICsrc3BhY2VzUmVtb3ZlZDtcbiAgICAgICAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgICAgICAgcG9zLnkgKz0gdGhpcy5iaXRtYXBmb250LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGFyRGF0YSA9IHRoaXMuYml0bWFwZm9udC5jaGFyc1tjaGFyQ29kZV07XG4gICAgICAgICAgICBpZiAoIWNoYXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkNoYXJDb2RlICYmIGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXSkge1xuICAgICAgICAgICAgICAgIHBvcy54ICs9IGNoYXJEYXRhLmtlcm5pbmdbcHJldkNoYXJDb2RlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBnbGlwdGhkYXRhID0gbmV3IERhdGFHbGlwdGgoKTtcbiAgICAgICAgICAgIGdsaXB0aGRhdGEudGV4dHVyZSA9IGNoYXJEYXRhLnRleHR1cmU7XG4gICAgICAgICAgICBnbGlwdGhkYXRhLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgZ2xpcHRoZGF0YS5jaGFyQ29kZSA9IGNoYXJDb2RlO1xuICAgICAgICAgICAgZ2xpcHRoZGF0YS5wb3NpdGlvbiA9IG5ldyBQb2ludF8xLlBvaW50KHBvcy54ICsgY2hhckRhdGEueE9mZnNldCArICh0aGlzLl9sZXR0ZXJTcGFjaW5nIC8gMiksIHBvcy55ICsgY2hhckRhdGEueU9mZnNldCk7XG4gICAgICAgICAgICBjaGFycy5wdXNoKGdsaXB0aGRhdGEpO1xuICAgICAgICAgICAgcG9zLnggKz0gY2hhckRhdGEueEFkdmFuY2UgKyB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICAgICAgICAgICAgbGFzdExpbmVXaWR0aCA9IHBvcy54O1xuICAgICAgICAgICAgbWF4TGluZUhlaWdodCA9IE1hdGgubWF4KG1heExpbmVIZWlnaHQsIChjaGFyRGF0YS55T2Zmc2V0ICsgY2hhckRhdGEudGV4dHVyZS5oZWlnaHQpKTtcbiAgICAgICAgICAgIHByZXZDaGFyQ29kZSA9IGNoYXJDb2RlO1xuICAgICAgICAgICAgaWYgKGxhc3RCcmVha1BvcyAhPT0gLTEgJiYgbWF4V2lkdGggPiAwICYmIHBvcy54ID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICArK3NwYWNlc1JlbW92ZWQ7XG4gICAgICAgICAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXMoY2hhcnMsIDEgKyBsYXN0QnJlYWtQb3MgLSBzcGFjZXNSZW1vdmVkLCAxICsgaSAtIGxhc3RCcmVha1Bvcyk7XG4gICAgICAgICAgICAgICAgaSA9IGxhc3RCcmVha1BvcztcbiAgICAgICAgICAgICAgICBsYXN0QnJlYWtQb3MgPSAtMTtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdEJyZWFrV2lkdGgpO1xuICAgICAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdEJyZWFrV2lkdGgpO1xuICAgICAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgICAgICAgcG9zLnkgKz0gdGhpcy5iaXRtYXBmb250LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdENoYXIgPSB0ZXh0LmNoYXJBdCh0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAobGFzdENoYXIgIT09ICdcXHInICYmIGxhc3RDaGFyICE9PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKCgvKD86XFxzKS8pLnRlc3QobGFzdENoYXIpKSB7XG4gICAgICAgICAgICAgICAgbGFzdExpbmVXaWR0aCA9IGxhc3RCcmVha1dpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKGxhc3RMaW5lV2lkdGgpO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0TGluZVdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZUFsaWduT2Zmc2V0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpJDEgPSAwOyBpJDEgPD0gbGluZTsgaSQxKyspIHtcbiAgICAgICAgICAgIGxldCBhbGlnbk9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fZm9udC5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGFsaWduT2Zmc2V0ID0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpJDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZm9udC5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICBhbGlnbk9mZnNldCA9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2kkMV0pIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVBbGlnbk9mZnNldHMucHVzaChhbGlnbk9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbkNoYXJzID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICBsZXQgdGludCA9IHRoaXMudGludDtcbiAgICAgICAgZm9yIChsZXQgaSQyID0gMDsgaSQyIDwgbGVuQ2hhcnM7IGkkMisrKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHRoaXMuX2dseXBoc1tpJDJdO1xuICAgICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgICAgICBjLnRleHR1cmUgPSBjaGFyc1tpJDJdLnRleHR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjID0gbmV3IFNwcml0ZV8xLlNwcml0ZShjaGFyc1tpJDJdLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGMucm91bmRQaXhlbHMgPSB0aGlzLnJvdW5kUGl4ZWxzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dseXBocy5wdXNoKGMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLnBvc2l0aW9uLnggPSAoY2hhcnNbaSQyXS5wb3NpdGlvbi54ICsgbGluZUFsaWduT2Zmc2V0c1tjaGFyc1tpJDJdLmxpbmVdKSAqIHNjYWxlO1xuICAgICAgICAgICAgYy5wb3NpdGlvbi55ID0gY2hhcnNbaSQyXS5wb3NpdGlvbi55ICogc2NhbGU7XG4gICAgICAgICAgICBjLnNjYWxlLnggPSBjLnNjYWxlLnkgPSBzY2FsZTtcbiAgICAgICAgICAgIGMudGludCA9IHRpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSQzID0gbGVuQ2hhcnM7IGkkMyA8IHRoaXMuX2dseXBocy5sZW5ndGg7ICsraSQzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuX2dseXBoc1tpJDNdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0V2lkdGggPSBtYXhMaW5lV2lkdGggKiBzY2FsZTtcbiAgICAgICAgdGhpcy5fdGV4dEhlaWdodCA9IChwb3MueSArIHRoaXMuYml0bWFwZm9udC5saW5lSGVpZ2h0KSAqIHNjYWxlO1xuICAgICAgICBpZiAodGhpcy5hbmNob3IueCAhPT0gMCB8fCB0aGlzLmFuY2hvci55ICE9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpJDQgPSAwOyBpJDQgPCBsZW5DaGFyczsgaSQ0KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbHlwaHNbaSQ0XS54IC09IHRoaXMuX3RleHRXaWR0aCAqIHRoaXMuYW5jaG9yLng7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2x5cGhzW2kkNF0ueSAtPSB0aGlzLl90ZXh0SGVpZ2h0ICogdGhpcy5hbmNob3IueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXhMaW5lSGVpZ2h0ID0gbWF4TGluZUhlaWdodCAqIHNjYWxlO1xuICAgIH1cbiAgICA7XG4gICAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICBzdXBlci51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0TG9jYWxCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldExvY2FsQm91bmRzKCk7XG4gICAgfVxuICAgIDtcbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXQgZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250LmZvbnRTaXplO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZvbnRTaXplKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZvbnQuZm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgdGludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQudGludDtcbiAgICB9XG4gICAgO1xuICAgIHNldCB0aW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZvbnQudGludCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCBhbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQuYWxpZ247XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYWxpZ24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZm9udC5hbGlnbiA9IHZhbHVlIHx8ICdsZWZ0JztcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgYW5jaG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hbmNob3IuY29weUZyb20odmFsdWUpO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHQodGV4dCkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dCA9PT0gdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCBtYXhXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heFdpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IG1heFdpZHRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXhXaWR0aCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXhXaWR0aCA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCBtYXhMaW5lSGVpZ2h0KCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhMaW5lSGVpZ2h0O1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHRleHRXaWR0aCgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dFdpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGxldHRlclNwYWNpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xldHRlclNwYWNpbmcgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZ2V0IHRleHRIZWlnaHQoKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRIZWlnaHQ7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQml0bWFwVGV4dCA9IEJpdG1hcFRleHQ7XG5jbGFzcyBCaXRtYXBGb250VHJhY2tlciBleHRlbmRzIEZsYXNoQmFzZU9iamVjdF8xLkZsYXNoQmFzZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZm9udFNpemUgPSAxNjtcbiAgICB9XG59XG5jbGFzcyBEYXRhR2xpcHRoIHtcbn1cbmNsYXNzIEZvbnRNYXAge1xufVxuY2xhc3MgRm9udENoYXJhY3RlckRhdGEge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBCbGVuZE1vZGVzU2V0dGluZ3Mge1xuICAgIC8qKlxuKiBDb3JyZWN0cyBQaXhpSlMgYmxlbmQsIHRha2VzIHByZW11bHRpcGxpZWQgYWxwaGEgaW50byBhY2NvdW50XG4qXG4qIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4qIEBmdW5jdGlvbiBtYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2Rlc1xuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge0FycmF5PG51bWJlcltdPn0gW2FycmF5XSAtIFRoZSBhcnJheSB0byBvdXRwdXQgaW50by5cbiogQHJldHVybiB7QXJyYXk8bnVtYmVyW10+fSBNYXBwZWQgbW9kZXMuXG4qL1xuICAgIHN0YXRpYyBtYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2RlcygpIHtcbiAgICAgICAgdmFyIHBtID0gW107XG4gICAgICAgIHZhciBucG0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgICAgICBwbVtpXSA9IGk7XG4gICAgICAgICAgICBucG1baV0gPSBpO1xuICAgICAgICB9XG4gICAgICAgIHBtW0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgIHBtW0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BRERfTlBNXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BREQ7XG4gICAgICAgIHBtW0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU5fTlBNXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU47XG4gICAgICAgIG5wbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNO1xuICAgICAgICBucG1bQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkFERF0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREX05QTTtcbiAgICAgICAgbnBtW0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU5dID0gQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNDUkVFTl9OUE07XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBhcnJheS5wdXNoKG5wbSk7XG4gICAgICAgIGFycmF5LnB1c2gocG0pO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIC8qKlxuKiBjaGFuZ2VzIGJsZW5kTW9kZSBhY2NvcmRpbmcgdG8gdGV4dHVyZSBmb3JtYXRcbipcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiogQGZ1bmN0aW9uIGNvcnJlY3RCbGVuZE1vZGVcbiogQHBhcmFtIHtudW1iZXJ9IGJsZW5kTW9kZSBzdXBwb3NlZCBibGVuZCBtb2RlXG4qIEBwYXJhbSB7Ym9vbGVhbn0gcHJlbXVsdGlwbGllZCAgd2hldGhlciBzb3VyY2UgaXMgcHJlbXVsdGlwbGllZFxuKiBAcmV0dXJucyB7bnVtYmVyfSB0cnVlIGJsZW5kIG1vZGUgZm9yIHRoaXMgdGV4dHVyZVxuKi9cbiAgICBzdGF0aWMgY29ycmVjdEJsZW5kTW9kZShibGVuZE1vZGUsIHByZW11bHRpcGxpZWQpIHtcbiAgICAgICAgcmV0dXJuIEJsZW5kTW9kZXNTZXR0aW5ncy5wcmVtdWx0aXBseUJsZW5kTW9kZVtwcmVtdWx0aXBsaWVkID8gMSA6IDBdW2JsZW5kTW9kZV07XG4gICAgfVxuICAgIC8qKlxuKiBNYXBzIGdsIGJsZW5kIGNvbWJpbmF0aW9ucyB0byBXZWJHTC5cbipcbiogQG1lbWJlcm9mIFBJWElcbiogQGZ1bmN0aW9uIG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aVxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBUaGUgcmVuZGVyaW5nIGNvbnRleHQuXG4qIEBwYXJhbSB7bnVtYmVyW11bXX0gW2FycmF5PVtdXSAtIFRoZSBhcnJheSB0byBvdXRwdXQgaW50by5cbiogQHJldHVybiB7bnVtYmVyW11bXX0gTWFwcGVkIG1vZGVzLlxuKi9cbiAgICBzdGF0aWMgbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpKGdsLCBhcnJheSA9IFtdKSB7XG4gICAgICAgIC8vIFRPRE8gLSBwcmVtdWx0aXBseSBhbHBoYSB3b3VsZCBiZSBkaWZmZXJlbnQuXG4gICAgICAgIC8vIGFkZCBhIGJvb2xlYW4gZm9yIHRoYXQhXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUxdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BRERdID0gW2dsLk9ORSwgZ2wuRFNUX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTVVMVElQTFldID0gW2dsLkRTVF9DT0xPUiwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNDUkVFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRBUktFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkxJR0hURU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5DT0xPUl9ET0RHRV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkNPTE9SX0JVUk5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5IQVJEX0xJR0hUXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRJRkZFUkVOQ0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5FWENMVVNJT05dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5IVUVdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQVRVUkFUSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQ09MT1JdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9ORV0gPSBbMCwgMF07XG4gICAgICAgIC8vIG5vdC1wcmVtdWx0aXBsaWVkIGJsZW5kIG1vZGVzXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BRERfTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLkRTVF9BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNDUkVFTl9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgLy8gY29tcG9zaXRlIG9wZXJhdGlvbnNcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNSQ19JTl0gPSBbZ2wuRFNUX0FMUEhBLCBnbC5aRVJPXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNSQ19PVVRdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLlpFUk9dO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU1JDX0FUT1BdID0gW2dsLkRTVF9BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5EU1RfT1ZFUl0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuT05FXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRTVF9JTl0gPSBbZ2wuWkVSTywgZ2wuU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRTVF9PVVRdID0gW2dsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuRFNUX0FUT1BdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLlNSQ19BTFBIQV07XG4gICAgICAgIC8vIFNVQlRSQUNUIGZyb20gZmxhc2hcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNVQlRSQUNUXSA9IFtnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUsIGdsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVCwgZ2wuRlVOQ19BRERdO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufVxuLyoqXG4qIFZhcmlvdXMgYmxlbmQgbW9kZXMgc3VwcG9ydGVkIGJ5IFBJWEkuXG4qXG4qIElNUE9SVEFOVCAtIFRoZSBXZWJHTCByZW5kZXJlciBvbmx5IHN1cHBvcnRzIHRoZSBOT1JNQUwsIEFERCwgTVVMVElQTFkgYW5kIFNDUkVFTiBibGVuZCBtb2Rlcy5cbiogQW55dGhpbmcgZWxzZSB3aWxsIHNpbGVudGx5IGFjdCBsaWtlIE5PUk1BTC5cbipcbiogQG1lbWJlcm9mIFBJWElcbiogQG5hbWUgQkxFTkRfTU9ERVNcbiogQGVudW0ge251bWJlcn1cbiogQHByb3BlcnR5IHtudW1iZXJ9IE5PUk1BTFxuKiBAcHJvcGVydHkge251bWJlcn0gQUREXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBNVUxUSVBMWVxuKiBAcHJvcGVydHkge251bWJlcn0gU0NSRUVOXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBPVkVSTEFZXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEQVJLRU5cbiogQHByb3BlcnR5IHtudW1iZXJ9IExJR0hURU5cbiogQHByb3BlcnR5IHtudW1iZXJ9IENPTE9SX0RPREdFXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0xPUl9CVVJOXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBIQVJEX0xJR0hUXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTT0ZUX0xJR0hUXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBESUZGRVJFTkNFXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBFWENMVVNJT05cbiogQHByb3BlcnR5IHtudW1iZXJ9IEhVRVxuKiBAcHJvcGVydHkge251bWJlcn0gU0FUVVJBVElPTlxuKiBAcHJvcGVydHkge251bWJlcn0gQ09MT1JcbiogQHByb3BlcnR5IHtudW1iZXJ9IExVTUlOT1NJVFlcbiogQHByb3BlcnR5IHtudW1iZXJ9IE5PUk1BTF9OUE1cbiogQHByb3BlcnR5IHtudW1iZXJ9IEFERF9OUE1cbiogQHByb3BlcnR5IHtudW1iZXJ9IFNDUkVFTl9OUE1cbiogQHByb3BlcnR5IHtudW1iZXJ9IE5PTkVcbiogQHByb3BlcnR5IHtudW1iZXJ9IFNSQ19JTlxuKiBAcHJvcGVydHkge251bWJlcn0gU1JDX09VVFxuKiBAcHJvcGVydHkge251bWJlcn0gU1JDX0FUT1BcbiogQHByb3BlcnR5IHtudW1iZXJ9IERTVF9PVkVSXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEU1RfSU5cbiogQHByb3BlcnR5IHtudW1iZXJ9IERTVF9PVVRcbiogQHByb3BlcnR5IHtudW1iZXJ9IERTVF9BVE9QXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVUJUUkFDVFxuKiBAcHJvcGVydHkge251bWJlcn0gU1JDX09WRVJcbiogQHByb3BlcnR5IHtudW1iZXJ9IEVSQVNFXG4qL1xuQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTID0ge1xuICAgIE5PUk1BTDogMCxcbiAgICBBREQ6IDEsXG4gICAgTVVMVElQTFk6IDIsXG4gICAgU0NSRUVOOiAzLFxuICAgIE9WRVJMQVk6IDQsXG4gICAgREFSS0VOOiA1LFxuICAgIExJR0hURU46IDYsXG4gICAgQ09MT1JfRE9ER0U6IDcsXG4gICAgQ09MT1JfQlVSTjogOCxcbiAgICBIQVJEX0xJR0hUOiA5LFxuICAgIFNPRlRfTElHSFQ6IDEwLFxuICAgIERJRkZFUkVOQ0U6IDExLFxuICAgIEVYQ0xVU0lPTjogMTIsXG4gICAgSFVFOiAxMyxcbiAgICBTQVRVUkFUSU9OOiAxNCxcbiAgICBDT0xPUjogMTUsXG4gICAgTFVNSU5PU0lUWTogMTYsXG4gICAgTk9STUFMX05QTTogMTcsXG4gICAgQUREX05QTTogMTgsXG4gICAgU0NSRUVOX05QTTogMTksXG4gICAgTk9ORTogMjAsXG4gICAgU1JDX09WRVI6IDAsXG4gICAgU1JDX0lOOiAyMSxcbiAgICBTUkNfT1VUOiAyMixcbiAgICBTUkNfQVRPUDogMjMsXG4gICAgRFNUX09WRVI6IDI0LFxuICAgIERTVF9JTjogMjUsXG4gICAgRFNUX09VVDogMjYsXG4gICAgRFNUX0FUT1A6IDI3LFxuICAgIEVSQVNFOiAyNixcbiAgICBTVUJUUkFDVDogMjgsXG59O1xuLyoqXG4qIG1hcHMgcHJlbXVsdGlwbHkgZmxhZyBhbmQgYmxlbmRNb2RlIHRvIGFkanVzdGVkIGJsZW5kTW9kZVxuKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuKiBAY29uc3QgcHJlbXVsdGlwbHlCbGVuZE1vZGVcbiogQHR5cGUge0FycmF5PG51bWJlcltdPn1cbiovXG5CbGVuZE1vZGVzU2V0dGluZ3MucHJlbXVsdGlwbHlCbGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3MubWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMoKTtcbmV4cG9ydHMuQmxlbmRNb2Rlc1NldHRpbmdzID0gQmxlbmRNb2Rlc1NldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclwiKTtcbmNvbnN0IEJsdXJGaWx0ZXJQYXNzXzEgPSByZXF1aXJlKFwiLi9CbHVyRmlsdGVyUGFzc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY2xhc3MgQmx1ckZpbHRlciBleHRlbmRzIEZpbHRlcl8xLkZpbHRlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZW5ndGggPSAxLCBxdWFsaXR5ID0gMSwgcmVzb2x1dGlvbiA9IDEsIGtlcm5lbFNpemUgPSA1KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlclBhc3NfMS5CbHVyRmlsdGVyUGFzcyh0cnVlLCBzdHJlbmd0aCwgcXVhbGl0eSwgcmVzb2x1dGlvbiwga2VybmVsU2l6ZSk7XG4gICAgICAgIHRoaXMuYmx1cllGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlclBhc3NfMS5CbHVyRmlsdGVyUGFzcyhmYWxzZSwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpO1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgICAgICB0aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHx8IDQ7XG4gICAgICAgIHRoaXMuYmx1ciA9IHN0cmVuZ3RoIHx8IDg7XG4gICAgICAgIHRoaXMucmVwZWF0RWRnZVBpeGVscyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuc3lzdGVtcy5GaWx0ZXJTeXN0ZW19IGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgb3V0cHV0IHRhcmdldC5cbiAgICAgKi9cbiAgICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xuICAgICAgICB2YXIgeFN0cmVuZ3RoID0gTWF0aC5hYnModGhpcy5ibHVyWEZpbHRlci5zdHJlbmd0aCk7XG4gICAgICAgIHZhciB5U3RyZW5ndGggPSBNYXRoLmFicyh0aGlzLmJsdXJZRmlsdGVyLnN0cmVuZ3RoKTtcbiAgICAgICAgaWYgKHhTdHJlbmd0aCAmJiB5U3RyZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBmaWx0ZXJNYW5hZ2VyLmdldEZpbHRlclRleHR1cmUoKTtcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIHJlbmRlclRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIHJlbmRlclRhcmdldCwgb3V0cHV0LCBjbGVhcik7XG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyLnJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh5U3RyZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYmx1cllGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIHVwZGF0ZVBhZGRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXRFZGdlUGl4ZWxzKSB7XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gTWF0aC5tYXgoTWF0aC5hYnModGhpcy5ibHVyWEZpbHRlci5zdHJlbmd0aCksIE1hdGguYWJzKHRoaXMuYmx1cllGaWx0ZXIuc3RyZW5ndGgpKSAqIDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGdldCBibHVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlUGFkZGluZygpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBhc3NlcyBmb3IgYmx1ci4gTW9yZSBwYXNzZXMgbWVhbnMgaGlnaGVyIHF1YWlsaXR5IGJsdXJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIGdldCBxdWFsaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5xdWFsaXR5O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHF1YWxpdHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5xdWFsaXR5ID0gdGhpcy5ibHVyWUZpbHRlci5xdWFsaXR5ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG4gICAgZ2V0IGJsdXJYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGJsdXJYKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWSBwcm9wZXJ0eVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBnZXQgYmx1clkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXI7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYmx1clkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXBkYXRlUGFkZGluZygpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYmxlbmRtb2RlIG9mIHRoZSBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgICAqL1xuICAgIGdldCBibGVuZE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsZW5kTW9kZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlIHRoZSBlZGdlIG9mIHRoZSB0YXJnZXQgd2lsbCBiZSBjbGFtcGVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sfVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZ2V0IHJlcGVhdEVkZ2VQaXhlbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXBlYXRFZGdlUGl4ZWxzO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHJlcGVhdEVkZ2VQaXhlbHModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVwZWF0RWRnZVBpeGVscyA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5CbHVyRmlsdGVyID0gQmx1ckZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9GaWx0ZXJcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIEJsdXJGaWx0ZXJQYXNzIGV4dGVuZHMgRmlsdGVyXzEuRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihob3Jpem9udGFsLCBzdHJlbmd0aCwgcXVhbGl0eSwgcmVzb2x1dGlvbiwga2VybmVsU2l6ZSkge1xuICAgICAgICBrZXJuZWxTaXplID0ga2VybmVsU2l6ZSB8fCA1O1xuICAgICAgICB2YXIgdmVydFNyYyA9IEJsdXJGaWx0ZXJQYXNzLmdlbmVyYXRlQmx1clZlcnRTb3VyY2Uoa2VybmVsU2l6ZSwgaG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciBmcmFnU3JjID0gQmx1ckZpbHRlclBhc3MuZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZShrZXJuZWxTaXplKTtcbiAgICAgICAgc3VwZXIodmVydFNyYywgZnJhZ1NyYyk7XG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGhvcml6b250YWw7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT047XG4gICAgICAgIHRoaXMuX3F1YWxpdHkgPSAwO1xuICAgICAgICB0aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHx8IDQ7XG4gICAgICAgIHRoaXMuYmx1ciA9IHN0cmVuZ3RoIHx8IDg7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZUJsdXJGcmFnU291cmNlKGtlcm5lbFNpemUpIHtcbiAgICAgICAgdmFyIGtlcm5lbCA9IEJsdXJGaWx0ZXJQYXNzLkdBVVNTSUFOX1ZBTFVFU1trZXJuZWxTaXplXTtcbiAgICAgICAgdmFyIGhhbGZMZW5ndGggPSBrZXJuZWwubGVuZ3RoO1xuICAgICAgICB2YXIgZnJhZ1NvdXJjZSA9IEJsdXJGaWx0ZXJQYXNzLmZyYWdUZW1wbGF0ZSQyO1xuICAgICAgICB2YXIgYmx1ckxvb3AgPSAnJztcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyVpbmRleCVdKSAqICV2YWx1ZSU7JztcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJsdXIgPSB0ZW1wbGF0ZS5yZXBsYWNlKCclaW5kZXglJywgaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHZhbHVlID0gaTtcbiAgICAgICAgICAgIGlmIChpID49IGhhbGZMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGtlcm5lbFNpemUgLSBpIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsdXIgPSBibHVyLnJlcGxhY2UoJyV2YWx1ZSUnLCBrZXJuZWxbdmFsdWVdKTtcbiAgICAgICAgICAgIGJsdXJMb29wICs9IGJsdXI7XG4gICAgICAgICAgICBibHVyTG9vcCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBmcmFnU291cmNlID0gZnJhZ1NvdXJjZS5yZXBsYWNlKCclYmx1ciUnLCBibHVyTG9vcCk7XG4gICAgICAgIGZyYWdTb3VyY2UgPSBmcmFnU291cmNlLnJlcGxhY2UoJyVzaXplJScsIGtlcm5lbFNpemUpO1xuICAgICAgICByZXR1cm4gZnJhZ1NvdXJjZTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlQmx1clZlcnRTb3VyY2Uoa2VybmVsU2l6ZSwgeCkge1xuICAgICAgICB2YXIgaGFsZkxlbmd0aCA9IE1hdGguY2VpbChrZXJuZWxTaXplIC8gMik7XG4gICAgICAgIHZhciB2ZXJ0U291cmNlID0gQmx1ckZpbHRlclBhc3MudmVydFRlbXBsYXRlO1xuICAgICAgICB2YXIgYmx1ckxvb3AgPSAnJztcbiAgICAgICAgdmFyIHRlbXBsYXRlO1xuICAgICAgICAvLyBsZXQgdmFsdWU7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZSA9ICd2Qmx1clRleENvb3Jkc1slaW5kZXglXSA9ICB0ZXh0dXJlQ29vcmQgKyB2ZWMyKCVzYW1wbGVJbmRleCUgKiBzdHJlbmd0aCwgMC4wKTsnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSAndkJsdXJUZXhDb29yZHNbJWluZGV4JV0gPSAgdGV4dHVyZUNvb3JkICsgdmVjMigwLjAsICVzYW1wbGVJbmRleCUgKiBzdHJlbmd0aCk7JztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJsdXIgPSB0ZW1wbGF0ZS5yZXBsYWNlKCclaW5kZXglJywgaSk7XG4gICAgICAgICAgICAvLyB2YWx1ZSA9IGk7XG4gICAgICAgICAgICAvLyBpZihpID49IGhhbGZMZW5ndGgpXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAvLyAgICAgdmFsdWUgPSBrZXJuZWxTaXplIC0gaSAtIDE7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBibHVyID0gYmx1ci5yZXBsYWNlKCclc2FtcGxlSW5kZXglJywgKChpIC0gKGhhbGZMZW5ndGggLSAxKSkgKyBcIi4wXCIpKTtcbiAgICAgICAgICAgIGJsdXJMb29wICs9IGJsdXI7XG4gICAgICAgICAgICBibHVyTG9vcCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICB2ZXJ0U291cmNlID0gdmVydFNvdXJjZS5yZXBsYWNlKCclYmx1ciUnLCBibHVyTG9vcCk7XG4gICAgICAgIHZlcnRTb3VyY2UgPSB2ZXJ0U291cmNlLnJlcGxhY2UoJyVzaXplJScsIGtlcm5lbFNpemUpO1xuICAgICAgICByZXR1cm4gdmVydFNvdXJjZTtcbiAgICB9XG4gICAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAoMSAvIG91dHB1dC53aWR0aCkgKiAob3V0cHV0LndpZHRoIC8gaW5wdXQud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9ICgxIC8gb3V0cHV0LmhlaWdodCkgKiAob3V0cHV0LmhlaWdodCAvIGlucHV0LmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ob3Jpem9udGFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAoMSAvIGZpbHRlck1hbmFnZXIucmVuZGVyZXIud2lkdGgpICogKGZpbHRlck1hbmFnZXIucmVuZGVyZXIud2lkdGggLyBpbnB1dC53aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gKDEgLyBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLmhlaWdodCkgKiAoZmlsdGVyTWFuYWdlci5yZW5kZXJlci5oZWlnaHQgLyBpbnB1dC5oZWlnaHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NyZWVuIHNwYWNlIVxuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoICo9IHRoaXMuc3RyZW5ndGg7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggLz0gdGhpcy5wYXNzZXM7XG4gICAgICAgIGlmICh0aGlzLnBhc3NlcyA9PT0gMSkge1xuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyO1xuICAgICAgICAgICAgdmFyIGZsaXAgPSBpbnB1dDtcbiAgICAgICAgICAgIHZhciBmbG9wID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBmbGlwLCBmbG9wLCBmYWxzZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucGFzc2VzIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKGZsaXAsIGZsaXAuZmlsdGVyRnJhbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudVNhbXBsZXIgPSBmbG9wO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gZmxvcDtcbiAgICAgICAgICAgICAgICBmbG9wID0gZmxpcDtcbiAgICAgICAgICAgICAgICBmbGlwID0gdGVtcDtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZCA9IHRydWU7XG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGZsb3AsIG91dHB1dCwgY2xlYXIpO1xuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5yZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMTZcbiAgICAgKi9cbiAgICBnZXQgYmx1cigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZW5ndGg7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYmx1cih2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSAxICsgKE1hdGguYWJzKHZhbHVlKSAqIDIpO1xuICAgICAgICB0aGlzLnN0cmVuZ3RoID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBxdWFsaXR5IG9mIHRoZSBibHVyIGJ5IG1vZGlmeWluZyB0aGUgbnVtYmVyIG9mIHBhc3Nlcy4gTW9yZSBwYXNzZXMgbWVhbnMgaGlnaGVyXG4gICAgICogcXVhaWxpdHkgYmx1cmluZyBidXQgdGhlIGxvd2VyIHRoZSBwZXJmb3JtYW5jZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCA0XG4gICAgICovXG4gICAgZ2V0IHF1YWxpdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWFsaXR5O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHF1YWxpdHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcXVhbGl0eSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnBhc3NlcyA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG59XG5CbHVyRmlsdGVyUGFzcy5HQVVTU0lBTl9WQUxVRVMgPSB7XG4gICAgNTogWzAuMTUzMzg4LCAwLjIyMTQ2MSwgMC4yNTAzMDFdLFxuICAgIDc6IFswLjA3MTMwMywgMC4xMzE1MTQsIDAuMTg5ODc5LCAwLjIxNDYwN10sXG4gICAgOTogWzAuMDI4NTMyLCAwLjA2NzIzNCwgMC4xMjQwMDksIDAuMTc5MDQ0LCAwLjIwMjM2XSxcbiAgICAxMTogWzAuMDA5MywgMC4wMjgwMDIsIDAuMDY1OTg0LCAwLjEyMTcwMywgMC4xNzU3MTMsIDAuMTk4NTk2XSxcbiAgICAxMzogWzAuMDAyNDA2LCAwLjAwOTI1NSwgMC4wMjc4NjcsIDAuMDY1NjY2LCAwLjEyMTExNywgMC4xNzQ4NjgsIDAuMTk3NjQxXSxcbiAgICAxNTogWzAuMDAwNDg5LCAwLjAwMjQwMywgMC4wMDkyNDYsIDAuMDI3ODQsIDAuMDY1NjAyLCAwLjEyMDk5OSwgMC4xNzQ2OTcsIDAuMTk3NDQ4XSxcbn07XG5CbHVyRmlsdGVyUGFzcy52ZXJ0VGVtcGxhdGUgPSBcIlxcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxuICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcblxcbiAgICB1bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xcblxcbiAgICB2YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbJXNpemUlXTtcXG5cXG4gICAgdW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXG4gICAgdW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xcbiAgICBcXG4gICAgdmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxuICAgIHtcXG4gICAgICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcbiAgICBcXG4gICAgICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG4gICAgfVxcbiAgICBcXG4gICAgdmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxcbiAgICB7XFxuICAgICAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4odm9pZClcXG4gICAge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcblxcbiAgICAgICAgdmVjMiB0ZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXG4gICAgICAgICVibHVyJVxcbiAgICB9XCI7XG5CbHVyRmlsdGVyUGFzcy5mcmFnVGVtcGxhdGUkMiA9IFtcbiAgICAndmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWyVzaXplJV07JyxcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcbiAgICAndm9pZCBtYWluKHZvaWQpJyxcbiAgICAneycsXG4gICAgJyAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7JyxcbiAgICAnICAgICVibHVyJScsXG4gICAgJ30nXG5dLmpvaW4oJ1xcbicpO1xuZXhwb3J0cy5CbHVyRmlsdGVyUGFzcyA9IEJsdXJGaWx0ZXJQYXNzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcbmNsYXNzIEJvdW5kcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heFkgPSAtSW5maW5pdHk7XG4gICAgICAgIHRoaXMucmVjdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICogQ2hlY2tzIGlmIGJvdW5kcyBhcmUgZW1wdHkuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBlbXB0eS5cbiAqL1xuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pblggPiB0aGlzLm1heFggfHwgdGhpcy5taW5ZID4gdGhpcy5tYXhZO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBib3VuZHMgYW5kIHJlc2V0cy5cbiAgICAgKlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUlEKys7XG4gICAgICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFkgPSAtSW5maW5pdHk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIENhbiByZXR1cm4gUmVjdGFuZ2xlLkVNUFRZIGNvbnN0YW50LCBlaXRoZXIgY29uc3RydWN0IG5ldyByZWN0YW5nbGUsIGVpdGhlciB1c2UgeW91ciByZWN0YW5nbGVcbiAqIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgaXQgd2lsbCByZXR1cm4gdGVtcFJlY3RcbiAqXG4gKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0IC0gdGVtcG9yYXJ5IG9iamVjdCB3aWxsIGJlIHVzZWQgaWYgQUFCQiBpcyBub3QgZW1wdHlcbiAqIEByZXR1cm5zIHtQSVhJLlJlY3RhbmdsZX0gQSByZWN0YW5nbGUgb2YgdGhlIGJvdW5kc1xuICovXG4gICAgZ2V0UmVjdGFuZ2xlKHJlY3QpIHtcbiAgICAgICAgaWYgKHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFkpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcbiAgICAgICAgcmVjdC54ID0gdGhpcy5taW5YO1xuICAgICAgICByZWN0LnkgPSB0aGlzLm1pblk7XG4gICAgICAgIHJlY3Qud2lkdGggPSB0aGlzLm1heFggLSB0aGlzLm1pblg7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gdGhpcy5tYXhZIC0gdGhpcy5taW5ZO1xuICAgICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGlubGluZWQgd2hlbiBpdHMgcG9zc2libGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRQb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHBvaW50LngpO1xuICAgICAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHBvaW50LngpO1xuICAgICAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHBvaW50LnkpO1xuICAgICAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHBvaW50LnkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHF1YWQsIG5vdCB0cmFuc2Zvcm1lZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZlcnRpY2VzIC0gVGhlIHZlcnRzIHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGRRdWFkKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgICB2YXIgbWluWSA9IHRoaXMubWluWTtcbiAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgICB2YXIgeCA9IHZlcnRpY2VzWzBdO1xuICAgICAgICB2YXIgeSA9IHZlcnRpY2VzWzFdO1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICAgICAgeCA9IHZlcnRpY2VzWzJdO1xuICAgICAgICB5ID0gdmVydGljZXNbM107XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgICAgICB4ID0gdmVydGljZXNbNF07XG4gICAgICAgIHkgPSB2ZXJ0aWNlc1s1XTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIHggPSB2ZXJ0aWNlc1s2XTtcbiAgICAgICAgeSA9IHZlcnRpY2VzWzddO1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICAgICAgdGhpcy5taW5YID0gbWluWDtcbiAgICAgICAgdGhpcy5taW5ZID0gbWluWTtcbiAgICAgICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICAgICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgc3ByaXRlIGZyYW1lLCB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UcmFuc2Zvcm19IHRyYW5zZm9ybSAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDAgLSBUT0RPXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTEgLSBUT0RPXG4gICAgICovXG4gICAgYWRkRnJhbWUodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gdHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgYSA9IG1hdHJpeC5hO1xuICAgICAgICB2YXIgYiA9IG1hdHJpeC5iO1xuICAgICAgICB2YXIgYyA9IG1hdHJpeC5jO1xuICAgICAgICB2YXIgZCA9IG1hdHJpeC5kO1xuICAgICAgICB2YXIgdHggPSBtYXRyaXgudHg7XG4gICAgICAgIHZhciB0eSA9IG1hdHJpeC50eTtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG4gICAgICAgIHZhciB4ID0gKGEgKiB4MCkgKyAoYyAqIHkwKSArIHR4O1xuICAgICAgICB2YXIgeSA9IChiICogeDApICsgKGQgKiB5MCkgKyB0eTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIHggPSAoYSAqIHgxKSArIChjICogeTApICsgdHg7XG4gICAgICAgIHkgPSAoYiAqIHgxKSArIChkICogeTApICsgdHk7XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgICAgICB4ID0gKGEgKiB4MCkgKyAoYyAqIHkxKSArIHR4O1xuICAgICAgICB5ID0gKGIgKiB4MCkgKyAoZCAqIHkxKSArIHR5O1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICAgICAgeCA9IChhICogeDEpICsgKGMgKiB5MSkgKyB0eDtcbiAgICAgICAgeSA9IChiICogeDEpICsgKGQgKiB5MSkgKyB0eTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgICAgIHRoaXMubWF4WSA9IG1heFk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIHNjcmVlbiB2ZXJ0aWNlcyBmcm9tIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmVydGV4RGF0YSAtIGNhbGN1bGF0ZWQgdmVydGljZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVnaW5PZmZzZXQgLSBiZWdpbiBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IC0gZW5kIG9mZnNldCwgZXhjbHVkZWRcbiAgICAgKi9cbiAgICBhZGRWZXJ0ZXhEYXRhKHZlcnRleERhdGEsIGJlZ2luT2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG4gICAgICAgIGZvciAodmFyIGkgPSBiZWdpbk9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZlcnRleERhdGFbaV07XG4gICAgICAgICAgICB2YXIgeSA9IHZlcnRleERhdGFbaSArIDFdO1xuICAgICAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5taW5YID0gbWluWDtcbiAgICAgICAgdGhpcy5taW5ZID0gbWluWTtcbiAgICAgICAgdGhpcy5tYXhYID0gbWF4WDtcbiAgICAgICAgdGhpcy5tYXhZID0gbWF4WTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhcnJheSBvZiBtZXNoIHZlcnRpY2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gLSBtZXNoIHRyYW5zZm9ybVxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2ZXJ0aWNlcyAtIG1lc2ggY29vcmRpbmF0ZXMgaW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmVnaW5PZmZzZXQgLSBiZWdpbiBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IC0gZW5kIG9mZnNldCwgZXhjbHVkZWRcbiAgICAgKi9cbiAgICBhZGRWZXJ0aWNlcyh0cmFuc2Zvcm0sIHZlcnRpY2VzLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSB0cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciBhID0gbWF0cml4LmE7XG4gICAgICAgIHZhciBiID0gbWF0cml4LmI7XG4gICAgICAgIHZhciBjID0gbWF0cml4LmM7XG4gICAgICAgIHZhciBkID0gbWF0cml4LmQ7XG4gICAgICAgIHZhciB0eCA9IG1hdHJpeC50eDtcbiAgICAgICAgdmFyIHR5ID0gbWF0cml4LnR5O1xuICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xuICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGJlZ2luT2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciByYXdYID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICB2YXIgcmF3WSA9IHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciB4ID0gKGEgKiByYXdYKSArIChjICogcmF3WSkgKyB0eDtcbiAgICAgICAgICAgIHZhciB5ID0gKGQgKiByYXdZKSArIChiICogcmF3WCkgKyB0eTtcbiAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgICAgIHRoaXMubWF4WSA9IG1heFk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gYm91bmRzIC0gVE9ET1xuICAgICAqL1xuICAgIGFkZEJvdW5kcyhib3VuZHMpIHtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG4gICAgICAgIHRoaXMubWluWCA9IGJvdW5kcy5taW5YIDwgbWluWCA/IGJvdW5kcy5taW5YIDogbWluWDtcbiAgICAgICAgdGhpcy5taW5ZID0gYm91bmRzLm1pblkgPCBtaW5ZID8gYm91bmRzLm1pblkgOiBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBib3VuZHMubWF4WCA+IG1heFggPyBib3VuZHMubWF4WCA6IG1heFg7XG4gICAgICAgIHRoaXMubWF4WSA9IGJvdW5kcy5tYXhZID4gbWF4WSA/IGJvdW5kcy5tYXhZIDogbWF4WTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgb3RoZXIgQm91bmRzLCBtYXNrZWQgd2l0aCBCb3VuZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Cb3VuZHN9IGJvdW5kcyAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge1BJWEkuQm91bmRzfSBtYXNrIC0gVE9ET1xuICAgICAqL1xuICAgIGFkZEJvdW5kc01hc2soYm91bmRzLCBtYXNrKSB7XG4gICAgICAgIHZhciBfbWluWCA9IGJvdW5kcy5taW5YID4gbWFzay5taW5YID8gYm91bmRzLm1pblggOiBtYXNrLm1pblg7XG4gICAgICAgIHZhciBfbWluWSA9IGJvdW5kcy5taW5ZID4gbWFzay5taW5ZID8gYm91bmRzLm1pblkgOiBtYXNrLm1pblk7XG4gICAgICAgIHZhciBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgbWFzay5tYXhYID8gYm91bmRzLm1heFggOiBtYXNrLm1heFg7XG4gICAgICAgIHZhciBfbWF4WSA9IGJvdW5kcy5tYXhZIDwgbWFzay5tYXhZID8gYm91bmRzLm1heFkgOiBtYXNrLm1heFk7XG4gICAgICAgIGlmIChfbWluWCA8PSBfbWF4WCAmJiBfbWluWSA8PSBfbWF4WSkge1xuICAgICAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgICAgICB2YXIgbWluWSA9IHRoaXMubWluWTtcbiAgICAgICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xuICAgICAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG4gICAgICAgICAgICB0aGlzLm1pblggPSBfbWluWCA8IG1pblggPyBfbWluWCA6IG1pblg7XG4gICAgICAgICAgICB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblk7XG4gICAgICAgICAgICB0aGlzLm1heFggPSBfbWF4WCA+IG1heFggPyBfbWF4WCA6IG1heFg7XG4gICAgICAgICAgICB0aGlzLm1heFkgPSBfbWF4WSA+IG1heFkgPyBfbWF4WSA6IG1heFk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgb3RoZXIgQm91bmRzLCBtYXNrZWQgd2l0aCBSZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Cb3VuZHN9IGJvdW5kcyAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBhcmVhIC0gVE9ET1xuICAgICAqL1xuICAgIGFkZEJvdW5kc0FyZWEoYm91bmRzLCBhcmVhKSB7XG4gICAgICAgIHZhciBfbWluWCA9IGJvdW5kcy5taW5YID4gYXJlYS54ID8gYm91bmRzLm1pblggOiBhcmVhLng7XG4gICAgICAgIHZhciBfbWluWSA9IGJvdW5kcy5taW5ZID4gYXJlYS55ID8gYm91bmRzLm1pblkgOiBhcmVhLnk7XG4gICAgICAgIHZhciBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgYXJlYS54ICsgYXJlYS53aWR0aCA/IGJvdW5kcy5tYXhYIDogKGFyZWEueCArIGFyZWEud2lkdGgpO1xuICAgICAgICB2YXIgX21heFkgPSBib3VuZHMubWF4WSA8IGFyZWEueSArIGFyZWEuaGVpZ2h0ID8gYm91bmRzLm1heFkgOiAoYXJlYS55ICsgYXJlYS5oZWlnaHQpO1xuICAgICAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcbiAgICAgICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XG4gICAgICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YO1xuICAgICAgICAgICAgdGhpcy5taW5ZID0gX21pblkgPCBtaW5ZID8gX21pblkgOiBtaW5ZO1xuICAgICAgICAgICAgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYO1xuICAgICAgICAgICAgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQm91bmRzID0gQm91bmRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcbmNsYXNzIEJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoZGF0YSA9IG51bGwsIF9zdGF0aWMgPSBmYWxzZSwgaW5kZXggPSBudWxsKSB7XG4gICAgICAgIGlmIChfc3RhdGljID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIF9zdGF0aWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YSBpbiB0aGUgYnVmZmVyLCBhcyBhIHR5cGVkIGFycmF5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5QnVmZmVyfCBTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgYnVmZmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdDxudW1iZXIsIEdMQnVmZmVyPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dsQnVmZmVycyA9IHt9O1xuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGF0aWMgPSBfc3RhdGljO1xuICAgICAgICB0aGlzLmlkID0gQnVmZmVyLlVJRCsrO1xuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyXzEuUnVubmVyKCdkaXNwb3NlQnVmZmVyJywgMik7XG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoJ2Rpc3Bvc2VCdWZmZXInLCAyKTtcbiAgICB9XG4gICAgLy8gVE9ETyBjb3VsZCBleHBsb3JlIGZsYWdnaW5nIG9ubHkgYSBwYXJ0aWFsIHVwbG9hZD9cbiAgICAvKipcbiAgICAgKiBmbGFncyB0aGlzIGJ1ZmZlciBhcyByZXF1aXJpbmcgYW4gdXBsb2FkIHRvIHRoZSBHUFVcbiAgICAgKi9cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHRoaXMuZGF0YTtcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQrKztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIGRpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeVxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5ydW4odGhpcywgZmFsc2UpO1xuICAgICAgICAvLyB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBidWZmZXJcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBidWZmZXIgYmFzZWQgb24gYW4gYXJyYXkgb3IgVHlwZWRBcnJheVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3IHwgbnVtYmVyW119IGRhdGEgdGhlIFR5cGVkQXJyYXkgdGhhdCB0aGUgYnVmZmVyIHdpbGwgc3RvcmUuIElmIHRoaXMgaXMgYSByZWd1bGFyIEFycmF5IGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGEgRmxvYXQzMkFycmF5LlxuICAgICAqIEByZXR1cm4ge1BJWEkuQnVmZmVyfSBBIG5ldyBCdWZmZXIgYmFzZWQgb24gdGhlIGRhdGEgcHJvdmlkZWQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihkYXRhKTtcbiAgICB9XG4gICAgO1xufVxuQnVmZmVyLlVJRCA9IDA7XG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlXCIpO1xuY2xhc3MgQnVmZmVyUmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZV8xLlJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJlZiA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXJSZXNvdXJjZSB3aWR0aCBvciBoZWlnaHQgaW52YWxpZCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU291cmNlIGFycmF5XG4gICAgICAgICAqIENhbm5vdCBiZSBDbGFtcGVkVWludDhBcnJheSBiZWNhdXNlIGl0IGNhbnQgYmUgdXBsb2FkZWQgdG8gV2ViR0xcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fFVpbnQ4QXJyYXl8VWludDMyQXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBzb3VyY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZCB0aGUgdGV4dHVyZSB0byB0aGUgR1BVLlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgVXBsb2FkIHRvIHRoZSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgUmVmZXJlbmNlIHRvIHBhcmVudCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtQSVhJLkdMVGV4dHVyZX0gZ2xUZXh0dXJlIGdsVGV4dHVyZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlzIHN1Y2Nlc3NcbiAgICAgKi9cbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG4gICAgICAgIGlmIChnbFRleHR1cmUud2lkdGggPT09IGJhc2VUZXh0dXJlLndpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGJhc2VUZXh0dXJlLmhlaWdodCkge1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IGJhc2VUZXh0dXJlLndpZHRoO1xuICAgICAgICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGJhc2VUZXh0dXJlLmhlaWdodDtcbiAgICAgICAgICAgIHZhciBpbnRlcm5hbEZvcm1hdCA9IGJhc2VUZXh0dXJlLmZvcm1hdDtcbiAgICAgICAgICAgIC8vIGd1ZXNzIHNpemVkIGZvcm1hdCBieSB0eXBlIGFuZCBmb3JtYXRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTFJlbmRlcmluZ0NvbnRleHQvdGV4SW1hZ2UyRFxuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAyXG4gICAgICAgICAgICAgICAgJiYgYmFzZVRleHR1cmUudHlwZSA9PT0gcmVuZGVyZXIuZ2wuRkxPQVRcbiAgICAgICAgICAgICAgICAmJiBiYXNlVGV4dHVyZS5mb3JtYXQgPT09IHJlbmRlcmVyLmdsLlJHQkEpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHJlbmRlcmVyLmdsLlJHQkEzMkY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgaW50ZXJuYWxGb3JtYXQsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXV0by1kZXRlY3QgdGhlIHR5cGUgb2YgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiA8Y2FudmFzPlxuICAgICAqL1xuICAgIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5XG4gICAgICAgICAgICB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgICAgICB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50MzJBcnJheTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5CdWZmZXJSZXNvdXJjZSA9IEJ1ZmZlclJlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBDYWNoZVNldHRpbmdzIHtcbiAgICBzdGF0aWMgY2xlYXJUZXh0dXJlQ2FjaGUoKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIENhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlKSB7XG4gICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGtleSBpbiBDYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGVba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZGVzdHJveVRleHR1cmVDYWNoZSgpIHtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChrZXkgaW4gQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGUpIHtcbiAgICAgICAgICAgIENhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW2tleV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoa2V5IGluIENhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZSkge1xuICAgICAgICAgICAgQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2tleV0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuQ2FjaGVTZXR0aW5ncy5Qcm9ncmFtQ2FjaGUgPSB7fTtcbkNhY2hlU2V0dGluZ3MubmFtZUNhY2hlID0ge307XG5DYWNoZVNldHRpbmdzLnByb2dyYW1DYWNoZSA9IHt9O1xuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGUgPSB7fTtcbkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZSA9IHt9O1xuQ2FjaGVTZXR0aW5ncy5kZWZhdWx0R3JvdXBDYWNoZSA9IHt9O1xuZXhwb3J0cy5DYWNoZVNldHRpbmdzID0gQ2FjaGVTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jbGFzcyBDYW52YXNSZW5kZXJUYXJnZXQge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIENhbnZhcyBvYmplY3QgdGhhdCBiZWxvbmdzIHRvIHRoaXMgQ2FudmFzUmVuZGVyVGFyZ2V0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjYW52YXMgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgQ2FudmFzUmVuZGVyVGFyZ2V0IGNsYXNzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNhbnZhcyB0byB0aGUgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgbmV3IHdpZHRoIG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIG5ldyBoZWlnaHQgb2YgdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2lkdGggKiB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgY2FudmFzLlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aDtcbiAgICB9XG4gICAgO1xuICAgIHNldCB3aWR0aCh2YWwpIHtcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB2YWw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGhlaWdodCh2YWwpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdmFsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkNhbnZhc1JlbmRlclRhcmdldCA9IENhbnZhc1JlbmRlclRhcmdldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUltYWdlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0Jhc2VJbWFnZVJlc291cmNlXCIpO1xuY2xhc3MgQ2FudmFzUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICB9XG4gICAgc3RhdGljIHRlc3Qoc291cmNlKSB7XG4gICAgICAgIHJldHVybiAoc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkNhbnZhc1Jlc291cmNlID0gQ2FudmFzUmVzb3VyY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENhbnZhc1NldHRpbmdzIHtcbiAgICAvKipcbiogVHJpbSB0cmFuc3BhcmVudCBib3JkZXJzIGZyb20gYSBjYW52YXNcbipcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiogQGZ1bmN0aW9uIHRyaW1DYW52YXNcbiogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gdGhlIGNhbnZhcyB0byB0cmltXG4qIEByZXR1cm5zIHtvYmplY3R9IFRyaW0gZGF0YVxuKi9cbiAgICBzdGF0aWMgdHJpbUNhbnZhcyhjYW52YXMpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcmVteS83ODQ1MDhcbiAgICAgICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgIHZhciBsZW4gPSBwaXhlbHMubGVuZ3RoO1xuICAgICAgICB2YXIgYm91bmQgPSB7XG4gICAgICAgICAgICB0b3A6IG51bGwsXG4gICAgICAgICAgICBsZWZ0OiBudWxsLFxuICAgICAgICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICAgICAgICBib3R0b206IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB4O1xuICAgICAgICB2YXIgeTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAgICAgICBpZiAocGl4ZWxzW2kgKyAzXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHggPSAoaSAvIDQpICUgd2lkdGg7XG4gICAgICAgICAgICAgICAgeSA9IH5+KChpIC8gNCkgLyB3aWR0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kLnRvcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZC50b3AgPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYm91bmQubGVmdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZC5sZWZ0ID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeCA8IGJvdW5kLmxlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmQubGVmdCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChib3VuZC5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZC5yaWdodCA9IHggKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChib3VuZC5yaWdodCA8IHgpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmQucmlnaHQgPSB4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kLmJvdHRvbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZC5ib3R0b20gPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChib3VuZC5ib3R0b20gPCB5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kLmJvdHRvbSA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChib3VuZC50b3AgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHdpZHRoID0gYm91bmQucmlnaHQgLSBib3VuZC5sZWZ0O1xuICAgICAgICAgICAgaGVpZ2h0ID0gYm91bmQuYm90dG9tIC0gYm91bmQudG9wICsgMTtcbiAgICAgICAgICAgIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YShib3VuZC5sZWZ0LCBib3VuZC50b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5DYW52YXNTZXR0aW5ncyA9IENhbnZhc1NldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XG5jbGFzcyBDaXJjbGUge1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLkNJUkNcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkNJUkM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIENpcmNsZSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5DaXJjbGV9IGEgY29weSBvZiB0aGUgQ2lyY2xlXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBDaXJjbGVcbiAgICAgKi9cbiAgICBjb250YWlucyh4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLnJhZGl1cyA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIyID0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcbiAgICAgICAgdmFyIGR4ID0gKHRoaXMueCAtIHgpO1xuICAgICAgICB2YXIgZHkgPSAodGhpcy55IC0geSk7XG4gICAgICAgIGR4ICo9IGR4O1xuICAgICAgICBkeSAqPSBkeTtcbiAgICAgICAgcmV0dXJuIChkeCArIGR5IDw9IHIyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGNpcmNsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICAqXG4gICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAgKi9cbiAgICBnZXRCb3VuZHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQ2xlYW5VcFNldHRpbmdzIHtcbn1cbkNsZWFuVXBTZXR0aW5ncy5kZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XG4gICAgdGV4dHVyZTogdHJ1ZSxcbiAgICBjaGlsZHJlbjogZmFsc2UsXG4gICAgYmFzZVRleHR1cmU6IHRydWUsXG59O1xuZXhwb3J0cy5DbGVhblVwU2V0dGluZ3MgPSBDbGVhblVwU2V0dGluZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuY2xhc3MgQ29sb3JNYXRyaXhGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXJfMS5GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgICBtOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAxLCAwXSksXG4gICAgICAgICAgICB1QWxwaGE6IDEsXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKHNldHRpbmdzXzEuc2V0dGluZ3MuZGVmYXVsdEZpbHRlclZlcnRleCwgQ29sb3JNYXRyaXhGaWx0ZXIuZnJhZ21lbnQkNCwgdW5pZm9ybXMpO1xuICAgICAgICB0aGlzLmFscGhhID0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjdXJyZW50IG1hdHJpeCBhbmQgc2V0IHRoZSBuZXcgb25lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtYXRyaXggLSA1eDQgbWF0cml4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSkge1xuICAgICAgICBpZiAobXVsdGlwbHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbXVsdGlwbHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3TWF0cml4ID0gbWF0cml4O1xuICAgICAgICBpZiAobXVsdGlwbHkpIHtcbiAgICAgICAgICAgIHRoaXMuX211bHRpcGx5KG5ld01hdHJpeCwgdGhpcy51bmlmb3Jtcy5tLCBtYXRyaXgpO1xuICAgICAgICAgICAgbmV3TWF0cml4ID0gdGhpcy5fY29sb3JNYXRyaXgobmV3TWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIG5ldyBtYXRyaXhcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tID0gbmV3TWF0cml4O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gbWF0NSdzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG91dCAtIDV4NCBtYXRyaXggdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhIC0gNXg0IG1hdHJpeCB0aGUgZmlyc3Qgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGIgLSA1eDQgbWF0cml4IHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gNXg0IG1hdHJpeFxuICAgICAqL1xuICAgIF9tdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICAgICAgLy8gUmVkIENoYW5uZWxcbiAgICAgICAgb3V0WzBdID0gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYls1XSkgKyAoYVsyXSAqIGJbMTBdKSArIChhWzNdICogYlsxNV0pO1xuICAgICAgICBvdXRbMV0gPSAoYVswXSAqIGJbMV0pICsgKGFbMV0gKiBiWzZdKSArIChhWzJdICogYlsxMV0pICsgKGFbM10gKiBiWzE2XSk7XG4gICAgICAgIG91dFsyXSA9IChhWzBdICogYlsyXSkgKyAoYVsxXSAqIGJbN10pICsgKGFbMl0gKiBiWzEyXSkgKyAoYVszXSAqIGJbMTddKTtcbiAgICAgICAgb3V0WzNdID0gKGFbMF0gKiBiWzNdKSArIChhWzFdICogYls4XSkgKyAoYVsyXSAqIGJbMTNdKSArIChhWzNdICogYlsxOF0pO1xuICAgICAgICBvdXRbNF0gPSAoYVswXSAqIGJbNF0pICsgKGFbMV0gKiBiWzldKSArIChhWzJdICogYlsxNF0pICsgKGFbM10gKiBiWzE5XSkgKyBhWzRdO1xuICAgICAgICAvLyBHcmVlbiBDaGFubmVsXG4gICAgICAgIG91dFs1XSA9IChhWzVdICogYlswXSkgKyAoYVs2XSAqIGJbNV0pICsgKGFbN10gKiBiWzEwXSkgKyAoYVs4XSAqIGJbMTVdKTtcbiAgICAgICAgb3V0WzZdID0gKGFbNV0gKiBiWzFdKSArIChhWzZdICogYls2XSkgKyAoYVs3XSAqIGJbMTFdKSArIChhWzhdICogYlsxNl0pO1xuICAgICAgICBvdXRbN10gPSAoYVs1XSAqIGJbMl0pICsgKGFbNl0gKiBiWzddKSArIChhWzddICogYlsxMl0pICsgKGFbOF0gKiBiWzE3XSk7XG4gICAgICAgIG91dFs4XSA9IChhWzVdICogYlszXSkgKyAoYVs2XSAqIGJbOF0pICsgKGFbN10gKiBiWzEzXSkgKyAoYVs4XSAqIGJbMThdKTtcbiAgICAgICAgb3V0WzldID0gKGFbNV0gKiBiWzRdKSArIChhWzZdICogYls5XSkgKyAoYVs3XSAqIGJbMTRdKSArIChhWzhdICogYlsxOV0pICsgYVs5XTtcbiAgICAgICAgLy8gQmx1ZSBDaGFubmVsXG4gICAgICAgIG91dFsxMF0gPSAoYVsxMF0gKiBiWzBdKSArIChhWzExXSAqIGJbNV0pICsgKGFbMTJdICogYlsxMF0pICsgKGFbMTNdICogYlsxNV0pO1xuICAgICAgICBvdXRbMTFdID0gKGFbMTBdICogYlsxXSkgKyAoYVsxMV0gKiBiWzZdKSArIChhWzEyXSAqIGJbMTFdKSArIChhWzEzXSAqIGJbMTZdKTtcbiAgICAgICAgb3V0WzEyXSA9IChhWzEwXSAqIGJbMl0pICsgKGFbMTFdICogYls3XSkgKyAoYVsxMl0gKiBiWzEyXSkgKyAoYVsxM10gKiBiWzE3XSk7XG4gICAgICAgIG91dFsxM10gPSAoYVsxMF0gKiBiWzNdKSArIChhWzExXSAqIGJbOF0pICsgKGFbMTJdICogYlsxM10pICsgKGFbMTNdICogYlsxOF0pO1xuICAgICAgICBvdXRbMTRdID0gKGFbMTBdICogYls0XSkgKyAoYVsxMV0gKiBiWzldKSArIChhWzEyXSAqIGJbMTRdKSArIChhWzEzXSAqIGJbMTldKSArIGFbMTRdO1xuICAgICAgICAvLyBBbHBoYSBDaGFubmVsXG4gICAgICAgIG91dFsxNV0gPSAoYVsxNV0gKiBiWzBdKSArIChhWzE2XSAqIGJbNV0pICsgKGFbMTddICogYlsxMF0pICsgKGFbMThdICogYlsxNV0pO1xuICAgICAgICBvdXRbMTZdID0gKGFbMTVdICogYlsxXSkgKyAoYVsxNl0gKiBiWzZdKSArIChhWzE3XSAqIGJbMTFdKSArIChhWzE4XSAqIGJbMTZdKTtcbiAgICAgICAgb3V0WzE3XSA9IChhWzE1XSAqIGJbMl0pICsgKGFbMTZdICogYls3XSkgKyAoYVsxN10gKiBiWzEyXSkgKyAoYVsxOF0gKiBiWzE3XSk7XG4gICAgICAgIG91dFsxOF0gPSAoYVsxNV0gKiBiWzNdKSArIChhWzE2XSAqIGJbOF0pICsgKGFbMTddICogYlsxM10pICsgKGFbMThdICogYlsxOF0pO1xuICAgICAgICBvdXRbMTldID0gKGFbMTVdICogYls0XSkgKyAoYVsxNl0gKiBiWzldKSArIChhWzE3XSAqIGJbMTRdKSArIChhWzE4XSAqIGJbMTldKSArIGFbMTldO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRmxvYXQzMiBBcnJheSBhbmQgbm9ybWFsaXplIHRoZSBvZmZzZXQgY29tcG9uZW50IHRvIDAtMVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtYXRyaXggLSA1eDQgbWF0cml4XG4gICAgICogQHJldHVybiB7bnVtYmVyW119IDV4NCBtYXRyaXggd2l0aCBhbGwgdmFsdWVzIGJldHdlZW4gMC0xXG4gICAgICovXG4gICAgX2NvbG9yTWF0cml4KG1hdHJpeCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBGbG9hdDMyIEFycmF5IGFuZCBub3JtYWxpemUgdGhlIG9mZnNldCBjb21wb25lbnQgdG8gMC0xXG4gICAgICAgIHZhciBtID0gbmV3IEZsb2F0MzJBcnJheShtYXRyaXgpO1xuICAgICAgICBtWzRdIC89IDI1NTtcbiAgICAgICAgbVs5XSAvPSAyNTU7XG4gICAgICAgIG1bMTRdIC89IDI1NTtcbiAgICAgICAgbVsxOV0gLz0gMjU1O1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkanVzdHMgYnJpZ2h0bmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSB2YWx1ZSBvZiB0aGUgYnJpZ3RobmVzcyAoMC0xLCB3aGVyZSAwIGlzIGJsYWNrKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGJyaWdodG5lc3MoYiwgbXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIGIsIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCBiLCAwLCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgYiwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWF0cmljZXMgaW4gZ3JleSBzY2FsZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIHZhbHVlIG9mIHRoZSBncmV5ICgwLTEsIHdoZXJlIDAgaXMgYmxhY2spXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgZ3JleXNjYWxlKHNjYWxlLCBtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcbiAgICAgICAgICAgIHNjYWxlLCBzY2FsZSwgc2NhbGUsIDAsIDAsXG4gICAgICAgICAgICBzY2FsZSwgc2NhbGUsIHNjYWxlLCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBibGFjayBhbmQgd2hpdGUgbWF0cmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGJsYWNrQW5kV2hpdGUobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXG4gICAgICAgICAgICAwLjMsIDAuNiwgMC4xLCAwLCAwLFxuICAgICAgICAgICAgMC4zLCAwLjYsIDAuMSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaHVlIHByb3BlcnR5IG9mIHRoZSBjb2xvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGh1ZShyb3RhdGlvbiwgbXVsdGlwbHkpIHtcbiAgICAgICAgcm90YXRpb24gPSAocm90YXRpb24gfHwgMCkgLyAxODAgKiBNYXRoLlBJO1xuICAgICAgICB2YXIgY29zUiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgICAgICAgdmFyIHNpblIgPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgICAgICAvKiBhIGdvb2QgYXBwcm94aW1hdGlvbiBmb3IgaHVlIHJvdGF0aW9uXG4gICAgICAgICAgICBUaGlzIG1hdHJpeCBpcyBmYXIgYmV0dGVyIHRoYW4gdGhlIHZlcnNpb25zIHdpdGggbWFnaWMgbHVtaW5hbmNlIGNvbnN0YW50c1xuICAgICAgICAgICAgZm9ybWVybHkgdXNlZCBoZXJlLCBidXQgYWxzbyB1c2VkIGluIHRoZSBzdGFybGluZyBmcmFtZXdvcmsgKGZsYXNoKSBhbmQga25vd24gZnJvbSB0aGlzXG4gICAgICAgICAgICBvbGQgcGFydCBvZiB0aGUgaW50ZXJuZXQ6IHF1YXNpbW9uZG8uY29tL2FyY2hpdmVzLzAwMDU2NS5waHBcblxuICAgICAgICAgICAgVGhpcyBuZXcgbWF0cml4IGlzIGJhc2VkIG9uIHJnYiBjdWJlIHJvdGF0aW9uIGluIHNwYWNlLiBMb29rIGhlcmUgZm9yIGEgbW9yZSBkZXNjcmlwdGl2ZVxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gYXMgYSBzaGFkZXIgbm90IGEgZ2VuZXJhbCBtYXRyaXg6XG4gICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iLzU4ODQxYzIzOTE5YmQ1OTc4N2VmZmMwMzMzYTQ4OTdiNDM4MzU0MTIvc3JjL2ZpbHRlcnMvYWRqdXN0L2h1ZXNhdHVyYXRpb24uanNcblxuICAgICAgICAgICAgVGhpcyBpcyB0aGUgc291cmNlIGZvciB0aGUgY29kZTpcbiAgICAgICAgICAgIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDc4ODUvc2hpZnQtaHVlLW9mLWFuLXJnYi1jb2xvci84NTEwNzUxIzg1MTA3NTFcbiAgICAgICAgICAgICovXG4gICAgICAgIHZhciB3ID0gMSAvIDM7XG4gICAgICAgIHZhciBzcXJXID0gc3FydCh3KTsgLy8gd2VpZ2h0IGlzXG4gICAgICAgIHZhciBhMDAgPSBjb3NSICsgKCgxLjAgLSBjb3NSKSAqIHcpO1xuICAgICAgICB2YXIgYTAxID0gKHcgKiAoMS4wIC0gY29zUikpIC0gKHNxclcgKiBzaW5SKTtcbiAgICAgICAgdmFyIGEwMiA9ICh3ICogKDEuMCAtIGNvc1IpKSArIChzcXJXICogc2luUik7XG4gICAgICAgIHZhciBhMTAgPSAodyAqICgxLjAgLSBjb3NSKSkgKyAoc3FyVyAqIHNpblIpO1xuICAgICAgICB2YXIgYTExID0gY29zUiArICh3ICogKDEuMCAtIGNvc1IpKTtcbiAgICAgICAgdmFyIGExMiA9ICh3ICogKDEuMCAtIGNvc1IpKSAtIChzcXJXICogc2luUik7XG4gICAgICAgIHZhciBhMjAgPSAodyAqICgxLjAgLSBjb3NSKSkgLSAoc3FyVyAqIHNpblIpO1xuICAgICAgICB2YXIgYTIxID0gKHcgKiAoMS4wIC0gY29zUikpICsgKHNxclcgKiBzaW5SKTtcbiAgICAgICAgdmFyIGEyMiA9IGNvc1IgKyAodyAqICgxLjAgLSBjb3NSKSk7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICBhMDAsIGEwMSwgYTAyLCAwLCAwLFxuICAgICAgICAgICAgYTEwLCBhMTEsIGExMiwgMCwgMCxcbiAgICAgICAgICAgIGEyMCwgYTIxLCBhMjIsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbnRyYXN0IG1hdHJpeCwgaW5jcmVhc2UgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBkYXJrIGFuZCBicmlnaHRcbiAgICAgKiBJbmNyZWFzZSBjb250cmFzdCA6IHNoYWRvd3MgZGFya2VyIGFuZCBoaWdobGlnaHRzIGJyaWdodGVyXG4gICAgICogRGVjcmVhc2UgY29udHJhc3QgOiBicmluZyB0aGUgc2hhZG93cyB1cCBhbmQgdGhlIGhpZ2hsaWdodHMgZG93blxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHZhbHVlIG9mIHRoZSBjb250cmFzdCAoMC0xKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGNvbnRyYXN0KGFtb3VudCwgbXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIHYgPSAoYW1vdW50IHx8IDApICsgMTtcbiAgICAgICAgdmFyIG8gPSAtMC41ICogKHYgLSAxKTtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIHYsIDAsIDAsIDAsIG8sXG4gICAgICAgICAgICAwLCB2LCAwLCAwLCBvLFxuICAgICAgICAgICAgMCwgMCwgdiwgMCwgbyxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2F0dXJhdGlvbiBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gY29sb3JzXG4gICAgICogSW5jcmVhc2Ugc2F0dXJhdGlvbiA6IGluY3JlYXNlIGNvbnRyYXN0LCBicmlnaHRuZXNzLCBhbmQgc2hhcnBuZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHNhdHVyYXRpb24gYW1vdW50ICgwLTEpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgc2F0dXJhdGUoYW1vdW50LCBtdWx0aXBseSA9IG51bGwpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gKGFtb3VudCAqIDIgLyAzKSArIDE7XG4gICAgICAgIHZhciB5ID0gKCh4IC0gMSkgKiAtMC41KTtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIHgsIHksIHksIDAsIDAsXG4gICAgICAgICAgICB5LCB4LCB5LCAwLCAwLFxuICAgICAgICAgICAgeSwgeSwgeCwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc2F0dXJhdGUgaW1hZ2UgKHJlbW92ZSBjb2xvcilcbiAgICAgKlxuICAgICAqIENhbGwgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXNhdHVyYXRlKCkge1xuICAgICAgICB0aGlzLnNhdHVyYXRlKC0xKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIE5lZ2F0aXZlIGltYWdlIChpbnZlcnNlIG9mIGNsYXNzaWMgcmdiIG1hdHJpeClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIG5lZ2F0aXZlKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICAtMSwgMCwgMCwgMSwgMCxcbiAgICAgICAgICAgIDAsIC0xLCAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgMCwgLTEsIDEsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXBpYSBpbWFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgc2VwaWEobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIDAuMzkzLCAwLjc2ODk5OTksIDAuMTg4OTk5OTksIDAsIDAsXG4gICAgICAgICAgICAwLjM0OSwgMC42ODU5OTk5LCAwLjE2Nzk5OTk5LCAwLCAwLFxuICAgICAgICAgICAgMC4yNzIsIDAuNTMzOTk5OSwgMC4xMzA5OTk5OSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENvbG9yIG1vdGlvbiBwaWN0dXJlIHByb2Nlc3MgaW52ZW50ZWQgaW4gMTkxNiAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHRlY2huaWNvbG9yKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICAxLjkxMjUyNzc4OTE0NTYwODMsIC0wLjg1NDUzNDQ5NzY5NTE2NDUsIC0wLjA5MTU1NTA4NDgyNzU1NTg1LCAwLCAxMS43OTM2MDM0MzQzNzczMzcsXG4gICAgICAgICAgICAtMC4zMDg3ODMzMzg1OTI4MDk3LCAxLjc2NTg5MDg1NTU0NTg0MjgsIC0wLjEwNjAxNzQzMDc0NzIyMjQ1LCAwLCAtNzAuMzUyMDUxNjE0NjEzOTgsXG4gICAgICAgICAgICAtMC4yMzExMDMzNzc1NDg2MTYsIC0wLjc1MDE4OTkxOTc0NDAyMTIsIDEuODQ3NTk3ODE2MTA4MTg5LCAwLCAzMC45NTA5NDA4Njk0OTExMzgsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQb2xhcm9pZCBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHBvbGFyb2lkKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICAxLjQzOCwgLTAuMDYyLCAtMC4wNjIsIDAsIDAsXG4gICAgICAgICAgICAtMC4xMjIsIDEuMzc4LCAtMC4xMjIsIDAsIDAsXG4gICAgICAgICAgICAtMC4wMTYsIC0wLjAxNiwgMS40ODMsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgd2hvIHRyYW5zZm9ybXMgOiBSZWQgLT4gQmx1ZSBhbmQgQmx1ZSAtPiBSZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHRvQkdSKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgICAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb2xvciByZXZlcnNhbCBmaWxtIGludHJvZHVjZWQgYnkgRWFzdG1hbiBLb2RhayBpbiAxOTM1LiAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGtvZGFjaHJvbWUobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxuICAgICAgICAgICAgLTAuMTY0MDQzMzk5NjIyNDQ2MTYsIDEuMDgzNTI1MTU2NjI5MTMwNCwgLTAuMDU0OTg4MDUxMTU2MzMxMzIsIDAsIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgICAgICAgIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLCAtMC41NjAzNDE2Mjc3Njk1MjQ4LCAxLjYwMTQ4NTA3NjE5NjQ5NDMsIDAsIDM1LjYyOTgyODA3NDYwOTQ2LFxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQnJvd24gZGVsaWNpb3VzIGJyb3duaSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cbiAgICBicm93bmkobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIDAuNTk5NzAyMzQ5ODE1OTcxNSwgMC4zNDU1MzI0MzA0ODM5MTI2MywgLTAuMjcwODI5ODY3NDUzODA0MiwgMCwgNDcuNDMxOTI4NTU2MDA4NzMsXG4gICAgICAgICAgICAtMC4wMzc3MDMyNDk4Mzc3ODMxNTcsIDAuODYwOTU3NzU4Nzk5MjY0MSwgMC4xNTA1OTU1MjM4ODQ1OTkxMywgMCwgLTM2Ljk2ODQxNDk4MzE5MTI3LFxuICAgICAgICAgICAgMC4yNDExMzYzNTEyODE1MzMzNSwgLTAuMDc0NDEwMzc5MDg0MjI0OTIsIDAuNDQ5NzIxODIwNjQ4NzcxNTMsIDAsIC03LjU2MjA3NTI3NzU5MTI4MyxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFZpbnRhZ2UgZmlsdGVyICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgdmludGFnZShtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgMC42Mjc5MzQ1NjM1NjA1OTk0LCAwLjMyMDIxODM0MjA4MTkzNjcsIC0wLjAzOTY1NDA4MjExMzEyNDUzLCAwLCA5LjY1MTI4NTgzNTI5NDEyMyxcbiAgICAgICAgICAgIDAuMDI1NzgzOTc3MDQ4MDg4NjgsIDAuNjQ0MTE4ODY0NDM3NDc3MSwgMC4wMzI1OTEyNzYxNjE0OTI5NCwgMCwgNy40NjI4MjkxNzY0NzA1OTEsXG4gICAgICAgICAgICAwLjA0NjYwNTU1NTY3ODI3MTksIC0wLjA4NTEyMzI5ODcyNDc4OTEsIDAuNTI0MTY0ODAxODcwMDQ2NSwgMCwgNS4xNTkxOTA1ODgyMzUyOTYsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBXZSBkb24ndCBrbm93IGV4YWN0bHkgd2hhdCBpdCBkb2VzLCBraW5kIG9mIGdyYWRpZW50IG1hcCwgYnV0IGZ1bm55IHRvIHBsYXkgd2l0aCFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXNhdHVyYXRpb24gLSBUb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9uZWQgLSBUb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGlnaHRDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhcmtDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgY29sb3JUb25lKGRlc2F0dXJhdGlvbiwgdG9uZWQsIGxpZ2h0Q29sb3IsIGRhcmtDb2xvciwgbXVsdGlwbHkpIHtcbiAgICAgICAgZGVzYXR1cmF0aW9uID0gZGVzYXR1cmF0aW9uIHx8IDAuMjtcbiAgICAgICAgdG9uZWQgPSB0b25lZCB8fCAwLjE1O1xuICAgICAgICBsaWdodENvbG9yID0gbGlnaHRDb2xvciB8fCAweEZGRTU4MDtcbiAgICAgICAgZGFya0NvbG9yID0gZGFya0NvbG9yIHx8IDB4MzM4MDAwO1xuICAgICAgICB2YXIgbFIgPSAoKGxpZ2h0Q29sb3IgPj4gMTYpICYgMHhGRikgLyAyNTU7XG4gICAgICAgIHZhciBsRyA9ICgobGlnaHRDb2xvciA+PiA4KSAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgbEIgPSAobGlnaHRDb2xvciAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgZFIgPSAoKGRhcmtDb2xvciA+PiAxNikgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgdmFyIGRHID0gKChkYXJrQ29sb3IgPj4gOCkgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgdmFyIGRCID0gKGRhcmtDb2xvciAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgMC4zLCAwLjU5LCAwLjExLCAwLCAwLFxuICAgICAgICAgICAgbFIsIGxHLCBsQiwgZGVzYXR1cmF0aW9uLCAwLFxuICAgICAgICAgICAgZFIsIGRHLCBkQiwgdG9uZWQsIDAsXG4gICAgICAgICAgICBsUiAtIGRSLCBsRyAtIGRHLCBsQiAtIGRCLCAwLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBOaWdodCBlZmZlY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlbnNpdHkgLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBuaWdodCBlZmZlY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgbmlnaHQoaW50ZW5zaXR5LCBtdWx0aXBseSkge1xuICAgICAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkgfHwgMC4xO1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgaW50ZW5zaXR5ICogKC0yLjApLCAtaW50ZW5zaXR5LCAwLCAwLCAwLFxuICAgICAgICAgICAgLWludGVuc2l0eSwgMCwgaW50ZW5zaXR5LCAwLCAwLFxuICAgICAgICAgICAgMCwgaW50ZW5zaXR5LCBpbnRlbnNpdHkgKiAyLjAsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQcmVkYXRvciBlZmZlY3RcbiAgICAgKlxuICAgICAqIEVyYXNlIHRoZSBjdXJyZW50IG1hdHJpeCBieSBzZXR0aW5nIGEgbmV3IGluZGVwZW50IG9uZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIGhvdyBtdWNoIHRoZSBwcmVkYXRvciBmZWVscyBoaXMgZnV0dXJlIHZpY3RpbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHByZWRhdG9yKGFtb3VudCwgbXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIC8vIHJvdyAxXG4gICAgICAgICAgICAxMS4yMjQxMzA2MzA0OTMxNjQgKiBhbW91bnQsXG4gICAgICAgICAgICAtNC43OTQ0ODY5OTk1MTE3MTkgKiBhbW91bnQsXG4gICAgICAgICAgICAtMi44NzQ2MTE4NTQ1NTMyMjI3ICogYW1vdW50LFxuICAgICAgICAgICAgMCAqIGFtb3VudCxcbiAgICAgICAgICAgIDAuNDAzNDI0MzgyMjA5Nzc3ODMgKiBhbW91bnQsXG4gICAgICAgICAgICAvLyByb3cgMlxuICAgICAgICAgICAgLTMuNjMzMDY5NzUzNjQ2ODUwNiAqIGFtb3VudCxcbiAgICAgICAgICAgIDkuMTkzMTU3MTk2MDQ0OTIyICogYW1vdW50LFxuICAgICAgICAgICAgLTIuOTUxODEwODM2NzkxOTkyICogYW1vdW50LFxuICAgICAgICAgICAgMCAqIGFtb3VudCxcbiAgICAgICAgICAgIC0xLjMxNjEzNTA0ODg2NjI3MiAqIGFtb3VudCxcbiAgICAgICAgICAgIC8vIHJvdyAzXG4gICAgICAgICAgICAtMy4yMTg0MTk3OTAyNjc5NDQzICogYW1vdW50LFxuICAgICAgICAgICAgLTQuMjM3NTAzMDUxNzU3ODEyNSAqIGFtb3VudCxcbiAgICAgICAgICAgIDcuNDc2NDQ4MDU5MDgyMDMxICogYW1vdW50LFxuICAgICAgICAgICAgMCAqIGFtb3VudCxcbiAgICAgICAgICAgIDAuODA0NDQ1OTIyMzc0NzI1MyAqIGFtb3VudCxcbiAgICAgICAgICAgIC8vIHJvdyA0XG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBMU0QgZWZmZWN0XG4gICAgICpcbiAgICAgKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGxzZChtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgMiwgLTAuNCwgMC41LCAwLCAwLFxuICAgICAgICAgICAgLTAuNSwgMiwgLTAuNCwgMCwgMCxcbiAgICAgICAgICAgIC0wLjQsIC0wLjUsIDMsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyB0aGUgZGVmYXVsdCBvbmVcbiAgICAgKlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgZmFsc2UpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIG1hdHJpeCBvZiB0aGUgY29sb3IgbWF0cml4IGZpbHRlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICogQGRlZmF1bHQgWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdXG4gICAgICovXG4gICAgZ2V0IG1hdHJpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBtYXRyaXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgb3BhY2l0eSB2YWx1ZSB0byB1c2Ugd2hlbiBtaXhpbmcgdGhlIG9yaWdpbmFsIGFuZCByZXN1bHRhbnQgY29sb3JzLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgdmFsdWUgaXMgMCwgdGhlIG9yaWdpbmFsIGNvbG9yIGlzIHVzZWQgd2l0aG91dCBtb2RpZmljYXRpb24uXG4gICAgICogV2hlbiB0aGUgdmFsdWUgaXMgMSwgdGhlIHJlc3VsdCBjb2xvciBpcyB1c2VkLlxuICAgICAqIFdoZW4gaW4gdGhlIHJhbmdlICgwLCAxKSB0aGUgY29sb3IgaXMgaW50ZXJwb2xhdGVkIGJldHdlZW4gdGhlIG9yaWdpbmFsIGFuZCByZXN1bHQgYnkgdGhpcyBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIGdldCBhbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbn1cbi8qIVxuKiBAcGl4aS9maWx0ZXItY29sb3ItbWF0cml4IC0gdjUuMC4wLXJjLjNcbiogQ29tcGlsZWQgV2VkLCAxMCBBcHIgMjAxOSAwMToyMToxNSBVVENcbipcbiogQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiovXG5Db2xvck1hdHJpeEZpbHRlci5mcmFnbWVudCQ0ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIGZsb2F0IG1bMjBdO1xcclxcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG5cXHJcXG4gICAgaWYgKHVBbHBoYSA9PSAwLjApIHtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGM7XFxyXFxuICAgICAgICByZXR1cm47XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cXHJcXG4gICAgaWYgKGMuYSA+IDAuMCkge1xcclxcbiAgICAgIGMucmdiIC89IGMuYTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICB2ZWM0IHJlc3VsdDtcXHJcXG5cXHJcXG4gICAgcmVzdWx0LnIgPSAobVswXSAqIGMucik7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVsxXSAqIGMuZyk7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVsyXSAqIGMuYik7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVszXSAqIGMuYSk7XFxyXFxuICAgICAgICByZXN1bHQuciArPSBtWzRdO1xcclxcblxcclxcbiAgICByZXN1bHQuZyA9IChtWzVdICogYy5yKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzZdICogYy5nKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzddICogYy5iKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzhdICogYy5hKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IG1bOV07XFxyXFxuXFxyXFxuICAgIHJlc3VsdC5iID0gKG1bMTBdICogYy5yKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTFdICogYy5nKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTJdICogYy5iKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTNdICogYy5hKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gbVsxNF07XFxyXFxuXFxyXFxuICAgIHJlc3VsdC5hID0gKG1bMTVdICogYy5yKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTZdICogYy5nKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTddICogYy5iKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMThdICogYy5hKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gbVsxOV07XFxyXFxuXFxyXFxuICAgIHZlYzMgcmdiID0gbWl4KGMucmdiLCByZXN1bHQucmdiLCB1QWxwaGEpO1xcclxcblxcclxcbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYSBhZ2Fpbi5cXHJcXG4gICAgcmdiICo9IHJlc3VsdC5hO1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYiwgcmVzdWx0LmEpO1xcclxcbn1cXHJcXG5cIjtcbmV4cG9ydHMuQ29sb3JNYXRyaXhGaWx0ZXIgPSBDb2xvck1hdHJpeEZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jbGFzcyBDb2xvclNldHRpbmdzIHtcbiAgICBzdGF0aWMgcHJlbXVsdGlwbHlUaW50KHRpbnQsIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFscGhhICogMjU1IDw8IDI0KSArIHRpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscGhhID09PSAwLjApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBSID0gKCh0aW50ID4+IDE2KSAmIDB4RkYpO1xuICAgICAgICB2YXIgRyA9ICgodGludCA+PiA4KSAmIDB4RkYpO1xuICAgICAgICB2YXIgQiA9ICh0aW50ICYgMHhGRik7XG4gICAgICAgIFIgPSAoKFIgKiBhbHBoYSkgKyAwLjUpIHwgMDtcbiAgICAgICAgRyA9ICgoRyAqIGFscGhhKSArIDAuNSkgfCAwO1xuICAgICAgICBCID0gKChCICogYWxwaGEpICsgMC41KSB8IDA7XG4gICAgICAgIHJldHVybiAoYWxwaGEgKiAyNTUgPDwgMjQpICsgKFIgPDwgMTYpICsgKEcgPDwgOCkgKyBCO1xuICAgIH1cbiAgICBzdGF0aWMgcHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRpbnQsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5KSB7XG4gICAgICAgIG91dCA9IG91dCB8fCBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBvdXRbMF0gPSAoKHRpbnQgPj4gMTYpICYgMHhGRikgLyAyNTUuMDtcbiAgICAgICAgb3V0WzFdID0gKCh0aW50ID4+IDgpICYgMHhGRikgLyAyNTUuMDtcbiAgICAgICAgb3V0WzJdID0gKHRpbnQgJiAweEZGKSAvIDI1NS4wO1xuICAgICAgICBpZiAocHJlbXVsdGlwbHkgfHwgcHJlbXVsdGlwbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0WzBdICo9IGFscGhhO1xuICAgICAgICAgICAgb3V0WzFdICo9IGFscGhhO1xuICAgICAgICAgICAgb3V0WzJdICo9IGFscGhhO1xuICAgICAgICB9XG4gICAgICAgIG91dFszXSA9IGFscGhhO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2luZ2xlQ29sb3IoY29sb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuaGV4MnN0cmluZyhjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGNvbG9yLmluZGV4T2YoJzB4JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoJzB4JywgJyMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDb2xvcihjb2xvcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29sb3JTZXR0aW5ncy5nZXRTaW5nbGVDb2xvcihjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29sb3JbaV0gPSBDb2xvclNldHRpbmdzLmdldFNpbmdsZUNvbG9yKGNvbG9yW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcHJlbXVsdGlwbHlSZ2JhKHJnYiwgYWxwaGEsIG91dCwgcHJlbXVsdGlwbHkpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIGlmIChwcmVtdWx0aXBseSB8fCBwcmVtdWx0aXBseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSByZ2JbMF0gKiBhbHBoYTtcbiAgICAgICAgICAgIG91dFsxXSA9IHJnYlsxXSAqIGFscGhhO1xuICAgICAgICAgICAgb3V0WzJdID0gcmdiWzJdICogYWxwaGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRbMF0gPSByZ2JbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSByZ2JbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSByZ2JbMl07XG4gICAgICAgIH1cbiAgICAgICAgb3V0WzNdID0gYWxwaGE7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsIGNvbG9yIG51bWJlciB0byBhbiBbUiwgRywgQl0gYXJyYXkgb2Ygbm9ybWFsaXplZCBmbG9hdHMgKG51bWJlcnMgZnJvbSAwLjAgdG8gMS4wKS5cbipcbiogQGV4YW1wbGVcbiogUElYSS51dGlscy5oZXgycmdiKDB4ZmZmZmZmKTsgLy8gcmV0dXJucyBbMSwgMSwgMV1cbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiogQGZ1bmN0aW9uIGhleDJyZ2JcbiogQHBhcmFtIHtudW1iZXJ9IGhleCAtIFRoZSBoZXhhZGVjaW1hbCBudW1iZXIgdG8gY29udmVydFxuKiBAcGFyYW0gIHtudW1iZXJbXX0gW291dD1bXV0gSWYgc3VwcGxpZWQsIHRoaXMgYXJyYXkgd2lsbCBiZSB1c2VkIHJhdGhlciB0aGFuIHJldHVybmluZyBhIG5ldyBvbmVcbiogQHJldHVybiB7bnVtYmVyW119IEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgW1IsIEcsIEJdIG9mIHRoZSBjb2xvciB3aGVyZSBhbGwgdmFsdWVzIGFyZSBmbG9hdHMuXG4qL1xuICAgIHN0YXRpYyBoZXgycmdiKGhleCwgb3V0ID0gbnVsbCkge1xuICAgICAgICBvdXQgPSBvdXQgfHwgW107XG4gICAgICAgIG91dFswXSA9ICgoaGV4ID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xuICAgICAgICBvdXRbMV0gPSAoKGhleCA+PiA4KSAmIDB4RkYpIC8gMjU1O1xuICAgICAgICBvdXRbMl0gPSAoaGV4ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuKiBDb252ZXJ0cyBhIGNvbG9yIGFzIGFuIFtSLCBHLCBCXSBhcnJheSBvZiBub3JtYWxpemVkIGZsb2F0cyB0byBhIGhleGFkZWNpbWFsIG51bWJlci5cbipcbiogQGV4YW1wbGVcbiogUElYSS51dGlscy5yZ2IyaGV4KFsxLCAxLCAxXSk7IC8vIHJldHVybnMgMHhmZmZmZmZcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiogQGZ1bmN0aW9uIHJnYjJoZXhcbiogQHBhcmFtIHtudW1iZXJbXX0gcmdiIC0gQXJyYXkgb2YgbnVtYmVycyB3aGVyZSBhbGwgdmFsdWVzIGFyZSBub3JtYWxpemVkIGZsb2F0cyBmcm9tIDAuMCB0byAxLjAuXG4qIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIGluIGhleGFkZWNpbWFsLlxuKi9cbiAgICBzdGF0aWMgcmdiMmhleChyZ2IpIHtcbiAgICAgICAgcmV0dXJuICgoKHJnYlswXSAqIDI1NSkgPDwgMTYpICsgKChyZ2JbMV0gKiAyNTUpIDw8IDgpICsgKHJnYlsyXSAqIDI1NSB8IDApKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbG9yU2V0dGluZ3MgPSBDb2xvclNldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBEaXNwbGF5T2JqZWN0XzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5T2JqZWN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY29uc3QgVXRpbHNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vVXRpbHNTZXR0aW5nc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgRGlzcGxheU9iamVjdF8xLkRpc3BsYXlPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFycmF5IG9mIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3RbXX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGNvbnRhaW5lciB3aWxsIHNvcnQgaXRzIGNoaWxkcmVuIGJ5IHpJbmRleCB2YWx1ZVxuICAgICAgICAgKiB3aGVuIHVwZGF0ZVRyYW5zZm9ybSgpIGlzIGNhbGxlZCwgb3IgbWFudWFsbHkgaWYgc29ydENoaWxkcmVuKCkgaXMgY2FsbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGFjdHVhbGx5IGNoYW5nZXMgdGhlIG9yZGVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheSwgc28gc2hvdWxkIGJlIHRyZWF0ZWRcbiAgICAgICAgICogYXMgYSBiYXNpYyBzb2x1dGlvbiB0aGF0IGlzIG5vdCBwZXJmb3JtYW50IGNvbXBhcmVkIHRvIG90aGVyIHNvbHV0aW9ucyxcbiAgICAgICAgICogc3VjaCBhcyBAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGktZGlzcGxheVxuICAgICAgICAgKlxuICAgICAgICAgKiBBbHNvIGJlIGF3YXJlIG9mIHRoYXQgdGhpcyBtYXkgbm90IHdvcmsgbmljZWx5IHdpdGggdGhlIGFkZENoaWxkQXQoKSBmdW5jdGlvbixcbiAgICAgICAgICogYXMgdGhlIHpJbmRleCBzb3J0aW5nIG1heSBjYXVzZSB0aGUgY2hpbGQgdG8gYXV0b21hdGljYWxseSBzb3J0ZWQgdG8gYW5vdGhlciBwb3NpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLlNPUlRBQkxFX0NISUxEUkVOXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuU09SVEFCTEVfQ0hJTERSRU47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgY2hpbGRyZW4gYmUgc29ydGVkIGJ5IHpJbmRleCBhdCB0aGUgbmV4dCB1cGRhdGVUcmFuc2Zvcm0gY2FsbC5cbiAgICAgICAgICogV2lsbCBnZXQgYXV0b21hdGljYWxseSBzZXQgdG8gdHJ1ZSBpZiBhIG5ldyBjaGlsZCBpcyBhZGRlZCwgb3IgaWYgYSBjaGlsZCdzIHpJbmRleCBjaGFuZ2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBEaXNwbGF5T2JqZWN0IGlzIGFkZGVkIHRvIHRoaXMgQ29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5Db250YWluZXIjY2hpbGRBZGRlZFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgYWRkZWQgdG8gdGhlIENvbnRhaW5lci5cbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB0aGF0IGFkZGVkIHRoZSBjaGlsZC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGNoaWxkcmVuJ3MgaW5kZXggb2YgdGhlIGFkZGVkIGNoaWxkLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBEaXNwbGF5T2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB0aGlzIENvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNyZW1vdmVkRnJvbVxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgcmVtb3ZlZCBmcm9tIHRoZSBDb250YWluZXIuXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdGhhdCByZW1vdmVkIHJlbW92ZWQgdGhlIGNoaWxkLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgZm9ybWVyIGNoaWxkcmVuJ3MgaW5kZXggb2YgdGhlIHJlbW92ZWQgY2hpbGRcbiAgICAgICAgICovXG4gICAgfVxuICAgIC8qKlxuICogUmV0dXJucyB0aGUgZGlzcGxheSBvYmplY3QgaW4gdGhlIGNvbnRhaW5lci5cbiAqXG4gKiBAbWV0aG9kIGdldENoaWxkQnlOYW1lXG4gKiBAbWVtYmVyb2YgUElYSS5Db250YWluZXIjXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIEluc3RhbmNlIG5hbWUuXG4gKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAqL1xuICAgIGdldENoaWxkQnlOYW1lKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBPdmVycmlkYWJsZSBtZXRob2QgdGhhdCBjYW4gYmUgdXNlZCBieSBDb250YWluZXIgc3ViY2xhc3NlcyB3aGVuZXZlciB0aGUgY2hpbGRyZW4gYXJyYXkgaXMgbW9kaWZpZWRcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkNoaWxkcmVuQ2hhbmdlKG9wdGlvbnMpIHtcbiAgICAgICAgLyogZW1wdHkgKi9cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgb25lIG9yIG1vcmUgY2hpbGRyZW4gdG8gdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIE11bHRpcGxlIGl0ZW1zIGNhbiBiZSBhZGRlZCBsaWtlIHNvOiBgbXlDb250YWluZXIuYWRkQ2hpbGQodGhpbmdPbmUsIHRoaW5nVHdvLCB0aGluZ1RocmVlKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uUElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBEaXNwbGF5T2JqZWN0KHMpIHRvIGFkZCB0byB0aGUgY29udGFpbmVyXG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgZmlyc3QgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXG4gICAgICovXG4gICAgYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cbiAgICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYXJndW1lbnRzIHByb3BlcnR5IGFuZCBhZGQgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXplZCBieSBKUyBydW50aW1lc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoYXJndW1lbnRzJDFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIGhhcyBhIHBhcmVudCB0aGVuIGxldHMgcmVtb3ZlIGl0IGFzIFBpeGlKUyBvYmplY3RzIGNhbiBvbmx5IGV4aXN0IGluIG9uZSBwbGFjZVxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5zb3J0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZW5zdXJlIGNoaWxkIHRyYW5zZm9ybSB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UodGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRBZGRlZFwiKSk7XG4gICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ2NoaWxkQWRkZWQnLCBjaGlsZCwgdGhpcywgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcImFkZGVkXCIpKTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmVtaXQoJ2FkZGVkJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoaWxkIHRvIHRoZSBjb250YWluZXIgYXQgYSBzcGVjaWZpZWQgaW5kZXguIElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gYWRkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIHBsYWNlIHRoZSBjaGlsZCBpblxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIGFkZGVkLlxuICAgICAqL1xuICAgIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChjaGlsZCArIFwiYWRkQ2hpbGRBdDogVGhlIGluZGV4IFwiICsgaW5kZXggKyBcIiBzdXBwbGllZCBpcyBvdXQgb2YgYm91bmRzIFwiICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSB0cnVlO1xuICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgICAgLy8gZW5zdXJlIGJvdW5kcyB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXG4gICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gICAgICAgIC8vIGNoaWxkLmVtaXQoJ2FkZGVkJywgdGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRBZGRlZFwiKSk7XG4gICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRBZGRlZCcsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN3YXBzIHRoZSBwb3NpdGlvbiBvZiAyIERpc3BsYXkgT2JqZWN0cyB3aXRoaW4gdGhpcyBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBGaXJzdCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkMiAtIFNlY29uZCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXG4gICAgICovXG4gICAgc3dhcENoaWxkcmVuKGNoaWxkLCBjaGlsZDIpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBjaGlsZDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2luZGV4MV0gPSBjaGlsZDI7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baW5kZXgyXSA9IGNoaWxkO1xuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgxIDwgaW5kZXgyID8gaW5kZXgxIDogaW5kZXgyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IHBvc2l0aW9uIG9mIGEgY2hpbGQgRGlzcGxheU9iamVjdCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgdG8gaWRlbnRpZnlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3QgdG8gaWRlbnRpZnlcbiAgICAgKi9cbiAgICBnZXRDaGlsZEluZGV4KGNoaWxkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiBhbiBleGlzdGluZyBjaGlsZCBpbiB0aGUgZGlzcGxheSBvYmplY3QgY29udGFpbmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgRGlzcGxheU9iamVjdCBpbnN0YW5jZSBmb3Igd2hpY2ggeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBpbmRleCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgcmVzdWx0aW5nIGluZGV4IG51bWJlciBmb3IgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0XG4gICAgICovXG4gICAgc2V0Q2hpbGRJbmRleChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlRoZSBpbmRleCBcIiArIGluZGV4ICsgXCIgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyBcIiArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgY3VycmVudEluZGV4LCAxKTsgLy8gcmVtb3ZlIGZyb20gb2xkIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7IC8vIGFkZCBhdCBuZXcgcG9zaXRpb25cbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGF0XG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBhbnkuXG4gICAgICovXG4gICAgZ2V0Q2hpbGRBdChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiZ2V0Q2hpbGRBdDogSW5kZXggKFwiICsgaW5kZXggKyBcIikgZG9lcyBub3QgZXhpc3QuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uUElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBEaXNwbGF5T2JqZWN0KHMpIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cbiAgICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYXJndW1lbnRzIHByb3BlcnR5IGFuZCBhZGQgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXplZCBieSBKUyBydW50aW1lc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoYXJndW1lbnRzJDFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG4gICAgICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxuICAgICAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmVtaXQoJ3JlbW92ZWQnLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRSZW1vdmVkXCIpKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRSZW1vdmVkJywgY2hpbGQsIHRoaXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaW5kZXgpO1xuICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkLi5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG4gICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgICAgICAvLyBjaGlsZC5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRSZW1vdmVkXCIpKTtcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdjaGlsZFJlbW92ZWQnLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgY29udGFpbmVyIHRoYXQgYXJlIHdpdGhpbiB0aGUgYmVnaW4gYW5kIGVuZCBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiZWdpbkluZGV4PTBdIC0gVGhlIGJlZ2lubmluZyBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZEluZGV4PXRoaXMuY2hpbGRyZW4ubGVuZ3RoXSAtIFRoZSBlbmRpbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqIEByZXR1cm5zIHtEaXNwbGF5T2JqZWN0W119IExpc3Qgb2YgcmVtb3ZlZCBjaGlsZHJlblxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkcmVuKGJlZ2luSW5kZXggPSAwLCBlbmRJbmRleCA9IEluZmluaXR5KSB7XG4gICAgICAgIGlmIChiZWdpbkluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGJlZ2luSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWdpbiA9IGJlZ2luSW5kZXg7XG4gICAgICAgIHZhciBlbmQgPSB0eXBlb2YgZW5kSW5kZXggPT09ICdudW1iZXInID8gZW5kSW5kZXggOiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdmFyIHJhbmdlID0gZW5kIC0gYmVnaW47XG4gICAgICAgIHZhciByZW1vdmVkO1xuICAgICAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZCkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGJlZ2luLCByYW5nZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRbaV0udHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRbaV0udHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoYmVnaW5JbmRleCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCByZW1vdmVkLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmVkW2kkMV0uZW1pdCgncmVtb3ZlZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRSZW1vdmVkXCIpKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ2NoaWxkUmVtb3ZlZCcsIHJlbW92ZWRbaSQxXSwgdGhpcywgaSQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlbW92ZUNoaWxkcmVuOiBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZS4nKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNvcnRzIGNoaWxkcmVuIGJ5IHpJbmRleC4gUHJldmlvdXMgb3JkZXIgaXMgbWFudGFpbmVkIGZvciAyIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUgekluZGV4LlxuICAgICAqL1xuICAgIHNvcnRDaGlsZHJlbigpIHtcbiAgICAgICAgdmFyIHNvcnRSZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY2hpbGQuX2xhc3RTb3J0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICBpZiAoIXNvcnRSZXF1aXJlZCAmJiBjaGlsZC56SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBzb3J0UmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0UmVxdWlyZWQgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNvcnQoQ29udGFpbmVyLnNvcnRDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvbiBhbGwgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIgZm9yIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ydGFibGVDaGlsZHJlbiAmJiB0aGlzLnNvcnREaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Q2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgcmVuZGVyIGZsYWdzLCBob3cgdG8gcHJvY2VzcyBzdHVmZiBoZXJlXG4gICAgICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIWNoaWxkLnJlbmRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICAgICAgLy8gVE9ETzogZmlsdGVyK21hc2ssIG5lZWQgdG8gbWFzayBib3RoIHNvbWVob3dcbiAgICAgICAgICAgIGlmIChjaGlsZC5fbWFzaykge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9tYXNrLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNNYXNrKGNoaWxkLl9ib3VuZHMsIGNoaWxkLl9tYXNrLl9ib3VuZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQuZmlsdGVyQXJlYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNBcmVhKGNoaWxkLl9ib3VuZHMsIGNoaWxkLmZpbHRlckFyZWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kcyhjaGlsZC5fYm91bmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0Qm91bmRzSUQgPSB0aGlzLl9ib3VuZHNJRDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QuIE92ZXJyaWRlIHRoaXMgdG9cbiAgICAgKiBjYWxjdWxhdGUgdGhlIGJvdW5kcyBvZiB0aGUgc3BlY2lmaWMgb2JqZWN0IChub3QgaW5jbHVkaW5nIGNoaWxkcmVuKS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgICAgICAvLyBGSUxMIElOLy9cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gYSBxdWljayBjaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IGhhcyBhIG1hc2sgb3IgYSBmaWx0ZXIuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrIHx8IHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJBZHZhbmNlZChyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICAgICAgLy8gc2ltcGxlIHJlbmRlciBjaGlsZHJlbiFcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBhbmQgYWR2YW5jZWQgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIHJlbmRlckFkdmFuY2VkKHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuICAgICAgICB2YXIgbWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgIC8vIHB1c2ggZmlsdGVyIGZpcnN0IGFzIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyBjb3JyZWN0IGZvciBhbnkgbWFza2luZ1xuICAgICAgICBpZiAoZmlsdGVycykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkRmlsdGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5wdXNoKGZpbHRlcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5maWx0ZXIucHVzaCh0aGlzLCB0aGlzLl9lbmFibGVkRmlsdGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2sucHVzaCh0aGlzLCB0aGlzLl9tYXNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhpcyBvYmplY3QgdG8gdGhlIGJhdGNoLCBvbmx5IHJlbmRlcmVkIGlmIGl0IGhhcyBhIHRleHR1cmUuXG4gICAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIC8vIG5vdyBsb29wIHRocm91Z2ggdGhlIGNoaWxkcmVuIGFuZCBtYWtlIHN1cmUgdGhleSBnZXQgcmVuZGVyZWRcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpJDEgPCBqOyBpJDErKykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpJDFdLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2sucG9wKHRoaXMsIHRoaXMuX21hc2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgd2hlcmUgY29udGVudCBpdHNlbGYgZ2V0cyByZW5kZXJlZC4uLlxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaW50ZXJuYWwgcmVmZXJlbmNlcyBhbmQgbGlzdGVuZXJzIGFzIHdlbGwgYXMgcmVtb3ZlcyBjaGlsZHJlbiBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuXG4gICAgICogRG8gbm90IHVzZSBhIENvbnRhaW5lciBhZnRlciBjYWxsaW5nIGBkZXN0cm95YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgICAqICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBkZXN0cm95Q2hpbGRyZW4gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMgJiYgb3B0aW9ucy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG9sZENoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIGlmIChkZXN0cm95Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBvbGRDaGlsZHJlbltpXS5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuICAgICAgICBpZiAod2lkdGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueSAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xuICAgICAgICBpZiAoaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0aWMgc29ydENoaWxkcmVuKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuekluZGV4ID09PSBiLnpJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGEuX2xhc3RTb3J0ZWRJbmRleCAtIGIuX2xhc3RTb3J0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS56SW5kZXggLSBiLnpJbmRleDtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRhaW5lciA9IENvbnRhaW5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIENvbnRleHRTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVpdGhlciAxIG9yIDIgdG8gcmVmbGVjdCB0aGUgV2ViR0wgdmVyc2lvbiBiZWluZyB1c2VkXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlbnNpb25zIGJlaW5nIHVzZWRcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQHByb3BlcnR5IHtXRUJHTF9kcmF3X2J1ZmZlcnN9IGRyYXdCdWZmZXJzIC0gV2ViR0wgdjEgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7V0VCR0xfZGVwdGhfdGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gV2ViR0wgdjEgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T0VTX3RleHR1cmVfZmxvYXR9IGZsb2F0VGV4dHVyZSAtIFdlYkdMIHYxIGV4dGVuc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkge1dFQkdMX2xvc2VfY29udGV4dH0gbG9zZUNvbnRleHQgLSBXZWJHTCB2MSBleHRlbnNpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtPRVNfdmVydGV4X2FycmF5X29iamVjdH0gdmVydGV4QXJyYXlPYmplY3QgLSBXZWJHTCB2MSBleHRlbnNpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgICAvLyBCaW5kIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRMb3N0ID0gdGhpcy5oYW5kbGVDb250ZXh0TG9zdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcyk7XG4gICAgICAgIHJlbmRlcmVyLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QsIGZhbHNlKTtcbiAgICAgICAgcmVuZGVyZXIudmlldy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0cnVlYCBpZiB0aGUgY29udGV4dCBpcyBsb3N0XG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgaXNMb3N0KCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmdsIHx8IHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgY29udGV4dCBjaGFuZ2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgbmV3IHdlYmdsIGNvbnRleHRcbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgLy8gcmVzdG9yZSBhIGNvbnRleHQgaWYgaXQgd2FzIHByZXZpb3VzbHkgbG9zdFxuICAgICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpICYmIGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykpIHtcbiAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykucmVzdG9yZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY29udGV4dFxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFdlYkdMIGNvbnRleHRcbiAgICAgKi9cbiAgICBpbml0RnJvbUNvbnRleHQoZ2wpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnZhbGlkYXRlQ29udGV4dChnbCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRCA9IENvbnRleHRTeXN0ZW0uQ09OVEVYVF9VSUQrKztcbiAgICAgICAgLy8gdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50LmdldEV2ZW50KFwiY29udGV4dGNoYW5nZVwiKSlcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UucnVuKGdsKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZnJvbSBjb250ZXh0IG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjb250ZXh0IGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBpbml0RnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNyZWF0ZUNvbnRleHQodGhpcy5yZW5kZXJlci52aWV3LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5pbml0RnJvbUNvbnRleHQoZ2wpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIFdlYkdMIENvbnRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY2FudmFzIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGdldCB0aGUgY29udGV4dCBmcm9tXG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBnZXRzIHBhc3NlZCBpbiB0byB0aGUgY2FudmFzIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29udGV4dCBhdHRyaWJ1dGVzXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvZ2V0Q29udGV4dFxuICAgICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgKi9cbiAgICBjcmVhdGVDb250ZXh0KGNhbnZhcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZ2w7XG4gICAgICAgIGlmIChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUFJFRkVSX0VOViA+PSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuRU5WLldFQkdMMikge1xuICAgICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsKSB7XG4gICAgICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDE7XG4gICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFnbCkge1xuICAgICAgICAgICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XG4gICAgICAgIHJldHVybiBnbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEF1dG8tcG9wdWxhdGUgdGhlIGV4dGVuc2lvbnNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXRFeHRlbnNpb25zKCkge1xuICAgICAgICAvLyB0aW1lIHRvIHNldCB1cCBkZWZhdWx0IGV4dGVuc2lvbnMgdGhhdCBQaXhpIHVzZXMuXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHtcbiAgICAgICAgICAgICAgICBkcmF3QnVmZmVyczogZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICAgICAgICAgICAgICBkZXB0aFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX1dFQkdMX2RlcHRoX3RleHR1cmUnKSxcbiAgICAgICAgICAgICAgICBmbG9hdFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgICAgICAgICAgICBsb3NlQ29udGV4dDogZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhBcnJheU9iamVjdDogZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpXG4gICAgICAgICAgICAgICAgICAgIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGRvbid0IHVzZSBhbnkgc3BlY2lmaWMgV2ViR0wgMiBvbmVzIHlldCFcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1dlYkdMQ29udGV4dEV2ZW50fSBldmVudCAtIFRoZSBjb250ZXh0IGxvc3QgZXZlbnQuXG4gICAgICovXG4gICAgaGFuZGxlQ29udGV4dExvc3QoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSByZXN0b3JlZCB3ZWJnbCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaGFuZGxlQ29udGV4dFJlc3RvcmVkKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5ydW4odGhpcy5nbCk7XG4gICAgfVxuICAgIDtcbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMucmVuZGVyZXIudmlldztcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyc1xuICAgICAgICB2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0KTtcbiAgICAgICAgdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKTtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBwb3N0LXJlbmRlciBydW5uZXIgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwb3N0cmVuZGVyKCkge1xuICAgICAgICB0aGlzLmdsLmZsdXNoKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gUmVuZGVyIGNvbnRleHRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUNvbnRleHQoZ2wpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgICAgICAvLyB0aGlzIGlzIGdvaW5nIHRvIGJlIGZhaXJseSBzaW1wbGUgZm9yIG5vdy4uIGJ1dCBhdCBsZWFzdCB3ZSBoYXZlIHJvb20gdG8gZ3JvdyFcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLnN0ZW5jaWwpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUHJvdmlkZWQgV2ViR0wgY29udGV4dCBkb2VzIG5vdCBoYXZlIGEgc3RlbmNpbCBidWZmZXIsIG1hc2tzIG1heSBub3QgcmVuZGVyIGNvcnJlY3RseScpO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG5Db250ZXh0U3lzdGVtLkNPTlRFWFRfVUlEID0gMDtcbmV4cG9ydHMuQ29udGV4dFN5c3RlbSA9IENvbnRleHRTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENvdW50TGltaXRlciB7XG4gICAgY29uc3RydWN0b3IobWF4SXRlbXNQZXJGcmFtZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBwcmVwYXJlZCBlYWNoIGZyYW1lLlxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhJdGVtc1BlckZyYW1lID0gbWF4SXRlbXNQZXJGcmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBjYW4gYmUgcHJlcGFyZWQgaW4gdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1zTGVmdCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbnkgY291bnRpbmcgcHJvcGVydGllcyB0byBzdGFydCBmcmVzaCBvbiBhIG5ldyBmcmFtZS5cbiAgICAgKi9cbiAgICBiZWdpbkZyYW1lKCkge1xuICAgICAgICB0aGlzLml0ZW1zTGVmdCA9IHRoaXMubWF4SXRlbXNQZXJGcmFtZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgYW5vdGhlciBpdGVtIGNhbiBiZSB1cGxvYWRlZC4gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgaXRlbS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgaXRlbSBpcyBhbGxvd2VkIHRvIGJlIHVwbG9hZGVkLlxuICAgICAqL1xuICAgIGFsbG93ZWRUb1VwbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNMZWZ0LS0gPiAwO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkNvdW50TGltaXRlciA9IENvdW50TGltaXRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXJyYXlSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQXJyYXlSZXNvdXJjZVwiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBDdWJlUmVzb3VyY2UgZXh0ZW5kcyBBcnJheVJlc291cmNlXzEuQXJyYXlSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IEN1YmVSZXNvdXJjZS5TSURFUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkludmFsaWQgbGVuZ3RoLiBHb3QgXCIgKyAodGhpcy5sZW5ndGgpICsgXCIsIGV4cGVjdGVkIDZcIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ3ViZVJlc291cmNlLlNJREVTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0udGFyZ2V0ID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGJpbmRpbmdcbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBwYXJlbnQgYmFzZSB0ZXh0dXJlXG4gICAgICovXG4gICAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgICAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgYmFzZVRleHR1cmUudGFyZ2V0ID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkIHRoZSByZXNvdXJjZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaXMgc3VjY2Vzc1xuICAgICAqL1xuICAgIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICB2YXIgZGlydHkgPSB0aGlzLml0ZW1EaXJ0eUlkcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDdWJlUmVzb3VyY2UuU0lERVM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNpZGUgPSB0aGlzLml0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGRpcnR5W2ldIDwgc2lkZS5kaXJ0eUlkKSB7XG4gICAgICAgICAgICAgICAgZGlydHlbaV0gPSBzaWRlLmRpcnR5SWQ7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZS5yZXNvdXJjZS51cGxvYWQocmVuZGVyZXIsIHNpZGUsIGdsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICA7XG59XG4vKipcbiogTnVtYmVyIG9mIHRleHR1cmUgc2lkZXMgdG8gc3RvcmUgZm9yIEN1YmVSZXNvdXJjZXNcbipcbiogQG5hbWUgUElYSS5yZXNvdXJjZXMuQ3ViZVJlc291cmNlLlNJREVTXG4qIEBzdGF0aWNcbiogQG1lbWJlciB7bnVtYmVyfVxuKiBAZGVmYXVsdCA2XG4qL1xuQ3ViZVJlc291cmNlLlNJREVTID0gNjtcbmV4cG9ydHMuQ3ViZVJlc291cmNlID0gQ3ViZVJlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCdWZmZXJSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQnVmZmVyUmVzb3VyY2VcIik7XG5jbGFzcyBEZXB0aFJlc291cmNlIGV4dGVuZHMgQnVmZmVyUmVzb3VyY2VfMS5CdWZmZXJSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcbiAgICAgICAgaWYgKGdsVGV4dHVyZS53aWR0aCA9PT0gYmFzZVRleHR1cmUud2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gYmFzZVRleHR1cmUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gYmFzZVRleHR1cmUud2lkdGg7XG4gICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCAvLyBOZWVkZWQgZm9yIGRlcHRoIHRvIHJlbmRlciBwcm9wZXJseSBpbiB3ZWJnbDIuMFxuICAgICAgICAgICAgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkRlcHRoUmVzb3VyY2UgPSBEZXB0aFJlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xuY2xhc3MgRGlzcGxhY2VtZW50RmlsdGVyIGV4dGVuZHMgRmlsdGVyXzEuRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGUsIHNjYWxlID0gMSkge1xuICAgICAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcbiAgICAgICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgc3VwZXIoRGlzcGxhY2VtZW50RmlsdGVyLnZlcnRleCQ0LCBEaXNwbGFjZW1lbnRGaWx0ZXIuZnJhZ21lbnQkNSwgeyBtYXBTYW1wbGVyOiBzcHJpdGUuX3RleHR1cmUsIGZpbHRlck1hdHJpeDogbWFza01hdHJpeCwgc2NhbGU6IHsgeDogMSwgeTogMSB9LCByb3RhdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMV0pLCB9KTtcbiAgICAgICAgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xuICAgICAgICB0aGlzLm1hc2tNYXRyaXggPSBtYXNrTWF0cml4O1xuICAgICAgICBpZiAoc2NhbGUgPT09IG51bGwgfHwgc2NhbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NhbGUgPSAyMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogc2NhbGVYLCBzY2FsZVkgZm9yIGRpc3BsYWNlbWVudHNcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgUG9pbnRfMS5Qb2ludChzY2FsZSwgc2NhbGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuc3lzdGVtcy5GaWx0ZXJTeXN0ZW19IGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgb3V0cHV0IHRhcmdldC5cbiAgICAgKi9cbiAgICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0KSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuZmlsdGVyTWF0cml4ID0gZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVTcHJpdGVNYXRyaXgodGhpcy5tYXNrTWF0cml4LCB0aGlzLm1hc2tTcHJpdGUpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnggPSB0aGlzLnNjYWxlLng7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuc2NhbGUueSA9IHRoaXMuc2NhbGUueTtcbiAgICAgICAgLy8gRXh0cmFjdCByb3RhdGlvbiBmcm9tIHdvcmxkIHRyYW5zZm9ybVxuICAgICAgICB2YXIgd3QgPSB0aGlzLm1hc2tTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgbGVuWCA9IE1hdGguc3FydCgod3QuYSAqIHd0LmEpICsgKHd0LmIgKiB3dC5iKSk7XG4gICAgICAgIHZhciBsZW5ZID0gTWF0aC5zcXJ0KCh3dC5jICogd3QuYykgKyAod3QuZCAqIHd0LmQpKTtcbiAgICAgICAgaWYgKGxlblggIT09IDAgJiYgbGVuWSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblswXSA9IHd0LmEgLyBsZW5YO1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsxXSA9IHd0LmIgLyBsZW5YO1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsyXSA9IHd0LmMgLyBsZW5ZO1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblszXSA9IHd0LmQgLyBsZW5ZO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRyYXcgdGhlIGZpbHRlci4uLlxuICAgICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbWVudCBtYXAuIE11c3QgYmUgcG93ZXIgb2YgMiBzaXplZCB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxuICAgICAqL1xuICAgIGdldCBtYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm1hcFNhbXBsZXI7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWFwKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlciA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG59XG5EaXNwbGFjZW1lbnRGaWx0ZXIuZnJhZ21lbnQkNSA9IFwidmFyeWluZyB2ZWMyIHZGaWx0ZXJDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzIgc2NhbGU7XFxyXFxudW5pZm9ybSBtYXQyIHJvdGF0aW9uO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcFNhbXBsZXI7XFxyXFxuXFxyXFxudW5pZm9ybSBoaWdocCB2ZWM0IGlucHV0U2l6ZTtcXHJcXG51bmlmb3JtIHZlYzQgaW5wdXRDbGFtcDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICB2ZWM0IG1hcCA9ICB0ZXh0dXJlMkQobWFwU2FtcGxlciwgdkZpbHRlckNvb3JkKTtcXHJcXG5cXHJcXG4gIG1hcCAtPSAwLjU7XFxyXFxuICBtYXAueHkgPSBzY2FsZSAqIGlucHV0U2l6ZS56dyAqIChyb3RhdGlvbiAqIG1hcC54eSk7XFxyXFxuXFxyXFxuICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNsYW1wKHZlYzIodlRleHR1cmVDb29yZC54ICsgbWFwLngsIHZUZXh0dXJlQ29vcmQueSArIG1hcC55KSwgaW5wdXRDbGFtcC54eSwgaW5wdXRDbGFtcC56dykpO1xcclxcbn1cXHJcXG5cIjtcbkRpc3BsYWNlbWVudEZpbHRlci52ZXJ0ZXgkNCA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyBmaWx0ZXJNYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZGaWx0ZXJDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xcclxcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXHJcXG5cXHJcXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXHJcXG57XFxyXFxuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcclxcblxcclxcbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxufVxcclxcblxcclxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXHJcXG57XFxyXFxuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuXFx0Z2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcclxcblxcdHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXHJcXG5cXHR2RmlsdGVyQ29vcmQgPSAoIGZpbHRlck1hdHJpeCAqIHZlYzMoIHZUZXh0dXJlQ29vcmQsIDEuMCkgICkueHk7XFxyXFxufVxcclxcblwiO1xuZXhwb3J0cy5EaXNwbGFjZW1lbnRGaWx0ZXIgPSBEaXNwbGFjZW1lbnRGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1JlbmRlclRleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgQm91bmRzXzEgPSByZXF1aXJlKFwiLi9Cb3VuZHNcIik7XG5jb25zdCBUcmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL1RyYW5zZm9ybVwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jbGFzcyBEaXNwbGF5T2JqZWN0IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyohXG4gKiBAcGl4aS9taXhpbi1nZXQtY2hpbGQtYnktbmFtZSAtIHY1LjAuMC1yYy4zXG4gKiBDb21waWxlZCBXZWQsIDEwIEFwciAyMDE5IDAxOjIxOjE1IFVUQ1xuICpcbiAqIEBwaXhpL21peGluLWdldC1jaGlsZC1ieS1uYW1lIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG5hbWUgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogIEZsYWcgZm9yIGlmIHRoZSBvYmplY3QgaXMgYWNjZXNzaWJsZS4gSWYgdHJ1ZSBBY2Nlc3NpYmlsaXR5TWFuYWdlciB3aWxsIG92ZXJsYXkgYVxuICAgICAgICAgKiAgIHNoYWRvdyBkaXYgd2l0aCBhdHRyaWJ1dGVzIHNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY2Nlc3NpYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB0aXRsZSBhdHRyaWJ1dGUgb2YgdGhlIHNoYWRvdyBkaXZcbiAgICAgICAgICogSWYgYWNjZXNzaWJsZVRpdGxlIEFORCBhY2Nlc3NpYmxlSGludCBoYXMgbm90IGJlZW4gdGhpcyB3aWxsIGRlZmF1bHQgdG8gJ2Rpc3BsYXlPYmplY3QgW3RhYkluZGV4XSdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7P3N0cmluZ31cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNjZXNzaWJsZVRpdGxlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9mIHRoZSBzaGFkb3cgZGl2XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNjZXNzaWJsZUhpbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgICAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FjY2Vzc2libGVEaXYgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICogRW5hYmxlIGludGVyYWN0aW9uIGV2ZW50cyBmb3IgdGhlIERpc3BsYXlPYmplY3QuIFRvdWNoLCBwb2ludGVyIGFuZCBtb3VzZVxuICAgICAgICAqIGV2ZW50cyB3aWxsIG5vdCBiZSBlbWl0dGVkIHVubGVzcyBgaW50ZXJhY3RpdmVgIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICAgICpcbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAgICAgICAgKiBzcHJpdGUuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAqIHNwcml0ZS5vbigndGFwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICogICAgLy9oYW5kbGUgZXZlbnRcbiAgICAgICAgKiB9KTtcbiAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGNoaWxkcmVuIHRvIHRoZSBkaXNwbGF5T2JqZWN0IGNhbiBiZSBjbGlja2VkL3RvdWNoZWRcbiAgICAgICAgICogU2V0dGluZyB0aGlzIHRvIGZhbHNlIGFsbG93cyBQaXhpSlMgdG8gYnlwYXNzIGEgcmVjdXJzaXZlIGBoaXRUZXN0YCBmdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5Db250YWluZXIjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJhY3Rpb24gc2hhcGUuIENoaWxkcmVuIHdpbGwgYmUgaGl0IGZpcnN0LCB0aGVuIHRoaXMgc2hhcGUgd2lsbCBiZSBjaGVja2VkLlxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgd2lsbCBjYXVzZSB0aGlzIHNoYXBlIHRvIGJlIGNoZWNrZWQgaW4gaGl0IHRlc3RzIHJhdGhlciB0aGFuIHRoZSBkaXNwbGF5T2JqZWN0J3MgYm91bmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAqIHNwcml0ZS5oaXRBcmVhID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKTtcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV8UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9XG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpdEFyZWEgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBkZWZpbmVzIHdoYXQgY3Vyc29yIG1vZGUgaXMgdXNlZCB3aGVuIHRoZSBtb3VzZSBjdXJzb3JcbiAgICAgICAgICogaXMgaG92ZXJlZCBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAqIHNwcml0ZS5jdXJzb3IgPSAnd2FpdCc7XG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQ1NTL2N1cnNvclxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgYWxsIHRyYWNrZWQgcG9pbnRlcnMsIGJ5IGlkZW50aWZpZXIuIFVzZSB0cmFja2VkUG9pbnRlcnMgdG8gYWNjZXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGE+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhY2tlZFBvaW50ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YSA9IGZhbHNlO1xuICAgICAgICAvLyBwZXJmb3JtYW5jZSBpbmNyZWFzZSB0byBhdm9pZCB1c2luZyBjYWxsLi4gKDEweCBmYXN0ZXIpXG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogbmVlZCB0byBjcmVhdGUgVHJhbnNmb3JtIGZyb20gZmFjdG9yeVxuICAgICAgICAvKipcbiAgICAgICAgICogV29ybGQgdHJhbnNmb3JtIGFuZCBsb2NhbCB0cmFuc2Zvcm0gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZWNvbWUgcmVhZC1vbmx5IGxhdGVyLCBwbGVhc2UgZG8gbm90IGFzc2lnbiBhbnl0aGluZyB0aGVyZSB1bmxlc3MgeW91IGtub3cgd2hhdCBhcmUgeW91IGRvaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybV8xLlRyYW5zZm9ybSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgb2JqZWN0LiBJZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduLCBhbmRcbiAgICAgICAgICogdGhlIHVwZGF0ZVRyYW5zZm9ybSBmdW5jdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgYWZmZWN0cyByZWN1cnNpdmUgY2FsbHMgZnJvbSBwYXJlbnQuIFlvdSBjYW4gYXNrIGZvciBib3VuZHMgb3IgY2FsbCB1cGRhdGVUcmFuc2Zvcm0gbWFudWFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHRoaXMgb2JqZWN0IGJlIHJlbmRlcmVkLCBpZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduIGJ1dCB0aGUgdXBkYXRlVHJhbnNmb3JtXG4gICAgICAgICAqIG1ldGhvZHMgd2lsbCBzdGlsbCBiZSBjYWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgYWZmZWN0cyByZWN1cnNpdmUgY2FsbHMgZnJvbSBwYXJlbnQuIFlvdSBjYW4gYXNrIGZvciBib3VuZHMgbWFudWFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQ29udGFpbmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtdWx0aXBsaWVkIGFscGhhIG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoaWNoIGluZGV4IGluIHRoZSBjaGlsZHJlbiBhcnJheSB0aGUgZGlzcGxheSBjb21wb25lbnQgd2FzIGJlZm9yZSB0aGUgcHJldmlvdXMgekluZGV4IHNvcnQuXG4gICAgICAgICAqIFVzZWQgYnkgY29udGFpbmVycyB0byBoZWxwIHNvcnQgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIHpJbmRleCwgYnkgdXNpbmcgcHJldmlvdXMgYXJyYXkgaW5kZXggYXMgdGhlIGRlY2lkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFNvcnRlZEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB6SW5kZXggb2YgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAgICAgICAqIEEgaGlnaGVyIHZhbHVlIHdpbGwgbWVhbiBpdCB3aWxsIGJlIHJlbmRlcmVkIG9uIHRvcCBvZiBvdGhlciBkaXNwbGF5T2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3pJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJlYSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQgdG8uIFRoaXMgaXMgdXNlZCBhcyBtb3JlIG9mIGFuIG9wdGltaXphdGlvblxuICAgICAgICAgKiByYXRoZXIgdGhhbiBmaWd1cmluZyBvdXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRpc3BsYXlPYmplY3QgZWFjaCBmcmFtZSB5b3UgY2FuIHNldCB0aGlzIHJlY3RhbmdsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQWxzbyB3b3JrcyBhcyBhbiBpbnRlcmFjdGlvbiBtYXNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHs/UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZmlsdGVycyBmb3IgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAgICAgICAqICogSU1QT1JUQU5UOiBUaGlzIGlzIGEgV2ViR0wgb25seSBmZWF0dXJlIGFuZCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICAgICAgICogVG8gcmVtb3ZlIGZpbHRlcnMgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvIGAnbnVsbCdgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHs/UElYSS5GaWx0ZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBib3VuZHMgb2JqZWN0LCB0aGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIGFuZCBzdG9yZSB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJvdW5kc31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kc18xLkJvdW5kcygpO1xuICAgICAgICB0aGlzLl9ib3VuZHNJRCA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RCb3VuZHNJRCA9IC0xO1xuICAgICAgICB0aGlzLl9ib3VuZHNSZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcmlnaW5hbCwgY2FjaGVkIG1hc2sgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHRoaXMgRGlzcGxheU9iamVjdCBpcyBhZGRlZCB0byBhIENvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNhZGRlZFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIGFkZGVkIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhpcyBEaXNwbGF5T2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBhIENvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNyZW1vdmVkXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgcmVtb3ZlZCBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkIHZpYSBkZXN0cm95KCkuIElmIHRydWUsIGl0IHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1c2VkIHRvIGZhc3QgY2hlY2sgaWYgYSBzcHJpdGUgaXMuLiBhIHNwcml0ZSFcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNTcHJpdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gKiBJbnRlcm5hbCBzZXQgb2YgYWxsIGFjdGl2ZSBwb2ludGVycywgYnkgaWRlbnRpZmllclxuICpcbiAqIEBtZW1iZXIge01hcDxudW1iZXIsIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhPn1cbiAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gKiBAcHJpdmF0ZVxuICovXG4gICAgZ2V0IHRyYWNrZWRQb2ludGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrZWRQb2ludGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFja2VkUG9pbnRlcnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tlZFBvaW50ZXJzO1xuICAgIH1cbiAgICAvKiFcbiAqIEBwaXhpL21peGluLWdldC1nbG9iYWwtcG9zaXRpb24gLSB2NS4wLjAtcmMuM1xuICogQ29tcGlsZWQgV2VkLCAxMCBBcHIgMjAxOSAwMToyMToxNSBVVENcbiAqXG4gKiBAcGl4aS9taXhpbi1nZXQtZ2xvYmFsLXBvc2l0aW9uIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGdsb2JhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdC4gRG9lcyBub3QgZGVwZW5kIG9uIG9iamVjdCBzY2FsZSwgcm90YXRpb24gYW5kIHBpdm90LlxuICAgICAqXG4gICAgICogQG1ldGhvZCBnZXRHbG9iYWxQb3NpdGlvblxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gd3JpdGUgdGhlIGdsb2JhbCB2YWx1ZSB0by4gSWYgbnVsbCBhIG5ldyBwb2ludCB3aWxsIGJlIHJldHVybmVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwVXBkYXRlIC0gU2V0dGluZyB0byB0cnVlIHdpbGwgc3RvcCB0aGUgdHJhbnNmb3JtcyBvZiB0aGUgc2NlbmUgZ3JhcGggZnJvbVxuICAgICAqICBiZWluZyB1cGRhdGVkLiBUaGlzIG1lYW5zIHRoZSBjYWxjdWxhdGlvbiByZXR1cm5lZCBNQVkgYmUgb3V0IG9mIGRhdGUgQlVUIHdpbGwgZ2l2ZSB5b3UgYVxuICAgICAqICBuaWNlIHBlcmZvcm1hbmNlIGJvb3N0LlxuICAgICAqIEByZXR1cm4ge1BvaW50fSBUaGUgdXBkYXRlZCBwb2ludC5cbiAgICAgKi9cbiAgICBnZXRHbG9iYWxQb3NpdGlvbihwb2ludCwgc2tpcFVwZGF0ZSkge1xuICAgICAgICBpZiAocG9pbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnRfMS5Qb2ludCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNraXBVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnRvR2xvYmFsKHRoaXMucG9zaXRpb24sIHBvaW50LCBza2lwVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50LnggPSB0aGlzLnBvc2l0aW9uLng7XG4gICAgICAgICAgICBwb2ludC55ID0gdGhpcy5wb3NpdGlvbi55O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogSWYgZW5hYmxlZCwgdGhlIG1vdXNlIGN1cnNvciB1c2UgdGhlIHBvaW50ZXIgYmVoYXZpb3Igd2hlbiBob3ZlcmVkIG92ZXIgdGhlIGRpc3BsYXlPYmplY3QgaWYgaXQgaXMgaW50ZXJhY3RpdmVcbiAqIFNldHRpbmcgdGhpcyBjaGFuZ2VzIHRoZSAnY3Vyc29yJyBwcm9wZXJ0eSB0byBgJ3BvaW50ZXInYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3Qgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuICogc3ByaXRlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAqIHNwcml0ZS5idXR0b25Nb2RlID0gdHJ1ZTtcbiAqIEBtZW1iZXIge2Jvb2xlYW59XG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICovXG4gICAgZ2V0IGJ1dHRvbk1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvciA9PT0gJ3BvaW50ZXInO1xuICAgIH1cbiAgICBzZXQgYnV0dG9uTW9kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vyc29yID09PSAncG9pbnRlcicpIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxuICAgICAqL1xuICAgIHN0YXRpYyBtaXhpbihzb3VyY2UpIHtcbiAgICAgICAgLy8gaW4gRVM4L0VTMjAxNywgdGhpcyB3b3VsZCBiZSByZWFsbHkgZWFzeTpcbiAgICAgICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgICAgLy8gZ2V0IGFsbCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBrZXlzXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHByb3BlcnRpZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0ga2V5c1tpXTtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgcHJvcGVydHkgdXNpbmcgdGhlIHByb3BlcnR5IGRlc2NyaXB0b3IgLSB0aGlzIHdvcmtzIGZvciBhY2Nlc3NvcnMgYW5kIG5vcm1hbCB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHByb3BlcnR5TmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXQgX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50KCkge1xuICAgICAgICBpZiAodGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG5ldyBEaXNwbGF5T2JqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBUT0RPIC0gT3B0aW1pemF0aW9uIHBhc3MhXG4gICAgICovXG4gICAgdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgLy8gbXVsdGlwbHkgdGhlIGFscGhhcy4uXG4gICAgICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICAgICAgICB0aGlzLl9ib3VuZHMudXBkYXRlSUQrKztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdHJhbnNmb3JtIG9mIGFsbCBvYmplY3RzIGZyb20gdGhlIHJvb3QgdG8gdGhpcyBvbmVcbiAgICAgKiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgdG9Mb2NhbCgpXG4gICAgICovXG4gICAgX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBVcGRhdGVdIC0gU2V0dGluZyB0byBgdHJ1ZWAgd2lsbCBzdG9wIHRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBzY2VuZSBncmFwaCBmcm9tXG4gICAgICogIGJlaW5nIHVwZGF0ZWQuIFRoaXMgbWVhbnMgdGhlIGNhbGN1bGF0aW9uIHJldHVybmVkIE1BWSBiZSBvdXQgb2YgZGF0ZSBCVVQgd2lsbCBnaXZlIHlvdSBhXG4gICAgICogIG5pY2UgcGVyZm9ybWFuY2UgYm9vc3QuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gW3JlY3RdIC0gT3B0aW9uYWwgcmVjdGFuZ2xlIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGJvdW5kcyBjYWxjdWxhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWEuXG4gICAgICovXG4gICAgZ2V0Qm91bmRzKHNraXBVcGRhdGUgPSB0cnVlLCByZWN0ID0gbnVsbCkge1xuICAgICAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kc0lEICE9PSB0aGlzLl9sYXN0Qm91bmRzSUQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2JvdW5kc1JlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdCA9IHRoaXMuX2JvdW5kc1JlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XG4gICAgfVxuICAgIDtcbiAgICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IFtyZWN0XSAtIE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb24uXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhLlxuICAgICAqL1xuICAgIGdldExvY2FsQm91bmRzKHJlY3QgPSBudWxsKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1SZWYgPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHBhcmVudFJlZiA9IHRoaXMucGFyZW50O1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQudHJhbnNmb3JtO1xuICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHNSZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoZmFsc2UsIHJlY3QpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFJlZjtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1SZWY7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcG9zaXRpb24gLSBUaGUgd29ybGQgb3JpZ2luIHRvIGNhbGN1bGF0ZSBmcm9tLlxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IFtwb2ludF0gLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsXG4gICAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBVcGRhdGU9ZmFsc2VdIC0gU2hvdWxkIHdlIHNraXAgdGhlIHVwZGF0ZSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7UElYSS5JUG9pbnR9IEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgdG9HbG9iYWwocG9zaXRpb24sIHBvaW50LCBza2lwVXBkYXRlKSB7XG4gICAgICAgIGlmIChza2lwVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNraXBVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIC8vIHRoaXMgcGFyZW50IGNoZWNrIGlzIGZvciBqdXN0IGluIGNhc2UgdGhlIGl0ZW0gaXMgYSByb290IG9iamVjdC5cbiAgICAgICAgICAgIC8vIElmIGl0IGlzIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBwYXJlbnQgc28gdGhhdCBkaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtIHdvcmtzIGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtYWlubHkgdG8gYXZvaWQgYSBwYXJlbnQgY2hlY2sgaW4gdGhlIG1haW4gbG9vcC4gRXZlcnkgbGl0dGxlIGhlbHBzIGZvciBwZXJmb3JtYW5jZSA6KVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIGxvdFxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseShwb3NpdGlvbiwgcG9pbnQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbG9jYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHJlbGF0aXZlIHRvIGFub3RoZXIgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IFtmcm9tXSAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgZ2xvYmFsIHBvc2l0aW9uIGZyb20uXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gW3BvaW50XSAtIEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWxcbiAgICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludCkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFVwZGF0ZT1mYWxzZV0gLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge1BJWEkuSVBvaW50fSBBIHBvaW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoaXMgb2JqZWN0XG4gICAgICovXG4gICAgdG9Mb2NhbChwb3NpdGlvbiwgZnJvbSwgcG9pbnQsIHNraXBVcGRhdGUpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgLy8gdGhpcyBwYXJlbnQgY2hlY2sgaXMgZm9yIGp1c3QgaW4gY2FzZSB0aGUgaXRlbSBpcyBhIHJvb3Qgb2JqZWN0LlxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgd2UgbmVlZCB0byBnaXZlIGl0IGEgdGVtcG9yYXJ5IHBhcmVudCBzbyB0aGF0IGRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0gd29ya3MgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1haW5seSB0byBhdm9pZCBhIHBhcmVudCBjaGVjayBpbiB0aGUgbWFpbiBsb29wLiBFdmVyeSBsaXR0bGUgaGVscHMgZm9yIHBlcmZvcm1hbmNlIDopXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzaW1wbHkgYXBwbHkgdGhlIG1hdHJpeC4uXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIE9WRVJXUklURTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGFyZW50IENvbnRhaW5lciBvZiB0aGlzIERpc3BsYXlPYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgQ29udGFpbmVyIHRvIGFkZCB0aGlzIERpc3BsYXlPYmplY3QgdG8uXG4gICAgICogQHJldHVybiB7UElYSS5Db250YWluZXJ9IFRoZSBDb250YWluZXIgdGhhdCB0aGlzIERpc3BsYXlPYmplY3Qgd2FzIGFkZGVkIHRvLlxuICAgICAqL1xuICAgIHNldFBhcmVudChjb250YWluZXIpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5hZGRDaGlsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRQYXJlbnQ6IEFyZ3VtZW50IG11c3QgYmUgYSBDb250YWluZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzZXQgdGhlIHBvc2l0aW9uLCBzY2FsZSwgc2tldyBhbmQgcGl2b3QgYXQgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSBYIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIFkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWD0xXSAtIFRoZSBYIHNjYWxlIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVk9MV0gLSBUaGUgWSBzY2FsZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcm90YXRpb249MF0gLSBUaGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NrZXdYPTBdIC0gVGhlIFggc2tldyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tld1k9MF0gLSBUaGUgWSBza2V3IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwaXZvdFg9MF0gLSBUaGUgWCBwaXZvdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl2b3RZPTBdIC0gVGhlIFkgcGl2b3QgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlXG4gICAgICovXG4gICAgc2V0VHJhbnNmb3JtKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCBwaXZvdFgsIHBpdm90WSkge1xuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbGVYID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYWxlWSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzY2FsZVkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByb3RhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNrZXdYID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNrZXdYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tld1kgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc2tld1kgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaXZvdFggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcGl2b3RYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGl2b3RZID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHBpdm90WSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0geTtcbiAgICAgICAgdGhpcy5zY2FsZS54ID0gIXNjYWxlWCA/IDEgOiBzY2FsZVg7XG4gICAgICAgIHRoaXMuc2NhbGUueSA9ICFzY2FsZVkgPyAxIDogc2NhbGVZO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHRoaXMuc2tldy54ID0gc2tld1g7XG4gICAgICAgIHRoaXMuc2tldy55ID0gc2tld1k7XG4gICAgICAgIHRoaXMucGl2b3QueCA9IHBpdm90WDtcbiAgICAgICAgdGhpcy5waXZvdC55ID0gcGl2b3RZO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEJhc2UgZGVzdHJveSBtZXRob2QgZm9yIGdlbmVyaWMgZGlzcGxheSBvYmplY3RzLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAqIHJlbW92ZSB0aGUgZGlzcGxheSBvYmplY3QgZnJvbSBpdHMgcGFyZW50IENvbnRhaW5lciBhcyB3ZWxsIGFzIHJlbW92ZVxuICAgICAqIGFsbCBjdXJyZW50IGV2ZW50IGxpc3RlbmVycyBhbmQgaW50ZXJuYWwgcmVmZXJlbmNlcy4gRG8gbm90IHVzZSBhIERpc3BsYXlPYmplY3RcbiAgICAgKiBhZnRlciBjYWxsaW5nIGBkZXN0cm95KClgLlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xuICAgICAgICAvLyB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi54XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgeCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHkgYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi55XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgeSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi55ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHdvcmxkIChwYXJlbnQpIGZhY3RvcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgd29ybGRUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gbG9jYWwgZmFjdG9yczogcG9zaXRpb24sIHNjYWxlLCBvdGhlciBzdHVmZi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBsb2NhbFRyYW5zZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLklQb2ludH1cbiAgICAgKi9cbiAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBwb3NpdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvYmplY3QuXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5JUG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2NhbGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUuY29weUZyb20odmFsdWUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHBpdm90IHBvaW50IG9mIHRoZSBkaXNwbGF5T2JqZWN0IHRoYXQgaXQgcm90YXRlcyBhcm91bmQuXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5JUG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHBpdm90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucGl2b3Q7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcGl2b3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucGl2b3QuY29weUZyb20odmFsdWUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHNrZXcgZmFjdG9yIGZvciB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHNrZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5za2V3O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHNrZXcodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2tldy5jb3B5RnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAqICdyb3RhdGlvbicgYW5kICdhbmdsZScgaGF2ZSB0aGUgc2FtZSBlZmZlY3Qgb24gYSBkaXNwbGF5IG9iamVjdDsgcm90YXRpb24gaXMgaW4gcmFkaWFucywgYW5nbGUgaXMgaW4gZGVncmVlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGFuZ2xlIG9mIHRoZSBvYmplY3QgaW4gZGVncmVlcy5cbiAgICAgKiAncm90YXRpb24nIGFuZCAnYW5nbGUnIGhhdmUgdGhlIHNhbWUgZWZmZWN0IG9uIGEgZGlzcGxheSBvYmplY3Q7IHJvdGF0aW9uIGlzIGluIHJhZGlhbnMsIGFuZ2xlIGlzIGluIGRlZ3JlZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gKiBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUkFEX1RPX0RFRztcbiAgICB9XG4gICAgO1xuICAgIHNldCBhbmdsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlICogTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLkRFR19UT19SQUQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgekluZGV4IG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAqIElmIGEgY29udGFpbmVyIGhhcyB0aGUgc29ydGFibGVDaGlsZHJlbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSwgY2hpbGRyZW4gd2lsbCBiZSBhdXRvbWF0aWNhbGx5XG4gICAgICogc29ydGVkIGJ5IHpJbmRleCB2YWx1ZTsgYSBoaWdoZXIgdmFsdWUgd2lsbCBtZWFuIGl0IHdpbGwgYmUgbW92ZWQgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBhcnJheSxcbiAgICAgKiBhbmQgdGh1cyByZW5kZXJlZCBvbiB0b3Agb2Ygb3RoZXIgZGlzcGxheU9iamVjdHMgd2l0aGluIHRoZSBzYW1lIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgekluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fekluZGV4O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHpJbmRleCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl96SW5kZXggPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5zb3J0RGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIG9iamVjdCBpcyBnbG9iYWxseSB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgd29ybGRWaXNpYmxlKCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xuICAgICAgICB9IHdoaWxlIChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbWFzayBmb3IgdGhlIGRpc3BsYXlPYmplY3QuIEEgbWFzayBpcyBhbiBvYmplY3QgdGhhdCBsaW1pdHMgdGhlIHZpc2liaWxpdHkgb2YgYW5cbiAgICAgKiBvYmplY3QgdG8gdGhlIHNoYXBlIG9mIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXQuIEluIFBpeGlKUyBhIHJlZ3VsYXIgbWFzayBtdXN0IGJlIGFcbiAgICAgKiB7QGxpbmsgUElYSS5HcmFwaGljc30gb3IgYSB7QGxpbmsgUElYSS5TcHJpdGV9IG9iamVjdC4gVGhpcyBhbGxvd3MgZm9yIG11Y2ggZmFzdGVyIG1hc2tpbmcgaW4gY2FudmFzIGFzIGl0XG4gICAgICogdXRpbGl0aWVzIHNoYXBlIGNsaXBwaW5nLiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBGb3Igc3ByaXRlIG1hc2sgYm90aCBhbHBoYSBhbmQgcmVkIGNoYW5uZWwgYXJlIHVzZWQuIEJsYWNrIG1hc2sgaXMgdGhlIHNhbWUgYXMgdHJhbnNwYXJlbnQgbWFzay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGdyYXBoaWNzID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcbiAgICAgKiBncmFwaGljcy5iZWdpbkZpbGwoMHhGRjMzMDApO1xuICAgICAqIGdyYXBoaWNzLmRyYXdSZWN0KDUwLCAyNTAsIDEwMCwgMTAwKTtcbiAgICAgKiBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICpcbiAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICogc3ByaXRlLm1hc2sgPSBncmFwaGljcztcbiAgICAgKiBAdG9kbyBBdCB0aGUgbW9tZW50LCBQSVhJLkNhbnZhc1JlbmRlcmVyIGRvZXNuJ3Qgc3VwcG9ydCBQSVhJLlNwcml0ZSBhcyBtYXNrLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cbiAgICAgKi9cbiAgICBnZXQgbWFzaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWFzayh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX21hc2suaXNNYXNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9tYXNrLmlzTWFzayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGlzIGRpc3BsYXkgb2JqZWN0IHRvIGJlIGNhY2hlZCBhcyBhIGJpdG1hcC5cbiAgICAgICAgICAgICAqIFRoaXMgYmFzaWNhbGx5IHRha2VzIGEgc25hcCBzaG90IG9mIHRoZSBkaXNwbGF5IG9iamVjdCBhcyBpdCBpcyBhdCB0aGF0IG1vbWVudC4gSXQgY2FuXG4gICAgICAgICAgICAgKiBwcm92aWRlIGEgcGVyZm9ybWFuY2UgYmVuZWZpdCBmb3IgY29tcGxleCBzdGF0aWMgZGlzcGxheU9iamVjdHMuXG4gICAgICAgICAgICAgKiBUbyByZW1vdmUgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJTVBPUlRBTlQgR09UQ0hBIC0gTWFrZSBzdXJlIHRoYXQgYWxsIHlvdXIgdGV4dHVyZXMgYXJlIHByZWxvYWRlZCBCRUZPUkUgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIHRydWVcbiAgICAgICAgICAgICAqIGFzIGl0IHdpbGwgdGFrZSBhIHNuYXBzaG90IG9mIHdoYXQgaXMgY3VycmVudGx5IHRoZXJlLiBJZiB0aGUgdGV4dHVyZXMgaGF2ZSBub3QgbG9hZGVkIHRoZW4gdGhleSB3aWxsIG5vdCBhcHBlYXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICAgICAgICAgKi9cbiAgICBnZXQgY2FjaGVBc0JpdG1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlQXNCaXRtYXA7XG4gICAgfVxuICAgIHNldCBjYWNoZUFzQml0bWFwKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZUFzQml0bWFwID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWNoZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZURhdGEgPSBuZXcgQ2FjaGVEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fY2FjaGVEYXRhO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbFJlbmRlciA9IHRoaXMucmVuZGVyO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcyA9IHRoaXMucmVuZGVyQ2FudmFzO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuY2FsY3VsYXRlQm91bmRzO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcztcbiAgICAgICAgICAgIGRhdGEub3JpZ2luYWxEZXN0cm95ID0gdGhpcy5kZXN0cm95O1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQgPSB0aGlzLmNvbnRhaW5zUG9pbnQ7XG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsTWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYSA9IHRoaXMuZmlsdGVyQXJlYTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyQ2FjaGVkO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9jYWNoZUFzQml0bWFwRGVzdHJveTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9jYWNoZURhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5zcHJpdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95Q2FjaGVkRGlzcGxheU9iamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBkYXRhLm9yaWdpbmFsUmVuZGVyO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSBkYXRhLm9yaWdpbmFsUmVuZGVyQ2FudmFzO1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzO1xuICAgICAgICAgICAgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcztcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IGRhdGEub3JpZ2luYWxEZXN0cm95O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSBkYXRhLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICAgICAgdGhpcy5jb250YWluc1BvaW50ID0gZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQ7XG4gICAgICAgICAgICB0aGlzLl9tYXNrID0gZGF0YS5vcmlnaW5hbE1hc2s7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBzcHJpdGUgd2l0aCBXZWJHTFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX3JlbmRlckNhY2hlZFxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqL1xuICAgIF9yZW5kZXJDYWNoZWQocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgV2ViR0wgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0XG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gdGhlIFdlYkdMIHJlbmRlcmVyXG4gICAgICovXG4gICAgX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZURhdGEgJiYgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBhbHBoYSBpcyBzZXQgdG8gMSBvdGhlcndpc2UgaXQgd2lsbCBnZXQgcmVuZGVyZWQgYXMgaW52aXNpYmxlIVxuICAgICAgICB2YXIgY2FjaGVBbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgICAgICAvLyBmaXJzdCB3ZSBmbHVzaCBhbnl0aGluZyBsZWZ0IGluIHRoZSByZW5kZXJlciAob3RoZXJ3aXNlIGl0IHdvdWxkIGdldCByZW5kZXJlZCB0byB0aGUgY2FjaGVkIHRleHR1cmUpXG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgIC8vIHRoaXMuZmlsdGVycz0gW107XG4gICAgICAgIC8vIG5leHQgd2UgZmluZCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgdW50cmFuc2Zvcm1lZCBvYmplY3RcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBhbHNvIGNhbGxzIHVwZGF0ZXRyYW5zZm9ybSBvbiBhbGwgaXRzIGNoaWxkcmVuIGFzIHBhcnQgb2YgdGhlIG1lYXN1cmluZy5cbiAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgdHJhbnNmb3JtIGFnYWluIGluIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgLy8gVE9ETyBwYXNzIGFuIG9iamVjdCB0byBjbG9uZSB0b28/IHNhdmVzIGhhdmluZyB0byBjcmVhdGUgYSBuZXcgb25lIGVhY2ggdGltZSFcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5jbG9uZSgpO1xuICAgICAgICAvLyBhZGQgc29tZSBwYWRkaW5nIVxuICAgICAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuZmlsdGVyc1swXS5wYWRkaW5nO1xuICAgICAgICAgICAgYm91bmRzLnBhZChwYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBib3VuZHMuY2VpbChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTik7XG4gICAgICAgIC8vIGZvciBub3cgd2UgY2FjaGUgdGhlIGN1cnJlbnQgcmVuZGVyVGFyZ2V0IHRoYXQgdGhlIFdlYkdMIHJlbmRlcmVyIGlzIGN1cnJlbnRseSB1c2luZy5cbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBtb3JlIGVsZWdhbnQuLlxuICAgICAgICB2YXIgY2FjaGVkUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuX2FjdGl2ZVJlbmRlclRhcmdldDtcbiAgICAgICAgLy8gV2UgYWxzbyBzdG9yZSB0aGUgZmlsdGVyIHN0YWNrIC0gSSB3aWxsIGRlZmluaXRlbHkgbG9vayB0byBjaGFuZ2UgaG93IHRoaXMgd29ya3MgYSBsaXR0bGUgbGF0ZXIgZG93biB0aGUgbGluZS5cbiAgICAgICAgLy8gY29uc3Qgc3RhY2sgPSByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmZpbHRlclN0YWNrO1xuICAgICAgICAvLyB0aGlzIHJlbmRlclRleHR1cmUgd2lsbCBiZSB1c2VkIHRvIHN0b3JlIHRoZSBjYWNoZWQgRGlzcGxheU9iamVjdFxuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgICB2YXIgdGV4dHVyZUNhY2hlSWQgPSBcImNhY2hlQXNCaXRtYXBfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gdGV4dHVyZUNhY2hlSWQ7XG4gICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gICAgICAgIFRleHR1cmVfMS5UZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xuICAgICAgICAvLyBuZWVkIHRvIHNldCAvL1xuICAgICAgICB2YXIgbSA9IERpc3BsYXlPYmplY3QuX3RlbXBNYXRyaXg7XG4gICAgICAgIG0udHggPSAtYm91bmRzLng7XG4gICAgICAgIG0udHkgPSAtYm91bmRzLnk7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLmlkZW50aXR5KCk7XG4gICAgICAgIC8vIHNldCBhbGwgcHJvcGVydGllcyB0byB0aGVyZSBvcmlnaW5hbCBzbyB3ZSBjYW4gcmVuZGVyIHRvIGEgdGV4dHVyZVxuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMuX2NhY2hlRGF0YS5vcmlnaW5hbFJlbmRlcjtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMsIHJlbmRlclRleHR1cmUsIHRydWUsIG0sIHRydWUpO1xuICAgICAgICAvLyBub3cgcmVzdG9yZSB0aGUgc3RhdGUgYmUgc2V0dGluZyB0aGUgbmV3IHByb3BlcnRpZXNcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKGNhY2hlZFJlbmRlclRhcmdldCk7XG4gICAgICAgIC8vIHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZmlsdGVyU3RhY2sgPSBzdGFjaztcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJDYWNoZWQ7XG4gICAgICAgIC8vIHRoZSByZXN0IGlzIHRoZSBzYW1lIGFzIGZvciBDYW52YXNcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm07XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzO1xuICAgICAgICB0aGlzLmdldExvY2FsQm91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHM7XG4gICAgICAgIHRoaXMuX21hc2sgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICAgICAgICAvLyBjcmVhdGUgb3VyIGNhY2hlZCBzcHJpdGVcbiAgICAgICAgdmFyIGNhY2hlZFNwcml0ZTsgLy8gPSBuZXcgU3ByaXRlKHJlbmRlclRleHR1cmUpO1xuICAgICAgICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpO1xuICAgICAgICBjYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCk7XG4gICAgICAgIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGE7XG4gICAgICAgIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgdHJhbnNmb3JtIG9mIHRoZSBjYWNoZWQgc3ByaXRlIHRvIGF2b2lkIHRoZSBuYXN0eSBmbGlja2VyLi5cbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSByZW5kZXJlci5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXAgdGhlIGhpdCB0ZXN0Li5cbiAgICAgICAgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gKiBSZW5kZXJzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHNwcml0ZSB3aXRoIGNhbnZhc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb24gX3JlbmRlckNhY2hlZENhbnZhc1xuICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB0aGUgV2ViR0wgcmVuZGVyZXJcbiAqL1xuICAgIF9yZW5kZXJDYWNoZWRDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzKHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xuICAgIH1cbiAgICA7XG4gICAgLy8gVE9ETyB0aGlzIGNhbiBiZSB0aGUgc2FtZSBhcyB0aGUgV2ViR0wgdmVyc2lvbi4uIHdpbGwgbmVlZCB0byBkbyBhIGxpdHRsZSB0d2Vha2luZyBmaXJzdCB0aG91Z2guLlxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIHRoZSBDYW52YXMgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzXG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gdGhlIFdlYkdMIHJlbmRlcmVyXG4gICAgICovXG4gICAgX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZURhdGEgJiYgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBib3VuZHMgYWN0dWFsbHkgdHJhbnNmb3JtcyB0aGUgb2JqZWN0IGZvciB1cyBhbHJlYWR5IVxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xuICAgICAgICB2YXIgY2FjaGVBbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xuICAgICAgICB2YXIgY2FjaGVkUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuY29udGV4dDtcbiAgICAgICAgYm91bmRzLmNlaWwoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT04pO1xuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgICB2YXIgdGV4dHVyZUNhY2hlSWQgPSBcImNhY2hlQXNCaXRtYXBfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gdGV4dHVyZUNhY2hlSWQ7XG4gICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gICAgICAgIFRleHR1cmVfMS5UZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xuICAgICAgICAvLyBuZWVkIHRvIHNldCAvL1xuICAgICAgICB2YXIgbSA9IERpc3BsYXlPYmplY3QuX3RlbXBNYXRyaXg7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLmNvcHlUbyhtKTtcbiAgICAgICAgbS5pbnZlcnQoKTtcbiAgICAgICAgbS50eCAtPSBib3VuZHMueDtcbiAgICAgICAgbS50eSAtPSBib3VuZHMueTtcbiAgICAgICAgLy8gbS5hcHBlbmQodGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0uKVxuICAgICAgICAvLyBzZXQgYWxsIHByb3BlcnRpZXMgdG8gdGhlcmUgb3JpZ2luYWwgc28gd2UgY2FuIHJlbmRlciB0byBhIHRleHR1cmVcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9jYWNoZURhdGEub3JpZ2luYWxSZW5kZXJDYW52YXM7XG4gICAgICAgIC8vIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIG0sIHRydWUpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIodGhpcywgcmVuZGVyVGV4dHVyZSwgdHJ1ZSwgbSwgZmFsc2UpO1xuICAgICAgICAvLyBub3cgcmVzdG9yZSB0aGUgc3RhdGUgYmUgc2V0dGluZyB0aGUgbmV3IHByb3BlcnRpZXNcbiAgICAgICAgcmVuZGVyZXIuY29udGV4dCA9IGNhY2hlZFJlbmRlclRhcmdldDtcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG4gICAgICAgIC8vIHRoZSByZXN0IGlzIHRoZSBzYW1lIGFzIGZvciBXZWJHTFxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSB0aGlzLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHM7XG4gICAgICAgIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcztcbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gICAgICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxuICAgICAgICB2YXIgY2FjaGVkU3ByaXRlOyAvLz0gbmV3IFNwcml0ZShyZW5kZXJUZXh0dXJlKTtcbiAgICAgICAgY2FjaGVkU3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICBjYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKGJvdW5kcy54IC8gYm91bmRzLndpZHRoKTtcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpO1xuICAgICAgICBjYWNoZWRTcHJpdGUuYWxwaGEgPSBjYWNoZUFscGhhO1xuICAgICAgICBjYWNoZWRTcHJpdGUuX2JvdW5kcyA9IHRoaXMuX2JvdW5kcztcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IGNhY2hlZFNwcml0ZTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHRyYW5zZm9ybSBvZiB0aGUgY2FjaGVkIHNwcml0ZSB0byBhdm9pZCB0aGUgbmFzdHkgZmxpY2tlci4uXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcmVuZGVyZXIuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFwIHRoZSBoaXQgdGVzdC4uXG4gICAgICAgIHRoaXMuY29udGFpbnNQb2ludCA9IGNhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQoY2FjaGVkU3ByaXRlKTtcbiAgICB9XG4gICAgO1xuICAgIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIGNhY2hlZCBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcygpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUudHJhbnNmb3JtLl93b3JsZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX2NhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLl9sYXN0Qm91bmRzSUQgPSB0aGlzLl9ib3VuZHNJRDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGVkIHNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGUgbG9jYWwgYm91bmRzLlxuICAgICAqL1xuICAgIF9nZXRDYWNoZWRMb2NhbEJvdW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuZ2V0TG9jYWxCb3VuZHMoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBjYWNoZWQgc3ByaXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVzdHJveUNhY2hlZERpc3BsYXlPYmplY3QoKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3RleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IG51bGw7XG4gICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCk7XG4gICAgICAgIFRleHR1cmVfMS5UZXh0dXJlLnJlbW92ZUZyb21DYWNoZSh0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQpO1xuICAgICAgICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gKiBEZXN0cm95cyB0aGUgY2FjaGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZS5cbiAqICBVc2VkIHdoZW4gZGVzdHJveWluZyBjb250YWluZXJzLCBzZWUgdGhlIENvbnRhaW5lci5kZXN0cm95IG1ldGhvZC5cbiAqL1xuICAgIF9jYWNoZUFzQml0bWFwRGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FjaGVBc0JpdG1hcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgfVxuICAgIDtcbn1cbkRpc3BsYXlPYmplY3QuX3RlbXBNYXRyaXggPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XG5leHBvcnRzLkRpc3BsYXlPYmplY3QgPSBEaXNwbGF5T2JqZWN0O1xuLy8gZmlndXJlZCB0aGVyZXMgbm8gcG9pbnQgYWRkaW5nIEFMTCB0aGUgZXh0cmEgdmFyaWFibGVzIHRvIHByb3RvdHlwZS5cbi8vIHRoaXMgbW9kZWwgY2FuIGhvbGQgdGhlIGluZm9ybWF0aW9uIG5lZWRlZC4gVGhpcyBjYW4gYWxzbyBiZSBnZW5lcmF0ZWQgb24gZGVtYW5kIGFzXG4vLyBtb3N0IG9iamVjdHMgYXJlIG5vdCBjYWNoZWQgYXMgYml0bWFwcy5cbi8qKlxuICogQGNsYXNzXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIENhY2hlRGF0YSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWQgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsUmVuZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFJlbmRlckNhbnZhcyA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxDYWxjdWxhdGVCb3VuZHMgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsR2V0TG9jYWxCb3VuZHMgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEhpdFRlc3QgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRGVzdHJveSA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxNYXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEZpbHRlckFyZWEgPSBudWxsO1xuICAgICAgICB0aGlzLnNwcml0ZSA9IG51bGw7XG4gICAgfVxufVxuO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBEaXNwbGF5U2V0dGluZ3Mge1xufVxuRGlzcGxheVNldHRpbmdzLlNPUlRBQkxFX0NISUxEUkVOID0gZmFsc2U7XG5EaXNwbGF5U2V0dGluZ3MuQ1JFQVRFX0lNQUdFX0JJVE1BUCA9IHRydWU7XG5EaXNwbGF5U2V0dGluZ3MuUkVOREVSRVJfVFlQRSA9IHtcbiAgICBVTktOT1dOOiAwLFxuICAgIFdFQkdMOiAxLFxuICAgIENBTlZBUzogMixcbn07XG5EaXNwbGF5U2V0dGluZ3MuRU5WID0ge1xuICAgIFdFQkdMX0xFR0FDWTogMCxcbiAgICBXRUJHTDogMSxcbiAgICBXRUJHTDI6IDIsXG59O1xuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT04gPSAxO1xuRGlzcGxheVNldHRpbmdzLlNDQUxFX01PREUgPSAxO1xuRGlzcGxheVNldHRpbmdzLlJPVU5EX1BJWEVMUyA9IGZhbHNlO1xuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPSBEaXNwbGF5U2V0dGluZ3MuRU5WLldFQkdMO1xuZXhwb3J0cy5EaXNwbGF5U2V0dGluZ3MgPSBEaXNwbGF5U2V0dGluZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIERyYXdNb2RlU2V0dGluZ3Mge1xufVxuLyoqXG4qIFZhcmlvdXMgd2ViZ2wgZHJhdyBtb2Rlcy4gVGhlc2UgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB3aGljaCBHTCBkcmF3TW9kZSB0byB1c2VcbiogdW5kZXIgY2VydGFpbiBzaXR1YXRpb25zIGFuZCByZW5kZXJlcnMuXG4qXG4qIEBtZW1iZXJvZiBQSVhJXG4qIEBzdGF0aWNcbiogQG5hbWUgRFJBV19NT0RFU1xuKiBAZW51bSB7bnVtYmVyfVxuKiBAcHJvcGVydHkge251bWJlcn0gUE9JTlRTXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSU5FU1xuKiBAcHJvcGVydHkge251bWJlcn0gTElORV9MT09QXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSU5FX1NUUklQXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBUUklBTkdMRVNcbiogQHByb3BlcnR5IHtudW1iZXJ9IFRSSUFOR0xFX1NUUklQXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBUUklBTkdMRV9GQU5cbiovXG5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMgPSB7XG4gICAgUE9JTlRTOiAwLFxuICAgIExJTkVTOiAxLFxuICAgIExJTkVfTE9PUDogMixcbiAgICBMSU5FX1NUUklQOiAzLFxuICAgIFRSSUFOR0xFUzogNCxcbiAgICBUUklBTkdMRV9TVFJJUDogNSxcbiAgICBUUklBTkdMRV9GQU46IDYsXG59O1xuZXhwb3J0cy5EcmF3TW9kZVNldHRpbmdzID0gRHJhd01vZGVTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBTaGFwZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9TaGFwZVNldHRpbmdzXCIpO1xuY2xhc3MgRWxsaXBzZSB7XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCBoYWxmV2lkdGggPSAwLCBoYWxmSGVpZ2h0ID0gMCkge1xuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFsZldpZHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhhbGZXaWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbGZIZWlnaHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaGFsZkhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IGhhbGZXaWR0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoYWxmSGVpZ2h0O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5FTElQXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5FTElQO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBFbGxpcHNlIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkVsbGlwc2V9IGEgY29weSBvZiB0aGUgZWxsaXBzZVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEVsbGlwc2UodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm9ybWFsaXplIHRoZSBjb29yZHMgdG8gYW4gZWxsaXBzZSB3aXRoIGNlbnRlciAwLDBcbiAgICAgICAgdmFyIG5vcm14ID0gKCh4IC0gdGhpcy54KSAvIHRoaXMud2lkdGgpO1xuICAgICAgICB2YXIgbm9ybXkgPSAoKHkgLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHQpO1xuICAgICAgICBub3JteCAqPSBub3JteDtcbiAgICAgICAgbm9ybXkgKj0gbm9ybXk7XG4gICAgICAgIHJldHVybiAobm9ybXggKyBub3JteSA8PSAxKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGdldEJvdW5kcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUodGhpcy54IC0gdGhpcy53aWR0aCwgdGhpcy55IC0gdGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5FbGxpcHNlID0gRWxsaXBzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmxhc2hCYXNlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9GbGFzaEJhc2VPYmplY3RcIik7XG5jbGFzcyBFdmVudCBleHRlbmRzIEZsYXNoQmFzZU9iamVjdF8xLkZsYXNoQmFzZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXNldCh0eXBlLCBidWJibGUsIGNhbmNlbGFibGUpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUYXJnZXQ7XG4gICAgfVxuICAgIHNldEN1cnJlbnRUYXJnZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIGdldCBjYW5jZWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsYWJsZTtcbiAgICB9XG4gICAgZ2V0IGJ1YmJsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWJibGVzO1xuICAgIH1cbiAgICBnZXQgZXZlbnRQaGFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50UGhhc2U7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gRXZlbnQuZ2V0RXZlbnQodGhpcy5fdHlwZSwgdGhpcy5fYnViYmxlcywgdGhpcy5fY2FuY2VsYWJsZSk7XG4gICAgfVxuICAgIHJlc2V0KHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9idWJibGVzID0gYnViYmxlO1xuICAgICAgICB0aGlzLl9jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgICB9XG4gICAgc3RhdGljIGdldEV2ZW50KHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XG4gICAgICAgIGlmIChFdmVudC5FdmVudENhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHRlID0gRXZlbnQuRXZlbnRDYWNoZVtFdmVudC5FdmVudENhY2hlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgRXZlbnQuRXZlbnRDYWNoZS5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgIHRlLnJlc2V0KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudCh0eXBlLCBidWJibGUsIGNhbmNlbGFibGUpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgbGV0IGluZGV4ID0gRXZlbnQuRXZlbnRDYWNoZS5pbmRleE9mKHRoaXMpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBFdmVudC5FdmVudENhY2hlLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzRGlzcG9zYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB9XG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xuICAgIH1cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICB9XG59XG5FdmVudC5BRERFRF9UT19TVEFHRSA9IFwiYWRkZWRUb1N0YWdlXCI7XG5FdmVudC5BRERFRCA9IFwiYWRkZWRcIjtcbkV2ZW50LkVOVEVSX0ZSQU1FID0gXCJlbnRlckZyYW1lXCI7XG5FdmVudC5FWElUX0ZSQU1FID0gXCJleGl0RnJhbWVcIjtcbkV2ZW50LkZSQU1FX0NPTlNUUlVDVEVEID0gXCJmcmFtZUNvbnN0cnVjdGVkXCI7XG5FdmVudC5SRU1PVkVEID0gXCJyZW1vdmVkXCI7XG5FdmVudC5SRU1PVkVEX0ZST01fU1RBR0UgPSBcInJlbW92ZWRGcm9tU3RhZ2VcIjtcbkV2ZW50LlJFTkRFUiA9IFwicmVuZGVyXCI7XG5FdmVudC5DT01QTEVURSA9IFwiY29tcGxldGVcIjtcbkV2ZW50LklOSVQgPSBcImluaXRcIjtcbkV2ZW50Lk9QRU4gPSBcIm9wZW5cIjtcbkV2ZW50LlVOTE9BRCA9IFwidW5sb2FkXCI7XG5FdmVudC5DTEVBUiA9IFwiY2xlYXJcIjtcbkV2ZW50LlNPVU5EX0NPTVBMRVRFID0gXCJzb3VuZENvbXBsZXRlXCI7XG5FdmVudC5TT1VORF9TVEFSVEVEID0gXCJzb3VuZFN0YXJ0ZWRcIjtcbkV2ZW50LkFDVElWQVRFID0gXCJhY3RpdmF0ZVwiO1xuRXZlbnQuREVBQ1RJVkFURSA9IFwiZGVzYWN0aXZhdGVcIjtcbkV2ZW50LlJFU0laRSA9IFwicmVzaXplXCI7XG5FdmVudC5DSEFOR0UgPSBcImNoYW5nZVwiO1xuRXZlbnQuRXZlbnRDYWNoZSA9IFtdO1xuZXhwb3J0cy5FdmVudCA9IEV2ZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGbGFzaEJhc2VPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0ZsYXNoQmFzZU9iamVjdFwiKTtcbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciBleHRlbmRzIEZsYXNoQmFzZU9iamVjdF8xLkZsYXNoQmFzZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0ID0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICB3aGlsZSAobWV0aG9kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbXMgPSBtZXRob2RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1tpXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgIH1cbiAgICB3aWxsVHJpZ2dlcih0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBtZXRob2RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBtZXRob2RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kc1tpXS5vYmplY3RGdW5jdGlvbiA9PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kc1tpXS5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWV0aG9kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0V2ZW50TGlzdGVuZXIodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2RzID0gdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdO1xuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgbWV0aG9kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1tldmVudC50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBldmVudC5zZXRDdXJyZW50VGFyZ2V0KHRoaXMpO1xuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbZXZlbnQudHlwZV07XG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBtZXRob2RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBtZXRob2Rjb3B5ID0gbWV0aG9kcy5jb25jYXQoKTtcbiAgICAgICAgICAgICAgICBtZXRob2Rjb3B5ID0gbWV0aG9kY29weS5zb3J0KHRoaXMuZ2V0TWV0aG9kUHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChtZXRob2Rjb3B5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kY29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmV2ZW50VHlwZSAhPSBldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIobWV0aG9kLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmlzRGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlLCBwcmlvcml0eSA9IDAsIHVzZVdlYWtSZWZlcmVuY2UgPSBmYWxzZSwgc2NvcGUgPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVnaXN0ZXJlZCh0eXBlLCBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgIHZhciBtZXRob2RTY29wZSA9IE1ldGhvZFNjb3BlLmdldE1ldGhvZFNjb3BlKCk7XG4gICAgICAgIG1ldGhvZFNjb3BlLmV2ZW50VHlwZSA9IHR5cGU7XG4gICAgICAgIG1ldGhvZFNjb3BlLnBhcmVudERpc3BhdGNoZXIgPSB0aGlzO1xuICAgICAgICBtZXRob2RTY29wZS5vYmplY3RGdW5jdGlvbiA9IGxpc3RlbmVyO1xuICAgICAgICBtZXRob2RTY29wZS5zY29wZSA9IHNjb3BlO1xuICAgICAgICBtZXRob2RTY29wZS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICAgICAgICBtZXRob2RzLnB1c2gobWV0aG9kU2NvcGUpO1xuICAgIH1cbiAgICB0cmlnZ2VyKG1ldGhvZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKG1ldGhvZC5vYmplY3RGdW5jdGlvbikge1xuICAgICAgICAgICAgbWV0aG9kLm9iamVjdEZ1bmN0aW9uLmNhbGwobWV0aG9kLnNjb3BlLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWV0aG9kUHJpb3JpdHkobWV0aG9kMSwgbWV0aG9kMikge1xuICAgICAgICBpZiAobWV0aG9kMS5wcmlvcml0eSA+IG1ldGhvZDIucHJpb3JpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaXNSZWdpc3RlcmVkKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG1ldGhvZHNbaV0ub2JqZWN0RnVuY3Rpb24gPT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XG5jbGFzcyBNZXRob2RTY29wZSBleHRlbmRzIEZsYXNoQmFzZU9iamVjdF8xLkZsYXNoQmFzZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMub2JqZWN0RnVuY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJlbnREaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IDA7XG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGdldE1ldGhvZFNjb3BlKCkge1xuICAgICAgICBpZiAoTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB0ZSA9IE1ldGhvZFNjb3BlLk1ldGhvZFNjb3BlQ2FjaGVbTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIE1ldGhvZFNjb3BlLk1ldGhvZFNjb3BlQ2FjaGUubGVuZ3RoIC09IDE7XG4gICAgICAgICAgICB0ZS5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kU2NvcGUoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vYmplY3RGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudERpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgICBsZXQgaW5kZXggPSBNZXRob2RTY29wZS5NZXRob2RTY29wZUNhY2hlLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIE1ldGhvZFNjb3BlLk1ldGhvZFNjb3BlQ2FjaGUudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk1ldGhvZFNjb3BlLk1ldGhvZFNjb3BlQ2FjaGUgPSBbXTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vUmVuZGVyVGV4dHVyZVwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xuY29uc3QgQ2FudmFzUmVuZGVyVGFyZ2V0XzEgPSByZXF1aXJlKFwiLi9DYW52YXNSZW5kZXJUYXJnZXRcIik7XG5jbGFzcyBFeHRyYWN0IHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgZm9yIGV4dHJhY3RpbmcgZGF0YSAoaW1hZ2UsIHBpeGVscywgZXRjLikgZnJvbSBhIGRpc3BsYXkgb2JqZWN0IG9yIHJlbmRlciB0ZXh0dXJlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuZXh0cmFjdC5FeHRyYWN0fSBleHRyYWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLlJlbmRlcmVyI1xuICAgICAgICAgKiBAc2VlIFBJWEkuZXh0cmFjdC5FeHRyYWN0XG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXJlci5leHRyYWN0ID0gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2lsbCByZXR1cm4gYSBIVE1MIEltYWdlIG9mIHRoZSB0YXJnZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcbiAgICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9IEhUTUwgSW1hZ2Ugb2YgdGhlIHRhcmdldFxuICAgICAqL1xuICAgIGltYWdlKHRhcmdldCkge1xuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gdGhpcy5iYXNlNjQodGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGltYWdlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogV2lsbCByZXR1cm4gYSBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiB0aGlzIHRhcmdldC4gSXQgd29ya3MgYnkgY2FsbGluZ1xuICAgICAqICBgRXh0cmFjdC5nZXRDYW52YXNgIGFuZCB0aGVuIHJ1bm5pbmcgdG9EYXRhVVJMIG9uIHRoYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLlJlbmRlclRleHR1cmV9IHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIGJhc2U2NCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzKHRhcmdldCkudG9EYXRhVVJMKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQ2FudmFzIGVsZW1lbnQsIHJlbmRlcnMgdGhpcyB0YXJnZXQgdG8gaXQgYW5kIHRoZW4gcmV0dXJucyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcbiAgICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIENhbnZhcyBlbGVtZW50IHdpdGggdGhlIHRleHR1cmUgcmVuZGVyZWQgb24uXG4gICAgICovXG4gICAgY2FudmFzKHRhcmdldCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgcmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGZyYW1lO1xuICAgICAgICB2YXIgZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmU7XG4gICAgICAgIHZhciBnZW5lcmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSB0aGlzLnJlbmRlcmVyLmdlbmVyYXRlVGV4dHVyZSh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICAgICAgICBmcmFtZSA9IHJlbmRlclRleHR1cmUuZnJhbWU7XG4gICAgICAgICAgICBmbGlwWSA9IGZhbHNlO1xuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHJlbmRlclRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGZsaXBZID0gdHJ1ZTtcbiAgICAgICAgICAgIGZyYW1lID0gRXh0cmFjdC5URU1QX1JFQ1Q7XG4gICAgICAgICAgICBmcmFtZS53aWR0aCA9IHRoaXMucmVuZGVyZXIud2lkdGg7XG4gICAgICAgICAgICBmcmFtZS5oZWlnaHQgPSB0aGlzLnJlbmRlcmVyLmhlaWdodDtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZS53aWR0aCAqIHJlc29sdXRpb247XG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgY2FudmFzQnVmZmVyID0gbmV3IENhbnZhc1JlbmRlclRhcmdldF8xLkNhbnZhc1JlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCAxKTtcbiAgICAgICAgdmFyIHdlYmdsUGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoRXh0cmFjdC5CWVRFU19QRVJfUElYRUwgKiB3aWR0aCAqIGhlaWdodCk7XG4gICAgICAgIC8vIHJlYWQgcGl4ZWxzIHRvIHRoZSBhcnJheVxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICAgICAgZ2wucmVhZFBpeGVscyhmcmFtZS54ICogcmVzb2x1dGlvbiwgZnJhbWUueSAqIHJlc29sdXRpb24sIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHdlYmdsUGl4ZWxzKTtcbiAgICAgICAgLy8gYWRkIHRoZSBwaXhlbHMgdG8gdGhlIGNhbnZhc1xuICAgICAgICB2YXIgY2FudmFzRGF0YSA9IGNhbnZhc0J1ZmZlci5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY2FudmFzRGF0YS5kYXRhLnNldCh3ZWJnbFBpeGVscyk7XG4gICAgICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LnB1dEltYWdlRGF0YShjYW52YXNEYXRhLCAwLCAwKTtcbiAgICAgICAgLy8gcHVsbGluZyBwaXhlbHNcbiAgICAgICAgaWYgKGZsaXBZKSB7XG4gICAgICAgICAgICBjYW52YXNCdWZmZXIuY29udGV4dC5zY2FsZSgxLCAtMSk7XG4gICAgICAgICAgICBjYW52YXNCdWZmZXIuY29udGV4dC5kcmF3SW1hZ2UoY2FudmFzQnVmZmVyLmNhbnZhcywgMCwgLWhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVyYXRlZCkge1xuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlbmQgdGhlIGNhbnZhcyBiYWNrLi5cbiAgICAgICAgcmV0dXJuIGNhbnZhc0J1ZmZlci5jYW52YXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBXaWxsIHJldHVybiBhIG9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIHRoZSBlbnRpcmUgdGV4dHVyZSBpbiBSR0JBXG4gICAgICogb3JkZXIsIHdpdGggaW50ZWdlciB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNTUgKGluY2x1ZGVkKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcbiAgICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB0aGUgbWFpbiByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fSBPbmUtZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBvZiB0aGUgZW50aXJlIHRleHR1cmVcbiAgICAgKi9cbiAgICBwaXhlbHModGFyZ2V0KSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgZnJhbWU7XG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlO1xuICAgICAgICB2YXIgZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gdGhpcy5yZW5kZXJlci5nZW5lcmF0ZVRleHR1cmUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICByZXNvbHV0aW9uID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgZnJhbWUgPSByZW5kZXJUZXh0dXJlLmZyYW1lO1xuICAgICAgICAgICAgLy8gYmluZCB0aGUgYnVmZmVyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQocmVuZGVyVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGZyYW1lID0gRXh0cmFjdC5URU1QX1JFQ1Q7XG4gICAgICAgICAgICBmcmFtZS53aWR0aCA9IHJlbmRlcmVyLndpZHRoO1xuICAgICAgICAgICAgZnJhbWUuaGVpZ2h0ID0gcmVuZGVyZXIuaGVpZ2h0O1xuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IGZyYW1lLndpZHRoICogcmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodCAqIHJlc29sdXRpb247XG4gICAgICAgIHZhciB3ZWJnbFBpeGVscyA9IG5ldyBVaW50OEFycmF5KEV4dHJhY3QuQllURVNfUEVSX1BJWEVMICogd2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAvLyByZWFkIHBpeGVscyB0byB0aGUgYXJyYXlcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgIGdsLnJlYWRQaXhlbHMoZnJhbWUueCAqIHJlc29sdXRpb24sIGZyYW1lLnkgKiByZXNvbHV0aW9uLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB3ZWJnbFBpeGVscyk7XG4gICAgICAgIGlmIChnZW5lcmF0ZWQpIHtcbiAgICAgICAgICAgIHJlbmRlclRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2ViZ2xQaXhlbHM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgZXh0cmFjdFxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5leHRyYWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbkV4dHJhY3QuVEVNUF9SRUNUID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuRXh0cmFjdC5CWVRFU19QRVJfUElYRUwgPSA0O1xuZXhwb3J0cy5FeHRyYWN0ID0gRXh0cmFjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xuY2xhc3MgRmlsbFN0eWxlIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5GaWxsU3R5bGV9XG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBvYmogPSBuZXcgRmlsbFN0eWxlKCk7XG4gICAgICAgIG9iai5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgIG9iai5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgICAgIG9iai50ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgICAgICBvYmoubWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgICAgIG9iai52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzZXRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZXggY29sb3IgdmFsdWUgdXNlZCB3aGVuIGNvbG9yaW5nIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IDB4RkZGRkZGO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFscGhhIHZhbHVlIHVzZWQgd2hlbiBmaWxsaW5nIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSB0byBiZSB1c2VkIGZvciB0aGUgZmlsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBUZXh0dXJlXzEuVGV4dHVyZS5XSElURTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2Zvcm0gYXBscGllZCB0byB0aGUgdGV4dHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgY3VycmVudCBmaWxsIGlzIHZpc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkZpbGxTdHlsZSA9IEZpbGxTdHlsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmFtXCIpO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xuY2xhc3MgRmlsdGVyIGV4dGVuZHMgU2hhZGVyXzEuU2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMgPSBudWxsLCBmcmFnbWVudFNyYyA9IG51bGwsIHVuaWZvcm1zID0gbnVsbCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20odmVydGV4U3JjIHx8IEZpbHRlci5kZWZhdWx0VmVydGV4U3JjLCBmcmFnbWVudFNyYyB8fCBGaWx0ZXIuZGVmYXVsdEZyYWdtZW50U3JjKTtcbiAgICAgICAgc3VwZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhZGRpbmcgb2YgdGhlIGZpbHRlci4gU29tZSBmaWx0ZXJzIHJlcXVpcmUgZXh0cmEgc3BhY2UgdG8gYnJlYXRoIHN1Y2ggYXMgYSBibHVyLlxuICAgICAgICAgKiBJbmNyZWFzaW5nIHRoaXMgd2lsbCBhZGQgZXh0cmEgd2lkdGggYW5kIGhlaWdodCB0byB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QgdGhhdCB0aGVcbiAgICAgICAgICogZmlsdGVyIGlzIGFwcGxpZWQgdG8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgZmlsdGVyLiBTZXR0aW5nIHRoaXMgdG8gYmUgbG93ZXIgd2lsbCBsb3dlciB0aGUgcXVhbGl0eSBidXRcbiAgICAgICAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHNldHRpbmdzXzEuc2V0dGluZ3MuRklMVEVSX1JFU09MVVRJT047XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbmFibGVkIGlzIHRydWUgdGhlIGZpbHRlciBpcyBhcHBsaWVkLCBpZiBmYWxzZSBpdCB3aWxsIG5vdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbmFibGVkLCBQaXhpSlMgd2lsbCBmaXQgdGhlIGZpbHRlciBhcmVhIGludG8gYm91bmRhcmllcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAgICAgKiBTd2l0Y2ggaXQgb2ZmIGlmIGl0IGRvZXMgbm90IHdvcmsgZm9yIHNwZWNpZmljIHNoYWRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0ZpdCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWdhY3kgZmlsdGVycyB1c2UgcG9zaXRpb24gYW5kIHV2cyBmcm9tIGF0dHJpYnV0ZXNcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZ2FjeSA9ICEhdGhpcy5wcm9ncmFtLmF0dHJpYnV0ZURhdGEuYVRleHR1cmVDb29yZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBXZWJHTCBzdGF0ZSB0aGUgZmlsdGVyIHJlcXVpcmVzIHRvIHJlbmRlclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlN0YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZV8xLlN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLnN5c3RlbXMuRmlsdGVyU3lzdGVtfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBmaWx0ZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBpbnB1dCAtIFRoZSBpbnB1dCByZW5kZXIgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyIC0gU2hvdWxkIHRoZSBvdXRwdXQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nIHRvIGl0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjdXJyZW50U3RhdGVdIC0gSXQncyBjdXJyZW50IHN0YXRlIG9mIGZpbHRlci5cbiAgICAgKiAgICAgICAgVGhlcmUgYXJlIHNvbWUgdXNlZnVsIHByb3BlcnRpZXMgaW4gdGhlIGN1cnJlbnRTdGF0ZSA6XG4gICAgICogICAgICAgIHRhcmdldCwgZmlsdGVycywgc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUsIHJlbmRlclRhcmdldCwgcmVzb2x1dGlvblxuICAgICAqL1xuICAgIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyLCBjdXJyZW50U3RhdGUsIGRlcnApIHtcbiAgICAgICAgLy8gZG8gYXMgeW91IHBsZWFzZSFcbiAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhciwgY3VycmVudFN0YXRlLCBkZXJwKTtcbiAgICAgICAgLy8gb3IganVzdCBkbyBhIHJlZ3VsYXIgcmVuZGVyLi5cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJsZW5kbW9kZSBvZiB0aGUgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgKi9cbiAgICBnZXQgYmxlbmRNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB2ZXJ0ZXggc2hhZGVyIHNvdXJjZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xuICAgICAgICByZXR1cm4gRmlsdGVyLmRlZmF1bHRWZXJ0ZXgkMTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgZGVmYXVsdEZyYWdtZW50U3JjKCkge1xuICAgICAgICByZXR1cm4gRmlsdGVyLmRlZmF1bHRGcmFnbWVudCQxO1xuICAgIH1cbiAgICA7XG59XG4vKipcbiAqIFVzZWQgZm9yIGNhY2hpbmcgc2hhZGVyIElEc1xuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkZpbHRlci5TT1VSQ0VfS0VZX01BUCA9IHt9O1xuRmlsdGVyLmRlZmF1bHRWZXJ0ZXgkMSA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XFxyXFxudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xcclxcblxcclxcbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxcclxcbntcXHJcXG4gICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XFxyXFxuXFxyXFxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG59XFxyXFxuXFxyXFxudmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxcclxcbntcXHJcXG4gICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxyXFxufVxcclxcblwiO1xuRmlsdGVyLmRlZmF1bHRGcmFnbWVudCQxID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG59XFxyXFxuXCI7XG5leHBvcnRzLkZpbHRlciA9IEZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jbGFzcyBGaWx0ZXJTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYXJnZXQgb2YgdGhlIGZpbHRlcnNcbiAgICAgICAgICogV2Ugc3RvcmUgZm9yIGNhc2Ugd2hlbiBjdXN0b20gZmlsdGVyIHdhbnRzIHRvIGtub3cgdGhlIGVsZW1lbnQgaXQgd2FzIGFwcGxpZWQgb25cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGF0aWJpbGl0eSB3aXRoIFBpeGlKUyB2NCBmaWx0ZXJzXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZ2FjeSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x1dGlvbiBvZiBmaWx0ZXJzXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcbiAgICAgICAgLy8gbmV4dCB0aHJlZSBmaWVsZHMgYXJlIGNyZWF0ZWQgb25seSBmb3Igcm9vdFxuICAgICAgICAvLyByZS1hc3NpZ25lZCBmb3IgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3VyY2UgZnJhbWVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdGluYXRpb24gZnJhbWVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGZpbHRlcnNcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWx0ZXJbXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjbGVhcnMgdGhlIHN0YXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkZpbHRlclN0YXRlID0gRmlsdGVyU3RhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xuY29uc3QgUXVhZF8xID0gcmVxdWlyZShcIi4vUXVhZFwiKTtcbmNvbnN0IFF1YWRVdl8xID0gcmVxdWlyZShcIi4vUXVhZFV2XCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBVbmlmb3JtR3JvdXBfMSA9IHJlcXVpcmUoXCIuL1VuaWZvcm1Hcm91cFwiKTtcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1JlbmRlclRleHR1cmVcIik7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNvbnN0IEZpbHRlclN0YXRlXzEgPSByZXF1aXJlKFwiLi9GaWx0ZXJTdGF0ZVwiKTtcbmNvbnN0IERyYXdNb2RlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0RyYXdNb2RlU2V0dGluZ3NcIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNsYXNzIEZpbHRlclN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBmaWx0ZXJzIGZvciB0aGUgRmlsdGVyU3lzdGVtXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrID0gW3t9XTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0b3JlcyBhIGJ1bmNoIG9mIFBPMiB0ZXh0dXJlcyB1c2VkIGZvciBmaWx0ZXJpbmdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbCA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogYSBwb29sIGZvciBzdG9yaW5nIGZpbHRlciBzdGF0ZXMsIHNhdmUgdXMgY3JlYXRpbmcgbmV3IG9uZXMgZWFjaCB0aWNrXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZVBvb2wgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdmVyeSBzaW1wbGUgZ2VvbWV0cnkgdXNlZCB3aGVuIGRyYXdpbmcgYSBmaWx0ZXIgZWZmZWN0IHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5RdWFkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWFkID0gbmV3IFF1YWRfMS5RdWFkKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWFkIFVWc1xuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlF1YWRVdn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVhZFV2ID0gbmV3IFF1YWRVdl8xLlF1YWRVdigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVtcG9yYXJ5IHJlY3QgZm9yIG1hdGhzXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBY3RpdmUgc3RhdGVcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmVTdGF0ZSA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB1bmlmb3JtIGdyb3VwIGlzIGF0dGFjaGVkIHRvIGZpbHRlciB1bmlmb3JtcyB3aGVuIHVzZWRcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Vbmlmb3JtR3JvdXB9XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UElYSS5SZWN0YW5nbGV9IG91dHB1dEZyYW1lXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBpbnB1dFNpemVcbiAgICAgICAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGlucHV0UGl4ZWxcbiAgICAgICAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGlucHV0Q2xhbXBcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJlc29sdXRpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGZpbHRlckFyZWFcbiAgICAgICAgICogQHByb3BlcnR5IHtGbG9hZDMyQXJyYXl9IGZpbHRlckNsYW1wXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cF8xLlVuaWZvcm1Hcm91cCh7XG4gICAgICAgICAgICBvdXRwdXRGcmFtZTogdGhpcy50ZW1wUmVjdCxcbiAgICAgICAgICAgIGlucHV0U2l6ZTogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgICAgICAgIGlucHV0UGl4ZWw6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICAgICAgICBpbnB1dENsYW1wOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgICAgICAgIC8vIGxlZ2FjeSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGZpbHRlckFyZWE6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICAgICAgICBmaWx0ZXJDbGFtcDogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3BpeGVsc1dpZHRoID0gcmVuZGVyZXIudmlldy53aWR0aDtcbiAgICAgICAgdGhpcy5fcGl4ZWxzSGVpZ2h0ID0gcmVuZGVyZXIudmlldy5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgZmlsdGVyIHRvIHRoZSBTeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvZiB0aGUgZmlsdGVyIHRvIHJlbmRlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyW119IGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseS5cbiAgICAgKi9cbiAgICBwdXNoKHRhcmdldCwgZmlsdGVycykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgZmlsdGVyU3RhY2sgPSB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjaztcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZVBvb2wucG9wKCkgfHwgbmV3IEZpbHRlclN0YXRlXzEuRmlsdGVyU3RhdGUoKTtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBmaWx0ZXJzWzBdLnJlc29sdXRpb247XG4gICAgICAgIHZhciBwYWRkaW5nID0gZmlsdGVyc1swXS5wYWRkaW5nO1xuICAgICAgICB2YXIgYXV0b0ZpdCA9IGZpbHRlcnNbMF0uYXV0b0ZpdDtcbiAgICAgICAgdmFyIGxlZ2FjeSA9IGZpbHRlcnNbMF0ubGVnYWN5O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuICAgICAgICAgICAgLy8gbGV0cyB1c2UgdGhlIGxvd2VzdCByZXNvbHV0aW9uLi5cbiAgICAgICAgICAgIHJlc29sdXRpb24gPSBNYXRoLm1pbihyZXNvbHV0aW9uLCBmaWx0ZXIucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAvLyBhbmQgdGhlIGxhcmdlc3QgYW1vdW50IG9mIHBhZGRpbmchXG4gICAgICAgICAgICBwYWRkaW5nID0gTWF0aC5tYXgocGFkZGluZywgZmlsdGVyLnBhZGRpbmcpO1xuICAgICAgICAgICAgLy8gb25seSBhdXRvIGZpdCBpZiBhbGwgZmlsdGVycyBhcmUgYXV0b2ZpdFxuICAgICAgICAgICAgYXV0b0ZpdCA9IGF1dG9GaXQgfHwgZmlsdGVyLmF1dG9GaXQ7XG4gICAgICAgICAgICBsZWdhY3kgPSBsZWdhY3kgfHwgZmlsdGVyLmxlZ2FjeTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyU3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1swXS5yZW5kZXJUZXh0dXJlID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGZpbHRlclN0YWNrLnB1c2goc3RhdGUpO1xuICAgICAgICBzdGF0ZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcbiAgICAgICAgc3RhdGUubGVnYWN5ID0gbGVnYWN5O1xuICAgICAgICBzdGF0ZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLmNvcHlGcm9tKHRhcmdldC5maWx0ZXJBcmVhIHx8IHRhcmdldC5nZXRCb3VuZHModHJ1ZSkpO1xuICAgICAgICBzdGF0ZS5zb3VyY2VGcmFtZS5wYWQocGFkZGluZyk7XG4gICAgICAgIGlmIChhdXRvRml0KSB7XG4gICAgICAgICAgICBzdGF0ZS5zb3VyY2VGcmFtZS5maXQodGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLnNvdXJjZUZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByb3VuZCB0byB3aG9sZSBudW1iZXIgYmFzZWQgb24gcmVzb2x1dGlvblxuICAgICAgICBzdGF0ZS5zb3VyY2VGcmFtZS5jZWlsKHJlc29sdXRpb24pO1xuICAgICAgICBzdGF0ZS5yZW5kZXJUZXh0dXJlID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCwgc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0LCByZXNvbHV0aW9uKTtcbiAgICAgICAgc3RhdGUuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgICAgIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzdGF0ZS5yZW5kZXJUZXh0dXJlLndpZHRoO1xuICAgICAgICBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IHN0YXRlLnJlbmRlclRleHR1cmUuaGVpZ2h0O1xuICAgICAgICBzdGF0ZS5yZW5kZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gc3RhdGUuc291cmNlRnJhbWU7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChzdGF0ZS5yZW5kZXJUZXh0dXJlLCBzdGF0ZS5zb3VyY2VGcmFtZSk7IC8vIC8sIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUpO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmNsZWFyKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQb3BzIG9mZiB0aGUgZmlsdGVyIGFuZCBhcHBsaWVzIGl0LlxuICAgICAqXG4gICAgICovXG4gICAgcG9wKCkge1xuICAgICAgICB2YXIgZmlsdGVyU3RhY2sgPSB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjaztcbiAgICAgICAgdmFyIHN0YXRlID0gZmlsdGVyU3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gc3RhdGUuZmlsdGVycztcbiAgICAgICAgdGhpcy5hY3RpdmVTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB2YXIgZ2xvYmFsVW5pZm9ybXMgPSB0aGlzLmdsb2JhbFVuaWZvcm1zLnVuaWZvcm1zO1xuICAgICAgICBnbG9iYWxVbmlmb3Jtcy5vdXRwdXRGcmFtZSA9IHN0YXRlLnNvdXJjZUZyYW1lO1xuICAgICAgICBnbG9iYWxVbmlmb3Jtcy5yZXNvbHV0aW9uID0gc3RhdGUucmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGlucHV0U2l6ZSA9IGdsb2JhbFVuaWZvcm1zLmlucHV0U2l6ZTtcbiAgICAgICAgdmFyIGlucHV0UGl4ZWwgPSBnbG9iYWxVbmlmb3Jtcy5pbnB1dFBpeGVsO1xuICAgICAgICB2YXIgaW5wdXRDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XG4gICAgICAgIGlucHV0U2l6ZVswXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XG4gICAgICAgIGlucHV0U2l6ZVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgICAgICBpbnB1dFNpemVbMl0gPSAxLjAgLyBpbnB1dFNpemVbMF07XG4gICAgICAgIGlucHV0U2l6ZVszXSA9IDEuMCAvIGlucHV0U2l6ZVsxXTtcbiAgICAgICAgaW5wdXRQaXhlbFswXSA9IGlucHV0U2l6ZVswXSAqIHN0YXRlLnJlc29sdXRpb247XG4gICAgICAgIGlucHV0UGl4ZWxbMV0gPSBpbnB1dFNpemVbMV0gKiBzdGF0ZS5yZXNvbHV0aW9uO1xuICAgICAgICBpbnB1dFBpeGVsWzJdID0gMS4wIC8gaW5wdXRQaXhlbFswXTtcbiAgICAgICAgaW5wdXRQaXhlbFszXSA9IDEuMCAvIGlucHV0UGl4ZWxbMV07XG4gICAgICAgIGlucHV0Q2xhbXBbMF0gPSAwLjUgKiBpbnB1dFBpeGVsWzJdO1xuICAgICAgICBpbnB1dENsYW1wWzFdID0gMC41ICogaW5wdXRQaXhlbFszXTtcbiAgICAgICAgaW5wdXRDbGFtcFsyXSA9IChzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCAqIGlucHV0U2l6ZVsyXSkgLSAoMC41ICogaW5wdXRQaXhlbFsyXSk7XG4gICAgICAgIGlucHV0Q2xhbXBbM10gPSAoc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0ICogaW5wdXRTaXplWzNdKSAtICgwLjUgKiBpbnB1dFBpeGVsWzNdKTtcbiAgICAgICAgLy8gb25seSB1cGRhdGUgdGhlIHJlY3QgaWYgaXRzIGxlZ2FjeS4uXG4gICAgICAgIGlmIChzdGF0ZS5sZWdhY3kpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJBcmVhID0gZ2xvYmFsVW5pZm9ybXMuZmlsdGVyQXJlYTtcbiAgICAgICAgICAgIGZpbHRlckFyZWFbMF0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgICAgICAgICAgZmlsdGVyQXJlYVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgICAgICAgICAgZmlsdGVyQXJlYVsyXSA9IHN0YXRlLnNvdXJjZUZyYW1lLng7XG4gICAgICAgICAgICBmaWx0ZXJBcmVhWzNdID0gc3RhdGUuc291cmNlRnJhbWUueTtcbiAgICAgICAgICAgIGdsb2JhbFVuaWZvcm1zLmZpbHRlckNsYW1wID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRDbGFtcDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbFVuaWZvcm1zLnVwZGF0ZSgpO1xuICAgICAgICB2YXIgbGFzdFN0YXRlID0gZmlsdGVyU3RhY2tbZmlsdGVyU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZmlsdGVyc1swXS5hcHBseSh0aGlzLCBzdGF0ZS5yZW5kZXJUZXh0dXJlLCBsYXN0U3RhdGUucmVuZGVyVGV4dHVyZSwgZmFsc2UsIHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShzdGF0ZS5yZW5kZXJUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmbGlwID0gc3RhdGUucmVuZGVyVGV4dHVyZTtcbiAgICAgICAgICAgIHZhciBmbG9wID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShmbGlwLndpZHRoLCBmbGlwLmhlaWdodCwgc3RhdGUucmVzb2x1dGlvbik7XG4gICAgICAgICAgICBmbG9wLmZpbHRlckZyYW1lID0gZmxpcC5maWx0ZXJGcmFtZTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgZmxvcCwgdHJ1ZSwgc3RhdGUpO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gZmxpcDtcbiAgICAgICAgICAgICAgICBmbGlwID0gZmxvcDtcbiAgICAgICAgICAgICAgICBmbG9wID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgbGFzdFN0YXRlLnJlbmRlclRleHR1cmUsIGZhbHNlLCBzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnJldHVybkZpbHRlclRleHR1cmUoZmxpcCk7XG4gICAgICAgICAgICB0aGlzLnJldHVybkZpbHRlclRleHR1cmUoZmxvcCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zdGF0ZVBvb2wucHVzaChzdGF0ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGZpbHRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5GaWx0ZXJ9IGZpbHRlciAtIFRoZSBmaWx0ZXIgdG8gZHJhdy5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgcmVuZGVyIHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gb3V0cHV0IC0gVGhlIHRhcmdldCB0byBvdXRwdXQgdG8uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhciAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZyB0byBpdFxuICAgICAqL1xuICAgIGFwcGx5RmlsdGVyKGZpbHRlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKG91dHB1dCwgb3V0cHV0ID8gb3V0cHV0LmZpbHRlckZyYW1lIDogbnVsbCk7XG4gICAgICAgIGlmIChjbGVhcikge1xuICAgICAgICAgICAgLy8gZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xuICAgICAgICAgICAgLy8gZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB1bmlmb3Jtcy4uXG4gICAgICAgIGZpbHRlci51bmlmb3Jtcy51U2FtcGxlciA9IGlucHV0O1xuICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZmlsdGVyR2xvYmFscyA9IHRoaXMuZ2xvYmFsVW5pZm9ybXM7XG4gICAgICAgIC8vIFRPRE8gbWFrZSBpdCBzbyB0aGF0IHRoZSBvcmRlciBvZiB0aGlzIGRvZXMgbm90IG1hdHRlci4uXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgZG9lcyBhdCB0aGUgbW9tZW50IGNvcyBvZiBnbG9iYWwgdW5pZm9ybXMuXG4gICAgICAgIC8vIHRoZXkgbmVlZCB0byBnZXQgcmVzeW5jZWRcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0U3RhdGUoZmlsdGVyLnN0YXRlKTtcbiAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoZmlsdGVyKTtcbiAgICAgICAgaWYgKGZpbHRlci5sZWdhY3kpIHtcbiAgICAgICAgICAgIHRoaXMucXVhZFV2Lm1hcChpbnB1dC5fZnJhbWUsIGlucHV0LmZpbHRlckZyYW1lKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQodGhpcy5xdWFkVXYpO1xuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyhEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLlRSSUFOR0xFUyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMucXVhZCk7XG4gICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVApO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBtYXBwZWQgbWF0cml4LlxuICAgICAqXG4gICAgICogVE9ETyBwbGF5aW5nIGFyb3VuZCBoZXJlLi4gdGhpcyBpcyB0ZW1wb3JhcnkgLSAod2lsbCBlbmQgdXAgaW4gdGhlIHNoYWRlcilcbiAgICAgKiB0aGlzIHJldHVybnMgYSBtYXRyaXggdGhhdCB3aWxsIG5vcm1hbGl6ZSBtYXAgZmlsdGVyIGNvcmRzIGluIHRoZSBmaWx0ZXIgdG8gc2NyZWVuIHNwYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBvdXRwdXRNYXRyaXggLSB0aGUgbWF0cml4IHRvIG91dHB1dCB0by5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hcHBlZCBtYXRyaXguXG4gICAgICovXG4gICAgY2FsY3VsYXRlU2NyZWVuU3BhY2VNYXRyaXgob3V0cHV0TWF0cml4KSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLmFjdGl2ZVN0YXRlO1xuICAgICAgICByZXR1cm4gRmlsdGVyU3lzdGVtLmNhbGN1bGF0ZVNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLCBjdXJyZW50U3RhdGUuZGVzdGluYXRpb25GcmFtZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgbWFwIHRoZSBmaWx0ZXIgY29vcmQgc28gdGhhdCBhIHRleHR1cmUgY2FuIGJlIHVzZWQgYmFzZWQgb24gdGhlIHRyYW5zZm9ybSBvZiBhIHNwcml0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gb3V0cHV0TWF0cml4IC0gVGhlIG1hdHJpeCB0byBvdXRwdXQgdG8uXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gc3ByaXRlIC0gVGhlIHNwcml0ZSB0byBtYXAgdG8uXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoZSBtYXBwZWQgbWF0cml4LlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVNwcml0ZU1hdHJpeChvdXRwdXRNYXRyaXgsIHNwcml0ZSkge1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5hY3RpdmVTdGF0ZTtcbiAgICAgICAgcmV0dXJuIEZpbHRlclN5c3RlbS5jYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUsIGN1cnJlbnRTdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLCBzcHJpdGUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBGaWx0ZXIgU3lzdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIGNvbnRleHQgd2FzIGxvc3QsIGRvIG5vdCBmcmVlIHNoYWRlcnNcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koY29udGV4dExvc3QpIHtcbiAgICAgICAgaWYgKGNvbnRleHRMb3N0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnRleHRMb3N0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250ZXh0TG9zdCkge1xuICAgICAgICAgICAgdGhpcy5lbXB0eVBvb2woKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0cyBhIFBvd2VyLW9mLVR3byByZW5kZXIgdGV4dHVyZSBvciBmdWxsU2NyZWVuIHRleHR1cmVcbiAgICAgKlxuICAgICAqIFRPRE8gbW92ZSB0byBhIHNlcGFyYXRlIGNsYXNzIGNvdWxkIGJlIG9uIHJlbmRlcmVyP1xuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5XaWR0aCAtIFRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZSBpbiByZWFsIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluSGVpZ2h0IC0gVGhlIG1pbmltdW0gaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZSBpbiByZWFsIHBpeGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAgICogQHJldHVybiB7UElYSS5SZW5kZXJUZXh0dXJlfSBUaGUgbmV3IHJlbmRlciB0ZXh0dXJlLlxuICAgICAqL1xuICAgIGdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24pIHtcbiAgICAgICAgaWYgKHJlc29sdXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IEZpbHRlclN5c3RlbS5zY3JlZW5LZXk7XG4gICAgICAgIG1pbldpZHRoICo9IHJlc29sdXRpb247XG4gICAgICAgIG1pbkhlaWdodCAqPSByZXNvbHV0aW9uO1xuICAgICAgICBpZiAobWluV2lkdGggIT09IHRoaXMuX3BpeGVsc1dpZHRoIHx8IG1pbkhlaWdodCAhPT0gdGhpcy5fcGl4ZWxzSGVpZ2h0KSB7XG4gICAgICAgICAgICBtaW5XaWR0aCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5uZXh0UG93MihtaW5XaWR0aCk7XG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MubmV4dFBvdzIobWluSGVpZ2h0KTtcbiAgICAgICAgICAgIGtleSA9ICgobWluV2lkdGggJiAweEZGRkYpIDw8IDE2KSB8IChtaW5IZWlnaHQgJiAweEZGRkYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50ZXh0dXJlUG9vbFtrZXldKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVQb29sW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IHRoaXMudGV4dHVyZVBvb2xba2V5XS5wb3AoKTtcbiAgICAgICAgaWYgKCFyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgYnlwYXNzIGNhY2hlLi5cbiAgICAgICAgICAgIC8vIGludGVybmFsbHkgLSB0aGlzIHdpbGwgY2F1c2UgYSB0ZXh0dXJlIHRvIGJlIGJvdW5kLi5cbiAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBtaW5XaWR0aCAvIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtaW5IZWlnaHQgLyByZXNvbHV0aW9uLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJUZXh0dXJlLmZpbHRlclBvb2xLZXkgPSBrZXk7XG4gICAgICAgIHJldHVybiByZW5kZXJUZXh0dXJlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0cyBleHRyYSByZW5kZXIgdGV4dHVyZSB0byB1c2UgaW5zaWRlIGN1cnJlbnQgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVzb2x1dGlvbiByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXJUZXh0dXJlXG4gICAgICogQHJldHVybnMge1BJWEkuUmVuZGVyVGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXRGaWx0ZXJUZXh0dXJlKHJlc29sdXRpb24pIHtcbiAgICAgICAgdmFyIHJ0ID0gdGhpcy5hY3RpdmVTdGF0ZS5yZW5kZXJUZXh0dXJlO1xuICAgICAgICB2YXIgZmlsdGVyVGV4dHVyZSA9IHRoaXMuZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUocnQud2lkdGgsIHJ0LmhlaWdodCwgcmVzb2x1dGlvbiB8fCBydC5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uKTtcbiAgICAgICAgZmlsdGVyVGV4dHVyZS5maWx0ZXJGcmFtZSA9IHJ0LmZpbHRlckZyYW1lO1xuICAgICAgICByZXR1cm4gZmlsdGVyVGV4dHVyZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEZyZWVzIGEgcmVuZGVyIHRleHR1cmUgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IHJlbmRlclRleHR1cmUgLSBUaGUgcmVuZGVyVGFyZ2V0IHRvIGZyZWVcbiAgICAgKi9cbiAgICByZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgdmFyIGtleSA9IHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleTtcbiAgICAgICAgcmVuZGVyVGV4dHVyZS5maWx0ZXJGcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2xba2V5XS5wdXNoKHJlbmRlclRleHR1cmUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRW1wdGllcyB0aGUgdGV4dHVyZSBwb29sLlxuICAgICAqXG4gICAgICovXG4gICAgZW1wdHlQb29sKCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMudGV4dHVyZVBvb2wpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZVBvb2xbaV07XG4gICAgICAgICAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVzW2pdLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fTtcbiAgICB9XG4gICAgO1xuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlUG9vbFtGaWx0ZXJTeXN0ZW0uc2NyZWVuS2V5XTtcbiAgICAgICAgaWYgKHRleHR1cmVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZXNbal0uZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHR1cmVQb29sW0ZpbHRlclN5c3RlbS5zY3JlZW5LZXldID0gW107XG4gICAgICAgIHRoaXMuX3BpeGVsc1dpZHRoID0gdGhpcy5yZW5kZXJlci52aWV3LndpZHRoO1xuICAgICAgICB0aGlzLl9waXhlbHNIZWlnaHQgPSB0aGlzLnJlbmRlcmVyLnZpZXcuaGVpZ2h0O1xuICAgIH1cbiAgICA7XG4gICAgLy8gdGhpcyB3aWxsIG1hcCB0aGUgZmlsdGVyIGNvb3JkIHNvIHRoYXQgYSB0ZXh0dXJlIGNhbiBiZSB1c2VkIGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm0gb2YgYSBzcHJpdGVcbiAgICBzdGF0aWMgY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgZmlsdGVyQXJlYSwgdGV4dHVyZVNpemUsIHNwcml0ZSkge1xuICAgICAgICB2YXIgb3JpZyA9IHNwcml0ZS5fdGV4dHVyZS5vcmlnO1xuICAgICAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LnNldCh0ZXh0dXJlU2l6ZS53aWR0aCwgMCwgMCwgdGV4dHVyZVNpemUuaGVpZ2h0LCBmaWx0ZXJBcmVhLngsIGZpbHRlckFyZWEueSk7XG4gICAgICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHNwcml0ZS53b3JsZFRyYW5zZm9ybS5jb3B5VG8oTWF0cml4XzEuTWF0cml4LlRFTVBfTUFUUklYKTtcbiAgICAgICAgd29ybGRUcmFuc2Zvcm0uaW52ZXJ0KCk7XG4gICAgICAgIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKTtcbiAgICAgICAgbWFwcGVkTWF0cml4LnNjYWxlKDEuMCAvIG9yaWcud2lkdGgsIDEuMCAvIG9yaWcuaGVpZ2h0KTtcbiAgICAgICAgbWFwcGVkTWF0cml4LnRyYW5zbGF0ZShzcHJpdGUuYW5jaG9yLngsIHNwcml0ZS5hbmNob3IueSk7XG4gICAgICAgIHJldHVybiBtYXBwZWRNYXRyaXg7XG4gICAgfVxuICAgIC8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbWFwcGVkIG1hdHJpeFxuICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gb3V0cHV0TWF0cml4IG1hdHJpeCB0aGF0IHdpbGwgbm9ybWFsaXplIG1hcCBmaWx0ZXIgY29yZHMgaW4gdGhlIGZpbHRlciB0byBzY3JlZW4gc3BhY2VcbiAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGZpbHRlckFyZWEgZmlsdGVyIGFyZWFcbiAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHRleHR1cmVTaXplIHRleHR1cmUgc2l6ZVxuICogQHJldHVybnMge1BJWEkuTWF0cml4fSBzYW1lIGFzIG91dHB1dE1hdHJpeFxuICogQHByaXZhdGVcbiAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVTY3JlZW5TcGFjZU1hdHJpeChvdXRwdXRNYXRyaXgsIGZpbHRlckFyZWEsIHRleHR1cmVTaXplKSB7XG4gICAgICAgIC8vIFRPRE8gdW53cmFwP1xuICAgICAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LmlkZW50aXR5KCk7XG4gICAgICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoZmlsdGVyQXJlYS54IC8gdGV4dHVyZVNpemUud2lkdGgsIGZpbHRlckFyZWEueSAvIHRleHR1cmVTaXplLmhlaWdodCk7XG4gICAgICAgIG1hcHBlZE1hdHJpeC5zY2FsZSh0ZXh0dXJlU2l6ZS53aWR0aCwgdGV4dHVyZVNpemUuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcbiAgICB9XG59XG5GaWx0ZXJTeXN0ZW0uc2NyZWVuS2V5ID0gJ3NjcmVlbic7XG5leHBvcnRzLkZpbHRlclN5c3RlbSA9IEZpbHRlclN5c3RlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgRmxhc2hCYXNlT2JqZWN0Lm5hbWVDb3VudCsrO1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJpbnN0YW5jZS1cIiArIHRoaXMuY2xhc3NOYW1lICsgXCItXCIgKyBGbGFzaEJhc2VPYmplY3QubmFtZUNvdW50O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZU5hbWUgPSBcImluc3RhbmNlLVwiICsgdGhpcy5jbGFzc05hbWUgKyBcIi1cIiArIEZsYXNoQmFzZU9iamVjdC5uYW1lQ291bnQ7XG4gICAgICAgIHRoaXMuX2hhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yWyduYW1lJ107XG4gICAgfVxuICAgIGdldCBjbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yWyduYW1lJ107XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgfVxuICAgIGdldCBoYXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzQ2hhbmdlZDtcbiAgICB9XG4gICAgc2V0IGhhc0NoYW5nZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGFzQ2hhbmdlZCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGluc3RhbmNlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlTmFtZTtcbiAgICB9XG59XG5GbGFzaEJhc2VPYmplY3QubmFtZUNvdW50ID0gMDtcbmV4cG9ydHMuRmxhc2hCYXNlT2JqZWN0ID0gRmxhc2hCYXNlT2JqZWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4vVVJMUmVxdWVzdFwiKTtcbmNvbnN0IFVSTExvYWRlcl8xID0gcmVxdWlyZShcIi4vVVJMTG9hZGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY29uc3QgSU9FcnJvckV2ZW50XzEgPSByZXF1aXJlKFwiLi9JT0Vycm9yRXZlbnRcIik7XG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RNZXRob2RfMSA9IHJlcXVpcmUoXCIuL1VSTFJlcXVlc3RNZXRob2RcIik7XG5jb25zdCBYTUxQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL1hNTFBhcnNlclwiKTtcbmNvbnN0IE5ldHdvcmtTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTmV0d29ya1NldHRpbmdzXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi9SZXNvdXJjZUxvYWRlclwiKTtcbmNsYXNzIEZvbnRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG4gICAgc3RhdGljIHNldCBXZWJGb250Q29uZmlnKHZhbHVlKSB7XG4gICAgICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgICAgICBhY3RpdmUoKSB7XG4gICAgICAgICAgICAgICAgRm9udE1hbmFnZXIud2ViRm9udEFjdGl2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3dbJ1dlYkZvbnRDb25maWcnXSA9IGNvbmZpZztcbiAgICAgICAgRm9udE1hbmFnZXIubG9hZFdlYkZvbnQoKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJpdG1hcEZvbnQobmFtZSkge1xuICAgICAgICBpZiAoRm9udE1hbmFnZXIuYml0bWFwZm9udHNbbmFtZV0gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gRm9udE1hbmFnZXIuYml0bWFwZm9udHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBhZGRCaXRtYXBGb250KGRhdGEpIHtcbiAgICAgICAgRm9udE1hbmFnZXIuYml0bWFwZm9udHNbZGF0YS5mb250XSA9IGRhdGE7XG4gICAgfVxuICAgIHN0YXRpYyBsb2FkQml0bWFwRm9udChwYXRoKSB7XG4gICAgICAgIGxldCBsb2FkZXIgPSBuZXcgQml0bWFwRm9udExvYWRlcigpO1xuICAgICAgICBGb250TWFuYWdlci5mb250TG9hZGVyc1tsb2FkZXIuaW5zdGFuY2VOYW1lXSA9IGxvYWRlcjtcbiAgICAgICAgbG9hZGVyLmxvYWRGb250KHBhdGgpO1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VCaXRtYXBGb250RGF0YSh4bWwsIGJhc2UpIHtcbiAgICAgICAgbGV0IHBhZ2VpZDtcbiAgICAgICAgbGV0IHBhZ2VwYXRoO1xuICAgICAgICBsZXQgZGF0YSA9IG5ldyBCaXRtYXBGb250KCk7XG4gICAgICAgIGRhdGEudGV4dHVyZSA9IGJhc2U7XG4gICAgICAgIGxldCBpbmZvID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbmZvJylbMF07XG4gICAgICAgIGxldCBjb21tb24gPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NvbW1vbicpWzBdO1xuICAgICAgICBsZXQgcGFnZXMgPSB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhZ2UnKVswXTtcbiAgICAgICAgbGV0IHJlcyA9IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5nZXRSZXNvbHV0aW9uT2ZVcmwocGFnZXMuZ2V0QXR0cmlidXRlKCdmaWxlJyksIERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OKTtcbiAgICAgICAgZGF0YS5mb250ID0gaW5mby5nZXRBdHRyaWJ1dGUoJ2ZhY2UnKTtcbiAgICAgICAgZGF0YS5zaXplID0gcGFyc2VJbnQoaW5mby5nZXRBdHRyaWJ1dGUoJ3NpemUnKSwgMTApO1xuICAgICAgICBkYXRhLmxpbmVIZWlnaHQgPSBwYXJzZUludChjb21tb24uZ2V0QXR0cmlidXRlKCdsaW5lSGVpZ2h0JyksIDEwKSAvIHJlcztcbiAgICAgICAgZGF0YS5jaGFycyA9IHt9O1xuICAgICAgICBwYWdlaWQgPSBwYWdlcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIHBhZ2VwYXRoID0gcGFnZXMuZ2V0QXR0cmlidXRlKCdmaWxlJyk7XG4gICAgICAgIGRhdGEudGV4dHVyZVBhdGggPSBwYWdlcGF0aDtcbiAgICAgICAgbGV0IGxldHRlcnMgPSBBcnJheS5mcm9tKHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2hhcicpKTtcbiAgICAgICAgZm9yIChsZXQgaSQxID0gMDsgaSQxIDwgbGV0dGVycy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBsZXQgbGV0dGVyID0gbGV0dGVyc1tpJDFdO1xuICAgICAgICAgICAgbGV0IGNoYXJDb2RlID0gcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgnaWQnKSwgMTApO1xuICAgICAgICAgICAgbGV0IHBhZ2UgPSBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCdwYWdlJykpIHx8IDA7XG4gICAgICAgICAgICBsZXQgdGV4dHVyZVJlY3QgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKChwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCd4JyksIDEwKSAvIHJlcykgKyAoYmFzZS5mcmFtZS54IC8gcmVzKSwgKHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ3knKSwgMTApIC8gcmVzKSArIChiYXNlLmZyYW1lLnkgLyByZXMpLCBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLCAxMCkgLyByZXMsIHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpLCAxMCkgLyByZXMpO1xuICAgICAgICAgICAgbGV0IGZvbnRjaGFyID0gbmV3IEZvbnRDaGFyYWN0ZXJEYXRhKCk7XG4gICAgICAgICAgICBmb250Y2hhci54T2Zmc2V0ID0gcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgneG9mZnNldCcpLCAxMCkgLyByZXM7XG4gICAgICAgICAgICBmb250Y2hhci55T2Zmc2V0ID0gcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgneW9mZnNldCcpLCAxMCkgLyByZXM7XG4gICAgICAgICAgICBmb250Y2hhci54QWR2YW5jZSA9IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ3hhZHZhbmNlJyksIDEwKSAvIHJlcztcbiAgICAgICAgICAgIGZvbnRjaGFyLmtlcm5pbmcgPSB7fTtcbiAgICAgICAgICAgIGZvbnRjaGFyLnRleHR1cmUgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUoYmFzZS5iYXNlVGV4dHVyZSwgdGV4dHVyZVJlY3QpO1xuICAgICAgICAgICAgZm9udGNoYXIucGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICBkYXRhLmNoYXJzW2NoYXJDb2RlXSA9IGZvbnRjaGFyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBrZXJuaW5ncyA9IEFycmF5LmZyb20oeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdrZXJuaW5nJykpO1xuICAgICAgICBmb3IgKGxldCBpJDIgPSAwOyBpJDIgPCBrZXJuaW5ncy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICBsZXQga2VybmluZyA9IGtlcm5pbmdzW2kkMl07XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSBwYXJzZUludChrZXJuaW5nLmdldEF0dHJpYnV0ZSgnZmlyc3QnKSwgMTApIC8gcmVzO1xuICAgICAgICAgICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KGtlcm5pbmcuZ2V0QXR0cmlidXRlKCdzZWNvbmQnKSwgMTApIC8gcmVzO1xuICAgICAgICAgICAgbGV0IGFtb3VudCA9IHBhcnNlSW50KGtlcm5pbmcuZ2V0QXR0cmlidXRlKCdhbW91bnQnKSwgMTApIC8gcmVzO1xuICAgICAgICAgICAgaWYgKGRhdGEuY2hhcnNbc2Vjb25kXSkge1xuICAgICAgICAgICAgICAgIGRhdGEuY2hhcnNbc2Vjb25kXS5rZXJuaW5nW2ZpcnN0XSA9IGFtb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5Gb250TWFuYWdlci5mb250TG9hZGVycyA9IHt9O1xuRm9udE1hbmFnZXIuYml0bWFwZm9udHMgPSB7fTtcbkZvbnRNYW5hZ2VyLndlYkZvbnRBY3RpdmUgPSAoKSA9PiB7XG4gICAgaWYgKEZvbnRNYW5hZ2VyLm9uV2ViRm9udGxvYWRlZCkge1xuICAgICAgICBGb250TWFuYWdlci5vbldlYkZvbnRsb2FkZWQoKTtcbiAgICB9XG59O1xuRm9udE1hbmFnZXIubG9hZFdlYkZvbnQgPSAoKSA9PiB7XG4gICAgY29uc3Qgd2YgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICB3Zi5zcmMgPSBgJHtkb2N1bWVudC5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnaHR0cHMnIDogJ2h0dHAnfTovL2FqYXguZ29vZ2xlYXBpcy5jb20vYWpheC9saWJzL3dlYmZvbnQvMS93ZWJmb250LmpzYDtcbiAgICB3Zi50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgd2YuYXN5bmMgPSAndHJ1ZSc7XG4gICAgY29uc3QgcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICBzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHdmLCBzKTtcbn07XG5leHBvcnRzLkZvbnRNYW5hZ2VyID0gRm9udE1hbmFnZXI7XG5jbGFzcyBCaXRtYXBGb250IHtcbn1cbmV4cG9ydHMuQml0bWFwRm9udCA9IEJpdG1hcEZvbnQ7XG5jbGFzcyBCaXRtYXBGb250TG9hZGVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVGb250WE1MQ29tcGxldGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZm9udHhtbCA9IFhNTFBhcnNlcl8xLlhNTFBhcnNlci5wYXJzZSh0aGlzLnVybGxvYWRlci5kYXRhKTtcbiAgICAgICAgICAgIGxldCBwYWdlcyA9IHRoaXMuZm9udHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncGFnZScpWzBdO1xuICAgICAgICAgICAgbGV0IHBhZ2VwYXRoID0gcGFnZXMuZ2V0QXR0cmlidXRlKCdmaWxlJyk7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVsb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QodGhpcy5yb290cGF0aCArIHBhZ2VwYXRoKSk7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZXRleHR1cmVMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlbG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGV0ZXh0dXJlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgYiA9IG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMudGV4dHVyZWxvYWRlci5pbWFnZURhdGEpO1xuICAgICAgICAgICAgbGV0IHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUoYik7XG4gICAgICAgICAgICB0aGlzLmZvbnRkYXRhID0gRm9udE1hbmFnZXIucGFyc2VCaXRtYXBGb250RGF0YSh0aGlzLmZvbnR4bWwsIHQpO1xuICAgICAgICAgICAgRm9udE1hbmFnZXIuYWRkQml0bWFwRm9udCh0aGlzLmZvbnRkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ09NUExFVEUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVGb250TG9hZEVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBsb2FkRm9udChwYXRoKSB7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KHBhdGgpO1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiL1wiKSA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgcGF0aHBhcnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICBwYXRocGFydHMucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnJvb3RwYXRoID0gcGF0aHBhcnRzLmpvaW4oXCIvXCIpICsgXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJvb3RwYXRoID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IFVSTFJlcXVlc3RNZXRob2RfMS5VUkxSZXF1ZXN0TWV0aG9kLlBPU1Q7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyID0gbmV3IFVSTExvYWRlcl8xLlVSTExvYWRlcigpO1xuICAgICAgICB0aGlzLnVybGxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRm9udFhNTENvbXBsZXRlKTtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQuSU9fRVJST1IsIHRoaXMuaGFuZGxlRm9udExvYWRFcnJvcik7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmxvYWQocmVxdWVzdCk7XG4gICAgfVxufVxuY2xhc3MgRm9udENoYXJhY3RlckRhdGEge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XG5jb25zdCBEZXB0aFJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9EZXB0aFJlc291cmNlXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNvbnN0IFJ1bm5lcl8xID0gcmVxdWlyZShcIi4vUnVubmVyXCIpO1xuY2xhc3MgRnJhbWVidWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCB8fCAxMDApO1xuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgfHwgMTAwKTtcbiAgICAgICAgdGhpcy5zdGVuY2lsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVwdGggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXJ0eUlkID0gMDtcbiAgICAgICAgdGhpcy5kaXJ0eUZvcm1hdCA9IDA7XG4gICAgICAgIHRoaXMuZGlydHlTaXplID0gMDtcbiAgICAgICAgdGhpcy5kZXB0aFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbG9yVGV4dHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5nbEZyYW1lYnVmZmVycyA9IHt9O1xuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyXzEuUnVubmVyKCdkaXNwb3NlRnJhbWVidWZmZXInLCAyKTtcbiAgICAgICAgLy8gdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcignZGlzcG9zZUZyYW1lYnVmZmVyJywgMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgY29sb3JUZXh0dXJlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGNvbG9yVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JUZXh0dXJlc1swXTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0dXJlIHRvIHRoZSBjb2xvclRleHR1cmUgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gLSBJbmRleCBvZiB0aGUgYXJyYXkgdG8gYWRkIHRoZSB0ZXh0dXJlIHRvXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IFt0ZXh0dXJlXSAtIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBhcnJheVxuICAgICAqL1xuICAgIGFkZENvbG9yVGV4dHVyZShpbmRleCwgdGV4dHVyZSkge1xuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gYWRkIHNvbWUgdmFsaWRhdGlvbiB0byB0aGUgdGV4dHVyZSAtIHNhbWUgd2lkdGggLyBoZWlnaHQgZXRjP1xuICAgICAgICB0aGlzLmNvbG9yVGV4dHVyZXNbaW5kZXhdID0gdGV4dHVyZSB8fCBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShudWxsLCB7IHNjYWxlTW9kZTogMCxcbiAgICAgICAgICAgIHJlc29sdXRpb246IDEsXG4gICAgICAgICAgICBtaXBtYXA6IGZhbHNlLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH0pOyAvLyB8fCBuZXcgVGV4dHVyZSgpO1xuICAgICAgICB0aGlzLmRpcnR5SWQrKztcbiAgICAgICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGRlcHRoIHRleHR1cmUgdG8gdGhlIGZyYW1lIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IFt0ZXh0dXJlXSAtIFRleHR1cmUgdG8gYWRkXG4gICAgICovXG4gICAgYWRkRGVwdGhUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IHRleHR1cmUgfHwgbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUobmV3IERlcHRoUmVzb3VyY2VfMS5EZXB0aFJlc291cmNlKG51bGwsIHsgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgfSksIHsgc2NhbGVNb2RlOiAwLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICAgIG1pcG1hcDogZmFsc2UsXG4gICAgICAgICAgICBmb3JtYXQ6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLkZPUk1BVFMuREVQVEhfQ09NUE9ORU5ULFxuICAgICAgICAgICAgdHlwZTogV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfU0hPUlQgfSk7IC8vIFVOU0lHTkVEX1NIT1JUO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xuICAgICAgICB0aGlzLmRpcnR5Rm9ybWF0Kys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRW5hYmxlIGRlcHRoIG9uIHRoZSBmcmFtZSBidWZmZXJcbiAgICAgKi9cbiAgICBlbmFibGVEZXB0aCgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xuICAgICAgICB0aGlzLmRpcnR5Rm9ybWF0Kys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHN0ZW5jaWwgb24gdGhlIGZyYW1lIGJ1ZmZlclxuICAgICAqL1xuICAgIGVuYWJsZVN0ZW5jaWwoKSB7XG4gICAgICAgIHRoaXMuc3RlbmNpbCA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xuICAgICAgICB0aGlzLmRpcnR5Rm9ybWF0Kys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzaXplIHRoZSBmcmFtZSBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSBmcmFtZSBidWZmZXIgdG8gcmVzaXplIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgZnJhbWUgYnVmZmVyIHRvIHJlc2l6ZSB0b1xuICAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy53aWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgICAgIHRoaXMuZGlydHlTaXplKys7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb2xvclRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY29sb3JUZXh0dXJlc1tpXTtcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gdGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgLy8gdGFrZSBpbnRvIGFjb3VudCB0aGUgZmFjdCB0aGUgdGV4dHVyZSBtYXkgaGF2ZSBhIGRpZmZlcmVudCByZXNvbHV0aW9uLi5cbiAgICAgICAgICAgIHRleHR1cmUuc2V0U2l6ZSh3aWR0aCAvIHJlc29sdXRpb24sIGhlaWdodCAvIHJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRlcHRoVGV4dHVyZSkge1xuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24kMSA9IHRoaXMuZGVwdGhUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiQxLCBoZWlnaHQgLyByZXNvbHV0aW9uJDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBkaXNwb3NlcyBXZWJHTCByZXNvdXJjZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoaXMgZ2VvbWV0cnlcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICAvLyB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyLnJ1bih0aGlzLCBmYWxzZSk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuRnJhbWVidWZmZXIgPSBGcmFtZWJ1ZmZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBGcmFtZWJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vRnJhbWVidWZmZXJcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY2xhc3MgRnJhbWVidWZmZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBtYW5hZ2VkIGZyYW1lYnVmZmVyc1xuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkZyYW1lYnVmZmVyW119XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGcmFtZWJ1ZmZlciB2YWx1ZSB0aGF0IHNob3dzIHRoYXQgd2UgZG9uJ3Qga25vdyB3aGF0IGlzIGJvdW5kXG4gICAgICAgICAqIEBtZW1iZXIge0ZyYW1lYnVmZmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5rbm93bkZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyXzEuRnJhbWVidWZmZXIoMTAsIDEwKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXG4gICAgICovXG4gICAgY29udGV4dENoYW5nZShnbCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMudW5rbm93bkZyYW1lYnVmZmVyO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgICAgICB0aGlzLmhhc01SVCA9IHRydWU7XG4gICAgICAgIHRoaXMud3JpdGVEZXB0aFRleHR1cmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc3Bvc2VBbGwodHJ1ZSk7XG4gICAgICAgIC8vIHdlYmdsMlxuICAgICAgICBpZiAodGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgLy8gd2ViZ2wgMSFcbiAgICAgICAgICAgIHZhciBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLmRyYXdCdWZmZXJzO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZURlcHRoVGV4dHVyZUV4dGVuc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLmRlcHRoVGV4dHVyZTtcbiAgICAgICAgICAgIGlmIChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUFJFRkVSX0VOViA9PT0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLkVOVi5XRUJHTF9MRUdBQ1kpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGdsLmRyYXdCdWZmZXJzID0gZnVuY3Rpb24gKGFjdGl2ZVRleHR1cmVzKSB7IHJldHVybiBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbi5kcmF3QnVmZmVyc1dFQkdMKGFjdGl2ZVRleHR1cmVzKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzTVJUID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2wuZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0ZURlcHRoVGV4dHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgICAgICogQmluZCBhIGZyYW1lYnVmZmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gW2ZyYW1lXSBmcmFtZSwgZGVmYXVsdCBpcyBmcmFtZWJ1ZmZlciBzaXplXG4gICAgICAgICAqL1xuICAgIGJpbmQoZnJhbWVidWZmZXIgPSBudWxsLCBmcmFtZSA9IG51bGwpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgaWYgKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGNhY2hpbmcgbGF5ZXIhXG4gICAgICAgICAgICB2YXIgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0gfHwgdGhpcy5pbml0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudCAhPT0gZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBmcmFtZWJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiby5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHRleHR1cmVzIGFyZSB1bmJvdW5kLi5cbiAgICAgICAgICAgIC8vIG5vdyBjaGVjayBmb3IgdXBkYXRlcy4uLlxuICAgICAgICAgICAgaWYgKGZiby5kaXJ0eUlkICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eUlkKSB7XG4gICAgICAgICAgICAgICAgZmJvLmRpcnR5SWQgPSBmcmFtZWJ1ZmZlci5kaXJ0eUlkO1xuICAgICAgICAgICAgICAgIGlmIChmYm8uZGlydHlGb3JtYXQgIT09IGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZiby5kaXJ0eUZvcm1hdCA9IGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmJvLmRpcnR5U2l6ZSAhPT0gZnJhbWVidWZmZXIuZGlydHlTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGZiby5kaXJ0eVNpemUgPSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldLnRleHR1cmVQYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQoZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlc1tpXS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQoZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoZnJhbWUueCwgZnJhbWUueSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoZnJhbWUueCwgZnJhbWUueSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIHRoaXMucmVuZGVyZXIud2lkdGgsIHRoaXMucmVuZGVyZXIuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQncyB2aWV3cG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gWCBwb3NpdGlvbiBvZiB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gWSBwb3NpdGlvbiBvZiB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB2aWV3cG9ydFxuICAgICAqL1xuICAgIHNldFZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZpZXdwb3J0O1xuICAgICAgICBpZiAodi53aWR0aCAhPT0gd2lkdGggfHwgdi5oZWlnaHQgIT09IGhlaWdodCB8fCB2LnggIT09IHggfHwgdi55ICE9PSB5KSB7XG4gICAgICAgICAgICB2LnggPSB4O1xuICAgICAgICAgICAgdi55ID0geTtcbiAgICAgICAgICAgIHYud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHYuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5nbC52aWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IHdpZHRoIGFuZCBoZWlnaHQuIFJldHVybnMgb2JqZWN0IHdpdGggYHdpZHRoYCBhbmQgYGhlaWdodGAgdmFsdWVzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBUT0RPIHN0b3JlIHRlbXBcbiAgICAgICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB0aGlzLmN1cnJlbnQud2lkdGgsIGhlaWdodDogdGhpcy5jdXJyZW50LmhlaWdodCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB0aGlzLnJlbmRlcmVyLndpZHRoLCBoZWlnaHQ6IHRoaXMucmVuZGVyZXIuaGVpZ2h0IH07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY29sb3Igb2YgdGhlIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByIC0gUmVkIHZhbHVlIGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgLSBHcmVlbiB2YWx1ZSBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIC0gQmx1ZSB2YWx1ZSBmcm9tIDAgdG8gMVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gQWxwaGEgdmFsdWUgZnJvbSAwIHRvIDFcbiAgICAgKi9cbiAgICBjbGVhcihyID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMSkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICAvLyBUT0RPIGNsZWFyIGNvbG9yIGNhbiBiZSBzZXQgb25seSBvbmUgcmlnaHQ/XG4gICAgICAgIGdsLmNsZWFyQ29sb3IociwgZywgYiwgYSk7XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogSW5pdGlhbGl6ZSBmcmFtZWJ1ZmZlclxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcbiAqL1xuICAgIGluaXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICAvLyBUT0RPIC0gbWFrZSB0aGlzIGEgY2xhc3M/XG4gICAgICAgIHZhciBmYm8gPSB7XG4gICAgICAgICAgICBmcmFtZWJ1ZmZlcjogZ2wuY3JlYXRlRnJhbWVidWZmZXIoKSxcbiAgICAgICAgICAgIHN0ZW5jaWw6IG51bGwsXG4gICAgICAgICAgICBkaXJ0eUlkOiAwLFxuICAgICAgICAgICAgZGlydHlGb3JtYXQ6IDAsXG4gICAgICAgICAgICBkaXJ0eVNpemU6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdID0gZmJvO1xuICAgICAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMucHVzaChmcmFtZWJ1ZmZlcik7XG4gICAgICAgIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpO1xuICAgICAgICByZXR1cm4gZmJvO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzaXplIHRoZSBmcmFtZWJ1ZmZlclxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcbiAgICAgKi9cbiAgICByZXNpemVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICB2YXIgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIGlmIChmYm8uc3RlbmNpbCkge1xuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKTtcbiAgICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sb3JUZXh0dXJlcyA9IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoY29sb3JUZXh0dXJlc1tpXSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBmcmFtZWJ1ZmZlclxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcbiAgICAgKi9cbiAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICB2YXIgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIC8vIGJpbmQgdGhlIGNvbG9yIHRleHR1cmVcbiAgICAgICAgdmFyIGNvbG9yVGV4dHVyZXMgPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzO1xuICAgICAgICB2YXIgY291bnQgPSBjb2xvclRleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFnbC5kcmF3QnVmZmVycykge1xuICAgICAgICAgICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2ZVRleHR1cmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldO1xuICAgICAgICAgICAgaWYgKHRleHR1cmUudGV4dHVyZVBhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZCh0ZXh0dXJlLnRleHR1cmUsIDApO1xuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCArIHRleHR1cmUuc2lkZSwgdGV4dHVyZS50ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQodGV4dHVyZSwgMCk7XG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS50ZXh0dXJlLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjdGl2ZVRleHR1cmVzLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZlVGV4dHVyZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZ2wuZHJhd0J1ZmZlcnMoYWN0aXZlVGV4dHVyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZURlcHRoVGV4dHVyZSA9IHRoaXMud3JpdGVEZXB0aFRleHR1cmU7XG4gICAgICAgICAgICBpZiAod3JpdGVEZXB0aFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwdGhUZXh0dXJlID0gZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5iaW5kKGRlcHRoVGV4dHVyZSwgMCk7XG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIGRlcHRoVGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXS50ZXh0dXJlLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZiby5zdGVuY2lsICYmIChmcmFtZWJ1ZmZlci5zdGVuY2lsIHx8IGZyYW1lYnVmZmVyLmRlcHRoKSkge1xuICAgICAgICAgICAgZmJvLnN0ZW5jaWwgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8uc3RlbmNpbCk7XG4gICAgICAgICAgICAvLyBUT0RPLi4gdGhpcyBpcyBkZXB0aCBBTkQgc3RlbmNpbD9cbiAgICAgICAgICAgIGlmICghZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7IC8vIHlvdSBjYW4ndCBoYXZlIGJvdGgsIHNvIG9uZSBzaG91bGQgdGFrZSBwcmlvcml0eSBpZiBlbmFibGVkXG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBmYm8uc3RlbmNpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICAgICAgICAvLyBmYm8uZW5hYmxlU3RlbmNpbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBmcmFtZWJ1ZmZlclxuICAgICAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXIgZnJhbWVidWZmZXIgdGhhdCBoYXMgdG8gYmUgZGlzcG9zZWQgb2ZcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250ZXh0TG9zdD1mYWxzZV0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgYWxsIGRlbGV0ZSBmdW5jdGlvbiBjYWxsc1xuICAgICAqL1xuICAgIGRpc3Bvc2VGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlciwgY29udGV4dExvc3QpIHtcbiAgICAgICAgdmFyIGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAoIWZibykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLmluZGV4T2YoZnJhbWVidWZmZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWVidWZmZXIuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgICAgIGlmICghY29udGV4dExvc3QpIHtcbiAgICAgICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZiby5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAoZmJvLnN0ZW5jaWwpIHtcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoZmJvLnN0ZW5jaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBhbGwgZnJhbWVidWZmZXJzLCBidXQgbm90IHRleHR1cmVzIGJvdW5kIHRvIHRoZW1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250ZXh0TG9zdD1mYWxzZV0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgYWxsIGRlbGV0ZSBmdW5jdGlvbiBjYWxsc1xuICAgICAqL1xuICAgIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnM7XG4gICAgICAgIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QuY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlRnJhbWVidWZmZXIobGlzdFtpXSwgY29udGV4dExvc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiByZXNldHMgZnJhbWVidWZmZXIgc3RvcmVkIHN0YXRlLCBiaW5kcyBzY3JlZW4gZnJhbWVidWZmZXJcbiAgICAgKlxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIHJlbmRlclRleHR1cmUgcmVzZXQoKVxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnVua25vd25GcmFtZWJ1ZmZlcjtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5GcmFtZWJ1ZmZlclN5c3RlbSA9IEZyYW1lYnVmZmVyU3lzdGVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBHTEJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLnVwZGF0ZUlEID0gLTE7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IC0xO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICB9XG59XG5leHBvcnRzLkdMQnVmZmVyID0gR0xCdWZmZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEdMUHJvZ3JhbSB7XG4gICAgY29uc3RydWN0b3IocHJvZ3JhbSwgdW5pZm9ybURhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIHNoYWRlciBwcm9ncmFtXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFByb2dyYW19XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBob2xkcyB0aGUgdW5pZm9ybSBkYXRhIHdoaWNoIGNvbnRhaW5zIHVuaWZvcm0gbG9jYXRpb25zXG4gICAgICAgICAqIGFuZCBjdXJyZW50IHVuaWZvcm0gdmFsdWVzIHVzZWQgZm9yIGNhY2hpbmcgYW5kIHByZXZlbnRpbmcgdW5uZWVkZWQgR1BVIGNvbW1hbmRzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5pZm9ybURhdGEgPSB1bmlmb3JtRGF0YTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuaWZvcm1Hcm91cHMgaG9sZHMgdGhlIHZhcmlvdXMgdXBsb2FkIGZ1bmN0aW9ucyBmb3IgdGhlIHNoYWRlci4gRWFjaCB1bmlmb3JtIGdyb3VwXG4gICAgICAgICAqIGFuZCBwcm9ncmFtIGhhdmUgYSB1bmlxdWUgdXBsb2FkIGZ1bmN0aW9uIGdlbmVyYXRlZC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bmlmb3JtR3JvdXBzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgcHJvZ3JhbVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybURhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cHMgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkdMUHJvZ3JhbSA9IEdMUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgR0xUZXh0dXJlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBXZWJHTCB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7V2ViR0xUZXh0dXJlfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB0aGlzLndpZHRoID0gLTE7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0dXJlIGNvbnRlbnRzIGRpcnR5IGZsYWdcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eUlkID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0dXJlIHN0eWxlIGRpcnR5IGZsYWdcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgbWlwIGxldmVscyBoYXMgdG8gYmUgZ2VuZXJhdGVkXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pcG1hcCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcE1vZGUgY29waWVkIGZyb20gYmFzZVRleHR1cmVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwTW9kZSA9IDMzMDcxO1xuICAgIH1cbn1cbmV4cG9ydHMuR0xUZXh0dXJlID0gR0xUZXh0dXJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBdHRyaWJ1dGVfMSA9IHJlcXVpcmUoXCIuL0F0dHJpYnV0ZVwiKTtcbmNvbnN0IEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xuY29uc3QgUnVubmVyXzEgPSByZXF1aXJlKFwiLi9SdW5uZXJcIik7XG5jbGFzcyBHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVycyA9IFtdLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gYnVmZmVycztcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgVkFPc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdsVmVydGV4QXJyYXlPYmplY3RzID0ge307XG4gICAgICAgIHRoaXMuaWQgPSBHZW9tZXRyeS5VSUQkMSsrO1xuICAgICAgICB0aGlzLmluc3RhbmNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluc3RhbmNlQ291bnQgPSAxO1xuICAgICAgICB0aGlzLl9zaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignZGlzcG9zZUdlb21ldHJ5JywgMik7XG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoJ2Rpc3Bvc2VHZW9tZXRyeScsIDIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnQgb2YgZXhpc3RpbmcgKG5vdCBkZXN0cm95ZWQpIG1lc2hlcyB0aGF0IHJlZmVyZW5jZSB0aGlzIGdlb21ldHJ5XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKlxuICAgICogQWRkcyBhbiBhdHRyaWJ1dGUgdG8gdGhlIGdlb21ldHJ5XG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSAobWF0Y2hpbmcgdXAgdG8gYSBzaGFkZXIpXG4gICAgKiBAcGFyYW0ge1BJWEkuQnVmZmVyfSBbYnVmZmVyXSB0aGUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIGRhdGEgb2YgdGhlIGF0dHJpYnV0ZSAuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIEFycmF5IGFuZCBhIGJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgZnJvbSBpdC5cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZT0wXSB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB5b3UgaGF2ZSAyIGZsb2F0cyBwZXIgdmVydGV4IChlZyBwb3NpdGlvbiB4IGFuZCB5KSB0aGlzIHdvdWxkIGJlIDJcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIHNob3VsZCB0aGUgZGF0YSBiZSBub3JtYWxpemVkLlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0eXBlPVBJWEkuVFlQRVMuRkxPQVRdIHdoYXQgdHlwZSBvZiBudW1iZXIgaXMgdGhlIGF0dHJpYnV0ZS4gQ2hlY2sge1BJWEkuVFlQRVN9IHRvIHNlZSB0aGUgb25lcyBhdmFpbGFibGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RyaWRlPTBdIEhvdyBmYXIgYXBhcnQgKGluIGZsb2F0cykgdGhlIHN0YXJ0IG9mIGVhY2ggdmFsdWUgaXMuICh1c2VkIGZvciBpbnRlcmxlYXZpbmcgZGF0YSlcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gSG93IGZhciBpbnRvIHRoZSBhcnJheSB0byBzdGFydCByZWFkaW5nIHZhbHVlcyAodXNlZCBmb3IgaW50ZXJsZWF2aW5nIGRhdGEpXG4gICAgKlxuICAgICogQHJldHVybiB7UElYSS5HZW9tZXRyeX0gcmV0dXJucyBzZWxmLCB1c2VmdWwgZm9yIGNoYWluaW5nLlxuICAgICovXG4gICAgYWRkQXR0cmlidXRlKGlkLCBidWZmZXIsIHNpemUgPSBudWxsLCBub3JtYWxpemVkID0gZmFsc2UsIHR5cGUgPSBudWxsLCBzdHJpZGUgPSB1bmRlZmluZWQsIHN0YXJ0ID0gdW5kZWZpbmVkLCBpbnN0YW5jZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGEgYnVmZmVyIHdoZW4gY3JlYXRpbmcgYW4gYXR0cmlidXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGJ1ZmZlciFcbiAgICAgICAgaWYgKCFidWZmZXIuZGF0YSkge1xuICAgICAgICAgICAgLy8gaXRzIGFuIGFycmF5IVxuICAgICAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZHMgPSBpZC5zcGxpdCgnfCcpO1xuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoaWRzW2ldLCBidWZmZXIsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYnVmZmVyKTtcbiAgICAgICAgaWYgKGJ1ZmZlckluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgICAgICAgIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2lkXSA9IG5ldyBBdHRyaWJ1dGVfMS5BdHRyaWJ1dGUoYnVmZmVySW5kZXgsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUsIHN0cmlkZSwgc3RhcnQsIGluc3RhbmNlKTtcbiAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCBpZiB0aGVyZSBpcyBpbnN0YW5jZWQgZGF0YSB0aGVuIHRoaXMgd2lsbCBiZSBkcmF3biB3aXRoIGluc3RhbmNpbmchXG4gICAgICAgIHRoaXMuaW5zdGFuY2VkID0gdGhpcy5pbnN0YW5jZWQgfHwgaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkICB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHJlcXVpcmVkXG4gICAgICogQHJldHVybiB7UElYSS5BdHRyaWJ1dGV9IHRoZSBhdHRyaWJ1dGUgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW3RoaXMuYXR0cmlidXRlc1tpZF0uYnVmZmVyXTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICpcbiAgICAqIEFkZHMgYW4gaW5kZXggYnVmZmVyIHRvIHRoZSBnZW9tZXRyeVxuICAgICogVGhlIGluZGV4IGJ1ZmZlciBjb250YWlucyBpbnRlZ2VycywgdGhyZWUgZm9yIGVhY2ggdHJpYW5nbGUgaW4gdGhlIGdlb21ldHJ5LCB3aGljaCByZWZlcmVuY2UgdGhlIHZhcmlvdXMgYXR0cmlidXRlIGJ1ZmZlcnMgKHBvc2l0aW9uLCBjb2xvdXIsIFVWIGNvb3JkaW5hdGVzLCBvdGhlciBVViBjb29yZGluYXRlcywgbm9ybWFsLCDigKYpLiBUaGVyZSBpcyBvbmx5IE9ORSBpbmRleCBidWZmZXIuXG4gICAgKlxuICAgICogQHBhcmFtIHtQSVhJLkJ1ZmZlcn0gW2J1ZmZlcl0gdGhlIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSBkYXRhIG9mIHRoZSBpbmRleCBidWZmZXIuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIEFycmF5IGFuZCBhIGJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgZnJvbSBpdC5cbiAgICAqIEByZXR1cm4ge1BJWEkuR2VvbWV0cnl9IHJldHVybnMgc2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICAqL1xuICAgIGFkZEluZGV4KGJ1ZmZlcikge1xuICAgICAgICBpZiAoIWJ1ZmZlci5kYXRhKSB7XG4gICAgICAgICAgICAvLyBpdHMgYW4gYXJyYXkhXG4gICAgICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIuaW5kZXggPSB0cnVlO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmluZGV4T2YoYnVmZmVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBpbmRleCBidWZmZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuQnVmZmVyfSB0aGUgaW5kZXggYnVmZmVyLlxuICAgICAqL1xuICAgIGdldEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleEJ1ZmZlcjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIHN0cnVjdHVyZSBzbyB0aGF0IGFsbCBjdXJyZW50IGF0dHJpYnV0ZXMgYmVjb21lIGludGVybGVhdmVkIGludG8gYSBzaW5nbGUgYnVmZmVyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdXIgbW9kZWwgcmVtYWlucyBzdGF0aWMgYXMgaXQgb2ZmZXJzIGEgbGl0dGxlIHBlcmZvcm1hbmNlIGJvb3N0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdlb21ldHJ5fSByZXR1cm5zIHNlbGYsIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgaW50ZXJsZWF2ZSgpIHtcbiAgICAgICAgLy8gYSBzaW1wbGUgY2hlY2sgdG8gc2VlIGlmIGJ1ZmZlcnMgYXJlIGFscmVhZHkgaW50ZXJsZWF2ZWQuLlxuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMSB8fCAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLmluZGV4QnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzdW1lIGFscmVhZHkgdGhhdCBubyBidWZmZXJzIGFyZSBpbnRlcmxlYXZlZFxuICAgICAgICB2YXIgYXJyYXlzID0gW107XG4gICAgICAgIHZhciBzaXplcyA9IFtdO1xuICAgICAgICB2YXIgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKCk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1thdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgICAgICAgIGFycmF5cy5wdXNoKGJ1ZmZlci5kYXRhKTtcbiAgICAgICAgICAgIHNpemVzLnB1c2goKGF0dHJpYnV0ZS5zaXplICogR2VvbWV0cnkuYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdKSAvIDQpO1xuICAgICAgICAgICAgYXR0cmlidXRlLmJ1ZmZlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJsZWF2ZWRCdWZmZXIuZGF0YSA9IEdlb21ldHJ5LmludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyc1tpXSAhPT0gdGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJzID0gW2ludGVybGVhdmVkQnVmZmVyXTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5kYXRhLmxlbmd0aCAvICgoYXR0cmlidXRlLnN0cmlkZSAvIDQpIHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIGRpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeVxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lci5ydW4odGhpcywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBnZW9tZXRyeS5cbiAgICAgKi9cbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBjbG9uZSBvZiB0aGUgZ2VvbWV0cnlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQSVhJLkdlb21ldHJ5fSBhIG5ldyBjbG9uZSBvZiB0aGlzIGdlb21ldHJ5XG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2VvbWV0cnkuYnVmZmVyc1tpXSA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodGhpcy5idWZmZXJzW2ldLmRhdGEuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdmFyIGF0dHJpYiA9IHRoaXMuYXR0cmlidXRlc1tpJDFdO1xuICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlc1tpJDFdID0gbmV3IEF0dHJpYnV0ZV8xLkF0dHJpYnV0ZShhdHRyaWIuYnVmZmVyLCBhdHRyaWIuc2l6ZSwgYXR0cmliLm5vcm1hbGl6ZWQsIGF0dHJpYi50eXBlLCBhdHRyaWIuc3RyaWRlLCBhdHRyaWIuc3RhcnQsIGF0dHJpYi5pbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1t0aGlzLmJ1ZmZlcnMuaW5kZXhPZih0aGlzLmluZGV4QnVmZmVyKV07XG4gICAgICAgICAgICBnZW9tZXRyeS5pbmRleEJ1ZmZlci5pbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogbWVyZ2VzIGFuIGFycmF5IG9mIGdlb21ldHJpZXMgaW50byBhIG5ldyBzaW5nbGUgb25lXG4gICAgICogZ2VvbWV0cnkgYXR0cmlidXRlIHN0eWxlcyBtdXN0IG1hdGNoIGZvciB0aGlzIG9wZXJhdGlvbiB0byB3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR2VvbWV0cnlbXX0gZ2VvbWV0cmllcyBhcnJheSBvZiBnZW9tZXRyaWVzIHRvIG1lcmdlXG4gICAgICogQHJldHVybnMge1BJWEkuR2VvbWV0cnl9IHNoaW55IG5ldyBnZW9tZXRyeSFcbiAgICAgKi9cbiAgICBzdGF0aWMgbWVyZ2UoZ2VvbWV0cmllcykge1xuICAgICAgICAvLyB0b2RvIGFkZCBhIGdlb21ldHJ5IGNoZWNrIVxuICAgICAgICAvLyBhbHNvIGEgc2l6ZSBjaGVjay4uIGNhbnQgYmUgdG9vIGJpZyFdXG4gICAgICAgIHZhciBnZW9tZXRyeU91dCA9IG5ldyBHZW9tZXRyeSgpO1xuICAgICAgICB2YXIgYXJyYXlzID0gW107XG4gICAgICAgIHZhciBzaXplcyA9IFtdO1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgICAgICB2YXIgZ2VvbWV0cnk7XG4gICAgICAgIC8vIHBhc3Mgb25lLi4gZ2V0IHNpemVzLi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzaXplc1tqXSA9IHNpemVzW2pdIHx8IDA7XG4gICAgICAgICAgICAgICAgc2l6ZXNbal0gKz0gZ2VvbWV0cnkuYnVmZmVyc1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB0aGUgY29ycmVjdCBzaXplIGFycmF5cy4uXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgLy8gVE9ETyB0eXBlcyFcbiAgICAgICAgICAgIGFycmF5c1tpJDFdID0gbmV3IEdlb21ldHJ5Lm1hcCQxW0dlb21ldHJ5LmdldEJ1ZmZlclR5cGUoZ2VvbWV0cnkuYnVmZmVyc1tpJDFdLmRhdGEpXShzaXplc1tpJDFdKTtcbiAgICAgICAgICAgIGdlb21ldHJ5T3V0LmJ1ZmZlcnNbaSQxXSA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoYXJyYXlzW2kkMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhc3MgdG8gc2V0IGRhdGEuLlxuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpJDJdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGokMSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlzW2okMV0uc2V0KGdlb21ldHJ5LmJ1ZmZlcnNbaiQxXS5kYXRhLCBvZmZzZXRzW2okMV0pO1xuICAgICAgICAgICAgICAgIG9mZnNldHNbaiQxXSArPSBnZW9tZXRyeS5idWZmZXJzW2okMV0uZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbWV0cnlPdXQuYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIgPSBnZW9tZXRyeU91dC5idWZmZXJzW2dlb21ldHJ5LmJ1ZmZlcnMuaW5kZXhPZihnZW9tZXRyeS5pbmRleEJ1ZmZlcildO1xuICAgICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIuaW5kZXggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQyID0gMDtcbiAgICAgICAgICAgIHZhciBidWZmZXJJbmRleFRvQ291bnQgPSAwO1xuICAgICAgICAgICAgLy8gZ2V0IGEgYnVmZmVyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaSQzKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbWV0cnkuYnVmZmVyc1tpJDNdICE9PSBnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleFRvQ291bnQgPSBpJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIHN0cmlkZSBvZiBvbmUgYnVmZmVyLi5cbiAgICAgICAgICAgIGZvciAodmFyIGkkNCBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbaSQ0XTtcbiAgICAgICAgICAgICAgICBpZiAoKGF0dHJpYnV0ZS5idWZmZXIgfCAwKSA9PT0gYnVmZmVySW5kZXhUb0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmlkZSArPSAoKGF0dHJpYnV0ZS5zaXplICogR2VvbWV0cnkuYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdKSAvIDQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRpbWUgdG8gb2ZmIHNldCBhbGwgaW5kZXhlcy4uXG4gICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSQ1KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhCdWZmZXJEYXRhID0gZ2VvbWV0cmllc1tpJDVdLmluZGV4QnVmZmVyLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQyID0gMDsgaiQyIDwgaW5kZXhCdWZmZXJEYXRhLmxlbmd0aDsgaiQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIuZGF0YVtqJDIgKyBvZmZzZXQyXSArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBnZW9tZXRyeS5idWZmZXJzW2J1ZmZlckluZGV4VG9Db3VudF0uZGF0YS5sZW5ndGggLyAoc3RyaWRlKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQyICs9IGluZGV4QnVmZmVyRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5T3V0O1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGljIGdldEJ1ZmZlclR5cGUoYXJyYXkpIHtcbiAgICAgICAgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdVaW50MzJBcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ0ludDMyQXJyYXknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnVWludDE2QXJyYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdVaW50OEFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1hcCBvdXQgdGhlIHJlc3Qgb2YgdGhlIGFycmF5IGVsZW1lbnRzIVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKSB7XG4gICAgICAgIHZhciBvdXRTaXplID0gMDtcbiAgICAgICAgdmFyIHN0cmlkZSA9IDA7XG4gICAgICAgIHZhciB2aWV3cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RyaWRlICs9IHNpemVzW2ldO1xuICAgICAgICAgICAgb3V0U2l6ZSArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIob3V0U2l6ZSAqIDQpO1xuICAgICAgICB2YXIgb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIGxpdHRsZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGFycmF5cy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHNpemVzW2kkMV07XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaSQxXTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gR2VvbWV0cnkuZ2V0QnVmZmVyVHlwZShhcnJheSk7XG4gICAgICAgICAgICBpZiAoIXZpZXdzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdmlld3NbdHlwZV0gPSBuZXcgR2VvbWV0cnkubWFwW3R5cGVdKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgPSB2aWV3c1t0eXBlXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhTdGFydCA9ICgoaiAvIHNpemUgfCAwKSAqIHN0cmlkZSkgKyBsaXR0bGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaiAlIHNpemU7XG4gICAgICAgICAgICAgICAgb3V0W2luZGV4U3RhcnQgKyBpbmRleF0gPSBhcnJheVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpdHRsZU9mZnNldCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgfVxufVxuLyogZXNsaW50LWRpc2FibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xuR2VvbWV0cnkubWFwID0ge1xuICAgIEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuICAgIFVpbnQzMkFycmF5OiBVaW50MzJBcnJheSxcbiAgICBJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuICAgIFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXG59O1xuR2VvbWV0cnkuVUlEJDEgPSAwO1xuLyogZXNsaW50LWRpc2FibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xuR2VvbWV0cnkubWFwJDEgPSB7XG4gICAgRmxvYXQzMkFycmF5OiBGbG9hdDMyQXJyYXksXG4gICAgVWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxuICAgIEludDMyQXJyYXk6IEludDMyQXJyYXksXG4gICAgVWludDhBcnJheTogVWludDhBcnJheSxcbiAgICBVaW50MTZBcnJheTogVWludDE2QXJyYXksXG59O1xuR2VvbWV0cnkuYnl0ZVNpemVNYXAgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcbmV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBHTEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vR0xCdWZmZXJcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIEdlb21ldHJ5U3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB0cnVlYCBpZiB3ZSBoYXMgYCpfdmVydGV4X2FycmF5X29iamVjdGAgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNWYW8gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogYHRydWVgIGlmIGhhcyBgQU5HTEVfaW5zdGFuY2VkX2FycmF5c2AgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhY2hlIG9mIGN1cnJlbnRseSBib3VuZCBidWZmZXIsXG4gICAgICAgICAqIGNvbnRhaW5zIG9ubHkgdHdvIG1lbWJlcnMgd2l0aCBrZXlzIEFSUkFZX0JVRkZFUiBhbmQgRUxFTUVOVF9BUlJBWV9CVUZGRVJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0LjxudW1iZXIsIFBJWEkuQnVmZmVyPn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kQnVmZmVycyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGUgZm9yIGFsbCBnZW9tZXRyaWVzIGJ5IGlkLCB1c2VkIGluIGNhc2UgcmVuZGVyZXIgZ2V0cyBkZXN0cm95ZWQgb3IgZm9yIHByb2ZpbGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYW5hZ2VkR2VvbWV0cmllcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGUgZm9yIGFsbCBidWZmZXJzIGJ5IGlkLCB1c2VkIGluIGNhc2UgcmVuZGVyZXIgZ2V0cyBkZXN0cm95ZWQgb3IgZm9yIHByb2ZpbGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYW5hZ2VkQnVmZmVycyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VBbGwodHJ1ZSk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgICAgICAgLy8gd2ViZ2wyXG4gICAgICAgIGlmICghZ2wuY3JlYXRlVmVydGV4QXJyYXkpIHtcbiAgICAgICAgICAgIC8vIHdlYmdsIDEhXG4gICAgICAgICAgICB2YXIgbmF0aXZlVmFvRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMudmVydGV4QXJyYXlPYmplY3Q7XG4gICAgICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPT09IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0xfTEVHQUNZKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlVmFvRXh0ZW5zaW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYXRpdmVWYW9FeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZVZhb0V4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpOyB9O1xuICAgICAgICAgICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh2YW8pIHsgcmV0dXJuIG5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModmFvKTsgfTtcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh2YW8pIHsgcmV0dXJuIG5hdGl2ZVZhb0V4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh2YW8pOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNWYW8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVZlcnRleEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VFeHQgPSBnbC5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUV4dCkge1xuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gaW5zdGFuY2VFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGEsIGIpOyB9O1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlKSB7IHJldHVybiBpbnN0YW5jZUV4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkLCBlKTsgfTtcbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGluc3RhbmNlRXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzSW5zdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQmluZHMgZ2VvbWV0cnkgc28gdGhhdCBpcyBjYW4gYmUgZHJhd24uIENyZWF0aW5nIGEgVmFvIGlmIHJlcXVpcmVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgaW5zdGFuY2Ugb2YgZ2VvbWV0cnkgdG8gYmluZFxuICAgICAqIEBwYXJhbSB7UElYSS5TaGFkZXJ9IHNoYWRlciBpbnN0YW5jZSBvZiBzaGFkZXIgdG8gYmluZFxuICAgICAqL1xuICAgIGJpbmQoZ2VvbWV0cnksIHNoYWRlciA9IG51bGwpIHtcbiAgICAgICAgc2hhZGVyID0gc2hhZGVyIHx8IHRoaXMucmVuZGVyZXIuc2hhZGVyLnNoYWRlcjtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgLy8gbm90IHN1cmUgdGhlIGJlc3Qgd2F5IHRvIGFkZHJlc3MgdGhpcy4uXG4gICAgICAgIC8vIGN1cnJlbnRseSBkaWZmZXJlbnQgc2hhZGVycyByZXF1aXJlIGRpZmZlcmVudCBWQU9zIGZvciB0aGUgc2FtZSBnZW9tZXRyeVxuICAgICAgICAvLyBTdGlsbCBtdWxsaW5nIG92ZXIgdGhlIGJlc3Qgd2F5IHRvIHNvbHZlIHRoaXMgb25lLi5cbiAgICAgICAgLy8gd2lsbCBsaWtlbHkgbmVlZCB0byBtb2RpZnkgdGhlIHNoYWRlciBhdHRyaWJ1dGUgbG9jYXRpb25zIGF0IHJ1biB0aW1lIVxuICAgICAgICB2YXIgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICBpZiAoIXZhb3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdID0gZ2VvbWV0cnk7XG4gICAgICAgICAgICAvLyBnZW9tZXRyeS5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdID0gdmFvcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YW8gPSB2YW9zW3NoYWRlci5wcm9ncmFtLmlkXSB8fCB0aGlzLmluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pO1xuICAgICAgICB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmFvICE9PSB2YW8pIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZhbyA9IHZhbztcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1Zhbykge1xuICAgICAgICAgICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gLSBvcHRpbWlzZSBsYXRlciFcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBsb29wIHRocm91Z2ggaWYgbm90aGluZyBjaGFuZ2VkIVxuICAgICAgICAvLyBtYXliZSBsb29rIHRvIGFkZCBhbiAnYXV0b3VwZGF0ZScgdG8gZ2VvbWV0cnk/XG4gICAgICAgIHRoaXMudXBkYXRlQnVmZmVycygpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzZXQgYW5kIHVuYmluZCBhbnkgYWN0aXZlIFZBTyBhbmQgZ2VvbWV0cnlcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBidWZmZXJzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUJ1ZmZlcnMoKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuX2FjdGl2ZUdlb21ldHJ5O1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICAvLyByZXZlYWwoZ2wpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBnZW9tZXRyeS5idWZmZXJzW2ldO1xuICAgICAgICAgICAgdmFyIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgICAgICBpZiAoYnVmZmVyLl91cGRhdGVJRCAhPT0gZ2xCdWZmZXIudXBkYXRlSUQpIHtcbiAgICAgICAgICAgICAgICBnbEJ1ZmZlci51cGRhdGVJRCA9IGJ1ZmZlci5fdXBkYXRlSUQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBjYW4gY2FjaGUgdGhpcyBvbiBidWZmZXIhIG1heWJlIGFkZGVkIGEgZ2V0dGVyIC8gc2V0dGVyP1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYnVmZmVyLmluZGV4ID8gZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiBnbC5BUlJBWV9CVUZGRVI7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGNvdWxkIGNoYW5nZSBpZiB0aGUgVkFPIGNoYW5nZXMuLi5cbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhIGJldHRlciB3YXkgdG8gY2FjaGUuLlxuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLmJvdW5kQnVmZmVyc1t0eXBlXSAhPT0gZ2xCdWZmZXIpXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuYm91bmRCdWZmZXJzW3R5cGVdID0gZ2xCdWZmZXI7XG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCBnbEJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZEJ1ZmZlciA9IGdsQnVmZmVyO1xuICAgICAgICAgICAgICAgIGlmIChnbEJ1ZmZlci5ieXRlTGVuZ3RoID49IGJ1ZmZlci5kYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IGlzIGFsd2F5cyB6ZXJvIGZvciBub3chXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEodHlwZSwgMCwgYnVmZmVyLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdUeXBlID0gYnVmZmVyLnN0YXRpYyA/IGdsLlNUQVRJQ19EUkFXIDogZ2wuRFlOQU1JQ19EUkFXO1xuICAgICAgICAgICAgICAgICAgICBnbEJ1ZmZlci5ieXRlTGVuZ3RoID0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YSh0eXBlLCBidWZmZXIuZGF0YSwgZHJhd1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgY29tcGFiaWxpdHkgYmV0d2VlbiBhIGdlb21ldHJ5IGFuZCBhIHByb2dyYW1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtQSVhJLkdlb21ldHJ5fSBnZW9tZXRyeSAtIEdlb21ldHJ5IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gLSBQcm9ncmFtIGluc3RhbmNlXG4gICAgICovXG4gICAgY2hlY2tDb21wYXRpYmlsaXR5KGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgICAgIC8vIGdlb21ldHJ5IG11c3QgaGF2ZSBhdCBsZWFzdCBhbGwgdGhlIGF0dHJpYnV0ZXMgdGhhdCB0aGUgc2hhZGVyIHJlcXVpcmVzLlxuICAgICAgICB2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNoYWRlckF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgICAgIGZvciAodmFyIGogaW4gc2hhZGVyQXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCFnZW9tZXRyeUF0dHJpYnV0ZXNbal0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwic2hhZGVyIGFuZCBnZW9tZXRyeSBpbmNvbXBhdGlibGUsIGdlb21ldHJ5IG1pc3NpbmcgdGhlIFxcXCJcIiArIGogKyBcIlxcXCIgYXR0cmlidXRlXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBnZW9tZXRyeSBhbmQgcHJvZ3JhbSBhbmQgZ2VuZXJhdGVzIGEgdW5pcXVlIHNpZ25hdHVyZSBmb3IgdGhlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgdG8gZ2V0IHNpZ25hdHVyZSBmcm9tXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gdG8gdGVzdCBnZW9tZXRyeSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMge1N0cmluZ30gVW5pcXVlIHNpZ25hdHVyZSBvZiB0aGUgZ2VvbWV0cnkgYW5kIHByb2dyYW1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgICAgIHZhciBhdHRyaWJzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNoYWRlckF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgICAgIHZhciBzdHJpbmdzID0gWydnJywgZ2VvbWV0cnkuaWRdO1xuICAgICAgICBmb3IgKHZhciBpIGluIGF0dHJpYnMpIHtcbiAgICAgICAgICAgIGlmIChzaGFkZXJBdHRyaWJ1dGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdzLmpvaW4oJy0nKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb3IgZ2V0cyBWYW8gd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXMgdGhlIGdlb21ldHJ5IGFuZCBzdG9yZXMgaXQgb24gdGhlIGdlb21ldHJ5LlxuICAgICAqIElmIHZhbyBpcyBjcmVhdGVkLCBpdCBpcyBib3VuZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgLSBJbnN0YW5jZSBvZiBnZW9tZXRyeSB0byB0byBnZW5lcmF0ZSBWYW8gZm9yXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gLSBJbnN0YW5jZSBvZiBwcm9ncmFtXG4gICAgICovXG4gICAgaW5pdEdlb21ldHJ5VmFvKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb21wYXRpYmlsaXR5KGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIENPTlRFWFRfVUlEID0gdGhpcy5DT05URVhUX1VJRDtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICAgICAgdmFyIHZhb09iamVjdEhhc2ggPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgdmFyIHZhbyA9IHZhb09iamVjdEhhc2hbc2lnbmF0dXJlXTtcbiAgICAgICAgaWYgKHZhbykge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGdpdmUgdXMgZWFzeSBhY2Nlc3MgdG8gdGhlIHZhb1xuICAgICAgICAgICAgdmFvT2JqZWN0SGFzaFtwcm9ncmFtLmlkXSA9IHZhbztcbiAgICAgICAgICAgIHJldHVybiB2YW87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciB0ZW1wU3RyaWRlID0ge307XG4gICAgICAgIHZhciB0ZW1wU3RhcnQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBidWZmZXJzKSB7XG4gICAgICAgICAgICB0ZW1wU3RyaWRlW2pdID0gMDtcbiAgICAgICAgICAgIHRlbXBTdGFydFtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiQxIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1tqJDFdLnNpemUgJiYgcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2okMV0pIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2okMV0uc2l6ZSA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtqJDFdLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghYXR0cmlidXRlc1tqJDFdLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKFwiUElYSSBHZW9tZXRyeSBhdHRyaWJ1dGUgJ1wiICsgaiQxICsgXCInIHNpemUgY2Fubm90IGJlIGRldGVybWluZWQgKGxpa2VseSB0aGUgYm91bmQgc2hhZGVyIGRvZXMgbm90IGhhdmUgdGhlIGF0dHJpYnV0ZSlcIikpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wU3RyaWRlW2F0dHJpYnV0ZXNbaiQxXS5idWZmZXJdICs9IGF0dHJpYnV0ZXNbaiQxXS5zaXplICogR2VvbWV0cnlTeXN0ZW0uYnl0ZVNpemVNYXAkMVthdHRyaWJ1dGVzW2okMV0udHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiQyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2okMl07XG4gICAgICAgICAgICB2YXIgYXR0cmliU2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5zdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wU3RyaWRlW2F0dHJpYnV0ZS5idWZmZXJdID09PSBhdHRyaWJTaXplICogR2VvbWV0cnlTeXN0ZW0uYnl0ZVNpemVNYXAkMVthdHRyaWJ1dGUudHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnN0cmlkZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc3RyaWRlID0gdGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLnN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc3RhcnQgPSB0ZW1wU3RhcnRbYXR0cmlidXRlLmJ1ZmZlcl07XG4gICAgICAgICAgICAgICAgdGVtcFN0YXJ0W2F0dHJpYnV0ZS5idWZmZXJdICs9IGF0dHJpYlNpemUgKiBHZW9tZXRyeVN5c3RlbS5ieXRlU2l6ZU1hcCQxW2F0dHJpYnV0ZS50eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcbiAgICAgICAgLy8gZmlyc3QgdXBkYXRlIC0gYW5kIGNyZWF0ZSB0aGUgYnVmZmVycyFcbiAgICAgICAgLy8gb25seSBjcmVhdGUgYSBnbCBidWZmZXIgaWYgaXQgYWN0dWFsbHkgZ2V0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgICAgICAgaWYgKCFidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gPSBuZXcgR0xCdWZmZXJfMS5HTEJ1ZmZlcihnbC5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VkQnVmZmVyc1tidWZmZXIuaWRdID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlci5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5yZWZDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gLSBtYXliZSBtYWtlIHRoaXMgYSBkYXRhIG9iamVjdD9cbiAgICAgICAgLy8gbGV0cyB3YWl0IHRvIHNlZSBpZiB3ZSBuZWVkIHRvIGZpcnN0IVxuICAgICAgICB0aGlzLmFjdGl2YXRlVmFvKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gdmFvO1xuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIGNhY2hlIVxuICAgICAgICB2YW9PYmplY3RIYXNoW3Byb2dyYW0uaWRdID0gdmFvO1xuICAgICAgICB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV0gPSB2YW87XG4gICAgICAgIHJldHVybiB2YW87XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBidWZmZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHdpdGggZGF0YVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBkZWxldGVWZXJ0ZXhBcnJheVxuICAgICAqL1xuICAgIGRpc3Bvc2VCdWZmZXIoYnVmZmVyLCBjb250ZXh0TG9zdCkge1xuICAgICAgICBpZiAoIXRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hbmFnZWRCdWZmZXJzW2J1ZmZlci5pZF07XG4gICAgICAgIHZhciBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAvLyBidWZmZXIuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgICAgIGlmICghZ2xCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIoZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBnZW9tZXRyeVxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgR2VvbWV0cnkgd2l0aCBidWZmZXJzLiBPbmx5IFZBTyB3aWxsIGJlIGRpc3Bvc2VkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGRlbGV0ZVZlcnRleEFycmF5XG4gICAgICovXG4gICAgZGlzcG9zZUdlb21ldHJ5KGdlb21ldHJ5LCBjb250ZXh0TG9zdCkge1xuICAgICAgICBpZiAoIXRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdO1xuICAgICAgICB2YXIgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnM7XG4gICAgICAgIGdlb21ldHJ5LmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xuICAgICAgICBpZiAoIXZhb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBidWZmZXJzW2ldLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgICAgICBidWYucmVmQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChidWYucmVmQ291bnQgPT09IDAgJiYgIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlQnVmZmVyKGJ1ZmZlcnNbaV0sIGNvbnRleHRMb3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2YW9JZCBpbiB2YW9zKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9ubHkgc2lnbmF0dXJlcywgZXZlcnl0aGluZyBlbHNlIGFyZSBjb3BpZXNcbiAgICAgICAgICAgICAgICBpZiAodmFvSWRbMF0gPT09ICdnJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFvID0gdmFvc1t2YW9JZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWYW8gPT09IHZhbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2YW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBkaXNwb3NlIGFsbCBXZWJHTCByZXNvdXJjZXMgb2YgYWxsIG1hbmFnZWQgZ2VvbWV0cmllcyBhbmQgYnVmZmVyc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBgZ2wuZGVsZXRlYCBjYWxsc1xuICAgICAqL1xuICAgIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcbiAgICAgICAgdmFyIGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEdlb21ldHJpZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlR2VvbWV0cnkodGhpcy5tYW5hZ2VkR2VvbWV0cmllc1thbGxbaV1dLCBjb250ZXh0TG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsID0gT2JqZWN0LmtleXModGhpcy5tYW5hZ2VkQnVmZmVycyk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGFsbC5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VCdWZmZXIodGhpcy5tYW5hZ2VkQnVmZmVyc1thbGxbaSQxXV0sIGNvbnRleHRMb3N0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgdmVydGV4IGFycmF5IG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgLSBHZW9tZXRyeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UElYSS5Qcm9ncmFtfSBwcm9ncmFtIC0gU2hhZGVyIHByb2dyYW0gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhY3RpdmF0ZVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgQ09OVEVYVF9VSUQgPSB0aGlzLkNPTlRFWFRfVUlEO1xuICAgICAgICB2YXIgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnM7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB1cGRhdGUgdGhlIGluZGV4IGJ1ZmZlciBpZiB3ZSBoYXZlIG9uZS4uXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0QnVmZmVyID0gbnVsbDtcbiAgICAgICAgLy8gYWRkIGEgbmV3IG9uZSFcbiAgICAgICAgZm9yICh2YXIgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgICAgICAgdmFyIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdO1xuICAgICAgICAgICAgaWYgKHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0QnVmZmVyICE9PSBnbEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJ1ZmZlciA9IGdsQnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGFbal0ubG9jYXRpb247XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbnRyb2R1Y2Ugc3RhdGUgYWdhaW5cbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gb3B0aW1pc2UgdGhpcyBmb3Igb2xkZXIgZGV2aWNlcyB0aGF0IGhhdmUgbm8gVkFPc1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyaWJ1dGUuc2l6ZSwgYXR0cmlidXRlLnR5cGUgfHwgZ2wuRkxPQVQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkLCBhdHRyaWJ1dGUuc3RyaWRlLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjYWxjdWxhdGUgaW5zdGFuY2UgY291bnQgYmFzZWQgb2YgdGhpcy4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb21ldHJ5IGVycm9yLCBHUFUgSW5zdGFuY2luZyBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGdlb21ldHJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdHlwZSAtIHRoZSB0eXBlIHByaW1pdGl2ZSB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NpemVdIC0gdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIC0gU3RhcnRpbmcgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luc3RhbmNlQ291bnRdIC0gdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNldCBvZiBlbGVtZW50cyB0byBleGVjdXRlXG4gICAgICovXG4gICAgZHJhdyh0eXBlLCBzaXplID0gLTEsIHN0YXJ0ID0gMCwgaW5zdGFuY2VDb3VudCA9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fYWN0aXZlR2VvbWV0cnk7XG4gICAgICAgIC8vIFRPRE8uLiB0aGlzIHNob3VsZCBub3QgY2hhbmdlIHNvIG1heWJlIGNhY2hlIHRoZSBmdW5jdGlvbj9cbiAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBzaXplID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuaW5zdGFuY2VkKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgKHN0YXJ0IHx8IDApICogMiwgaW5zdGFuY2VDb3VudCB8fCAxKTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgKHN0YXJ0IHx8IDApICogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkuaW5zdGFuY2VkKSB7XG4gICAgICAgICAgICAvLyBUT0RPIG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGNhbGN1bGF0ZSBzaXplLi5cbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQodHlwZSwgc3RhcnQsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpLCBpbnN0YW5jZUNvdW50IHx8IDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyh0eXBlLCBzdGFydCwgc2l6ZSB8fCBnZW9tZXRyeS5nZXRTaXplKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVW5iaW5kL3Jlc2V0IGV2ZXJ5dGhpbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdW5iaW5kKCkge1xuICAgICAgICB0aGlzLmdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5HZW9tZXRyeVN5c3RlbS5ieXRlU2l6ZU1hcCQxID0geyA1MTI2OiA0LCA1MTIzOiAyLCA1MTIxOiAxIH07XG5leHBvcnRzLkdlb21ldHJ5U3lzdGVtID0gR2VvbWV0cnlTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xuY29uc3QgRmlsbFN0eWxlXzEgPSByZXF1aXJlKFwiLi9GaWxsU3R5bGVcIik7XG4vLyBpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNvbnN0IFVuaWZvcm1Hcm91cF8xID0gcmVxdWlyZShcIi4vVW5pZm9ybUdyb3VwXCIpO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XG5jb25zdCBQb2x5Z29uXzEgPSByZXF1aXJlKFwiLi9Qb2x5Z29uXCIpO1xuY29uc3QgRWxsaXBzZV8xID0gcmVxdWlyZShcIi4vRWxsaXBzZVwiKTtcbmNvbnN0IENpcmNsZV8xID0gcmVxdWlyZShcIi4vQ2lyY2xlXCIpO1xuY29uc3QgUm91bmRlZFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUm91bmRlZFJlY3RhbmdsZVwiKTtcbmNvbnN0IEFyY1V0aWxzXzEgPSByZXF1aXJlKFwiLi9BcmNVdGlsc1wiKTtcbmNvbnN0IEJlemllclV0aWxzXzEgPSByZXF1aXJlKFwiLi9CZXppZXJVdGlsc1wiKTtcbmNvbnN0IFF1YWRyYXRpY1V0aWxzXzEgPSByZXF1aXJlKFwiLi9RdWFkcmF0aWNVdGlsc1wiKTtcbmNvbnN0IExpbmVTdHlsZV8xID0gcmVxdWlyZShcIi4vTGluZVN0eWxlXCIpO1xuY29uc3QgR3JhcGhpY3NHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY3NHZW9tZXRyeVwiKTtcbmNvbnN0IFN0YXJfMSA9IHJlcXVpcmUoXCIuL1N0YXJcIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcbmNsYXNzIEdyYXBoaWNzIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihnZW9tZXRyeSA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGdlb21ldHJ5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSW5jbHVkZXMgdmVydGV4IHBvc2l0aW9ucywgZmFjZSBpbmRpY2VzLCBub3JtYWxzLCBjb2xvcnMsIFVWcywgYW5kXG4gICAgICAgICAqIGN1c3RvbSBhdHRyaWJ1dGVzIHdpdGhpbiBidWZmZXJzLCByZWR1Y2luZyB0aGUgY29zdCBvZiBwYXNzaW5nIGFsbFxuICAgICAgICAgKiB0aGlzIGRhdGEgdG8gdGhlIEdQVS4gQ2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIE1lc2ggb3IgR3JhcGhpY3Mgb2JqZWN0cy5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc0dlb21ldHJ5fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSB8fCBuZXcgR3JhcGhpY3NHZW9tZXRyeV8xLkdyYXBoaWNzR2VvbWV0cnkoKTtcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5yZWZDb3VudCsrO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzIHRoYXQgcHJvY2Vzc2VzIHRoZSBnZW9tZXRyeSBhbmQgcnVucyBvbiB0aGUgR1BVLlxuICAgICAgICAgKiBDYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgR3JhcGhpY3Mgb2JqZWN0cy5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSBXZWJHTCBzdGF0ZSB0aGUgR3JhcGhpY3MgcmVxdWlyZWQgdG8gcmVuZGVyLCBleGNsdWRlcyBzaGFkZXIgYW5kIGdlb21ldHJ5LiBFLmcuLFxuICAgICAgICAgKiBibGVuZCBtb2RlLCBjdWxsaW5nLCBkZXB0aCB0ZXN0aW5nLCBkaXJlY3Rpb24gb2YgcmVuZGVyaW5nIHRyaWFuZ2xlcywgYmFja2ZhY2UsIGV0Yy5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TdGF0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZV8xLlN0YXRlLmZvcjJkKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IGZpbGwgc3R5bGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWxsU3R5bGV9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZSA9IG5ldyBGaWxsU3R5bGVfMS5GaWxsU3R5bGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgbGluZSBzdHlsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkxpbmVTdHlsZX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGluZVN0eWxlID0gbmV3IExpbmVTdHlsZV8xLkxpbmVTdHlsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBzaGFwZSB0cmFuc2Zvcm0gbWF0cml4LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgaG9sZSBtb2RlIGlzIGVuYWJsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hvbGVNb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IHBhdGhcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2x5Z29ufVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gY2FjaGVBc0JpdG1hcCBpcyBzZXQgdG8gdHJ1ZSB0aGUgZ3JhcGhpY3Mgb2JqZWN0IHdpbGwgYmUgcmVuZGVyZWQgYXMgaWYgaXQgd2FzIGEgc3ByaXRlLlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3VyIGdyYXBoaWNzIGVsZW1lbnQgZG9lcyBub3QgY2hhbmdlIG9mdGVuLCBhcyBpdCB3aWxsIHNwZWVkIHVwIHRoZSByZW5kZXJpbmdcbiAgICAgICAgICogb2YgdGhlIG9iamVjdCBpbiBleGNoYW5nZSBmb3IgdGFraW5nIHVwIHRleHR1cmUgbWVtb3J5LiBJdCBpcyBhbHNvIHVzZWZ1bCBpZiB5b3UgbmVlZCB0aGUgZ3JhcGhpY3NcbiAgICAgICAgICogb2JqZWN0IHRvIGJlIGFudGktYWxpYXNlZCwgYmVjYXVzZSBpdCB3aWxsIGJlIHJlbmRlcmVkIHVzaW5nIGNhbnZhcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQgaWZcbiAgICAgICAgICogeW91IGFyZSBjb25zdGFudGx5IHJlZHJhd2luZyB0aGUgZ3JhcGhpY3MgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgY2FjaGVBc0JpdG1hcFxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5HcmFwaGljcyNcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbGxlY3Rpb25zIG9mIGJhdGNoZXMhIFRoZXNlIGNhbiBiZSBkcmF3biBieSB0aGUgcmVuZGVyZXIgYmF0Y2ggc3lzdGVtLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXRjaGVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgZGlydHkgZm9yIGxpbWl0aW5nIGNhbGN1bGF0aW5nIHRpbnRzIGZvciBiYXRjaGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgLTFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmF0Y2hUaW50ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3B5IG9mIHRoZSBvYmplY3QgdmVydGV4IGRhdGEuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICAgICAgdGhpcy5iYXRjaERpcnR5ID0gLTE7XG4gICAgICAgIC8vIFNldCBkZWZhdWx0XG4gICAgICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3Mgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgICAqIE5vdGUgdGhhdCB0aGUgb25seSB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGFyZSBjbG9uZWQsIG5vdCBpdHMgdHJhbnNmb3JtIChwb3NpdGlvbixzY2FsZSxldGMpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBBIGNsb25lIG9mIHRoZSBncmFwaGljcyBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhpY3ModGhpcy5nZW9tZXRyeSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBBcHBseSBhIHZhbHVlIG9mXG4gICAgICogYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcbiAgICAgKi9cbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgYmxlbmRNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mXG4gICAgICogMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICovXG4gICAgZ2V0IHRpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW50O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGludCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgZmlsbCBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuRmlsbFN0eWxlfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBmaWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsbFN0eWxlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgbGluZSBzdHlsZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuTGluZVN0eWxlfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZVN0eWxlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBsaW5lIHN0eWxlIHVzZWQgZm9yIHN1YnNlcXVlbnQgY2FsbHMgdG8gR3JhcGhpY3MgbWV0aG9kcyBzdWNoIGFzIHRoZSBsaW5lVG8oKVxuICAgICAqIG1ldGhvZCBvciB0aGUgZHJhd0NpcmNsZSgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MF0gLSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbG9yPTBdIC0gY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbHBoYT0xXSAtIGFscGhhIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxpZ25tZW50PTFdIC0gYWxpZ25tZW50IG9mIHRoZSBsaW5lIHRvIGRyYXcsICgwID0gaW5uZXIsIDAuNSA9IG1pZGRsZSwgMSA9IG91dHRlcilcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtuYXRpdmU9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgbGluZXMgd2lsbCBiZSBkcmF3IHVzaW5nIExJTkVTIGluc3RlYWQgb2YgVFJJQU5HTEVfU1RSSVBcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgbGluZVN0eWxlKHdpZHRoLCBjb2xvciA9IDAsIGFscGhhID0gMSwgYWxpZ25tZW50ID0gMC41LCBuYXRpdmUgPSBmYWxzZSkge1xuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb2xvciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGFscGhhID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IDAuNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGluZVRleHR1cmVTdHlsZSh3aWR0aCwgVGV4dHVyZV8xLlRleHR1cmUuV0hJVEUsIGNvbG9yLCBhbHBoYSwgbnVsbCwgYWxpZ25tZW50LCBuYXRpdmUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIExpa2UgbGluZSBzdHlsZSBidXQgc3VwcG9ydCB0ZXh0dXJlIGZvciBsaW5lIGZpbGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IFt0ZXh0dXJlPVBJWEkuVGV4dHVyZS5XSElURV0gLSBUZXh0dXJlIHRvIHVzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gLSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gW21hdHJpeD1udWxsXSBUZXh0dXJlIG1hdHJpeCB0byB0cmFuc2Zvcm0gdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxpZ25tZW50PTAuNV0gLSBhbGlnbm1lbnQgb2YgdGhlIGxpbmUgdG8gZHJhdywgKDAgPSBpbm5lciwgMC41ID0gbWlkZGxlLCAxID0gb3V0dGVyKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25hdGl2ZT1mYWxzZV0gLSBJZiB0cnVlIHRoZSBsaW5lcyB3aWxsIGJlIGRyYXcgdXNpbmcgTElORVMgaW5zdGVhZCBvZiBUUklBTkdMRV9TVFJJUFxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBsaW5lVGV4dHVyZVN0eWxlKHdpZHRoID0gMCwgdGV4dHVyZSA9IFRleHR1cmVfMS5UZXh0dXJlLldISVRFLCBjb2xvciA9IDB4RkZGRkZGLCBhbHBoYSA9IDEsIG1hdHJpeCA9IG51bGwsIGFsaWdubWVudCA9IDAuNSwgbmF0aXZlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGV4dHVyZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gVGV4dHVyZV8xLlRleHR1cmUuV0hJVEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbG9yID0gMHhGRkZGRkY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGFscGhhID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0cml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG1hdHJpeCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsaWdubWVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvbHkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlzaWJsZSA9IHdpZHRoID4gMCAmJiBhbHBoYSA+IDA7XG4gICAgICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fbGluZVN0eWxlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgbWF0cml4ID0gbWF0cml4LmNsb25lKCk7XG4gICAgICAgICAgICAgICAgbWF0cml4LmludmVydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9saW5lU3R5bGUsIHtcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGFscGhhOiBhbHBoYSxcbiAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxuICAgICAgICAgICAgICAgIGFsaWdubWVudDogYWxpZ25tZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZTogbmF0aXZlLFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHZpc2libGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgcG9seWdvbiBvYmplY3QgaW50ZXJuYWxseVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGFydFBvbHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaGFwZSh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBvbHlnb25fMS5Qb2x5Z29uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLnB1c2gocG9pbnRzW2xlbiAtIDJdLCBwb2ludHNbbGVuIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQb2x5Z29uXzEuUG9seWdvbigpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBGaW5pc2ggdGhlIHBvbHlnb24gb2JqZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBmaW5pc2hQb2x5KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaGFwZSh0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8geCwgeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIFggY29vcmRpbmF0ZSB0byBtb3ZlIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlIHRvIG1vdmUgdG9cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgbW92ZVRvKHgsIHkpIHtcbiAgICAgICAgdGhpcy5zdGFydFBvbHkoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHNbMF0gPSB4O1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50c1sxXSA9IHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRHJhd3MgYSBsaW5lIHVzaW5nIHRoZSBjdXJyZW50IGxpbmUgc3R5bGUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvICh4LCB5KTtcbiAgICAgKiBUaGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIGlzIHRoZW4gc2V0IHRvICh4LCB5KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIFggY29vcmRpbmF0ZSB0byBkcmF3IHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgbGluZVRvKHgsIHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgZHVwbGljYXRlcy4uXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICAgICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGZyb21YICE9PSB4IHx8IGZyb21ZICE9PSB5KSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIGN1cnZlXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdXG4gICAgICovXG4gICAgX2luaXRDdXJ2ZSh4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cyA9IFt4LCB5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxuICAgICAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBxdWFkcmF0aWNDdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgICAgICB0aGlzLl9pbml0Q3VydmUoKTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgUXVhZHJhdGljVXRpbHNfMS5RdWFkcmF0aWNVdGlscy5jdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSwgcG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgYmV6aWVyQ3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcbiAgICAgICAgdGhpcy5faW5pdEN1cnZlKCk7XG4gICAgICAgIEJlemllclV0aWxzXzEuQmV6aWVyVXRpbHMuY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHRoaXMuY3VycmVudFBhdGgucG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJjVG8oKSBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgYmV0d2VlbiB0d28gdGFuZ2VudHMgb24gdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIFwiYm9ycm93ZWRcIiBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZnhjYW52YXMvIC0gdGhhbmtzIGdvb2dsZSFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDIgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGFyY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MiAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgYXJjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyY1xuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBhcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XG4gICAgICAgIHRoaXMuX2luaXRDdXJ2ZSh4MSwgeTEpO1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG4gICAgICAgIHZhciByZXN1bHQgPSBBcmNVdGlsc18xLkFyY1V0aWxzLmN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cywgcG9pbnRzKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGN4ID0gcmVzdWx0LmN4O1xuICAgICAgICAgICAgdmFyIGN5ID0gcmVzdWx0LmN5O1xuICAgICAgICAgICAgdmFyIHJhZGl1cyQxID0gcmVzdWx0LnJhZGl1cztcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gcmVzdWx0LnN0YXJ0QW5nbGU7XG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSByZXN1bHQuZW5kQW5nbGU7XG4gICAgICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IHJlc3VsdC5hbnRpY2xvY2t3aXNlO1xuICAgICAgICAgICAgdGhpcy5hcmMoY3gsIGN5LCByYWRpdXMkMSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGFyYyBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgKHVzZWQgdG8gY3JlYXRlIGNpcmNsZXMsIG9yIHBhcnRzIG9mIGNpcmNsZXMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3kgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSwgaW4gcmFkaWFucyAoMCBpcyBhdCB0aGUgMyBvJ2Nsb2NrIHBvc2l0aW9uXG4gICAgICogIG9mIHRoZSBhcmMncyBjaXJjbGUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FudGljbG9ja3dpc2U9ZmFsc2VdIC0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRyYXdpbmcgc2hvdWxkIGJlXG4gICAgICogIGNvdW50ZXItY2xvY2t3aXNlIG9yIGNsb2Nrd2lzZS4gRmFsc2UgaXMgZGVmYXVsdCwgYW5kIGluZGljYXRlcyBjbG9ja3dpc2UsIHdoaWxlIHRydWVcbiAgICAgKiAgaW5kaWNhdGVzIGNvdW50ZXItY2xvY2t3aXNlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBhcmMoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGFudGljbG9ja3dpc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydEFuZ2xlID09PSBlbmRBbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbnRpY2xvY2t3aXNlICYmIGVuZEFuZ2xlIDw9IHN0YXJ0QW5nbGUpIHtcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5QSV8yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFudGljbG9ja3dpc2UgJiYgc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSkge1xuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUElfMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3dlZXAgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgICAgIGlmIChzd2VlcCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0WCA9IGN4ICsgKE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzKTtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IGN5ICsgKE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzKTtcbiAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnRQYXRoIGV4aXN0cywgdGFrZSBpdHMgcG9pbnRzLiBPdGhlcndpc2UgY2FsbCBgbW92ZVRvYCB0byBzdGFydCBhIHBhdGguXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoID8gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMgOiBudWxsO1xuICAgICAgICBpZiAocG9pbnRzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYWtlIGEgYmV0dGVyIGZpeC5cbiAgICAgICAgICAgIC8vIFdlIGNoZWNrIGhvdyBmYXIgb3VyIHN0YXJ0IGlzIGZyb20gdGhlIGxhc3QgZXhpc3RpbmcgcG9pbnRcbiAgICAgICAgICAgIHZhciB4RGlmZiA9IE1hdGguYWJzKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gLSBzdGFydFgpO1xuICAgICAgICAgICAgdmFyIHlEaWZmID0gTWF0aC5hYnMocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAtIHN0YXJ0WSk7XG4gICAgICAgICAgICBpZiAoeERpZmYgPCAwLjAwMSAmJiB5RGlmZiA8IDAuMDAxKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oc3RhcnRYLCBzdGFydFkpO1xuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgQXJjVXRpbHNfMS5BcmNVdGlscy5hcmMoc3RhcnRYLCBzdGFydFksIGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgcG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgYSBzaW1wbGUgb25lLWNvbG9yIGZpbGwgdGhhdCBzdWJzZXF1ZW50IGNhbGxzIHRvIG90aGVyIEdyYXBoaWNzIG1ldGhvZHNcbiAgICAgKiAoc3VjaCBhcyBsaW5lVG8oKSBvciBkcmF3Q2lyY2xlKCkpIHVzZSB3aGVuIGRyYXdpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbG9yPTBdIC0gdGhlIGNvbG9yIG9mIHRoZSBmaWxsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbHBoYT0xXSAtIHRoZSBhbHBoYSBvZiB0aGUgZmlsbFxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBiZWdpbkZpbGwoY29sb3IgPSAwLCBhbHBoYSA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVnaW5UZXh0dXJlRmlsbChUZXh0dXJlXzEuVGV4dHVyZS5XSElURSwgY29sb3IsIGFscGhhKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEJlZ2luIHRoZSB0ZXh0dXJlIGZpbGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSBbdGV4dHVyZT1QSVhJLlRleHR1cmUuV0hJVEVdIC0gVGV4dHVyZSB0byBmaWxsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2xvcj0weGZmZmZmZl0gLSBCYWNrZ3JvdW5kIHRvIGZpbGwgYmVoaW5kIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gQWxwaGEgb2YgZmlsbFxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IFttYXRyaXg9bnVsbF0gLSBUcmFuc2Zvcm0gbWF0cml4XG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGJlZ2luVGV4dHVyZUZpbGwodGV4dHVyZSwgY29sb3IsIGFscGhhLCBtYXRyaXggPSBudWxsKSB7XG4gICAgICAgIGlmICh0ZXh0dXJlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSBUZXh0dXJlXzEuVGV4dHVyZS5XSElURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29sb3IgPSAweEZGRkZGRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYWxwaGEgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRyaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbWF0cml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBvbHkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlzaWJsZSA9IGFscGhhID4gMDtcbiAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsU3R5bGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXggPSBtYXRyaXguY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBtYXRyaXguaW52ZXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2ZpbGxTdHlsZSwge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgICAgICAgICAgdGV4dHVyZTogdGV4dHVyZSxcbiAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgZmlsbCB0byB0aGUgbGluZXMgYW5kIHNoYXBlcyB0aGF0IHdlcmUgYWRkZWQgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGUgYmVnaW5GaWxsKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGVuZEZpbGwoKSB7XG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xuICAgICAgICB0aGlzLl9maWxsU3R5bGUucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGRyYXdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHJlY3RhbmdsZSBzaGFwZSB3aXRoIHJvdW5kZWQvYmV2ZWxlZCBjb3JuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gUmFkaXVzIG9mIHRoZSByZWN0YW5nbGUgY29ybmVyc1xuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBkcmF3Um91bmRlZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdTaGFwZShuZXcgUm91bmRlZFJlY3RhbmdsZV8xLlJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNpcmNsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBkcmF3Q2lyY2xlKHgsIHksIHJhZGl1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IENpcmNsZV8xLkNpcmNsZSh4LCB5LCByYWRpdXMpKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXdzIGFuIGVsbGlwc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGRyYXdFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBFbGxpcHNlXzEuRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHBvbHlnb24gdXNpbmcgdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfFBJWEkuUG9pbnRbXXxQSVhJLlBvbHlnb259IHBhdGggLSBUaGUgcGF0aCBkYXRhIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwb2x5Z29uLlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBkcmF3UG9seWdvbihwYXRoKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcbiAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgYXNzaWdubWVudCBkZW9wdFxuICAgICAgICAvLyBzZWUgc2VjdGlvbiAzLjE6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgICAgICB2YXIgcG9pbnRzID0gcGF0aDtcbiAgICAgICAgdmFyIGNsb3NlU3Ryb2tlID0gdHJ1ZTsgLy8gISF0aGlzLl9maWxsU3R5bGU7XG4gICAgICAgIC8vIGNoZWNrIGlmIGRhdGEgaGFzIHBvaW50cy4uXG4gICAgICAgIGlmIChwb2ludHMucG9pbnRzKSB7XG4gICAgICAgICAgICBjbG9zZVN0cm9rZSA9IHBvaW50cy5jbG9zZVN0cm9rZTtcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5wb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGxlYWsgZGVvcHRcbiAgICAgICAgICAgIC8vIHNlZSBzZWN0aW9uIDMuMjogaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMtbWFuYWdpbmctYXJndW1lbnRzXG4gICAgICAgICAgICBwb2ludHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IGFyZ3VtZW50cyQxW2ldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFwZSA9IG5ldyBQb2x5Z29uXzEuUG9seWdvbihwb2ludHMpO1xuICAgICAgICBzaGFwZS5jbG9zZVN0cm9rZSA9IGNsb3NlU3Ryb2tlO1xuICAgICAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRHJhdyBhbnkgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2lyY2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb258UElYSS5SZWN0YW5nbGV8UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBzaGFwZSAtIFNoYXBlIHRvIGRyYXdcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgZHJhd1NoYXBlKHNoYXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5faG9sZU1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZHJhd1NoYXBlKHNoYXBlLCB0aGlzLl9maWxsU3R5bGUuY2xvbmUoKSwgdGhpcy5fbGluZVN0eWxlLmNsb25lKCksIHRoaXMuX21hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5LmRyYXdIb2xlKHNoYXBlLCB0aGlzLl9tYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHN0YXIgc2hhcGUgd2l0aCBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gQ2VudGVyIFggcG9zaXRpb24gb2YgdGhlIHN0YXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIENlbnRlciBZIHBvc2l0aW9uIG9mIHRoZSBzdGFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50cyAtIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9mIHRoZSBzdGFyLCBtdXN0IGJlID4gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzdGFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gLSBUaGUgaW5uZXIgcmFkaXVzIGJldHdlZW4gcG9pbnRzLCBkZWZhdWx0IGhhbGYgYHJhZGl1c2BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uPTBdIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBzdGFyIGluIHJhZGlhbnMsIHdoZXJlIDAgaXMgdmVydGljYWxcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgZHJhd1N0YXIoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzID0gMCwgcm90YXRpb24gPSAwKSB7XG4gICAgICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByb3RhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb24obmV3IFN0YXJfMS5TdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cywgcm90YXRpb24pKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Nwcml0ZVJlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgZ3JhcGhpY3MgY29uc2lzdHMgb2Ygb25lIHJlY3RhbmdsZSwgYW5kIHRodXMsIGNhbiBiZSBkcmF3biBsaWtlIGEgU3ByaXRlIGFuZFxuICAgICAqIG1hc2tlZCB3aXRoIGdsLnNjaXNzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IDEgcmVjdC5cbiAgICAgKi9cbiAgICBpc0Zhc3RSZWN0KCkge1xuICAgICAgICAvLyB3aWxsIGZpeCB0aGlzIVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9PT0gMVxuICAgICAgICAvLyAgJiYgdGhpcy5ncmFwaGljc0RhdGFbMF0uc2hhcGUudHlwZSA9PT0gU0hBUEVTLlJFQ1RcbiAgICAgICAgLy8gJiYgIXRoaXMuZ3JhcGhpY3NEYXRhWzBdLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgICAgLy8gYmF0Y2ggcGFydC4uXG4gICAgICAgIC8vIGJhdGNoIGl0IVxuICAgICAgICBnZW9tZXRyeS51cGRhdGVCYXRjaGVzKCk7XG4gICAgICAgIGlmIChnZW9tZXRyeS5iYXRjaGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoRGlydHkgIT09IGdlb21ldHJ5LmJhdGNoRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoVGludCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaERpcnR5ID0gZ2VvbWV0cnkuYmF0Y2hEaXJ0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGdlb21ldHJ5LnBvaW50cyk7XG4gICAgICAgICAgICAgICAgdmFyIGJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ0kgPSBnZW9tZXRyeS5iYXRjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBnSS5zdHlsZS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICsgKGFscGhhICogMjU1IDw8IDI0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmVydGV4RGF0YS5idWZmZXIsIGdJLmF0dHJpYlN0YXJ0ICogNCAqIDIsIGdJLmF0dHJpYlNpemUgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkudXZzRmxvYXQzMi5idWZmZXIsIGdJLmF0dHJpYlN0YXJ0ICogNCAqIDIsIGdJLmF0dHJpYlNpemUgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoZ2VvbWV0cnkuaW5kaWNlc1VpbnQxNi5idWZmZXIsIGdJLnN0YXJ0ICogMiwgZ0kuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleERhdGE6IHZlcnRleERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuZE1vZGU6IGJsZW5kTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dnM6IHV2cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iYXRjaFJHQjogQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuaGV4MnJnYihjb2xvciksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGludFJHQjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGV4dHVyZTogZ0kuc3R5bGUudGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhOiBnSS5zdHlsZS5hbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkQWxwaGE6IDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVzW2ldID0gYmF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5iYXRjaCk7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVRpbnRzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoJDEgPSB0aGlzLmJhdGNoZXNbaSQxXTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2gkMS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhICogYmF0Y2gkMS5hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucGx1Z2lucy5iYXRjaC5yZW5kZXIoYmF0Y2gkMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gYmF0Y2hpbmcuLi5cbiAgICAgICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gc2hhZGVyIGhlcmUsIHdlIGNhbiB1c2UgdGhlIGRlZmF1bHQgc2hhZGVyLlxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGF0IG9ubHkgZ2V0cyBjcmVhdGVkIGlmIHdlIGFjdHVhbGx5IG5lZWQgaXQuLlxuICAgICAgICAgICAgICAgIGlmICghR3JhcGhpY3MuZGVmYXVsdFNoYWRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FtcGxlVmFsdWVzID0gbmV3IEludDMyQXJyYXkoMTYpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCAxNjsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVZhbHVlc1tpJDJdID0gaSQyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbnQ6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgTWF0cml4XzEuTWF0cml4KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gYmJhc2UgZGVmYXVsdCBzaGFkZXIgb2YgdGhlIGJhdGNoIHJlbmRlcmVycyBwcm9ncmFtXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmFtID0gcmVuZGVyZXIucGx1Z2lucy5iYXRjaC5zaGFkZXIucHJvZ3JhbTtcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZGVmYXVsdFNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlciA9IEdyYXBoaWNzLmRlZmF1bHRTaGFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdW5pZm9ybXMkMSA9IHRoaXMuc2hhZGVyLnVuaWZvcm1zO1xuICAgICAgICAgICAgLy8gbGV0cyBzZXQgdGhlIHRyYW5zZm9tclxuICAgICAgICAgICAgdW5pZm9ybXMkMS50cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIHRpbnQgPSB0aGlzLnRpbnQ7XG4gICAgICAgICAgICB2YXIgd2EgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBsZXRzIHNldCB0aGUgdGludC4uXG4gICAgICAgICAgICB1bmlmb3JtcyQxLnRpbnRbMF0gPSAoKCh0aW50ID4+IDE2KSAmIDB4RkYpIC8gMjU1KSAqIHdhO1xuICAgICAgICAgICAgdW5pZm9ybXMkMS50aW50WzFdID0gKCgodGludCA+PiA4KSAmIDB4RkYpIC8gMjU1KSAqIHdhO1xuICAgICAgICAgICAgdW5pZm9ybXMkMS50aW50WzJdID0gKCh0aW50ICYgMHhGRikgLyAyNTUpICogd2E7XG4gICAgICAgICAgICB1bmlmb3JtcyQxLnRpbnRbM10gPSB3YTtcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBkcmF3IGNhbGwsIHdlIGNhbiBzZXQgdGhlIHVuaWZvcm1zIG9mIHRoZSBzaGFkZXIgZGlyZWN0bHkgaGVyZS5cbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gdGFjayBhZHZhbnRhZ2Ugb2YgdGhlIHN5bmMgZnVuY3Rpb24gb2YgcGl4aSFcbiAgICAgICAgICAgIC8vIGJpbmQgYW5kIHN5bmMgdW5pZm9ybXMuLlxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSB3YXkgdG8gb3B0aW1pc2UgdGhpcy4uXG4gICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzLnNoYWRlcik7XG4gICAgICAgICAgICAvLyB0aGVuIHJlbmRlciBpdFxuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgdGhpcy5zaGFkZXIpO1xuICAgICAgICAgICAgLy8gc2V0IHN0YXRlLi5cbiAgICAgICAgICAgIHJlbmRlcmVyLnN0YXRlLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgLy8gdGhlbiByZW5kZXIgdGhlIHJlc3Qgb2YgdGhlbS4uLlxuICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgZ2VvbWV0cnkuZHJhd0NhbGxzLmxlbmd0aDsgaSQzKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NhbGwgPSBnZW9tZXRyeS5kcmF3Q2FsbHNbaSQzXTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBUZXh0dXJlQ291bnQgPSBkcmF3Q2FsbC50ZXh0dXJlQ291bnQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cFRleHR1cmVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZChkcmF3Q2FsbC50ZXh0dXJlc1tqXSwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJpbmQgdGhlIGdlb21ldHJ5Li4uXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyhkcmF3Q2FsbC50eXBlLCBkcmF3Q2FsbC5zaXplLCBkcmF3Q2FsbC5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBncmFwaGljIHNoYXBlIGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xuICAgICAgICB2YXIgbGIgPSB0aGlzLmdlb21ldHJ5LmJvdW5kcztcbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCBsYi5taW5YLCBsYi5taW5ZLCBsYi5tYXhYLCBsYi5tYXhZKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgZ3JhcGhpY3Mgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgR3JhcGhpY3MuX1RFTVBfUE9JTlQpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeS5jb250YWluc1BvaW50KEdyYXBoaWNzLl9URU1QX1BPSU5UKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlY2FsY3VhdGUgdGhlIHRpbnQgYnkgYXBwbHlpbmcgdGluIHRvIGJhdGNoZXMgdXNpbmcgR3JhcGhpY3MgdGludC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FsY3VsYXRlVGludHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoVGludCAhPT0gdGhpcy50aW50KSB7XG4gICAgICAgICAgICB0aGlzLmJhdGNoVGludCA9IHRoaXMudGludDtcbiAgICAgICAgICAgIHZhciB0aW50UkdCID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuaGV4MnJnYih0aGlzLnRpbnQsIEdyYXBoaWNzLnRlbXApO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoVGludCA9IGJhdGNoLl9iYXRjaFJHQjtcbiAgICAgICAgICAgICAgICB2YXIgciA9ICh0aW50UkdCWzBdICogYmF0Y2hUaW50WzBdKSAqIDI1NTtcbiAgICAgICAgICAgICAgICB2YXIgZyA9ICh0aW50UkdCWzFdICogYmF0Y2hUaW50WzFdKSAqIDI1NTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9ICh0aW50UkdCWzJdICogYmF0Y2hUaW50WzJdKSAqIDI1NTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIEl2YW4sIGNhbiB0aGlzIGJlIGRvbmUgaW4gb25lIGdvP1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IChyIDw8IDE2KSArIChnIDw8IDgpICsgKGIgfCAwKTtcbiAgICAgICAgICAgICAgICBiYXRjaC5fdGludFJHQiA9IChjb2xvciA+PiAxNilcbiAgICAgICAgICAgICAgICAgICAgKyAoY29sb3IgJiAweGZmMDApXG4gICAgICAgICAgICAgICAgICAgICsgKChjb2xvciAmIDB4ZmYpIDw8IDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSWYgdGhlcmUncyBhIHRyYW5zZm9ybSB1cGRhdGUgb3IgYSBjaGFuZ2UgdG8gdGhlIHNoYXBlIG9mIHRoZVxuICAgICAqIGdlb21ldHJ5LCByZWNhY3VsYXRlIHRoZSB2ZXJ0aWNlcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY2FsY3VsYXRlVmVydGljZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xuICAgICAgICB2YXIgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgLy8gcmV2ZWFsKHd0KVxuICAgICAgICB2YXIgYSA9IHd0LmE7XG4gICAgICAgIHZhciBiID0gd3QuYjtcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xuICAgICAgICB2YXIgZCA9IHd0LmQ7XG4gICAgICAgIHZhciB0eCA9IHd0LnR4O1xuICAgICAgICB2YXIgdHkgPSB3dC50eTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdlb21ldHJ5LnBvaW50czsgLy8gYmF0Y2gudmVydGV4RGF0YU9yaWdpbmFsO1xuICAgICAgICB2YXIgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YTtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICB2YXIgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgdmVydGV4RGF0YVtjb3VudCsrXSA9IChhICogeCkgKyAoYyAqIHkpICsgdHg7XG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhW2NvdW50KytdID0gKGQgKiB5KSArIChiICogeCkgKyB0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cbiAgICBjbG9zZVBhdGgoKSB7XG4gICAgICAgIHZhciBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgICAgIGlmIChjdXJyZW50UGF0aCkge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBhZGQgZXh0cmEgcG9pbnQgaW4gdGhlIGVuZCBiZWNhdXNlIGJ1aWxkTGluZSB3aWxsIHRha2UgY2FyZSBvZiB0aGF0XG4gICAgICAgICAgICBjdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBcHBseSBhIG1hdHJpeCB0byB0aGUgcG9zaXRpb25hbCBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gTWF0cml4IHRvIHVzZSBmb3IgdHJhbnNmb3JtIGN1cnJlbnQgc2hhcGUuXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgc2V0TWF0cml4KG1hdHJpeCkge1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXRyaXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQmVnaW4gYWRkaW5nIGhvbGVzIHRvIHRoZSBsYXN0IGRyYXcgc2hhcGVcbiAgICAgKiBJTVBPUlRBTlQ6IGhvbGVzIG11c3QgYmUgZnVsbHkgaW5zaWRlIGEgc2hhcGUgdG8gd29ya1xuICAgICAqIEFsc28gd2VpcmRuZXNzIGVuc3VlcyBpZiBob2xlcyBvdmVybGFwIVxuICAgICAqIEVsbGlwc2VzLCBDaXJjbGVzLCBSZWN0YW5nbGVzIGFuZCBSb3VuZGVkIFJlY3RhbmdsZXMgY2Fubm90IGJlIGhvbGVzIG9yIGhvc3QgZm9yIGhvbGVzIGluIENhbnZhc1JlbmRlcmVyLFxuICAgICAqIHBsZWFzZSB1c2UgYG1vdmVUb2AgYGxpbmVUb2AsIGBxdWFkcmF0aWNDdXJ2ZVRvYCBpZiB5b3UgcmVseSBvbiBwaXhpLWxlZ2FjeSBidW5kbGUuXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgYmVnaW5Ib2xlKCkge1xuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICAgICAgdGhpcy5faG9sZU1vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEVuZCBhZGRpbmcgaG9sZXMgdG8gdGhlIGxhc3QgZHJhdyBzaGFwZVxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuICAgIGVuZEhvbGUoKSB7XG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xuICAgICAgICB0aGlzLl9ob2xlTW9kZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxuICAgICAqICBvcHRpb25zIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdlb21ldHJ5LnJlZkNvdW50LS07XG4gICAgICAgIGlmICh0aGlzLmdlb21ldHJ5LnJlZkNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGluZVN0eWxlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fbGluZVN0eWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmlsbFN0eWxlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fZmlsbFN0eWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG51bGw7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgfVxuICAgIDtcbn1cbkdyYXBoaWNzLnRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSk7XG5HcmFwaGljcy5kZWZhdWx0U2hhZGVyID0gbnVsbDtcbi8qKlxuKiBUZW1wb3JhcnkgcG9pbnQgdG8gdXNlIGZvciBjb250YWluc1BvaW50XG4qXG4qIEBzdGF0aWNcbiogQHByaXZhdGVcbiogQG1lbWJlciB7UElYSS5Qb2ludH1cbiovXG5HcmFwaGljcy5fVEVNUF9QT0lOVCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XG5leHBvcnRzLkdyYXBoaWNzID0gR3JhcGhpY3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEdyYXBoaWNzRGF0YSB7XG4gICAgY29uc3RydWN0b3Ioc2hhcGUsIGZpbGxTdHlsZSA9IG51bGwsIGxpbmVTdHlsZSA9IG51bGwsIG1hdHJpeCA9IG51bGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGxpbmUuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTGluZVN0eWxlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lU3R5bGUgPSBsaW5lU3R5bGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGZpbGwuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRmlsbFN0eWxlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNmb3JtIG1hdHJpeC5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBzaGFwZSwgc2VlIHRoZSBDb25zdC5TaGFwZXMgZmlsZSBmb3IgYWxsIHRoZSBleGlzdGluZyB0eXBlcyxcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gc2hhcGUudHlwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIHBvaW50cy5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgaG9sZXMuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NEYXRhW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvbGVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3NEYXRhIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3NEYXRhfSBDbG9uZWQgR3JhcGhpY3NEYXRhIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNzRGF0YSh0aGlzLnNoYXBlLCB0aGlzLmZpbGxTdHlsZSwgdGhpcy5saW5lU3R5bGUsIHRoaXMubWF0cml4KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBkYXRhLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhvbGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuaG9sZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvaW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZVN0eWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkdyYXBoaWNzRGF0YSA9IEdyYXBoaWNzRGF0YTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmF0Y2hHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vQmF0Y2hHZW9tZXRyeVwiKTtcbmNvbnN0IEJvdW5kc18xID0gcmVxdWlyZShcIi4vQm91bmRzXCIpO1xuY29uc3QgR3JhcGhpY3NEYXRhXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljc0RhdGFcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XG5jb25zdCBCYXRjaERyYXdDYWxsXzEgPSByZXF1aXJlKFwiLi9CYXRjaERyYXdDYWxsXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcbmNvbnN0IERyYXdNb2RlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0RyYXdNb2RlU2V0dGluZ3NcIik7XG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xuY2xhc3MgQmF0Y2hQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmF0dHJpYlN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5hdHRyaWJTaXplID0gMDtcbiAgICB9XG59XG5jbGFzcyBHcmFwaGljc0dlb21ldHJ5IGV4dGVuZHMgQmF0Y2hHZW9tZXRyeV8xLkJhdGNoR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgcG9pbnRzIHRvIGRyYXdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgY29sb3JzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVWcyBjb2xsZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnV2cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgdGV4dHVyZSBJRHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmVJZHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIGRyYXduIHNoYXBlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc0RhdGFbXX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHRoZSBncmFwaGljcyBvYmplY3QgaGFzIGNoYW5nZWQuIElmIHRoaXMgaXMgc2V0IHRvIHRydWUgdGhlbiB0aGUgZ3JhcGhpY3NcbiAgICAgICAgICogb2JqZWN0IHdpbGwgYmUgcmVjYWxjdWxhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlydHkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2hlcyBuZWVkIHRvIHJlZ2VuZXJhdGVkIGlmIHRoZSBnZW9tZXRyeSBpcyB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmF0Y2hEaXJ0eSA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBjaGVjayBpZiB0aGUgY2FjaGUgaXMgZGlydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZURpcnR5ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSBjbGVhciB0aGUgZ3JhcGhpY3MgV2ViR0wgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJEaXJ0eSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGN1cnJlbnQgZHJhdyBjYWxscyBkcml2ZWQgZnJvbSB0aGUgYmF0Y2hlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhd0NhbGxzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm1lZGlhdGUgYWJzdHJhY3QgZm9ybWF0IHNlbnQgdG8gYmF0Y2ggc3lzdGVtLlxuICAgICAgICAgKiBDYW4gYmUgY29udmVydGVkIHRvIGRyYXdDYWxscyBvciB0byBiYXRjaGFibGUgb2JqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kZXggb2YgdGhlIGN1cnJlbnQgbGFzdCBzaGFwZSBpbiB0aGUgc3RhY2sgb2YgY2FsbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlZCBib3VuZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQm91bmRzfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzXzEuQm91bmRzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYm91bmRzIGRpcnR5IGZsYWcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFkZGluZyB0byBhZGQgdG8gdGhlIGJvdW5kcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc1BhZGRpbmcgPSAwO1xuICAgICAgICB0aGlzLmJhdGNoYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGljZXNVaW50MTYgPSBudWxsO1xuICAgICAgICB0aGlzLnV2c0Zsb2F0MzIgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RmlsbENvbW1hbmQodHlwZSkge1xuICAgICAgICBpZiAoIUdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzKSB7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kcyA9IHt9O1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlBPTFldID0gR3JhcGhpY3NHZW9tZXRyeS5idWlsZFBvbHk7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuQ0lSQ10gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkQ2lyY2xlO1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkVMSVBdID0gR3JhcGhpY3NHZW9tZXRyeS5idWlsZENpcmNsZTtcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzW1NoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5SRUNUXSA9IEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRSZWN0YW5nbGU7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUlJFQ10gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkUm91bmRlZFJlY3RhbmdsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbdHlwZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBib3VuZHMgb2YgdGhlIGdyYXBoaWMgZ2VvbWV0cnkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJvdW5kc31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgYm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5ib3VuZHNEaXJ0eSAhPT0gdGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoaWNzIHRoYXQgd2VyZSBkcmF3biB0byB0aGlzIEdyYXBoaWNzIG9iamVjdCwgYW5kIHJlc2V0cyBmaWxsIGFuZCBsaW5lIHN0eWxlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBUaGlzIEdyYXBoaWNzR2VvbWV0cnkgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzRGlydHkgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkrKztcbiAgICAgICAgICAgIHRoaXMuY2xlYXJEaXJ0eSsrO1xuICAgICAgICAgICAgdGhpcy5iYXRjaERpcnR5Kys7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbG9ycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlSWRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q2FsbHNbaV0udGV4dHVyZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MLnB1c2godGhpcy5kcmF3Q2FsbHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaGVzW2kkMV07XG4gICAgICAgICAgICAgICAgYmF0Y2guc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGJhdGNoLmF0dHJpYlN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBiYXRjaC5zdHlsZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5CQVRDSF9QT09MLnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgZ2l2ZW4gc2hhcGUgdG8gdGhpcyBHcmFwaGljcyBvYmplY3QuIENhbiBiZSBhbnkgb2YgQ2lyY2xlLCBSZWN0YW5nbGUsIEVsbGlwc2UsIExpbmUgb3IgUG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICAgICAqIEBwYXJhbSB7UElYSS5GaWxsU3R5bGV9IGZpbGxTdHlsZSAtIERlZmluZXMgc3R5bGUgb2YgdGhlIGZpbGwuXG4gICAgICogQHBhcmFtIHtQSVhJLkxpbmVTdHlsZX0gbGluZVN0eWxlIC0gRGVmaW5lcyBzdHlsZSBvZiB0aGUgbGluZXMuXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVHJhbnNmb3JtIGFwcGxpZWQgdG8gdGhlIHBvaW50cyBvZiB0aGUgc2hhcGUuXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBSZXR1cm5zIGdlb21ldHJ5IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBkcmF3U2hhcGUoc2hhcGUsIGZpbGxTdHlsZSwgbGluZVN0eWxlLCBtYXRyaXgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgR3JhcGhpY3NEYXRhXzEuR3JhcGhpY3NEYXRhKHNoYXBlLCBmaWxsU3R5bGUsIGxpbmVTdHlsZSwgbWF0cml4KTtcbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBnaXZlbiBzaGFwZSB0byB0aGlzIEdyYXBoaWNzIG9iamVjdC4gQ2FuIGJlIGFueSBvZiBDaXJjbGUsIFJlY3RhbmdsZSwgRWxsaXBzZSwgTGluZSBvciBQb2x5Z29uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUmVjdGFuZ2xlfFBJWEkuUm91bmRlZFJlY3RhbmdsZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGRyYXcuXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVHJhbnNmb3JtIGFwcGxpZWQgdG8gdGhlIHBvaW50cyBvZiB0aGUgc2hhcGUuXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBSZXR1cm5zIGdlb21ldHJ5IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBkcmF3SG9sZShzaGFwZSwgbWF0cml4KSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBHcmFwaGljc0RhdGFfMS5HcmFwaGljc0RhdGEoc2hhcGUsIG51bGwsIG51bGwsIG1hdHJpeCk7XG4gICAgICAgIHZhciBsYXN0U2hhcGUgPSB0aGlzLmdyYXBoaWNzRGF0YVt0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgZGF0YS5saW5lU3R5bGUgPSBsYXN0U2hhcGUubGluZVN0eWxlO1xuICAgICAgICBsYXN0U2hhcGUuaG9sZXMucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxuICAgICAqICBvcHRpb25zIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICAvLyBkZXN0cm95IGVhY2ggb2YgdGhlIEdyYXBoaWNzRGF0YSBvYmplY3RzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvaW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29sb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZHJhd0NhbGxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgYSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgZ2VvbWV0cnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gUG9pbnQgdG8gY2hlY2sgaWYgaXQncyBjb250YWluZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGdlb21ldHJ5LlxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgdmFyIGdyYXBoaWNzRGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICBpZiAoIWRhdGEuZmlsbFN0eWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgZGVhbCB3aXRoIGZpbGxzLi5cbiAgICAgICAgICAgIGlmIChkYXRhLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2hhcGUuY29udGFpbnMocG9pbnQueCwgcG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaG9sZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRhdGEuaG9sZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob2xlID0gZGF0YS5ob2xlc1tpJDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xlLnNoYXBlLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBpbnRlcm1lZGlhdGUgYmF0Y2ggZGF0YS4gRWl0aGVyIGdldHMgY29udmVydGVkIHRvIGRyYXdDYWxsc1xuICAgICAqIG9yIHVzZWQgdG8gY29udmVydCB0byBiYXRjaCBvYmplY3RzIGRpcmVjdGx5IGJ5IHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUJhdGNoZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09PSB0aGlzLmNhY2hlRGlydHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlydHkgIT09IHRoaXMuY2FjaGVEaXJ0eSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICAgICAgLy8gcmV2ZWFsKGRhdGEuZmlsbFN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmUucmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgIC8vIHJldmVhbChkYXRhLmxpbmVTdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5maWxsU3R5bGUgJiYgIWRhdGEuZmlsbFN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5saW5lU3R5bGUgJiYgIWRhdGEubGluZVN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhY2hlRGlydHkgPSB0aGlzLmRpcnR5O1xuICAgICAgICB2YXIgdXZzID0gdGhpcy51dnM7XG4gICAgICAgIHZhciBiYXRjaFBhcnQgPSB0aGlzLmJhdGNoZXMucG9wKClcbiAgICAgICAgICAgIHx8IEdyYXBoaWNzR2VvbWV0cnkuQkFUQ0hfUE9PTC5wb3AoKVxuICAgICAgICAgICAgfHwgbmV3IEJhdGNoUGFydCgpO1xuICAgICAgICBiYXRjaFBhcnQuc3R5bGUgPSBiYXRjaFBhcnQuc3R5bGVcbiAgICAgICAgICAgIHx8IHRoaXMuZ3JhcGhpY3NEYXRhWzBdLmZpbGxTdHlsZVxuICAgICAgICAgICAgfHwgdGhpcy5ncmFwaGljc0RhdGFbMF0ubGluZVN0eWxlO1xuICAgICAgICB2YXIgY3VycmVudFRleHR1cmUgPSBiYXRjaFBhcnQuc3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgLy8gcmV2ZWFsKGN1cnJlbnRUZXh0dXJlKTtcbiAgICAgICAgdmFyIGN1cnJlbnRDb2xvciA9IGJhdGNoUGFydC5zdHlsZS5jb2xvciArIGJhdGNoUGFydC5zdHlsZS5hbHBoYTtcbiAgICAgICAgdGhpcy5iYXRjaGVzLnB1c2goYmF0Y2hQYXJ0KTtcbiAgICAgICAgLy8gcmV2ZWFsKHRoaXMuYmF0Y2hlcyk7XG4gICAgICAgIC8vIFRPRE8gLSB0aGlzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgICAgIGZvciAodmFyIGkkMSA9IHRoaXMuc2hhcGVJbmRleDsgaSQxIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgdGhpcy5zaGFwZUluZGV4Kys7XG4gICAgICAgICAgICB2YXIgZGF0YSQxID0gdGhpcy5ncmFwaGljc0RhdGFbaSQxXTtcbiAgICAgICAgICAgIC8vIHJldmVhbChkYXRhJDEpO1xuICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBHcmFwaGljc0dlb21ldHJ5LmdldEZpbGxDb21tYW5kKGRhdGEkMS50eXBlKTtcbiAgICAgICAgICAgIC8vIHJldmVhbChjb21tYW5kKVxuICAgICAgICAgICAgdmFyIGZpbGxTdHlsZSA9IGRhdGEkMS5maWxsU3R5bGU7XG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlID0gZGF0YSQxLmxpbmVTdHlsZTtcbiAgICAgICAgICAgIC8vIGJ1aWxkIG91dCB0aGUgc2hhcGVzIHBvaW50cy4uXG4gICAgICAgICAgICBjb21tYW5kLmJ1aWxkKGRhdGEkMSk7XG4gICAgICAgICAgICBpZiAoZGF0YSQxLm1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtUG9pbnRzKGRhdGEkMS5wb2ludHMsIGRhdGEkMS5tYXRyaXgpO1xuICAgICAgICAgICAgICAgIC8vIHJldmVhbChkYXRhJDEucG9pbnRzKVxuICAgICAgICAgICAgICAgIC8vIFx0cmV2ZWFsKGRhdGEkMS5tYXRyaXgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IChqID09PSAwKSA/IGZpbGxTdHlsZSA6IGxpbmVTdHlsZTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXh0VGV4dHVyZSA9IHN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSB8fCAoc3R5bGUuY29sb3IgKyBzdHlsZS5hbHBoYSkgIT09IGN1cnJlbnRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHVzZSBhIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLndyYXBNb2RlID0gMTA0OTc7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbmV4dFRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IHN0eWxlLmNvbG9yICsgc3R5bGUuYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCQxID0gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYkluZGV4ID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LnNpemUgPSBpbmRleCQxIC0gYmF0Y2hQYXJ0LnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQuYXR0cmliU2l6ZSA9IGF0dHJpYkluZGV4IC0gYmF0Y2hQYXJ0LmF0dHJpYlN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2hQYXJ0LnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQgPSBHcmFwaGljc0dlb21ldHJ5LkJBVENIX1BPT0wucG9wKCkgfHwgbmV3IEJhdGNoUGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVzLnB1c2goYmF0Y2hQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LnN0YXJ0ID0gaW5kZXgkMTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LmF0dHJpYlN0YXJ0ID0gYXR0cmliSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIHRoaXMgdG8gdGhlIHJlbmRlciBwYXJ0Li5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSQxLmhvbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSG9sZXMoZGF0YSQxLmhvbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRQb2x5LnRyaWFuZ3VsYXRlKGRhdGEkMSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLnRyaWFuZ3VsYXRlKGRhdGEkMSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRMaW5lKGRhdGEkMSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGRhdGEkMS5ob2xlcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkTGluZShkYXRhJDEuaG9sZXNbaSQyXSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSAodGhpcy5wb2ludHMubGVuZ3RoIC8gMikgLSBzdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFV2cyh0aGlzLnBvaW50cywgdXZzLCBzdHlsZS50ZXh0dXJlLCBzdGFydCwgc2l6ZSwgc3R5bGUubWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGljZXMubGVuZ3RoO1xuICAgICAgICB2YXIgYXR0cmliID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgYmF0Y2hQYXJ0LnNpemUgPSBpbmRleCAtIGJhdGNoUGFydC5zdGFydDtcbiAgICAgICAgYmF0Y2hQYXJ0LmF0dHJpYlNpemUgPSBhdHRyaWIgLSBiYXRjaFBhcnQuYXR0cmliU3RhcnQ7XG4gICAgICAgIHRoaXMuaW5kaWNlc1VpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyBhIGNvbnN0Li5cbiAgICAgICAgdGhpcy5iYXRjaGFibGUgPSB0aGlzLmlzQmF0Y2hhYmxlKCk7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5iYXRjaERpcnR5Kys7XG4gICAgICAgICAgICB0aGlzLnV2c0Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXZzKTtcbiAgICAgICAgICAgIC8vIG9mZnNldCB0aGUgaW5kaWNlcyBzbyB0aGF0IGl0IHdvcmtzIHdpdGggdGhlIGJhdGNoZXIuLi5cbiAgICAgICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkkMysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaGVzW2kkM107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgYmF0Y2guc2l6ZTsgaiQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4JDIgPSBiYXRjaC5zdGFydCArIGokMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzVWludDE2W2luZGV4JDJdID0gdGhpcy5pbmRpY2VzVWludDE2W2luZGV4JDJdIC0gYmF0Y2guYXR0cmliU3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWlsZERyYXdDYWxscygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoaXMgZ3JhcGhpY3MgZ2VvbWV0cnkgY2FuIGJlIGJhdGNoZWQuXG4gICAgICogQ3VycmVudGx5IGl0IG5lZWRzIHRvIGJlIHNtYWxsIGVub3VnaCBhbmQgbm90IGNvbnRhaW4gYW55IG5hdGl2ZSBsaW5lcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNCYXRjaGFibGUoKSB7XG4gICAgICAgIHZhciBiYXRjaGVzID0gdGhpcy5iYXRjaGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChiYXRjaGVzW2ldLnN0eWxlLm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMucG9pbnRzLmxlbmd0aCA8IEdyYXBoaWNzR2VvbWV0cnkuQkFUQ0hBQkxFX1NJWkUgKiAyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGludGVybWVkaWF0ZSBiYXRjaGVzIGRhdGEgdG8gZHJhd0NhbGxzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBidWlsZERyYXdDYWxscygpIHtcbiAgICAgICAgdmFyIFRJQ0sgPSArK0Jhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdDYWxsc1tpXS50ZXh0dXJlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5EUkFXX0NBTExfUE9PTC5wdXNoKHRoaXMuZHJhd0NhbGxzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdDYWxscy5sZW5ndGggPSAwO1xuICAgICAgICB2YXIgdXZzID0gdGhpcy51dnM7XG4gICAgICAgIHZhciBjb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICAgICAgdmFyIHRleHR1cmVJZHMgPSB0aGlzLnRleHR1cmVJZHM7XG4gICAgICAgIHZhciBjdXJyZW50R3JvdXAgPSBHcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MLnBvcCgpIHx8IG5ldyBCYXRjaERyYXdDYWxsXzEuQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gMDtcbiAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSAwO1xuICAgICAgICBjdXJyZW50R3JvdXAudHlwZSA9IERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xuICAgICAgICB2YXIgdGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdmFyIHRleHR1cmVJZCA9IDA7XG4gICAgICAgIHZhciBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRyYXdNb2RlID0gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRVM7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgLy8gVE9ETyAtIHRoaXMgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5iYXRjaGVzW2kkMV07XG4gICAgICAgICAgICAvLyBUT0RPIGFkZCBzb21lIGZ1bGwgb24gTUFYX1RFWFRVUkUgQ09ERS4uXG4gICAgICAgICAgICB2YXIgTUFYX1RFWFRVUkVTID0gODtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRhdGEuc3R5bGU7XG4gICAgICAgICAgICB2YXIgbmV4dFRleHR1cmUgPSBzdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICAgICAgaWYgKG5hdGl2ZSAhPT0gc3R5bGUubmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlID0gc3R5bGUubmF0aXZlO1xuICAgICAgICAgICAgICAgIGRyYXdNb2RlID0gbmF0aXZlID8gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5MSU5FUyA6IERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHRoZSBiYXRjaCB0byBicmVhayFcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50ID0gTUFYX1RFWFRVUkVTO1xuICAgICAgICAgICAgICAgIFRJQ0srKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dHVyZSAhPT0gbmV4dFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkICE9PSBUSUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlQ291bnQgPT09IE1BWF9URVhUVVJFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgVElDSysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50R3JvdXAuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBHcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MLnBvcCgpIHx8IG5ldyBCYXRjaERyYXdDYWxsXzEuQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudHlwZSA9IGRyYXdNb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIHRoaXMgdG8gdGhlIHJlbmRlciBwYXJ0Li5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUudG91Y2hlZCA9IDE7IC8vIHRvdWNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkID0gVElDSztcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUuX2lkID0gdGV4dHVyZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS53cmFwTW9kZSA9IDEwNDk3O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZXNbY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCsrXSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAuc2l6ZSArPSBkYXRhLnNpemU7XG4gICAgICAgICAgICBpbmRleCArPSBkYXRhLnNpemU7XG4gICAgICAgICAgICB0ZXh0dXJlSWQgPSBuZXh0VGV4dHVyZS5faWQ7XG4gICAgICAgICAgICB0aGlzLmFkZENvbG9ycyhjb2xvcnMsIHN0eWxlLmNvbG9yLCBzdHlsZS5hbHBoYSwgZGF0YS5hdHRyaWJTaXplKTtcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dHVyZUlkcyh0ZXh0dXJlSWRzLCB0ZXh0dXJlSWQsIGRhdGEuYXR0cmliU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2ggPSBUSUNLO1xuICAgICAgICAvLyB1cGxvYWQuLlxuICAgICAgICAvLyBtZXJnZSBmb3Igbm93IVxuICAgICAgICB2YXIgdmVydHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgLy8gdmVydHMgYXJlIDIgcG9zaXRpb25zLi4gc28gd2UgKiBieSAzIGFzIHRoZXJlIGFyZSA2IHByb3BlcnRpZXMuLiB0aGVuIDQgY29zIGl0cyBieXRlc1xuICAgICAgICB2YXIgZ2xQb2ludHMgPSBuZXcgQXJyYXlCdWZmZXIodmVydHMubGVuZ3RoICogMyAqIDQpO1xuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShnbFBvaW50cyk7XG4gICAgICAgIHZhciB1MzIgPSBuZXcgVWludDMyQXJyYXkoZ2xQb2ludHMpO1xuICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHZlcnRzLmxlbmd0aCAvIDI7IGkkMisrKSB7XG4gICAgICAgICAgICBmMzJbcCsrXSA9IHZlcnRzW2kkMiAqIDJdO1xuICAgICAgICAgICAgZjMyW3ArK10gPSB2ZXJ0c1soaSQyICogMikgKyAxXTtcbiAgICAgICAgICAgIGYzMltwKytdID0gdXZzW2kkMiAqIDJdO1xuICAgICAgICAgICAgZjMyW3ArK10gPSB1dnNbKGkkMiAqIDIpICsgMV07XG4gICAgICAgICAgICB1MzJbcCsrXSA9IGNvbG9yc1tpJDJdO1xuICAgICAgICAgICAgZjMyW3ArK10gPSB0ZXh0dXJlSWRzW2kkMl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyLnVwZGF0ZShnbFBvaW50cyk7XG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVyLnVwZGF0ZSh0aGlzLmluZGljZXNVaW50MTYpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaG9sZXMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGFbXX0gaG9sZXMgLSBIb2xlcyB0byByZW5kZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvY2Vzc0hvbGVzKGhvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBob2xlID0gaG9sZXNbaV07XG4gICAgICAgICAgICB2YXIgY29tbWFuZCA9IEdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzW2hvbGUudHlwZV07XG4gICAgICAgICAgICBjb21tYW5kLmJ1aWxkKGhvbGUpO1xuICAgICAgICAgICAgaWYgKGhvbGUubWF0cml4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludHMoaG9sZS5wb2ludHMsIGhvbGUubWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIG9iamVjdC4gRXhwZW5zaXZlIHRvIHVzZSBwZXJmb3JtYW5jZS13aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgICAgIHZhciBoID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBkYXRhLmxpbmVTdHlsZSA/IGRhdGEubGluZVN0eWxlLndpZHRoIDogMDtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IGRhdGEuc2hhcGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5SRUNUIHx8IHR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5SUkVDKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54IC0gKGxpbmVXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueSAtIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLndpZHRoICsgbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5DSVJDKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLnJhZGl1cyArIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLnJhZGl1cyArIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkVMSVApIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyAobGluZVdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGggPSBzaGFwZS5oZWlnaHQgKyAobGluZVdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5IC0gaCA8IG1pblkgPyB5IC0gaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQT0xZXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqICsgMiA8IHBvaW50cy5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBwb2ludHNbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBwb2ludHNbaiArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSBNYXRoLmFicyh4MiAtIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBNYXRoLmFicyh5MiAtIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBNYXRoLnNxcnQoKGR4ICogZHgpICsgKGR5ICogZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3IDwgMWUtOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcncgPSAoKGggLyB3ICogZHkpICsgZHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJoID0gKChoIC8gdyAqIGR4KSArIGR5KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9ICh4MiArIHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gKHkyICsgeSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluWCA9IGN4IC0gcncgPCBtaW5YID8gY3ggLSBydyA6IG1pblg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gY3ggKyBydyA+IG1heFggPyBjeCArIHJ3IDogbWF4WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSBjeSAtIHJoIDwgbWluWSA/IGN5IC0gcmggOiBtaW5ZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4WSA9IGN5ICsgcmggPiBtYXhZID8gY3kgKyByaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW5YID0gMDtcbiAgICAgICAgICAgIG1heFggPSAwO1xuICAgICAgICAgICAgbWluWSA9IDA7XG4gICAgICAgICAgICBtYXhZID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuYm91bmRzUGFkZGluZztcbiAgICAgICAgdGhpcy5fYm91bmRzLm1pblggPSBtaW5YIC0gcGFkZGluZztcbiAgICAgICAgdGhpcy5fYm91bmRzLm1heFggPSBtYXhYICsgcGFkZGluZztcbiAgICAgICAgdGhpcy5fYm91bmRzLm1pblkgPSBtaW5ZIC0gcGFkZGluZztcbiAgICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSBtYXhZICsgcGFkZGluZztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBwb2ludHMgdXNpbmcgbWF0cml4LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIFBvaW50cyB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUcmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgbWF0cml4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBwb2ludHNbKGkgKiAyKV07XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50c1soaSAqIDIpICsgMV07XG4gICAgICAgICAgICBwb2ludHNbKGkgKiAyKV0gPSAobWF0cml4LmEgKiB4KSArIChtYXRyaXguYyAqIHkpICsgbWF0cml4LnR4O1xuICAgICAgICAgICAgcG9pbnRzWyhpICogMikgKyAxXSA9IChtYXRyaXguYiAqIHgpICsgKG1hdHJpeC5kICogeSkgKyBtYXRyaXgudHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZCBjb2xvcnMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3JzIC0gTGlzdCBvZiBjb2xvcnMgdG8gYWRkIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIC0gQ29sb3IgdG8gYWRkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIC0gQWxwaGEgdG8gdXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBOdW1iZXIgb2YgY29sb3JzIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZENvbG9ycyhjb2xvcnMsIGNvbG9yLCBhbHBoYSwgc2l6ZSkge1xuICAgICAgICAvLyBUT0RPIHVzZSB0aGUgcHJlbXVsdGlwbHkgYml0cyBJdmFuIGFkZGVkXG4gICAgICAgIHZhciByZ2IgPSAoY29sb3IgPj4gMTYpICsgKGNvbG9yICYgMHhmZjAwKSArICgoY29sb3IgJiAweGZmKSA8PCAxNik7XG4gICAgICAgIHZhciByZ2JhID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlUaW50KHJnYiwgYWxwaGEpO1xuICAgICAgICB3aGlsZSAoc2l6ZS0tID4gMCkge1xuICAgICAgICAgICAgY29sb3JzLnB1c2gocmdiYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0dXJlIGlkIHRoYXQgdGhlIHNoYWRlci9mcmFnbWVudCB3YW50cyB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdGV4dHVyZUlkc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICovXG4gICAgYWRkVGV4dHVyZUlkcyh0ZXh0dXJlSWRzLCBpZCwgc2l6ZSkge1xuICAgICAgICB3aGlsZSAoc2l6ZS0tID4gMCkge1xuICAgICAgICAgICAgdGV4dHVyZUlkcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBVVnMgZm9yIGEgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdmVydHMgLSBWZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHV2cyAtIFVWc1xuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gUmVmZXJlbmNlIHRvIFRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBidWZmZXIgc3RhcnQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZS9sZW5ndGggZm9yIGluZGV4IGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBbbWF0cml4XSAtIE9wdGlvbmFsIHRyYW5zZm9ybSBmb3IgYWxsIHBvaW50cy5cbiAgICAgKi9cbiAgICBhZGRVdnModmVydHMsIHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUsIG1hdHJpeCkge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgdXZzU3RhcnQgPSB1dnMubGVuZ3RoO1xuICAgICAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZlcnRzWyhzdGFydCArIGluZGV4KSAqIDJdO1xuICAgICAgICAgICAgdmFyIHkgPSB2ZXJ0c1soKHN0YXJ0ICsgaW5kZXgpICogMikgKyAxXTtcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnggPSAobWF0cml4LmEgKiB4KSArIChtYXRyaXguYyAqIHkpICsgbWF0cml4LnR4O1xuICAgICAgICAgICAgICAgIHkgPSAobWF0cml4LmIgKiB4KSArIChtYXRyaXguZCAqIHkpICsgbWF0cml4LnR5O1xuICAgICAgICAgICAgICAgIHggPSBueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB1dnMucHVzaCh4IC8gZnJhbWUud2lkdGgsIHkgLyBmcmFtZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIGlmIChmcmFtZS53aWR0aCA8IGJhc2VUZXh0dXJlLndpZHRoXG4gICAgICAgICAgICB8fCBmcmFtZS5oZWlnaHQgPCBiYXNlVGV4dHVyZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgdXZzU3RhcnQsIHNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdXZzIGFycmF5IGFjY29yZGluZyB0byBwb3NpdGlvbiBvZiB0ZXh0dXJlIHJlZ2lvblxuICAgICAqIERvZXMgbm90IHdvcmsgd2l0aCByb3RhdGVkIG9yIHRyaW1tZWQgdGV4dHVyZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXZzIGFycmF5XG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgcmVnaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHN0YXJ0aW5nIGluZGV4IGZvciB1dnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBob3cgbWFueSBwb2ludHMgdG8gYWRqdXN0XG4gICAgICovXG4gICAgYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUpIHtcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgdmFyIGVwcyA9IDFlLTY7XG4gICAgICAgIHZhciBmaW5pc2ggPSBzdGFydCArIChzaXplICogMik7XG4gICAgICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgICAgIHZhciBzY2FsZVggPSBmcmFtZS53aWR0aCAvIGJhc2VUZXh0dXJlLndpZHRoO1xuICAgICAgICB2YXIgc2NhbGVZID0gZnJhbWUuaGVpZ2h0IC8gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IGZyYW1lLnggLyBmcmFtZS53aWR0aDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBmcmFtZS55IC8gZnJhbWUud2lkdGg7XG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5mbG9vcih1dnNbc3RhcnRdICsgZXBzKTtcbiAgICAgICAgdmFyIG1pblkgPSBNYXRoLmZsb29yKHV2c1tzdGFydCArIDFdICsgZXBzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMjsgaSA8IGZpbmlzaDsgaSArPSAyKSB7XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgTWF0aC5mbG9vcih1dnNbaV0gKyBlcHMpKTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBNYXRoLmZsb29yKHV2c1tpICsgMV0gKyBlcHMpKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXRYIC09IG1pblg7XG4gICAgICAgIG9mZnNldFkgLT0gbWluWTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gc3RhcnQ7IGkkMSA8IGZpbmlzaDsgaSQxICs9IDIpIHtcbiAgICAgICAgICAgIHV2c1tpJDFdID0gKHV2c1tpJDFdICsgb2Zmc2V0WCkgKiBzY2FsZVg7XG4gICAgICAgICAgICB1dnNbaSQxICsgMV0gPSAodXZzW2kkMSArIDFdICsgb2Zmc2V0WSkgKiBzY2FsZVk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogQnVpbGRzIGEgbGluZSB0byBkcmF3XG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gZ3JhcGhpY3NHZW9tZXRyeSAtIEdlb21ldHJ5IHdoZXJlIHRvIGFwcGVuZCBvdXRwdXRcbiAqL1xuICAgIHN0YXRpYyBidWlsZExpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgICAgIGlmIChncmFwaGljc0RhdGEubGluZVN0eWxlLm5hdGl2ZSkge1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5idWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRMaW5lJDEoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhdyB1c2luZyB0aGUgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUykgbWV0aG9kXG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gZ3JhcGhpY3NHZW9tZXRyeSAtIEdlb21ldHJ5IHdoZXJlIHRvIGFwcGVuZCBvdXRwdXRcbiAqL1xuICAgIHN0YXRpYyBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMgfHwgZ3JhcGhpY3NEYXRhLnNoYXBlLnBvaW50cztcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgICAgICAvLyBzb3J0IGNvbG9yXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAxeCA9IHBvaW50c1soaSAtIDEpICogMl07XG4gICAgICAgICAgICB2YXIgcDF5ID0gcG9pbnRzWygoaSAtIDEpICogMikgKyAxXTtcbiAgICAgICAgICAgIHZhciBwMnggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgdmFyIHAyeSA9IHBvaW50c1soaSAqIDIpICsgMV07XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAxeCwgcDF5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4LCBwMnkpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQrKywgaW5kZXhTdGFydCsrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhdyB1c2luZyB0aGUgcG9seWdvbiBtZXRob2QuXG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gZ3JhcGhpY3NHZW9tZXRyeSAtIEdlb21ldHJ5IHdoZXJlIHRvIGFwcGVuZCBvdXRwdXRcbiAqL1xuICAgIHN0YXRpYyBidWlsZExpbmUkMShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHNoYXBlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cyB8fCBzaGFwZS5wb2ludHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgbGluZSB3aWR0aCBpcyBhbiBvZGQgbnVtYmVyIGFkZCAwLjUgdG8gYWxpZ24gdG8gYSB3aG9sZSBwaXhlbFxuICAgICAgICAvLyBjb21tZW50aW5nIHRoaXMgb3V0IGZpeGVzICM3MTEgYW5kICMxNjIwXG4gICAgICAgIC8vIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoJTIpXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgcG9pbnRzW2ldICs9IDAuNTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICB2YXIgc3R5bGUgPSBncmFwaGljc0RhdGEubGluZVN0eWxlO1xuICAgICAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXG4gICAgICAgIHZhciBmaXJzdFBvaW50ID0gbmV3IFBvaW50XzEuUG9pbnQocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICB2YXIgbGFzdFBvaW50ID0gbmV3IFBvaW50XzEuUG9pbnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHZhciBjbG9zZWRTaGFwZSA9IHNoYXBlLnR5cGUgIT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5QT0xZIHx8IHNoYXBlLmNsb3NlU3Ryb2tlO1xuICAgICAgICB2YXIgY2xvc2VkUGF0aCA9IGZpcnN0UG9pbnQueCA9PT0gbGFzdFBvaW50LnggJiYgZmlyc3RQb2ludC55ID09PSBsYXN0UG9pbnQueTtcbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IHBvaW50IGlzIHRoZSBsYXN0IHBvaW50IC0gZ29ubmEgaGF2ZSBpc3N1ZXMgOilcbiAgICAgICAgaWYgKGNsb3NlZFNoYXBlKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNsb25lIGFzIHdlIGFyZSBnb2luZyB0byBzbGlnaHRseSBtb2RpZnkgdGhlIHNoYXBlLi5cbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5zbGljZSgpO1xuICAgICAgICAgICAgaWYgKGNsb3NlZFBhdGgpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucG9wKCk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGxhc3RQb2ludC5zZXQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWlkUG9pbnRYID0gbGFzdFBvaW50LnggKyAoKGZpcnN0UG9pbnQueCAtIGxhc3RQb2ludC54KSAqIDAuNSk7XG4gICAgICAgICAgICB2YXIgbWlkUG9pbnRZID0gbGFzdFBvaW50LnkgKyAoKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSAqIDAuNSk7XG4gICAgICAgICAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChtaWRQb2ludFgsIG1pZFBvaW50WSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gICAgICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gICAgICAgIC8vIERSQVcgdGhlIExpbmVcbiAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGggLyAyO1xuICAgICAgICAvLyBzb3J0IGNvbG9yXG4gICAgICAgIHZhciBwMXggPSBwb2ludHNbMF07XG4gICAgICAgIHZhciBwMXkgPSBwb2ludHNbMV07XG4gICAgICAgIHZhciBwMnggPSBwb2ludHNbMl07XG4gICAgICAgIHZhciBwMnkgPSBwb2ludHNbM107XG4gICAgICAgIHZhciBwM3ggPSAwO1xuICAgICAgICB2YXIgcDN5ID0gMDtcbiAgICAgICAgdmFyIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgICAgICB2YXIgcGVycHkgPSBwMXggLSBwMng7XG4gICAgICAgIHZhciBwZXJwMnggPSAwO1xuICAgICAgICB2YXIgcGVycDJ5ID0gMDtcbiAgICAgICAgdmFyIHBlcnAzeCA9IDA7XG4gICAgICAgIHZhciBwZXJwM3kgPSAwO1xuICAgICAgICB2YXIgZGlzdCA9IE1hdGguc3FydCgocGVycHggKiBwZXJweCkgKyAocGVycHkgKiBwZXJweSkpO1xuICAgICAgICBwZXJweCAvPSBkaXN0O1xuICAgICAgICBwZXJweSAvPSBkaXN0O1xuICAgICAgICBwZXJweCAqPSB3aWR0aDtcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XG4gICAgICAgIHZhciByYXRpbyA9IHN0eWxlLmFsaWdubWVudDsgLy8gMC41O1xuICAgICAgICB2YXIgcjEgPSAoMSAtIHJhdGlvKSAqIDI7XG4gICAgICAgIHZhciByMiA9IHJhdGlvICogMjtcbiAgICAgICAgLy8gc3RhcnRcbiAgICAgICAgdmVydHMucHVzaChwMXggLSAocGVycHggKiByMSksIHAxeSAtIChwZXJweSAqIHIxKSk7XG4gICAgICAgIHZlcnRzLnB1c2gocDF4ICsgKHBlcnB4ICogcjIpLCBwMXkgKyAocGVycHkgKiByMikpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgcDF4ID0gcG9pbnRzWyhpIC0gMSkgKiAyXTtcbiAgICAgICAgICAgIHAxeSA9IHBvaW50c1soKGkgLSAxKSAqIDIpICsgMV07XG4gICAgICAgICAgICBwMnggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgcDJ5ID0gcG9pbnRzWyhpICogMikgKyAxXTtcbiAgICAgICAgICAgIHAzeCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgICAgICBwM3kgPSBwb2ludHNbKChpICsgMSkgKiAyKSArIDFdO1xuICAgICAgICAgICAgcGVycHggPSAtKHAxeSAtIHAyeSk7XG4gICAgICAgICAgICBwZXJweSA9IHAxeCAtIHAyeDtcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnB4ICogcGVycHgpICsgKHBlcnB5ICogcGVycHkpKTtcbiAgICAgICAgICAgIHBlcnB4IC89IGRpc3Q7XG4gICAgICAgICAgICBwZXJweSAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycHggKj0gd2lkdGg7XG4gICAgICAgICAgICBwZXJweSAqPSB3aWR0aDtcbiAgICAgICAgICAgIHBlcnAyeCA9IC0ocDJ5IC0gcDN5KTtcbiAgICAgICAgICAgIHBlcnAyeSA9IHAyeCAtIHAzeDtcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnAyeCAqIHBlcnAyeCkgKyAocGVycDJ5ICogcGVycDJ5KSk7XG4gICAgICAgICAgICBwZXJwMnggLz0gZGlzdDtcbiAgICAgICAgICAgIHBlcnAyeSAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycDJ4ICo9IHdpZHRoO1xuICAgICAgICAgICAgcGVycDJ5ICo9IHdpZHRoO1xuICAgICAgICAgICAgdmFyIGExID0gKC1wZXJweSArIHAxeSkgLSAoLXBlcnB5ICsgcDJ5KTtcbiAgICAgICAgICAgIHZhciBiMSA9ICgtcGVycHggKyBwMngpIC0gKC1wZXJweCArIHAxeCk7XG4gICAgICAgICAgICB2YXIgYzEgPSAoKC1wZXJweCArIHAxeCkgKiAoLXBlcnB5ICsgcDJ5KSkgLSAoKC1wZXJweCArIHAyeCkgKiAoLXBlcnB5ICsgcDF5KSk7XG4gICAgICAgICAgICB2YXIgYTIgPSAoLXBlcnAyeSArIHAzeSkgLSAoLXBlcnAyeSArIHAyeSk7XG4gICAgICAgICAgICB2YXIgYjIgPSAoLXBlcnAyeCArIHAyeCkgLSAoLXBlcnAyeCArIHAzeCk7XG4gICAgICAgICAgICB2YXIgYzIgPSAoKC1wZXJwMnggKyBwM3gpICogKC1wZXJwMnkgKyBwMnkpKSAtICgoLXBlcnAyeCArIHAyeCkgKiAoLXBlcnAyeSArIHAzeSkpO1xuICAgICAgICAgICAgdmFyIGRlbm9tID0gKGExICogYjIpIC0gKGEyICogYjEpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRlbm9tKSA8IDAuMSkge1xuICAgICAgICAgICAgICAgIGRlbm9tICs9IDEwLjE7XG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAocGVycHggKiByMSksIHAyeSAtIChwZXJweSAqIHIxKSk7XG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyAocGVycHggKiByMiksIHAyeSArIChwZXJweSAqIHIyKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHggPSAoKGIxICogYzIpIC0gKGIyICogYzEpKSAvIGRlbm9tO1xuICAgICAgICAgICAgdmFyIHB5ID0gKChhMiAqIGMxKSAtIChhMSAqIGMyKSkgLyBkZW5vbTtcbiAgICAgICAgICAgIHZhciBwZGlzdCA9ICgocHggLSBwMngpICogKHB4IC0gcDJ4KSkgKyAoKHB5IC0gcDJ5KSAqIChweSAtIHAyeSkpO1xuICAgICAgICAgICAgaWYgKHBkaXN0ID4gKDE5NiAqIHdpZHRoICogd2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgcGVycDN4ID0gcGVycHggLSBwZXJwMng7XG4gICAgICAgICAgICAgICAgcGVycDN5ID0gcGVycHkgLSBwZXJwMnk7XG4gICAgICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocGVycDN4ICogcGVycDN4KSArIChwZXJwM3kgKiBwZXJwM3kpKTtcbiAgICAgICAgICAgICAgICBwZXJwM3ggLz0gZGlzdDtcbiAgICAgICAgICAgICAgICBwZXJwM3kgLz0gZGlzdDtcbiAgICAgICAgICAgICAgICBwZXJwM3ggKj0gd2lkdGg7XG4gICAgICAgICAgICAgICAgcGVycDN5ICo9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gKHBlcnAzeCAqIHIxKSwgcDJ5IC0gKHBlcnAzeSAqIHIxKSk7XG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyAocGVycDN4ICogcjIpLCBwMnkgKyAocGVycDN5ICogcjIpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChwZXJwM3ggKiByMiAqIHIxKSwgcDJ5IC0gKHBlcnAzeSAqIHIxKSk7XG4gICAgICAgICAgICAgICAgaW5kZXhDb3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyAoKHB4IC0gcDJ4KSAqIHIxKSwgcDJ5ICsgKChweSAtIHAyeSkgKiByMSkpO1xuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gKChweCAtIHAyeCkgKiByMiksIHAyeSAtICgocHkgLSBwMnkpICogcjIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwMXggPSBwb2ludHNbKGxlbmd0aCAtIDIpICogMl07XG4gICAgICAgIHAxeSA9IHBvaW50c1soKGxlbmd0aCAtIDIpICogMikgKyAxXTtcbiAgICAgICAgcDJ4ID0gcG9pbnRzWyhsZW5ndGggLSAxKSAqIDJdO1xuICAgICAgICBwMnkgPSBwb2ludHNbKChsZW5ndGggLSAxKSAqIDIpICsgMV07XG4gICAgICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgICAgICBwZXJweSA9IHAxeCAtIHAyeDtcbiAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocGVycHggKiBwZXJweCkgKyAocGVycHkgKiBwZXJweSkpO1xuICAgICAgICBwZXJweCAvPSBkaXN0O1xuICAgICAgICBwZXJweSAvPSBkaXN0O1xuICAgICAgICBwZXJweCAqPSB3aWR0aDtcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XG4gICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gKHBlcnB4ICogcjEpLCBwMnkgLSAocGVycHkgKiByMSkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIChwZXJweCAqIHIyKSwgcDJ5ICsgKHBlcnB5ICogcjIpKTtcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgICAgIC8vIGluZGljZXMucHVzaChpbmRleFN0YXJ0KTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaW5kZXhDb3VudCAtIDI7ICsraSQxKSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCwgaW5kZXhTdGFydCArIDEsIGluZGV4U3RhcnQgKyAyKTtcbiAgICAgICAgICAgIGluZGV4U3RhcnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcbiAgICAgICAgZGltID0gZGltIHx8IDI7XG4gICAgICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCwgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsIG91dGVyTm9kZSA9IEdyYXBoaWNzR2VvbWV0cnkubGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSwgdHJpYW5nbGVzID0gW107XG4gICAgICAgIGlmICghb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldikge1xuICAgICAgICAgICAgcmV0dXJuIHRyaWFuZ2xlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcbiAgICAgICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgICAgICBvdXRlck5vZGUgPSBHcmFwaGljc0dlb21ldHJ5LmVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHNoYXBlIGlzIG5vdCB0b28gc2ltcGxlLCB3ZSdsbCB1c2Ugei1vcmRlciBjdXJ2ZSBoYXNoIGxhdGVyOyBjYWxjdWxhdGUgcG9seWdvbiBiYm94XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgICAgICBtaW5ZID0gbWF4WSA9IGRhdGFbMV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICAgICAgeCA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgICAgICAgICAgICBtYXhZID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICAgICAgaW52U2l6ZSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgICAgICAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDEgLyBpbnZTaXplIDogMDtcbiAgICAgICAgfVxuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dExpbmtlZChvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlcztcbiAgICB9XG4gICAgLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG4gICAgc3RhdGljIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICAgICAgdmFyIGksIGxhc3Q7XG4gICAgICAgIGlmIChjbG9ja3dpc2UgPT09IChHcmFwaGljc0dlb21ldHJ5LnNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSA+IDApKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gR3JhcGhpY3NHZW9tZXRyeS5pbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0pIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gR3JhcGhpY3NHZW9tZXRyeS5pbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdCAmJiBHcmFwaGljc0dlb21ldHJ5LmVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgICAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXN0O1xuICAgIH1cbiAgICAvLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXG4gICAgc3RhdGljIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXSwgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICBsaXN0ID0gR3JhcGhpY3NHZW9tZXRyeS5saW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkge1xuICAgICAgICAgICAgICAgIGxpc3Quc3RlaW5lciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKEdyYXBoaWNzR2VvbWV0cnkuZ2V0TGVmdG1vc3QobGlzdCkpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNvcnQoR3JhcGhpY3NHZW9tZXRyeS5jb21wYXJlWCk7XG4gICAgICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICAgICAgb3V0ZXJOb2RlID0gR3JhcGhpY3NHZW9tZXRyeS5maWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG4gICAgLy8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXG4gICAgc3RhdGljIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzID0gbnVsbCkge1xuICAgICAgICBpZiAoIWVhcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICAgICAgaWYgKCFwYXNzICYmIGludlNpemUpIHtcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9wID0gZWFyLCBwcmV2LCBuZXh0O1xuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICAgICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xuICAgICAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuICAgICAgICAgICAgaWYgKGludlNpemUgPyBHcmFwaGljc0dlb21ldHJ5LmlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBHcmFwaGljc0dlb21ldHJ5LmlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgICAgICAvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKG5leHQuaSAvIGRpbSk7XG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5yZW1vdmVOb2RlKGVhcik7XG4gICAgICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWFyID0gbmV4dDtcbiAgICAgICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXRMaW5rZWQoR3JhcGhpY3NHZW9tZXRyeS5maWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGVhciA9IEdyYXBoaWNzR2VvbWV0cnkuY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhlYXIsIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5zcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSB7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgICAgICBzdW0gKz0gKGRhdGFbal0gLSBkYXRhW2ldKSAqIChkYXRhW2kgKyAxXSArIGRhdGFbaiArIDFdKTtcbiAgICAgICAgICAgIGogPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG4gICAgc3RhdGljIGluc2VydE5vZGUoaSwgeCwgeSwgbGFzdCkge1xuICAgICAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgICAgICBwLm5leHQgPSBwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICAgICAgcC5wcmV2ID0gbGFzdDtcbiAgICAgICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG4gICAgc3RhdGljIGVxdWFscyhwMSwgcDIpIHtcbiAgICAgICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbiAgICB9XG4gICAgc3RhdGljIHJlbW92ZU5vZGUocCkge1xuICAgICAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICAgICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XG4gICAgICAgIGlmIChwLnByZXZaKSB7XG4gICAgICAgICAgICBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocC5uZXh0Wikge1xuICAgICAgICAgICAgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuICAgIHN0YXRpYyBnZXRMZWZ0bW9zdChzdGFydCkge1xuICAgICAgICB2YXIgcCA9IHN0YXJ0LCBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSB7XG4gICAgICAgICAgICAgICAgbGVmdG1vc3QgPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuICAgICAgICByZXR1cm4gbGVmdG1vc3Q7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlWChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnggLSBiLng7XG4gICAgfVxuICAgIC8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuICAgIHN0YXRpYyBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgICAgICBvdXRlck5vZGUgPSBHcmFwaGljc0dlb21ldHJ5LmZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgICAgIGlmIChvdXRlck5vZGUpIHtcbiAgICAgICAgICAgIHZhciBiID0gR3JhcGhpY3NHZW9tZXRyeS5zcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbiAgICBzdGF0aWMgZmlsdGVyUG9pbnRzKHN0YXJ0LCBlbmQgPSBudWxsKSB7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSBzdGFydCwgYWdhaW47XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMocCwgcC5uZXh0KSB8fCBHcmFwaGljc0dlb21ldHJ5LmFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgICAgICBwID0gZW5kID0gcC5wcmV2O1xuICAgICAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgfVxuICAgIC8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbiAgICBzdGF0aWMgYXJlYShwLCBxLCByKSB7XG4gICAgICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbiAgICB9XG4gICAgLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuICAgIC8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuICAgIHN0YXRpYyBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgICAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSwgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSwgYW4gPSBhLm5leHQsIGJwID0gYi5wcmV2O1xuICAgICAgICBhLm5leHQgPSBiO1xuICAgICAgICBiLnByZXYgPSBhO1xuICAgICAgICBhMi5uZXh0ID0gYW47XG4gICAgICAgIGFuLnByZXYgPSBhMjtcbiAgICAgICAgYjIubmV4dCA9IGEyO1xuICAgICAgICBhMi5wcmV2ID0gYjI7XG4gICAgICAgIGJwLm5leHQgPSBiMjtcbiAgICAgICAgYjIucHJldiA9IGJwO1xuICAgICAgICByZXR1cm4gYjI7XG4gICAgfVxuICAgIC8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbiAgICBzdGF0aWMgZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgICAgIHZhciBwID0gb3V0ZXJOb2RlLCBoeCA9IGhvbGUueCwgaHkgPSBob2xlLnksIHF4ID0gLUluZmluaXR5LCBtO1xuICAgICAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoeCA9PT0gcXgpIHtcbiAgICAgICAgICAgIHJldHVybiBtLnByZXY7XG4gICAgICAgIH0gLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcbiAgICAgICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcbiAgICAgICAgdmFyIHN0b3AgPSBtLCBteCA9IG0ueCwgbXkgPSBtLnksIHRhbk1pbiA9IEluZmluaXR5LCB0YW47XG4gICAgICAgIHAgPSBtLm5leHQ7XG4gICAgICAgIHdoaWxlIChwICE9PSBzdG9wKSB7XG4gICAgICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5wb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG4gICAgICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuICAgICAgICAgICAgICAgIGlmICgodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiBwLnggPiBtLngpKSAmJiBHcmFwaGljc0dlb21ldHJ5LmxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cbiAgICBzdGF0aWMgbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBHcmFwaGljc0dlb21ldHJ5LmFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IEdyYXBoaWNzR2VvbWV0cnkuYXJlYShhLCBhLm5leHQsIGIpIDwgMDtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuICAgIHN0YXRpYyBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSAtIChjeCAtIHB4KSAqIChieSAtIHB5KSA+PSAwO1xuICAgIH1cbiAgICAvLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuICAgIHN0YXRpYyBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICAgICAgdmFyIGEgPSBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgR3JhcGhpY3NHZW9tZXRyeS5pc1ZhbGlkRGlhZ29uYWwoYSwgYikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IEdyYXBoaWNzR2VvbWV0cnkuc3BsaXRQb2x5Z29uKGEsIGIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBmaWx0ZXIgY29saW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICAgICAgICAgICAgICBhID0gR3JhcGhpY3NHZW9tZXRyeS5maWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYyA9IEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gYS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxuICAgIHN0YXRpYyBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5uZXh0LmkgIT09IGIuaSAmJiBhLnByZXYuaSAhPT0gYi5pICYmICFHcmFwaGljc0dlb21ldHJ5LmludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmxvY2FsbHlJbnNpZGUoYSwgYikgJiYgR3JhcGhpY3NHZW9tZXRyeS5sb2NhbGx5SW5zaWRlKGIsIGEpICYmIEdyYXBoaWNzR2VvbWV0cnkubWlkZGxlSW5zaWRlKGEsIGIpO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbiAgICBzdGF0aWMgbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICAgICAgdmFyIHAgPSBhLCBpbnNpZGUgPSBmYWxzZSwgcHggPSAoYS54ICsgYi54KSAvIDIsIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfSB3aGlsZSAocCAhPT0gYSk7XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG4gICAgc3RhdGljIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICAgICAgdmFyIHAgPSBhO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5pbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbiAgICBzdGF0aWMgaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgICAgICBpZiAoKEdyYXBoaWNzR2VvbWV0cnkuZXF1YWxzKHAxLCBxMSkgJiYgR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMocDIsIHEyKSkgfHxcbiAgICAgICAgICAgIChHcmFwaGljc0dlb21ldHJ5LmVxdWFscyhwMSwgcTIpICYmIEdyYXBoaWNzR2VvbWV0cnkuZXF1YWxzKHAyLCBxMSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAxLCBxMSwgcDIpID4gMCAhPT0gR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAxLCBxMSwgcTIpID4gMCAmJlxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAyLCBxMiwgcDEpID4gMCAhPT0gR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAyLCBxMiwgcTEpID4gMDtcbiAgICB9XG4gICAgLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbiAgICBzdGF0aWMgY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcbiAgICAgICAgdmFyIHAgPSBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGEgPSBwLnByZXYsIGIgPSBwLm5leHQubmV4dDtcbiAgICAgICAgICAgIGlmICghR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMoYSwgYikgJiYgR3JhcGhpY3NHZW9tZXRyeS5pbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgR3JhcGhpY3NHZW9tZXRyeS5sb2NhbGx5SW5zaWRlKGEsIGIpICYmIEdyYXBoaWNzR2VvbWV0cnkubG9jYWxseUluc2lkZShiLCBhKSkge1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSk7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5yZW1vdmVOb2RlKHAubmV4dCk7XG4gICAgICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAgICAgdmFyIGEgPSBlYXIucHJldiwgYiA9IGVhciwgYyA9IGVhci5uZXh0O1xuICAgICAgICBpZiAoR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEsIGIsIGMpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuICAgICAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxuICAgICAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLCBtaW5UWSA9IGEueSA8IGIueSA/IChhLnkgPCBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA8IGMueSA/IGIueSA6IGMueSksIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSwgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xuICAgICAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xuICAgICAgICB2YXIgbWluWiA9IEdyYXBoaWNzR2VvbWV0cnkuek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgaW52U2l6ZSksIG1heFogPSBHcmFwaGljc0dlb21ldHJ5LnpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICB2YXIgcCA9IGVhci5wcmV2WiwgbiA9IGVhci5uZXh0WjtcbiAgICAgICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXG4gICAgICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLnByZXZaO1xuICAgICAgICAgICAgaWYgKG4gIT09IGVhci5wcmV2ICYmIG4gIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5wb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICAgICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcbiAgICAgICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLnByZXZaO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXG4gICAgICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgICAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBuLngsIG4ueSkgJiZcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gbi5uZXh0WjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG4gICAgc3RhdGljIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICAgICAgeCA9IDMyNzY3ICogKHggLSBtaW5YKSAqIGludlNpemU7XG4gICAgICAgIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgKiBpbnZTaXplO1xuICAgICAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgICAgICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgICAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgICAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuICAgICAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgICAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgICAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgICAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuICAgICAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xuICAgIH1cbiAgICAvLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbiAgICBzdGF0aWMgaXNFYXIoZWFyKSB7XG4gICAgICAgIHZhciBhID0gZWFyLnByZXYsIGIgPSBlYXIsIGMgPSBlYXIubmV4dDtcbiAgICAgICAgaWYgKEdyYXBoaWNzR2VvbWV0cnkuYXJlYShhLCBiLCBjKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcbiAgICAgICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICAgICAgdmFyIHAgPSBlYXIubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgICAgIGlmIChHcmFwaGljc0dlb21ldHJ5LnBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgc3RhdGljIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAgICAgdmFyIHAgPSBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHAueiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHAueiA9IEdyYXBoaWNzR2VvbWV0cnkuek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuICAgICAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICAgICAgcC5wcmV2WiA9IG51bGw7XG4gICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuc29ydExpbmtlZChwKTtcbiAgICB9XG4gICAgLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cbiAgICAvLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuICAgIHN0YXRpYyBzb3J0TGlua2VkKGxpc3QpIHtcbiAgICAgICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLCBpblNpemUgPSAxO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICAgICAgdGFpbCA9IG51bGw7XG4gICAgICAgICAgICBudW1NZXJnZXMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgICAgICBwU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpemUgIT09IDAgJiYgKHFTaXplID09PSAwIHx8ICFxIHx8IHAueiA8PSBxLnopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICAgICAgcFNpemUtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgICAgICB0YWlsID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IHE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWlsLm5leHRaID0gbnVsbDtcbiAgICAgICAgICAgIGluU2l6ZSAqPSAyO1xuICAgICAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIC8qKlxuICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS4gKGhlbHBlciBmdW5jdGlvbi4uKVxuICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICpcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVggLSBPcmlnaW4gcG9pbnQgeFxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21ZIC0gT3JpZ2luIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICogQHBhcmFtIHtudW1iZXJbXX0gW291dD1bXV0gLSBUaGUgb3V0cHV0IGFycmF5IHRvIGFkZCBwb2ludHMgaW50by4gSWYgbm90IHBhc3NlZCwgYSBuZXcgYXJyYXkgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge251bWJlcltdfSBhbiBhcnJheSBvZiBwb2ludHNcbiAqL1xuICAgIHN0YXRpYyBxdWFkcmF0aWNCZXppZXJDdXJ2ZShmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSwgb3V0KSB7XG4gICAgICAgIGlmIChvdXQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSAyMDtcbiAgICAgICAgdmFyIHBvaW50cyA9IG91dDtcbiAgICAgICAgdmFyIHhhID0gMDtcbiAgICAgICAgdmFyIHlhID0gMDtcbiAgICAgICAgdmFyIHhiID0gMDtcbiAgICAgICAgdmFyIHliID0gMDtcbiAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICB2YXIgeSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgICAgIGogPSBpIC8gbjtcbiAgICAgICAgICAgIC8vIFRoZSBHcmVlbiBMaW5lXG4gICAgICAgICAgICB4YSA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0UHQoZnJvbVgsIGNwWCwgaik7XG4gICAgICAgICAgICB5YSA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0UHQoZnJvbVksIGNwWSwgaik7XG4gICAgICAgICAgICB4YiA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0UHQoY3BYLCB0b1gsIGopO1xuICAgICAgICAgICAgeWIgPSBHcmFwaGljc0dlb21ldHJ5LmdldFB0KGNwWSwgdG9ZLCBqKTtcbiAgICAgICAgICAgIC8vIFRoZSBCbGFjayBEb3RcbiAgICAgICAgICAgIHggPSBHcmFwaGljc0dlb21ldHJ5LmdldFB0KHhhLCB4Yiwgaik7XG4gICAgICAgICAgICB5ID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRQdCh5YSwgeWIsIGopO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgLyoqXG4gKiBDYWxjdWxhdGUgYSBzaW5nbGUgcG9pbnQgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS5cbiAqIFV0aWxpdHkgZnVuY3Rpb24gdXNlZCBieSBxdWFkcmF0aWNCZXppZXJDdXJ2ZS5cbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuICpcbiAqIEBpZ25vcmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbjEgLSBmaXJzdCBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuMiAtIHNlY29uZCBudW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwZXJjIC0gcGVyY2VudGFnZVxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgcmVzdWx0XG4gKlxuICovXG4gICAgc3RhdGljIGdldFB0KG4xLCBuMiwgcGVyYykge1xuICAgICAgICB2YXIgZGlmZiA9IG4yIC0gbjE7XG4gICAgICAgIHJldHVybiBuMSArIChkaWZmICogcGVyYyk7XG4gICAgfVxufVxuR3JhcGhpY3NHZW9tZXRyeS5CQVRDSF9QT09MID0gW107XG5HcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MID0gW107XG4vKipcbiogVGhlIG1heGltdW0gbnVtYmVyIG9mIHBvaW50cyB0byBjb25zaWRlciBhbiBvYmplY3QgXCJiYXRjaGFibGVcIixcbiogYWJsZSB0byBiZSBiYXRjaGVkIGJ5IHRoZSByZW5kZXJlcidzIGJhdGNoIHN5c3RlbS5cbipcbiogQG1lbWJlcm9mIFBJWEkuR3JhcGhpY3NHZW9tZXRyeVxuKiBAc3RhdGljXG4qIEBtZW1iZXIge251bWJlcn0gQkFUQ0hBQkxFX1NJWkVcbiogQGRlZmF1bHQgMTAwXG4qL1xuR3JhcGhpY3NHZW9tZXRyeS5CQVRDSEFCTEVfU0laRSA9IDEwMDtcbi8qKlxuKiBCdWlsZHMgYSBwb2x5Z29uIHRvIGRyYXdcbipcbiogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4qXG4qIEBpZ25vcmVcbiogQHByaXZhdGVcbiogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhTmF0aXZlTGluZXMgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSBuYXRpdmVMaW5lc1xuKi9cbkdyYXBoaWNzR2VvbWV0cnkuYnVpbGRQb2x5ID0ge1xuICAgIG5hbWU6IFwiYnVpbGRQb2x5XCIsXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gZ3JhcGhpY3NEYXRhLnNoYXBlLnBvaW50cy5zbGljZSgpO1xuICAgIH0sXG4gICAgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIGhvbGVzID0gZ3JhcGhpY3NEYXRhLmhvbGVzO1xuICAgICAgICB2YXIgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID49IDYpIHtcbiAgICAgICAgICAgIHZhciBob2xlQXJyYXkgPSBbXTtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgaG9sZXMuLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBob2xlID0gaG9sZXNbaV07XG4gICAgICAgICAgICAgICAgaG9sZUFycmF5LnB1c2gocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQoaG9sZS5wb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29ydCBjb2xvclxuICAgICAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0KHBvaW50cywgaG9sZUFycmF5LCAyKTtcbiAgICAgICAgICAgIGlmICghdHJpYW5nbGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSQxICs9IDMpIHtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kkMV0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kkMSArIDFdICsgdmVydFBvcyk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpJDEgKyAyXSArIHZlcnRQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9pbnRzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpJDJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59O1xuLyoqXG4qIEJ1aWxkcyBhIHJlY3RhbmdsZSB0byBkcmF3XG4qXG4qIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuKlxuKiBAaWdub3JlXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YSAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcbiovXG5HcmFwaGljc0dlb21ldHJ5LmJ1aWxkUmVjdGFuZ2xlID0ge1xuICAgIG5hbWU6IFwiYnVpbGRSZWN0YW5nbGVcIixcbiAgICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgICAgIC8vIC0tLSAvL1xuICAgICAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgICB2YXIgeCA9IHJlY3REYXRhLng7XG4gICAgICAgIHZhciB5ID0gcmVjdERhdGEueTtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVjdERhdGEud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgICAgICBwb2ludHMubGVuZ3RoID0gMDtcbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSwgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQpO1xuICAgIH0sXG4gICAgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgICAgICAgdmVydHMucHVzaChwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s2XSwgcG9pbnRzWzddLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgIGdyYXBoaWNzR2VvbWV0cnkuaW5kaWNlcy5wdXNoKHZlcnRQb3MsIHZlcnRQb3MgKyAxLCB2ZXJ0UG9zICsgMiwgdmVydFBvcyArIDEsIHZlcnRQb3MgKyAyLCB2ZXJ0UG9zICsgMyk7XG4gICAgfSxcbn07XG4vKipcbiogQnVpbGRzIGEgcm91bmRlZCByZWN0YW5nbGUgdG8gZHJhd1xuKlxuKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbipcbiogQGlnbm9yZVxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGFOYXRpdmVMaW5lcyAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIG5hdGl2ZUxpbmVzXG4qL1xuR3JhcGhpY3NHZW9tZXRyeS5idWlsZFJvdW5kZWRSZWN0YW5nbGUgPSB7XG4gICAgbmFtZTogXCJidWlsZFJvdW5kZWRSZWN0YW5nbGVcIixcbiAgICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgICAgIHZhciBycmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgICAgICB2YXIgeCA9IHJyZWN0RGF0YS54O1xuICAgICAgICB2YXIgeSA9IHJyZWN0RGF0YS55O1xuICAgICAgICB2YXIgd2lkdGggPSBycmVjdERhdGEud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBycmVjdERhdGEuaGVpZ2h0O1xuICAgICAgICB2YXIgcmFkaXVzID0gcnJlY3REYXRhLnJhZGl1cztcbiAgICAgICAgcG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucXVhZHJhdGljQmV6aWVyQ3VydmUoeCwgeSArIHJhZGl1cywgeCwgeSwgeCArIHJhZGl1cywgeSwgcG9pbnRzKTtcbiAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGggLSByYWRpdXMsIHksIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzLCBwb2ludHMpO1xuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cywgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQsIHBvaW50cyk7XG4gICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHJhZGl1cywgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIHJhZGl1cywgcG9pbnRzKTtcbiAgICAgICAgLy8gdGhpcyB0aW55IG51bWJlciBkZWFscyB3aXRoIHRoZSBpc3N1ZSB0aGF0IG9jY3VycyB3aGVuIHBvaW50cyBvdmVybGFwIGFuZCBlYXJjdXQgZmFpbHMgdG8gdHJpYW5ndWxhdGUgdGhlIGl0ZW0uXG4gICAgICAgIC8vIFRPRE8gLSBmaXggdGhpcyBwcm9wZXJseSwgdGhpcyBpcyBub3QgdmVyeSBlbGVnYW50Li4gYnV0IGl0IHdvcmtzIGZvciBub3cuXG4gICAgfSxcbiAgICB0cmlhbmd1bGF0ZTogZnVuY3Rpb24gdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgICAgICB2YXIgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgICAgIHZhciB2ZWNQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgICAgICB2YXIgdHJpYW5nbGVzID0gR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXQocG9pbnRzLCBudWxsLCAyKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgajsgaSArPSAzKSB7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcbiAgICAgICAgICAgIC8vICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDFdICsgdmVjUG9zKTtcbiAgICAgICAgICAgIC8vICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMl0gKyB2ZWNQb3MpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMl0gKyB2ZWNQb3MpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGokMSA9IHBvaW50cy5sZW5ndGg7IGkkMSA8IGokMTsgaSQxKyspIHtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnRzW2kkMV0sIHBvaW50c1srK2kkMV0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4vKipcbiogQnVpbGRzIGEgY2lyY2xlIHRvIGRyYXdcbipcbiogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4qXG4qIEBpZ25vcmVcbiogQHByaXZhdGVcbiogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIGRyYXdcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YSAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcbiovXG5HcmFwaGljc0dlb21ldHJ5LmJ1aWxkQ2lyY2xlID0ge1xuICAgIG5hbWU6IFwiYnVpbGRDaXJjbGVcIixcbiAgICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gY29udmVydCBwb2ludHMgdG8gYSBuaWNlIHJlZ3VsYXIgZGF0YVxuICAgICAgICB2YXIgY2lyY2xlRGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciB4ID0gY2lyY2xlRGF0YS54O1xuICAgICAgICB2YXIgeSA9IGNpcmNsZURhdGEueTtcbiAgICAgICAgdmFyIHdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0O1xuICAgICAgICBwb2ludHMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gVE9ETyAtIGJpdCBoYWNreT8/XG4gICAgICAgIGlmIChncmFwaGljc0RhdGEudHlwZSA9PT0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkNJUkMpIHtcbiAgICAgICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS5yYWRpdXM7XG4gICAgICAgICAgICBoZWlnaHQgPSBjaXJjbGVEYXRhLnJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS53aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGNpcmNsZURhdGEuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG90YWxTZWdzID0gTWF0aC5mbG9vcigzMCAqIE1hdGguc3FydChjaXJjbGVEYXRhLnJhZGl1cykpXG4gICAgICAgICAgICB8fCBNYXRoLmZsb29yKDE1ICogTWF0aC5zcXJ0KGNpcmNsZURhdGEud2lkdGggKyBjaXJjbGVEYXRhLmhlaWdodCkpO1xuICAgICAgICB0b3RhbFNlZ3MgLz0gMi4zO1xuICAgICAgICB2YXIgc2VnID0gKE1hdGguUEkgKiAyKSAvIHRvdGFsU2VncztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbFNlZ3M7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeCArIChNYXRoLnNpbigtc2VnICogaSkgKiB3aWR0aCksIHkgKyAoTWF0aC5jb3MoLXNlZyAqIGkpICogaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgIH0sXG4gICAgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICAgICAgICB2YXIgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gICAgICAgIHZhciBjZW50ZXIgPSB2ZXJ0UG9zO1xuICAgICAgICB2ZXJ0cy5wdXNoKGdyYXBoaWNzRGF0YS5zaGFwZS54LCBncmFwaGljc0RhdGEuc2hhcGUueSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICAgICAgICAvLyBhZGQgc29tZSB1dnNcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh2ZXJ0UG9zKyssIGNlbnRlciwgdmVydFBvcyk7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbmV4cG9ydHMuR3JhcGhpY3NHZW9tZXRyeSA9IEdyYXBoaWNzR2VvbWV0cnk7XG5jbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihpLCB4LCB5KSB7XG4gICAgICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgICAgICB0aGlzLmkgPSBpO1xuICAgICAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgLy8gcHJldmlvdXMgYW5kIG5leHQgdmVydGV4IG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIC8vIHotb3JkZXIgY3VydmUgdmFsdWVcbiAgICAgICAgdGhpcy56ID0gbnVsbDtcbiAgICAgICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxuICAgICAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0WiA9IG51bGw7XG4gICAgICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jbGFzcyBHcm91cEQ4IHtcbiAgICBzdGF0aWMgdVgoaW5kKSB7XG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xuICAgICAgICByZXR1cm4gR3JvdXBEOC51eFtpbmRdO1xuICAgIH1cbiAgICBzdGF0aWMgdVkoaW5kKSB7XG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xuICAgICAgICByZXR1cm4gR3JvdXBEOC51eVtpbmRdO1xuICAgIH1cbiAgICBzdGF0aWMgdlgoaW5kKSB7XG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xuICAgICAgICByZXR1cm4gR3JvdXBEOC52eFtpbmRdO1xuICAgIH1cbiAgICBzdGF0aWMgdlkoaW5kKSB7XG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xuICAgICAgICByZXR1cm4gR3JvdXBEOC52eVtpbmRdO1xuICAgIH1cbiAgICBzdGF0aWMgaW52KHJvdGF0aW9uKSB7XG4gICAgICAgIGlmIChyb3RhdGlvbiAmIDgpIHtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGlvbiAmIDE1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoLXJvdGF0aW9uKSAmIDc7XG4gICAgfVxuICAgIHN0YXRpYyBhZGQocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpIHtcbiAgICAgICAgR3JvdXBEOC5pbml0KCk7XG4gICAgICAgIHJldHVybiBHcm91cEQ4Lm11bFtyb3RhdGlvblNlY29uZF1bcm90YXRpb25GaXJzdF07XG4gICAgfVxuICAgIHN0YXRpYyBzdWIocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpIHtcbiAgICAgICAgR3JvdXBEOC5pbml0KCk7XG4gICAgICAgIHJldHVybiBHcm91cEQ4Lm11bFtyb3RhdGlvblNlY29uZF1bR3JvdXBEOC5pbnYocm90YXRpb25GaXJzdCldO1xuICAgIH1cbiAgICBzdGF0aWMgcm90YXRlMTgwKHJvdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiByb3RhdGlvbiBeIDQ7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZlcnRpY2FsKHJvdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAocm90YXRpb24gJiAzKSA9PT0gMjtcbiAgICB9XG4gICAgc3RhdGljIGJ5RGlyZWN0aW9uKGR4LCBkeSkge1xuICAgICAgICBHcm91cEQ4LmluaXQoKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGR4KSAqIDIgPD0gTWF0aC5hYnMoZHkpKSB7XG4gICAgICAgICAgICBpZiAoZHkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LlM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5OO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGR5KSAqIDIgPD0gTWF0aC5hYnMoZHgpKSB7XG4gICAgICAgICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBHcm91cEQ4Llc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguU0U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5TVztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBHcm91cEQ4Lk5FO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBHcm91cEQ4Lk5XO1xuICAgIH1cbiAgICBzdGF0aWMgbWF0cml4QXBwZW5kUm90YXRpb25JbnYobWF0cml4LCByb3RhdGlvbiwgdHggPSAwLCB0eSA9IDApIHtcbiAgICAgICAgR3JvdXBEOC5pbml0KCk7XG4gICAgICAgIGxldCBtYXQgPSBHcm91cEQ4LnRlbXBNYXRyaWNlc1tHcm91cEQ4Lmludihyb3RhdGlvbildO1xuICAgICAgICBtYXQudHggPSB0eDtcbiAgICAgICAgbWF0LnR5ID0gdHk7XG4gICAgICAgIG1hdHJpeC5hcHBlbmQobWF0KTtcbiAgICB9XG4gICAgc3RhdGljIHNpZ251bSh4KSB7XG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KCkge1xuICAgICAgICBpZiAoR3JvdXBEOC5pc0luaXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBHcm91cEQ4LmlzSW5pdCA9IHRydWU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgICAgICAgR3JvdXBEOC5tdWwucHVzaChyb3cpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF91eCA9IEdyb3VwRDguc2lnbnVtKChHcm91cEQ4LnV4W2ldICogR3JvdXBEOC51eFtqXSkgKyAoR3JvdXBEOC52eFtpXSAqIEdyb3VwRDgudXlbal0pKTtcbiAgICAgICAgICAgICAgICB2YXIgX3V5ID0gR3JvdXBEOC5zaWdudW0oKEdyb3VwRDgudXlbaV0gKiBHcm91cEQ4LnV4W2pdKSArIChHcm91cEQ4LnZ5W2ldICogR3JvdXBEOC51eVtqXSkpO1xuICAgICAgICAgICAgICAgIHZhciBfdnggPSBHcm91cEQ4LnNpZ251bSgoR3JvdXBEOC51eFtpXSAqIEdyb3VwRDgudnhbal0pICsgKEdyb3VwRDgudnhbaV0gKiBHcm91cEQ4LnZ5W2pdKSk7XG4gICAgICAgICAgICAgICAgdmFyIF92eSA9IEdyb3VwRDguc2lnbnVtKChHcm91cEQ4LnV5W2ldICogR3JvdXBEOC52eFtqXSkgKyAoR3JvdXBEOC52eVtpXSAqIEdyb3VwRDgudnlbal0pKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDE2OyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEdyb3VwRDgudXhba10gPT09IF91eCAmJiBHcm91cEQ4LnV5W2tdID09PSBfdXkgJiYgR3JvdXBEOC52eFtrXSA9PT0gX3Z4ICYmIEdyb3VwRDgudnlba10gPT09IF92eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCAxNjsgaSQxKyspIHtcbiAgICAgICAgICAgIHZhciBtYXQgPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XG4gICAgICAgICAgICBtYXQuc2V0KEdyb3VwRDgudXhbaSQxXSwgR3JvdXBEOC51eVtpJDFdLCBHcm91cEQ4LnZ4W2kkMV0sIEdyb3VwRDgudnlbaSQxXSwgMCwgMCk7XG4gICAgICAgICAgICBHcm91cEQ4LnRlbXBNYXRyaWNlcy5wdXNoKG1hdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Hcm91cEQ4LmlzSW5pdCA9IGZhbHNlO1xuR3JvdXBEOC5FID0gMDtcbkdyb3VwRDguU0UgPSAxO1xuR3JvdXBEOC5TID0gMjtcbkdyb3VwRDguU1cgPSAzO1xuR3JvdXBEOC5XID0gNDtcbkdyb3VwRDguTlcgPSA1O1xuR3JvdXBEOC5OID0gNjtcbkdyb3VwRDguTkUgPSA3O1xuR3JvdXBEOC5NSVJST1JfVkVSVElDQUwgPSA4O1xuR3JvdXBEOC5NSVJST1JfSE9SSVpPTlRBTCA9IDEyO1xuR3JvdXBEOC51eCA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxXTtcbkdyb3VwRDgudXkgPSBbMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV07XG5Hcm91cEQ4LnZ4ID0gWzAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdO1xuR3JvdXBEOC52eSA9IFsxLCAxLCAwLCAtMSwgLTEsIC0xLCAwLCAxLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xXTtcbkdyb3VwRDgudGVtcE1hdHJpY2VzID0gW107XG5Hcm91cEQ4Lm11bCA9IFtdO1xuZXhwb3J0cy5Hcm91cEQ4ID0gR3JvdXBEODtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY2xhc3MgSU9FcnJvckV2ZW50IGV4dGVuZHMgRXZlbnRfMS5FdmVudCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYnViYmxlLCBjYW5jZWxhYmxlKTtcbiAgICAgICAgdGhpcy5lcnJvcklkID0gMDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBJT0Vycm9yRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG4gICAgICAgIGV2ZW50LnRleHQgPSB0aGlzLnRleHQ7XG4gICAgICAgIGV2ZW50LmVycm9ySWQgPSB0aGlzLmVycm9ySWQ7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgZ2V0IGlzRGlzcG9zYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbklPRXJyb3JFdmVudC5JT19FUlJPUiA9IFwiaW9FcnJvclwiO1xuZXhwb3J0cy5JT0Vycm9yRXZlbnQgPSBJT0Vycm9yRXZlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VJbWFnZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CYXNlSW1hZ2VSZXNvdXJjZVwiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jbGFzcyBJbWFnZVJlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIC8vIEJhc2VJbWFnZVJlc291cmNlLmNyb3NzT3JpZ2luKGltYWdlRWxlbWVudCwgc291cmNlLCBvcHRpb25zLmNyb3Nzb3JpZ2luKTtcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSBzb3VyY2U7XG4gICAgICAgICAgICBzb3VyY2UgPSBpbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVVJMIG9mIHRoZSBpbWFnZSBzb3VyY2VcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cmwgPSBzb3VyY2Uuc3JjO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBwcm9jZXNzIGlzIGNvbXBsZXRlZFxuICAgICAgICAgKiBAbWVtYmVyIHtQcm9taXNlPHZvaWQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJvY2VzcyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgaW1hZ2Ugc2hvdWxkIGJlIGRpc3Bvc2VkIGFmdGVyIHVwbG9hZFxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVzZXJ2ZUJpdG1hcCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgY2FwYWJsZSwgY29udmVydCB0aGUgaW1hZ2UgdXNpbmcgY3JlYXRlSW1hZ2VCaXRtYXAgQVBJXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuQ1JFQVRFX0lNQUdFX0JJVE1BUFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVCaXRtYXAgPSBvcHRpb25zLmNyZWF0ZUJpdG1hcCAhPT0gZmFsc2UgJiYgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLkNSRUFURV9JTUFHRV9CSVRNQVAgJiYgISF3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyB0ZXh0dXJlIHByZW11bHRpcGx5QWxwaGEgZmllbGRcbiAgICAgICAgICogQ29waWVzIGZyb20gb3B0aW9uc1xuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufG51bGx9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhICE9PSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBJbWFnZUJpdG1hcCBlbGVtZW50IGNyZWF0ZWQgZm9yIEhUTUxJbWFnZUVsZW1lbnRcbiAgICAgICAgICogQG1lbWJlciB7SW1hZ2VCaXRtYXB9XG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYml0bWFwID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb21pc2Ugd2hlbiBsb2FkaW5nXG4gICAgICAgICAqIEBtZW1iZXIge1Byb21pc2U8dm9pZD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBwcm9taXNlIHdoZW4gaW1hZ2Ugd2lsbCBiZSBsb2FkZWQgYW5kIHByb2Nlc3NlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY3JlYXRlQml0bWFwPXRydWVdIHdoZXRoZXIgcHJvY2VzcyBpbWFnZSBpbnRvIGJpdG1hcFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIGxvYWQoY3JlYXRlQml0bWFwID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChjcmVhdGVCaXRtYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVCaXRtYXAgPSBjcmVhdGVCaXRtYXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJzb3VyY2UgXCIgKyB0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuc291cmNlLnNyYztcbiAgICAgICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHJlZi5zb3VyY2U7XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNyZWF0ZUJpdG1hcCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucHJvY2VzcygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY29tcGxldGUgJiYgc291cmNlLnNyYykge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc291cmNlLm9ubG9hZCA9IGNvbXBsZXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgKiBDYWxsZWQgd2hlbiB3ZSBuZWVkIHRvIGNvbnZlcnQgaW1hZ2UgaW50byBCaXRtYXBJbWFnZS5cbiAgICAqIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHJlYWwgcHJvbWlzZSBpcyBjYWNoZWQgaW5zaWRlLlxuICAgICpcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBjYWNoZWQgcHJvbWlzZSB0byBmaWxsIHRoYXQgYml0bWFwXG4gICAgKi9cbiAgICBwcm9jZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvY2VzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYml0bWFwICE9PSBudWxsIHx8ICF3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2VzcyA9IHdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcCh0aGlzLnNvdXJjZSwgMCwgMCwgdGhpcy5zb3VyY2Uud2lkdGgsIHRoaXMuc291cmNlLmhlaWdodClcbiAgICAgICAgICAgIC50aGVuKChiaXRtYXApID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoMCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICogVXBsb2FkIHRoZSBpbWFnZSByZXNvdXJjZSB0byBHUFUuXG4gICAgKlxuICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFJlbmRlcmVyIHRvIHVwbG9hZCB0b1xuICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIEJhc2VUZXh0dXJlIGZvciB0aGlzIHJlc291cmNlXG4gICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmUgLSBHTFRleHR1cmUgdG8gdXNlXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAgKi9cbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICAgICAgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IHRoaXMucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgLy8gcmV2ZWFsKHRoaXMuYml0bWFwKVxuICAgICAgICBpZiAoIXRoaXMuY3JlYXRlQml0bWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYml0bWFwKSB7XG4gICAgICAgICAgICAvLyB5ZWFoLCBpZ25vcmUgdGhlIG91dHB1dFxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYml0bWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExvZ2dlcl8xLnRyYWNlKFwidXBsb2FkaW5nXCIpO1xuICAgICAgICBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHRoaXMuYml0bWFwKTtcbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlQml0bWFwKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgaWYgdGhlcmUgYXJlIG90aGVyIHJlbmRlcmVycyB0aGF0IHBvc3NpYmx5IG5lZWQgdGhpcyBiaXRtYXBcbiAgICAgICAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlclRleCA9IGJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyVGV4ICE9PSBnbFRleHR1cmUgJiYgb3RoZXJUZXguZGlydHlJZCAhPT0gYmFzZVRleHR1cmUuZGlydHlJZCkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYml0bWFwLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKFwiYml0bWFwIGZsYWdnZWRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5iaXRtYXAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICAqIEBvdmVycmlkZVxuICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5iaXRtYXApIHtcbiAgICAgICAgICAgIHRoaXMuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmJpdG1hcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkltYWdlUmVzb3VyY2UgPSBJbWFnZVJlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XG5jbGFzcyBJbnRlcmFjdGlvbkRhdGEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmdsb2JhbCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idXR0b24gPSAwO1xuICAgICAgICB0aGlzLmJ1dHRvbnMgPSAwO1xuICAgICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLnRpbHRYID0gMDtcbiAgICAgICAgdGhpcy50aWx0WSA9IDA7XG4gICAgICAgIHRoaXMucG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXNzdXJlID0gMDtcbiAgICAgICAgdGhpcy5yb3RhdGlvbkFuZ2xlID0gMDtcbiAgICAgICAgdGhpcy50d2lzdCA9IDA7XG4gICAgICAgIHRoaXMudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcbiAgICAgICAgdGhpcy53aGljaCA9IDA7XG4gICAgfVxuICAgIGdldExvY2FsUG9zaXRpb24oZGlzcGxheU9iamVjdCwgcG9pbnQgPSBudWxsLCBnbG9iYWxQb3MgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShnbG9iYWxQb3MgfHwgdGhpcy5nbG9iYWwsIHBvaW50KTtcbiAgICB9XG4gICAgO1xuICAgIGNvcHlFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idXR0b24gPSBldmVudC5idXR0b247XG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IE51bWJlci5pc0ludGVnZXIoZXZlbnQuYnV0dG9ucykgPyBldmVudC5idXR0b25zIDogZXZlbnQud2hpY2g7XG4gICAgICAgIHRoaXMud2lkdGggPSBldmVudC53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBldmVudC5oZWlnaHQ7XG4gICAgICAgIHRoaXMudGlsdFggPSBldmVudC50aWx0WDtcbiAgICAgICAgdGhpcy50aWx0WSA9IGV2ZW50LnRpbHRZO1xuICAgICAgICB0aGlzLnBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICAgIHRoaXMucHJlc3N1cmUgPSBldmVudC5wcmVzc3VyZTtcbiAgICAgICAgdGhpcy5yb3RhdGlvbkFuZ2xlID0gZXZlbnQucm90YXRpb25BbmdsZTtcbiAgICAgICAgdGhpcy50d2lzdCA9IGV2ZW50LnR3aXN0IHx8IDA7XG4gICAgICAgIHRoaXMudGFuZ2VudGlhbFByZXNzdXJlID0gZXZlbnQudGFuZ2VudGlhbFByZXNzdXJlIHx8IDA7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgcG9pbnRlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZGVudGlmaWVyO1xuICAgIH1cbiAgICA7XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuaXNQcmltYXJ5ID0gZmFsc2U7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuSW50ZXJhY3Rpb25EYXRhID0gSW50ZXJhY3Rpb25EYXRhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jbGFzcyBJbnRlcmFjdGlvbkV2ZW50IGV4dGVuZHMgRXZlbnRfMS5FdmVudCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYnViYmxlLCBjYW5jZWxhYmxlKTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuSW50ZXJhY3Rpb25FdmVudCA9IEludGVyYWN0aW9uRXZlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEludGVyYWN0aW9uRGF0YV8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25EYXRhXCIpO1xuY29uc3QgSW50ZXJhY3Rpb25FdmVudF8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25FdmVudFwiKTtcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuL01vdXNlRXZlbnRcIik7XG5jb25zdCBJbnRlcmFjdGlvblRyYWNraW5nRGF0YV8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25UcmFja2luZ0RhdGFcIik7XG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcbmNsYXNzIEludGVyYWN0aW9uTWFuYWdlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy51cGRhdGUgPSAoZGVsdGFUaW1lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kZWx0YVRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbHRhVGltZSA8IHRoaXMuaW50ZXJhY3Rpb25GcmVxdWVuY3kpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9kZWx0YVRpbWUgPSAwO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmRpZE1vdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpZE1vdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKGxldCBrIGluIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uRGF0YS5vcmlnaW5hbEV2ZW50ICYmIGludGVyYWN0aW9uRGF0YS5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgaW50ZXJhY3Rpb25EYXRhLm9yaWdpbmFsRXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yTW9kZSh0aGlzLmN1cnNvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUG9pbnRlckNvbXBsZXRlKGV2ZW50LCBmYWxzZSwgdGhpcy5wcm9jZXNzUG9pbnRlclVwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJDYW5jZWwgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUG9pbnRlckNvbXBsZXRlKGV2ZW50LCB0cnVlLCB0aGlzLnByb2Nlc3NQb2ludGVyQ2FuY2VsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJPdmVyID0gKG9yaWdpbmFsRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBldmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEob3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbMF07XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5nZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZU92ZXJSZW5kZXJlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09WRVIpO1xuICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJykge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX09WRVIpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlck91dCA9IChvcmlnaW5hbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzWzBdO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZU92ZXJSZW5kZXJlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yTW9kZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25FdmVudCA9IHRoaXMuY29uZmlndXJlSW50ZXJhY3Rpb25FdmVudEZvckRPTUV2ZW50KHRoaXMuZXZlbnREYXRhLCBldmVudCwgaW50ZXJhY3Rpb25EYXRhKTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YS5vcmlnaW5hbEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0LCBmYWxzZSk7XG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09VVCk7XG4gICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfT1VUKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlSW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGludGVyYWN0aW9uRGF0YS5pZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJEb3duID0gKG9yaWdpbmFsRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgb3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBldmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEob3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvUHJldmVudERlZmF1bHQgJiYgZXZlbnQuaXNOb3JtYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbmNlbGFibGUgPSBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgfHwgISgnY2FuY2VsYWJsZScgaW4gb3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBldmVudExlbiA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25FdmVudCA9IHRoaXMuY29uZmlndXJlSW50ZXJhY3Rpb25FdmVudEZvckRPTUV2ZW50KHRoaXMuZXZlbnREYXRhLCBldmVudCwgaW50ZXJhY3Rpb25EYXRhKTtcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTik7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfU1RBUlQpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1JpZ2h0QnV0dG9uID0gZXZlbnQuYnV0dG9uID09PSAyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUklHSFRfTU9VU0VfRE9XTiA6IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX0RPV04pO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IChvcmlnaW5hbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgaWYgKGV2ZW50c1swXS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudHNbMF0ucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWRNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXZlbnRMZW4gPSBldmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XG4gICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGl2ZSA9IGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnID8gdGhpcy5tb3ZlV2hlbkluc2lkZSA6IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NQb2ludGVyTW92ZSwgaW50ZXJhY3RpdmUpO1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSk7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfTU9WRSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX01PVkUpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnRzWzBdLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3JNb2RlKHRoaXMuY3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlckRvd24gPSAoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgaGl0KSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGxldCBpZCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIGlmICghZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSA9IG5ldyBJbnRlcmFjdGlvblRyYWNraW5nRGF0YV8xLkludGVyYWN0aW9uVHJhY2tpbmdEYXRhKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9TVEFSVCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNSaWdodEJ1dHRvbiA9IGRhdGEuYnV0dG9uID09PSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodEJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdLnJpZ2h0RG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF0ubGVmdERvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGlzUmlnaHRCdXR0b24gPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9ET1dOIDogTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfRE9XTik7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJVcCA9IChpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBoaXQpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhO1xuICAgICAgICAgICAgbGV0IGlkID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhLmlkZW50aWZpZXI7XG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdEYXRhID0gZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xuICAgICAgICAgICAgbGV0IGlzVG91Y2ggPSBkYXRhLnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xuICAgICAgICAgICAgbGV0IGlzTW91c2UgPSAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJyk7XG4gICAgICAgICAgICBsZXQgaXNNb3VzZVRhcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzTW91c2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNSaWdodEJ1dHRvbiA9IGRhdGEuYnV0dG9uID09PSAyO1xuICAgICAgICAgICAgICAgIGxldCBmbGFncyA9IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhXzEuSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1M7XG4gICAgICAgICAgICAgICAgbGV0IHRlc3QgPSBpc1JpZ2h0QnV0dG9uID8gZmxhZ3MuUklHSFRfRE9XTiA6IGZsYWdzLkxFRlRfRE9XTjtcbiAgICAgICAgICAgICAgICBsZXQgaXNEb3duID0gdHJhY2tpbmdEYXRhICE9PSB1bmRlZmluZWQgJiYgKHRyYWNraW5nRGF0YS5mbGFncyAmIHRlc3QpO1xuICAgICAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoaXNSaWdodEJ1dHRvbiA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQIDogTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfVVApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGlzUmlnaHRCdXR0b24gPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9DTElDSyA6IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LkNMSUNLKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc01vdXNlVGFwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoaXNSaWdodEJ1dHRvbiA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQX09VVFNJREUgOiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9VUF9PVVRTSURFKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0QnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEucmlnaHREb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEubGVmdERvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9FTkQpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vdXNlIHx8IGlzTW91c2VUYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVEFQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX1RBUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhLm92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNraW5nRGF0YSkge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVBfT1VUU0lERSk7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfRU5EX09VVFNJREUpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNraW5nRGF0YSAmJiB0cmFja2luZ0RhdGEubm9uZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJNb3ZlID0gKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGE7XG4gICAgICAgICAgICBsZXQgaXNUb3VjaCA9IGRhdGEucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gICAgICAgICAgICBsZXQgaXNNb3VzZSA9IChkYXRhLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGRhdGEucG9pbnRlclR5cGUgPT09ICdwZW4nKTtcbiAgICAgICAgICAgIGlmIChpc01vdXNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlck92ZXJPdXQoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgaGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5tb3ZlV2hlbkluc2lkZSB8fCBoaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX01PVkUpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX01PVkUpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc01vdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX01PVkUpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dCA9IChpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBoaXQpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhO1xuICAgICAgICAgICAgbGV0IGlkID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhLmlkZW50aWZpZXI7XG4gICAgICAgICAgICBsZXQgaXNNb3VzZSA9IChkYXRhLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGRhdGEucG9pbnRlclR5cGUgPT09ICdwZW4nKTtcbiAgICAgICAgICAgIGxldCB0cmFja2luZ0RhdGEgPSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF07XG4gICAgICAgICAgICBpZiAoaGl0ICYmICF0cmFja2luZ0RhdGEpIHtcbiAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEgPSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF0gPSBuZXcgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGFfMS5JbnRlcmFjdGlvblRyYWNraW5nRGF0YShpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGl0ICYmIHRoaXMubW91c2VPdmVyUmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYWNraW5nRGF0YS5vdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YS5vdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVkVSKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfT1ZFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc01vdXNlICYmIHRoaXMuY3Vyc29yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gZGlzcGxheU9iamVjdC5jdXJzb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2tpbmdEYXRhLm92ZXIpIHtcbiAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEub3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1VUKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9PVVQpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0RhdGEubm9uZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oaXRUZXN0RXZlbnQgPSBuZXcgSW50ZXJhY3Rpb25FdmVudF8xLkludGVyYWN0aW9uRXZlbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMuaGl0VGVzdEV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5hdXRvUHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gMTA7XG4gICAgICAgIHRoaXMubW91c2UgPSBuZXcgSW50ZXJhY3Rpb25EYXRhXzEuSW50ZXJhY3Rpb25EYXRhKCk7XG4gICAgICAgIHRoaXMubW91c2UuaWRlbnRpZmllciA9IEludGVyYWN0aW9uTWFuYWdlci5NT1VTRV9QT0lOVEVSX0lEO1xuICAgICAgICB0aGlzLm1vdXNlLmdsb2JhbC5zZXQoLTk5OTk5OSk7XG4gICAgICAgIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhID0ge307XG4gICAgICAgIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW0ludGVyYWN0aW9uTWFuYWdlci5NT1VTRV9QT0lOVEVSX0lEXSA9IHRoaXMubW91c2U7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25EYXRhUG9vbCA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50RGF0YSA9IG5ldyBJbnRlcmFjdGlvbkV2ZW50XzEuSW50ZXJhY3Rpb25FdmVudChcImludGVyYWN0aW9uXCIpO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMubW92ZVdoZW5JbnNpZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudHNBZGRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlT3ZlclJlbmRlcmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcbiAgICAgICAgdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgPSAhIXdpbmRvd1snUG9pbnRlckV2ZW50J107XG4gICAgICAgIHRoaXMuY3Vyc29yU3R5bGVzID0ge1xuICAgICAgICAgICAgZGVmYXVsdDogJ2luaGVyaXQnLFxuICAgICAgICAgICAgcG9pbnRlcjogJ3BvaW50ZXInXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3VycmVudEN1cnNvck1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RlbXBQb2ludCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudCh0aGlzLnJlbmRlcmVyLnZpZXcsIHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbik7XG4gICAgfVxuICAgIHNldFRhcmdldEVsZW1lbnQoZWxlbWVudCwgcmVzb2x1dGlvbiA9IDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudHMoKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmFkZEV2ZW50cygpO1xuICAgIH1cbiAgICA7XG4gICAgcmVtb3ZlRXZlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVGlja2VyXzEuVGlja2VyLnN5c3RlbS5yZW1vdmUodGhpcy51cGRhdGUpO1xuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLWNvbnRlbnQtem9vbWluZyddID0gJyc7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLXRvdWNoLWFjdGlvbiddID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyd0b3VjaC1hY3Rpb24nXSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIHRoaXMub25Qb2ludGVyT3V0KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgdGhpcy5vblBvaW50ZXJPdmVyKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5vblBvaW50ZXJDYW5jZWwpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm9uUG9pbnRlck91dCk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uUG9pbnRlck92ZXIpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblBvaW50ZXJEb3duKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5vblBvaW50ZXJDYW5jZWwpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uUG9pbnRlclVwKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmV2ZW50c0FkZGVkID0gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICBtYXBQb3NpdGlvblRvUG9pbnQocG9pbnQsIHgsIHkpIHtcbiAgICAgICAgbGV0IHJlY3Q7XG4gICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgcmVjdCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxLjAgLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHBvaW50LnggPSAoKHggLSByZWN0LmxlZnQpICogKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LndpZHRoIC8gcmVjdC53aWR0aCkpICogcmVzb2x1dGlvbk11bHRpcGxpZXI7XG4gICAgICAgIHBvaW50LnkgPSAoKHkgLSByZWN0LnRvcCkgKiAodGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpKSAqIHJlc29sdXRpb25NdWx0aXBsaWVyO1xuICAgIH1cbiAgICA7XG4gICAgY29uZmlndXJlSW50ZXJhY3Rpb25FdmVudEZvckRPTUV2ZW50KGludGVyYWN0aW9uRXZlbnQsIHBvaW50ZXJFdmVudCwgaW50ZXJhY3Rpb25EYXRhKSB7XG4gICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgdGhpcy5tYXBQb3NpdGlvblRvUG9pbnQoaW50ZXJhY3Rpb25EYXRhLmdsb2JhbCwgcG9pbnRlckV2ZW50LmNsaWVudFgsIHBvaW50ZXJFdmVudC5jbGllbnRZKTtcbiAgICAgICAgaWYgKHBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50Lmdsb2JhbFggPSBpbnRlcmFjdGlvbkRhdGEuZ2xvYmFsLng7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnQuZ2xvYmFsWSA9IGludGVyYWN0aW9uRGF0YS5nbG9iYWwueTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlcmFjdGlvbkRhdGEub3JpZ2luYWxFdmVudCA9IHBvaW50ZXJFdmVudDtcbiAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5yZXNldCgpO1xuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25FdmVudDtcbiAgICB9XG4gICAgO1xuICAgIGFkZEV2ZW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFRpY2tlcl8xLlRpY2tlci5zeXN0ZW0uYWRkKHRoaXMudXBkYXRlLCB0aGlzLCBUaWNrZXJfMS5UaWNrZXIuVVBEQVRFX1BSSU9SSVRZLklOVEVSQUNUSU9OKTtcbiAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJy1tcy1jb250ZW50LXpvb21pbmcnXSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyd0b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMub25Qb2ludGVyRG93bik7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybGVhdmUnLCB0aGlzLm9uUG9pbnRlck91dCk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyb3ZlcicsIHRoaXMub25Qb2ludGVyT3Zlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMub25Qb2ludGVyQ2FuY2VsKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5vblBvaW50ZXJPdXQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vblBvaW50ZXJPdmVyKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Qb2ludGVyRG93bik7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Qb2ludGVyQ2FuY2VsKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRzQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgcHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGZ1bmMsIGhpdFRlc3QsIGludGVyYWN0aXZlID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QgfHwgIWRpc3BsYXlPYmplY3QudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwb2ludCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5nbG9iYWw7XG4gICAgICAgIGludGVyYWN0aXZlID0gZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZSB8fCBpbnRlcmFjdGl2ZTtcbiAgICAgICAgbGV0IGhpdCA9IGZhbHNlO1xuICAgICAgICBsZXQgaW50ZXJhY3RpdmVQYXJlbnQgPSBpbnRlcmFjdGl2ZTtcbiAgICAgICAgbGV0IGhpdFRlc3RDaGlsZHJlbiA9IHRydWU7XG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmhpdEFyZWEpIHtcbiAgICAgICAgICAgIGlmIChoaXRUZXN0KSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIHRoaXMuX3RlbXBQb2ludCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0LmhpdEFyZWEuY29udGFpbnModGhpcy5fdGVtcFBvaW50LngsIHRoaXMuX3RlbXBQb2ludC55KSkge1xuICAgICAgICAgICAgICAgICAgICBoaXRUZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhpdFRlc3RDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcmFjdGl2ZVBhcmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpc3BsYXlPYmplY3QuX21hc2spIHtcbiAgICAgICAgICAgIGlmIChoaXRUZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZGlzcGxheU9iamVjdC5fbWFzay5jb250YWluc1BvaW50ICYmIGRpc3BsYXlPYmplY3QuX21hc2suY29udGFpbnNQb2ludChwb2ludCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpdFRlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaGl0VGVzdENoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0IGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoaGl0VGVzdENoaWxkcmVuICYmIGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmVDaGlsZHJlbiAmJiBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZEhpdCA9IHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIGNoaWxkLCBmdW5jLCBoaXRUZXN0LCBpbnRlcmFjdGl2ZVBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEhpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlUGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRIaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25FdmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0VGVzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGhpdFRlc3QgJiYgIWludGVyYWN0aW9uRXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0LmhpdEFyZWEgJiYgZGlzcGxheU9iamVjdC5jb250YWluc1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGl0ICYmICFpbnRlcmFjdGlvbkV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LnRhcmdldCA9IGRpc3BsYXlPYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgISFoaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGl0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0Q3Vyc29yTW9kZShtb2RlID0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEN1cnNvck1vZGUgPT09IG1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRDdXJzb3JNb2RlID0gbW9kZTtcbiAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5jdXJzb3JTdHlsZXNbbW9kZV07XG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2Ygc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgICAgICBzdHlsZShtb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmN1cnNvclN0eWxlcywgbW9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9IG1vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIGhpdFRlc3QoZ2xvYmFsUG9pbnQsIHJvb3QpIHtcbiAgICAgICAgdGhpcy5oaXRUZXN0RXZlbnQudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaXRUZXN0RXZlbnQuZGF0YS5nbG9iYWwgPSBnbG9iYWxQb2ludDtcbiAgICAgICAgbGV0IGN1cnJlbnRkaXNwbGF5O1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgY3VycmVudGRpc3BsYXkgPSByb290O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3VycmVudGRpc3BsYXkgPSB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUodGhpcy5oaXRUZXN0RXZlbnQsIGN1cnJlbnRkaXNwbGF5LCBudWxsLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGl0VGVzdEV2ZW50LnRhcmdldDtcbiAgICB9XG4gICAgO1xuICAgIG5vcm1hbGl6ZVRvUG9pbnRlckRhdGEoZXZlbnQpIHtcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRFdmVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsaSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSA8IGxpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmJ1dHRvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2guYnV0dG9uID0gZXZlbnQudG91Y2hlcy5sZW5ndGggPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC5idXR0b25zID0gZXZlbnQudG91Y2hlcy5sZW5ndGggPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5pc1ByaW1hcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLmlzUHJpbWFyeSA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gud2lkdGggPSB0b3VjaC5yYWRpdXNYIHx8IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2guaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC5oZWlnaHQgPSB0b3VjaC5yYWRpdXNZIHx8IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnRpbHRYID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50aWx0WSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gudGlsdFkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJUeXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC5wb2ludGVyVHlwZSA9ICd0b3VjaCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gucG9pbnRlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC5wb2ludGVySWQgPSB0b3VjaC5pZGVudGlmaWVyIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gucHJlc3N1cmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnByZXNzdXJlID0gdG91Y2guZm9yY2UgfHwgMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnR3aXN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC50d2lzdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC50YW5nZW50aWFsUHJlc3N1cmUgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmxheWVyWCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gubGF5ZXJYID0gdG91Y2gub2Zmc2V0WCA9IHRvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gubGF5ZXJZID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC5sYXllclkgPSB0b3VjaC5vZmZzZXRZID0gdG91Y2guY2xpZW50WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdG91Y2guaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2godG91Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQgJiYgKCF0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyB8fCAhKGV2ZW50IGluc3RhbmNlb2Ygd2luZG93WydQb2ludGVyRXZlbnQnXSkpKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luZXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQuaXNQcmltYXJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LmlzUHJpbWFyeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LndpZHRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LndpZHRoID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQuaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LmhlaWdodCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnRpbHRYID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnRpbHRYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQudGlsdFkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQudGlsdFkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC5wb2ludGVyVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC5wb2ludGVyVHlwZSA9ICdtb3VzZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnBvaW50ZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC5wb2ludGVySWQgPSBJbnRlcmFjdGlvbk1hbmFnZXIuTU9VU0VfUE9JTlRFUl9JRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQucHJlc3N1cmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQucHJlc3N1cmUgPSAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnR3aXN0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnR3aXN0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcmlnaW5ldmVudC5pc05vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRFdmVudHM7XG4gICAgfVxuICAgIDtcbiAgICBnZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpIHtcbiAgICAgICAgbGV0IHBvaW50ZXJJZCA9IGV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgaWYgKHBvaW50ZXJJZCA9PT0gSW50ZXJhY3Rpb25NYW5hZ2VyLk1PVVNFX1BPSU5URVJfSUQgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YSA9IHRoaXMubW91c2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXSkge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YSA9IHRoaXMuaW50ZXJhY3Rpb25EYXRhUG9vbC5wb3AoKSB8fCBuZXcgSW50ZXJhY3Rpb25EYXRhXzEuSW50ZXJhY3Rpb25EYXRhKCk7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEuaWRlbnRpZmllciA9IHBvaW50ZXJJZDtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF0gPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJhY3Rpb25EYXRhLmNvcHlFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiBpbnRlcmFjdGlvbkRhdGE7XG4gICAgfVxuICAgIDtcbiAgICBvblBvaW50ZXJDb21wbGV0ZShvcmlnaW5hbEV2ZW50LCBjYW5jZWxsZWQsIGZ1bmMpIHtcbiAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgbGV0IGV2ZW50TGVuID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgbGV0IGV2ZW50QXBwZW5kID0gb3JpZ2luYWxFdmVudC50YXJnZXQgIT09IHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID8gJ291dHNpZGUnIDogJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRMZW47IGkrKykge1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCBmdW5jLCBjYW5jZWxsZWQgfHwgIWV2ZW50QXBwZW5kKTtcbiAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGNhbmNlbGxlZCA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfQ0FOQ0VMIDogKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVApKTtcbiAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNSaWdodEJ1dHRvbiA9IGV2ZW50LmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQKSA6IChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9VUCkpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGNhbmNlbGxlZCA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX0NBTkNFTCA6IChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9FTkQpKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZUludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICByZWxlYXNlSW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKHBvaW50ZXJJZCkge1xuICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXTtcbiAgICAgICAgaWYgKGludGVyYWN0aW9uRGF0YSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF07XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25EYXRhUG9vbC5wdXNoKGludGVyYWN0aW9uRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIHByb2Nlc3NQb2ludGVyQ2FuY2VsKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGE7XG4gICAgICAgIGxldCBpZCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5pZGVudGlmaWVyO1xuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF07XG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0NBTkNFTCk7XG4gICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgaWYgKGRhdGEucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9DQU5DRUwpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5ldmVudERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMub25Qb2ludGVyRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJEb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJVcCA9IG51bGw7XG4gICAgICAgIHRoaXMub25Qb2ludGVyQ2FuY2VsID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlckNhbmNlbCA9IG51bGw7XG4gICAgICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJNb3ZlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJPdXQgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dCA9IG51bGw7XG4gICAgICAgIHRoaXMub25Qb2ludGVyT3ZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RlbXBQb2ludCA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbkludGVyYWN0aW9uTWFuYWdlci5NT1VTRV9QT0lOVEVSX0lEID0gMTtcbmV4cG9ydHMuSW50ZXJhY3Rpb25NYW5hZ2VyID0gSW50ZXJhY3Rpb25NYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBJbnRlcmFjdGlvblRyYWNraW5nRGF0YSB7XG4gICAgY29uc3RydWN0b3IocG9pbnRlcklkKSB7XG4gICAgICAgIHRoaXMuX3BvaW50ZXJJZCA9IHBvaW50ZXJJZDtcbiAgICAgICAgdGhpcy5fZmxhZ3MgPSBJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5OT05FO1xuICAgIH1cbiAgICBfZG9TZXQoZmxhZywgeW4pIHtcbiAgICAgICAgaWYgKHluKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzIHwgZmxhZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgJiAofmZsYWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXQgcG9pbnRlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcklkO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IGZsYWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxhZ3M7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZmxhZ3MoZmxhZ3MpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgO1xuICAgIGdldCBub25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxhZ3MgPT09IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLk5PTkU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgb3ZlcigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLk9WRVIpICE9PSAwO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IG92ZXIoeW4pIHtcbiAgICAgICAgdGhpcy5fZG9TZXQoSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1MuT1ZFUiwgeW4pO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHJpZ2h0RG93bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLlJJR0hUX0RPV04pICE9PSAwO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHJpZ2h0RG93bih5bikge1xuICAgICAgICB0aGlzLl9kb1NldChJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5SSUdIVF9ET1dOLCB5bik7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgbGVmdERvd24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiBJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5MRUZUX0RPV04pICE9PSAwO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGxlZnREb3duKHluKSB7XG4gICAgICAgIHRoaXMuX2RvU2V0KEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLkxFRlRfRE9XTiwgeW4pO1xuICAgIH1cbiAgICA7XG59XG5JbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUyA9IHtcbiAgICBOT05FOiAwLFxuICAgIE9WRVI6IDEgPDwgMCxcbiAgICBMRUZUX0RPV046IDEgPDwgMSxcbiAgICBSSUdIVF9ET1dOOiAxIDw8IDIsXG59O1xuZXhwb3J0cy5JbnRlcmFjdGlvblRyYWNraW5nRGF0YSA9IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGaWxsU3R5bGVfMSA9IHJlcXVpcmUoXCIuL0ZpbGxTdHlsZVwiKTtcbmNsYXNzIExpbmVTdHlsZSBleHRlbmRzIEZpbGxTdHlsZV8xLkZpbGxTdHlsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICB2YXIgb2JqID0gbmV3IExpbmVTdHlsZSgpO1xuICAgICAgICBvYmouY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgICBvYmouYWxwaGEgPSB0aGlzLmFscGhhO1xuICAgICAgICBvYmoudGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcbiAgICAgICAgb2JqLm1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgICAgICBvYmoudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICAgICAgb2JqLndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgICAgb2JqLmFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50O1xuICAgICAgICBvYmoubmF0aXZlID0gdGhpcy5uYXRpdmU7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgbGluZSBzdHlsZSB0byBkZWZhdWx0LlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICBzdXBlci5yZXNldCgpO1xuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGxpbmUgc3R5bGUgY29sb3JcbiAgICAgICAgdGhpcy5jb2xvciA9IDB4MDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCAodGhpY2tuZXNzKSBvZiBhbnkgbGluZXMgZHJhd24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IG9mIGFueSBsaW5lcyBkcmF3biAoMC41ID0gbWlkZGxlLCAxID0gb3V0dGVyLCAwID0gaW5uZXIpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxpZ25tZW50ID0gMC41O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSB0aGUgbGluZXMgd2lsbCBiZSBkcmF3IHVzaW5nIExJTkVTIGluc3RlYWQgb2YgVFJJQU5HTEVfU1RSSVBcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmF0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuTGluZVN0eWxlID0gTGluZVN0eWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9VVFBVVF9UT19DT05TT0xFID0gdHJ1ZTtcbmV4cG9ydHMudHJhY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwic2hvdzogbnVsbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwic2hvdzogMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwic2hvdzogXCIgKyB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvcnRzLk9VVFBVVF9UT19DT05TT0xFKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbmV4cG9ydHMucmV2ZWFsTWV0aG9kcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcInJldmVhbCBtZXRob2RzOiBudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJyZXZlYWwgbWV0aG9kczogXCI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VJdGVtID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUl0ZW0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWV0aG9kOiAnICsga2V5ICsgJyA6ICcgKyB2YWx1ZVtrZXldICsgXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLnJldmVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwicmV2ZWFsOiBudWxsXCI7XG4gICAgICAgIGlmIChleHBvcnRzLk9VVFBVVF9UT19DT05TT0xFKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwicmV2ZWFsOiB1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKGV4cG9ydHMuT1VUUFVUX1RPX0NPTlNPTEUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gXCJyZXZlYWw6IFwiO1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgaW5zdGFuY2VJdGVtID0gZ2V0VmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmIChpbnN0YW5jZUl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUl0ZW0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWV0aG9kOiAnICsga2V5ICsgXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBrZXkgKyAnIDogJyArIGluc3RhbmNlSXRlbSArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChleHBvcnRzLk9VVFBVVF9UT19DT05TT0xFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgZ2V0VmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciB2YWx1ZVJlc3VsdCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFsdWVSZXN1bHQgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVSZXN1bHQ7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNvbnN0IFNwcml0ZU1hc2tGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL1Nwcml0ZU1hc2tGaWx0ZXJcIik7XG5jbGFzcyBNYXNrU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgICAgIC8vIFRPRE8gLSB3ZSBkb24ndCBuZWVkIGJvdGghXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgdHJ1ZWAgaWYgY3VycmVudCBwdXNoZWQgbWFza2VkIGlzIHNjaXNzb3JcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaXNzb3IgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hc2sgZGF0YVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Npc3NvckRhdGEgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFyZ2V0IHRvIG1hc2tcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2Npc3NvclJlbmRlclRhcmdldCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmFibGUgc2Npc3NvclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5hYmxlU2Npc3NvciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9vbCBvZiB1c2VkIHNwcml0ZSBtYXNrIGZpbHRlcnNcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TcHJpdGVNYXNrRmlsdGVyW119XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbHBoYU1hc2tQb29sID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IGluZGV4IG9mIGFscGhhIG1hc2sgcG9vbFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFscGhhTWFza0luZGV4ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gRGlzcGxheSBPYmplY3QgdG8gcHVzaCB0aGUgbWFzayB0b1xuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV8UElYSS5HcmFwaGljc30gbWFza0RhdGEgLSBUaGUgbWFza2luZyBkYXRhLlxuICAgICAqL1xuICAgIHB1c2godGFyZ2V0LCBtYXNrRGF0YSkge1xuICAgICAgICAvLyBUT0RPIHRoZSByb290IGNoZWNrIG1lYW5zIHNjaXNzb3IgcmVjdCB3aWxsIG5vdFxuICAgICAgICAvLyBiZSB1c2VkIG9uIHJlbmRlciB0ZXh0dXJlcyBtb3JlIGluZm8gaGVyZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL3B1bGwvMzU0NVxuICAgICAgICBpZiAobWFza0RhdGEuaXNTcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbmFibGVTY2lzc29yXG4gICAgICAgICAgICAmJiAhdGhpcy5zY2lzc29yXG4gICAgICAgICAgICAmJiB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQucm9vdFxuICAgICAgICAgICAgJiYgIXRoaXMucmVuZGVyZXIuc3RlbmNpbC5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aFxuICAgICAgICAgICAgJiYgbWFza0RhdGEuaXNGYXN0UmVjdCgpKSB7XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gbWFza0RhdGEud29ybGRUcmFuc2Zvcm07XG4gICAgICAgICAgICB2YXIgcm90ID0gTWF0aC5hdGFuMihtYXRyaXguYiwgbWF0cml4LmEpO1xuICAgICAgICAgICAgLy8gdXNlIHRoZSBuZWFyZXN0IGRlZ3JlZSFcbiAgICAgICAgICAgIHJvdCA9IE1hdGgucm91bmQocm90ICogKDE4MCAvIE1hdGguUEkpKTtcbiAgICAgICAgICAgIGlmIChyb3QgJSA5MCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaFN0ZW5jaWxNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNjaXNzb3JNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXNoU3RlbmNpbE1hc2sobWFza0RhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IG1hc2sgZnJvbSB0aGUgbWFzayBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gRGlzcGxheSBPYmplY3QgdG8gcG9wIHRoZSBtYXNrIGZyb21cbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfFBJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cbiAgICAgKi9cbiAgICBwb3AodGFyZ2V0LCBtYXNrRGF0YSkge1xuICAgICAgICBpZiAobWFza0RhdGEuaXNTcHJpdGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9wU3ByaXRlTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmVuYWJsZVNjaXNzb3IgJiYgIXRoaXMucmVuZGVyZXIuc3RlbmNpbC5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wb3BTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9wU3RlbmNpbE1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHB1c2ggdGhlIHNwcml0ZSBtYXNrIHRvXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gbWFza0RhdGEgLSBTcHJpdGUgdG8gYmUgdXNlZCBhcyB0aGUgbWFza1xuICAgICAqL1xuICAgIHB1c2hTcHJpdGVNYXNrKHRhcmdldCwgbWFza0RhdGEpIHtcbiAgICAgICAgdmFyIGFscGhhTWFza0ZpbHRlciA9IHRoaXMuYWxwaGFNYXNrUG9vbFt0aGlzLmFscGhhTWFza0luZGV4XTtcbiAgICAgICAgaWYgKCFhbHBoYU1hc2tGaWx0ZXIpIHtcbiAgICAgICAgICAgIGFscGhhTWFza0ZpbHRlciA9IHRoaXMuYWxwaGFNYXNrUG9vbFt0aGlzLmFscGhhTWFza0luZGV4XSA9IFtuZXcgU3ByaXRlTWFza0ZpbHRlcl8xLlNwcml0ZU1hc2tGaWx0ZXIobWFza0RhdGEpXTtcbiAgICAgICAgfVxuICAgICAgICBhbHBoYU1hc2tGaWx0ZXJbMF0ucmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgYWxwaGFNYXNrRmlsdGVyWzBdLm1hc2tTcHJpdGUgPSBtYXNrRGF0YTtcbiAgICAgICAgdmFyIHN0YXNoRmlsdGVyQXJlYSA9IHRhcmdldC5maWx0ZXJBcmVhO1xuICAgICAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IG1hc2tEYXRhLmdldEJvdW5kcyh0cnVlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5maWx0ZXIucHVzaCh0YXJnZXQsIGFscGhhTWFza0ZpbHRlcik7XG4gICAgICAgIHRhcmdldC5maWx0ZXJBcmVhID0gc3Rhc2hGaWx0ZXJBcmVhO1xuICAgICAgICB0aGlzLmFscGhhTWFza0luZGV4Kys7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0LlxuICAgICAqXG4gICAgICovXG4gICAgcG9wU3ByaXRlTWFzayhhLCBiKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xuICAgICAgICB0aGlzLmFscGhhTWFza0luZGV4LS07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV8UElYSS5HcmFwaGljc30gbWFza0RhdGEgLSBUaGUgbWFza2luZyBkYXRhLlxuICAgICAqL1xuICAgIHB1c2hTdGVuY2lsTWFzayhtYXNrRGF0YSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5wdXNoU3RlbmNpbChtYXNrRGF0YSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0LlxuICAgICAqXG4gICAgICovXG4gICAgcG9wU3RlbmNpbE1hc2soYSwgYikge1xuICAgICAgICAvLyB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJlci5zdG9wKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5wb3BTdGVuY2lsKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwdXNoIHRoZSBtYXNrIHRvXG4gICAgICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzfSBtYXNrRGF0YSAtIFRoZSBtYXNraW5nIGRhdGEuXG4gICAgICovXG4gICAgcHVzaFNjaXNzb3JNYXNrKHRhcmdldCwgbWFza0RhdGEpIHtcbiAgICAgICAgbWFza0RhdGEucmVuZGVyYWJsZSA9IHRydWU7XG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQ7XG4gICAgICAgIHZhciBib3VuZHMgPSBtYXNrRGF0YS5nZXRCb3VuZHMoKTtcbiAgICAgICAgYm91bmRzLmZpdChyZW5kZXJUYXJnZXQuc2l6ZSk7XG4gICAgICAgIG1hc2tEYXRhLnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbC5lbmFibGUodGhpcy5yZW5kZXJlci5nbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbC5zY2lzc29yKGJvdW5kcy54ICogcmVzb2x1dGlvbiwgKHJlbmRlclRhcmdldC5yb290ID8gcmVuZGVyVGFyZ2V0LnNpemUuaGVpZ2h0IC0gYm91bmRzLnkgLSBib3VuZHMuaGVpZ2h0IDogYm91bmRzLnkpICogcmVzb2x1dGlvbiwgYm91bmRzLndpZHRoICogcmVzb2x1dGlvbiwgYm91bmRzLmhlaWdodCAqIHJlc29sdXRpb24pO1xuICAgICAgICB0aGlzLnNjaXNzb3JSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG4gICAgICAgIHRoaXMuc2Npc3NvckRhdGEgPSBtYXNrRGF0YTtcbiAgICAgICAgdGhpcy5zY2lzc29yID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFBvcCBzY2lzc29yIG1hc2tcbiAgICAgKlxuICAgICAqL1xuICAgIHBvcFNjaXNzb3JNYXNrKGEsIGIpIHtcbiAgICAgICAgdGhpcy5zY2lzc29yUmVuZGVyVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY2lzc29yRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Npc3NvciA9IGZhbHNlO1xuICAgICAgICAvLyBtdXN0IGJlIHNjaXNzb3IhXG4gICAgICAgIHZhciByZWYgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5NYXNrU3lzdGVtID0gTWFza1N5c3RlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTWF0aFNldHRpbmdzIHtcbiAgICBzdGF0aWMgdWlkKCkge1xuICAgICAgICByZXR1cm4gKytNYXRoU2V0dGluZ3MubmV4dFVpZDtcbiAgICB9XG4gICAgc3RhdGljIHNpZ24obikge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4gPCAwID8gLTEgOiAxO1xuICAgIH1cbiAgICBzdGF0aWMgc3RyaW5nMmhleChzdHJpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICYmIHN0cmluZ1swXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDE2KTtcbiAgICB9XG4gICAgc3RhdGljIGhleDJzdHJpbmcoaGV4KSB7XG4gICAgICAgIGhleCA9IGhleC50b1N0cmluZygxNik7XG4gICAgICAgIGhleCA9ICcwMDAwMDAnLnN1YnN0cigwLCA2IC0gaGV4Lmxlbmd0aCkgKyBoZXg7XG4gICAgICAgIHJldHVybiAoXCIjXCIgKyBoZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgbG9nMih2KSB7XG4gICAgICAgIHZhciByID0gKHYgPiAweEZGRkYpIDw8IDQ7XG4gICAgICAgIHYgPj4+PSByO1xuICAgICAgICB2YXIgc2hpZnQgPSAodiA+IDB4RkYpIDw8IDM7XG4gICAgICAgIHYgPj4+PSBzaGlmdDtcbiAgICAgICAgciB8PSBzaGlmdDtcbiAgICAgICAgc2hpZnQgPSAodiA+IDB4RikgPDwgMjtcbiAgICAgICAgdiA+Pj49IHNoaWZ0O1xuICAgICAgICByIHw9IHNoaWZ0O1xuICAgICAgICBzaGlmdCA9ICh2ID4gMHgzKSA8PCAxO1xuICAgICAgICB2ID4+Pj0gc2hpZnQ7XG4gICAgICAgIHIgfD0gc2hpZnQ7XG4gICAgICAgIHJldHVybiByIHwgKHYgPj4gMSk7XG4gICAgfVxuICAgIHN0YXRpYyBuZXh0UG93Mih2KSB7XG4gICAgICAgIHYgKz0gdiA9PT0gMDtcbiAgICAgICAgLS12O1xuICAgICAgICB2IHw9IHYgPj4+IDE7XG4gICAgICAgIHYgfD0gdiA+Pj4gMjtcbiAgICAgICAgdiB8PSB2ID4+PiA0O1xuICAgICAgICB2IHw9IHYgPj4+IDg7XG4gICAgICAgIHYgfD0gdiA+Pj4gMTY7XG4gICAgICAgIHJldHVybiB2ICsgMTtcbiAgICB9XG4gICAgc3RhdGljIGlzUG93Mih2KSB7XG4gICAgICAgIHJldHVybiAhKHYgJiAodiAtIDEpKSAmJiAoISF2KTtcbiAgICB9XG59XG5NYXRoU2V0dGluZ3MubmV4dFVpZCA9IDA7XG5NYXRoU2V0dGluZ3MuUElfMiA9IE1hdGguUEkgKiAyO1xuTWF0aFNldHRpbmdzLlJBRF9UT19ERUcgPSAxODAgLyBNYXRoLlBJO1xuTWF0aFNldHRpbmdzLkRFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xuZXhwb3J0cy5NYXRoU2V0dGluZ3MgPSBNYXRoU2V0dGluZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY2xhc3MgTWF0cml4IHtcbiAgICBjb25zdHJ1Y3RvcihhID0gMSwgYiA9IDAsIGMgPSAwLCBkID0gMSwgdHggPSAwLCB0eSA9IDApIHtcbiAgICAgICAgaWYgKGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYyA9IGM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZCA9IGQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHggPSB0eDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eSA9IHR5O1xuICAgICAgICB0aGlzLmFycmF5ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYSA9IGFycmF5WzBdXG4gICAgICogYiA9IGFycmF5WzFdXG4gICAgICogYyA9IGFycmF5WzNdXG4gICAgICogZCA9IGFycmF5WzRdXG4gICAgICogdHggPSBhcnJheVsyXVxuICAgICAqIHR5ID0gYXJyYXlbNV1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIGFycmF5IHRoYXQgdGhlIG1hdHJpeCB3aWxsIGJlIHBvcHVsYXRlZCBmcm9tLlxuICAgICAqL1xuICAgIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICB0aGlzLmEgPSBhcnJheVswXTtcbiAgICAgICAgdGhpcy5iID0gYXJyYXlbMV07XG4gICAgICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgICAgICB0aGlzLmQgPSBhcnJheVs0XTtcbiAgICAgICAgdGhpcy50eCA9IGFycmF5WzJdO1xuICAgICAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBtYXRyaXggcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGEgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGQgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR4IC0gTWF0cml4IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAtIE1hdHJpeCBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHNldChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5jID0gYztcbiAgICAgICAgdGhpcy5kID0gZDtcbiAgICAgICAgdGhpcy50eCA9IHR4O1xuICAgICAgICB0aGlzLnR5ID0gdHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBmcm9tIHRoZSBjdXJyZW50IE1hdHJpeCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYW5zcG9zZSAtIFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW291dD1uZXcgRmxvYXQzMkFycmF5KDkpXSAtIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGJlIGFzc2lnbmVkIHRvIG91dFxuICAgICAqIEByZXR1cm4ge251bWJlcltdfSB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheSB3aGljaCBjb250YWlucyB0aGUgbWF0cml4XG4gICAgICovXG4gICAgdG9BcnJheSh0cmFuc3Bvc2UsIG91dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyYXkgPSBvdXQgfHwgdGhpcy5hcnJheTtcbiAgICAgICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICAgICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgICAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgICAgICAgIGFycmF5WzNdID0gdGhpcy5jO1xuICAgICAgICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgICAgICBhcnJheVs1XSA9IDA7XG4gICAgICAgICAgICBhcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICAgICAgICBhcnJheVs3XSA9IHRoaXMudHk7XG4gICAgICAgICAgICBhcnJheVs4XSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgICAgICAgIGFycmF5WzFdID0gdGhpcy5jO1xuICAgICAgICAgICAgYXJyYXlbMl0gPSB0aGlzLnR4O1xuICAgICAgICAgICAgYXJyYXlbM10gPSB0aGlzLmI7XG4gICAgICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcbiAgICAgICAgICAgIGFycmF5WzVdID0gdGhpcy50eTtcbiAgICAgICAgICAgIGFycmF5WzZdID0gMDtcbiAgICAgICAgICAgIGFycmF5WzddID0gMDtcbiAgICAgICAgICAgIGFycmF5WzhdID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXQgYSBuZXcgcG9zaXRpb24gd2l0aCB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkLlxuICAgICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIHJlbmRlcmluZylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9zIC0gVGhlIG9yaWdpblxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAgICogQHJldHVybiB7UElYSS5Qb2ludH0gVGhlIG5ldyBwb2ludCwgdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgICAqL1xuICAgIGFwcGx5KHBvcywgbmV3UG9zKSB7XG4gICAgICAgIG5ld1BvcyA9IG5ld1BvcyB8fCBuZXcgUG9pbnRfMS5Qb2ludCgpO1xuICAgICAgICB2YXIgeCA9IHBvcy54O1xuICAgICAgICB2YXIgeSA9IHBvcy55O1xuICAgICAgICBuZXdQb3MueCA9ICh0aGlzLmEgKiB4KSArICh0aGlzLmMgKiB5KSArIHRoaXMudHg7XG4gICAgICAgIG5ld1Bvcy55ID0gKHRoaXMuYiAqIHgpICsgKHRoaXMuZCAqIHkpICsgdGhpcy50eTtcbiAgICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBpbnZlcnNlIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgd29ybGQgY29vcmRpbmF0ZSBzcGFjZSB0byBhIGNoaWxkJ3MgY29vcmRpbmF0ZSBzcGFjZS4gKGUuZy4gaW5wdXQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvcyAtIFRoZSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFtuZXdQb3NdIC0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IFRoZSBuZXcgcG9pbnQsIGludmVyc2UtdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgICAqL1xuICAgIGFwcGx5SW52ZXJzZShwb3MsIG5ld1Bvcykge1xuICAgICAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50XzEuUG9pbnQoKTtcbiAgICAgICAgdmFyIGlkID0gMSAvICgodGhpcy5hICogdGhpcy5kKSArICh0aGlzLmMgKiAtdGhpcy5iKSk7XG4gICAgICAgIHZhciB4ID0gcG9zLng7XG4gICAgICAgIHZhciB5ID0gcG9zLnk7XG4gICAgICAgIG5ld1Bvcy54ID0gKHRoaXMuZCAqIGlkICogeCkgKyAoLXRoaXMuYyAqIGlkICogeSkgKyAoKCh0aGlzLnR5ICogdGhpcy5jKSAtICh0aGlzLnR4ICogdGhpcy5kKSkgKiBpZCk7XG4gICAgICAgIG5ld1Bvcy55ID0gKHRoaXMuYSAqIGlkICogeSkgKyAoLXRoaXMuYiAqIGlkICogeCkgKyAoKCgtdGhpcy50eSAqIHRoaXMuYSkgKyAodGhpcy50eCAqIHRoaXMuYikpICogaWQpO1xuICAgICAgICByZXR1cm4gbmV3UG9zO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggSG93IG11Y2ggdG8gdHJhbnNsYXRlIHggYnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeSBieVxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICAgIHRoaXMudHggKz0geDtcbiAgICAgICAgdGhpcy50eSArPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBzY2FsZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgYW1vdW50IHRvIHNjYWxlIHZlcnRpY2FsbHlcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cbiAgICBzY2FsZSh4LCB5KSB7XG4gICAgICAgIHRoaXMuYSAqPSB4O1xuICAgICAgICB0aGlzLmQgKj0geTtcbiAgICAgICAgdGhpcy5jICo9IHg7XG4gICAgICAgIHRoaXMuYiAqPSB5O1xuICAgICAgICB0aGlzLnR4ICo9IHg7XG4gICAgICAgIHRoaXMudHkgKj0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHJvdGF0ZShhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBjMSA9IHRoaXMuYztcbiAgICAgICAgdmFyIHR4MSA9IHRoaXMudHg7XG4gICAgICAgIHRoaXMuYSA9IChhMSAqIGNvcykgLSAodGhpcy5iICogc2luKTtcbiAgICAgICAgdGhpcy5iID0gKGExICogc2luKSArICh0aGlzLmIgKiBjb3MpO1xuICAgICAgICB0aGlzLmMgPSAoYzEgKiBjb3MpIC0gKHRoaXMuZCAqIHNpbik7XG4gICAgICAgIHRoaXMuZCA9IChjMSAqIHNpbikgKyAodGhpcy5kICogY29zKTtcbiAgICAgICAgdGhpcy50eCA9ICh0eDEgKiBjb3MpIC0gKHRoaXMudHkgKiBzaW4pO1xuICAgICAgICB0aGlzLnR5ID0gKHR4MSAqIHNpbikgKyAodGhpcy50eSAqIGNvcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBlbmQuXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgYXBwZW5kKG1hdHJpeCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLmQ7XG4gICAgICAgIHRoaXMuYSA9IChtYXRyaXguYSAqIGExKSArIChtYXRyaXguYiAqIGMxKTtcbiAgICAgICAgdGhpcy5iID0gKG1hdHJpeC5hICogYjEpICsgKG1hdHJpeC5iICogZDEpO1xuICAgICAgICB0aGlzLmMgPSAobWF0cml4LmMgKiBhMSkgKyAobWF0cml4LmQgKiBjMSk7XG4gICAgICAgIHRoaXMuZCA9IChtYXRyaXguYyAqIGIxKSArIChtYXRyaXguZCAqIGQxKTtcbiAgICAgICAgdGhpcy50eCA9IChtYXRyaXgudHggKiBhMSkgKyAobWF0cml4LnR5ICogYzEpICsgdGhpcy50eDtcbiAgICAgICAgdGhpcy50eSA9IChtYXRyaXgudHggKiBiMSkgKyAobWF0cml4LnR5ICogZDEpICsgdGhpcy50eTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXRyaXggYmFzZWQgb24gYWxsIHRoZSBhdmFpbGFibGUgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBQb3NpdGlvbiBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBQb3NpdGlvbiBvbiB0aGUgeSBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpdm90WCAtIFBpdm90IG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl2b3RZIC0gUGl2b3Qgb24gdGhlIHkgYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBTY2FsZSBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWSAtIFNjYWxlIG9uIHRoZSB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gLSBSb3RhdGlvbiBpbiByYWRpYW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNrZXdYIC0gU2tldyBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNrZXdZIC0gU2tldyBvbiB0aGUgeSBheGlzXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgc2V0VHJhbnNmb3JtKHgsIHksIHBpdm90WCwgcGl2b3RZLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSkge1xuICAgICAgICB0aGlzLmEgPSBNYXRoLmNvcyhyb3RhdGlvbiArIHNrZXdZKSAqIHNjYWxlWDtcbiAgICAgICAgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgICAgIHRoaXMuYyA9IC1NYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcbiAgICAgICAgdGhpcy5kID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG4gICAgICAgIHRoaXMudHggPSB4IC0gKChwaXZvdFggKiB0aGlzLmEpICsgKHBpdm90WSAqIHRoaXMuYykpO1xuICAgICAgICB0aGlzLnR5ID0geSAtICgocGl2b3RYICogdGhpcy5iKSArIChwaXZvdFkgKiB0aGlzLmQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBwcmVwZW5kXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgcHJlcGVuZChtYXRyaXgpIHtcbiAgICAgICAgdmFyIHR4MSA9IHRoaXMudHg7XG4gICAgICAgIGlmIChtYXRyaXguYSAhPT0gMSB8fCBtYXRyaXguYiAhPT0gMCB8fCBtYXRyaXguYyAhPT0gMCB8fCBtYXRyaXguZCAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGExID0gdGhpcy5hO1xuICAgICAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICAgICAgdGhpcy5hID0gKGExICogbWF0cml4LmEpICsgKHRoaXMuYiAqIG1hdHJpeC5jKTtcbiAgICAgICAgICAgIHRoaXMuYiA9IChhMSAqIG1hdHJpeC5iKSArICh0aGlzLmIgKiBtYXRyaXguZCk7XG4gICAgICAgICAgICB0aGlzLmMgPSAoYzEgKiBtYXRyaXguYSkgKyAodGhpcy5kICogbWF0cml4LmMpO1xuICAgICAgICAgICAgdGhpcy5kID0gKGMxICogbWF0cml4LmIpICsgKHRoaXMuZCAqIG1hdHJpeC5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR4ID0gKHR4MSAqIG1hdHJpeC5hKSArICh0aGlzLnR5ICogbWF0cml4LmMpICsgbWF0cml4LnR4O1xuICAgICAgICB0aGlzLnR5ID0gKHR4MSAqIG1hdHJpeC5iKSArICh0aGlzLnR5ICogbWF0cml4LmQpICsgbWF0cml4LnR5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlY29tcG9zZXMgdGhlIG1hdHJpeCAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIGFuZCByb3RhdGlvbikgYW5kIHNldHMgdGhlIHByb3BlcnRpZXMgb24gdG8gYSB0cmFuc2Zvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gLSBUaGUgdHJhbnNmb3JtIHRvIGFwcGx5IHRoZSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVHJhbnNmb3JtfSBUaGUgdHJhbnNmb3JtIHdpdGggdGhlIG5ld2x5IGFwcGxpZWQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGRlY29tcG9zZSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgLy8gc29ydCBvdXQgcm90YXRpb24gLyBza2V3Li5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiID0gdGhpcy5iO1xuICAgICAgICB2YXIgYyA9IHRoaXMuYztcbiAgICAgICAgdmFyIGQgPSB0aGlzLmQ7XG4gICAgICAgIHZhciBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcbiAgICAgICAgdmFyIHNrZXdZID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoc2tld1ggKyBza2V3WSk7XG4gICAgICAgIGlmIChkZWx0YSA8IDAuMDAwMDEgfHwgTWF0aC5hYnMoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLlBJXzIgLSBkZWx0YSkgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSBza2V3WTtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5za2V3LnggPSB0cmFuc2Zvcm0uc2tldy55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy54ID0gc2tld1g7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy55ID0gc2tld1k7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmV4dCBzZXQgc2NhbGVcbiAgICAgICAgdHJhbnNmb3JtLnNjYWxlLnggPSBNYXRoLnNxcnQoKGEgKiBhKSArIChiICogYikpO1xuICAgICAgICB0cmFuc2Zvcm0uc2NhbGUueSA9IE1hdGguc3FydCgoYyAqIGMpICsgKGQgKiBkKSk7XG4gICAgICAgIC8vIG5leHQgc2V0IHBvc2l0aW9uXG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdGhpcy50eDtcbiAgICAgICAgdHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB0aGlzLnR5O1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSW52ZXJ0cyB0aGlzIG1hdHJpeFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLmQ7XG4gICAgICAgIHZhciB0eDEgPSB0aGlzLnR4O1xuICAgICAgICB2YXIgbiA9IChhMSAqIGQxKSAtIChiMSAqIGMxKTtcbiAgICAgICAgdGhpcy5hID0gZDEgLyBuO1xuICAgICAgICB0aGlzLmIgPSAtYjEgLyBuO1xuICAgICAgICB0aGlzLmMgPSAtYzEgLyBuO1xuICAgICAgICB0aGlzLmQgPSBhMSAvIG47XG4gICAgICAgIHRoaXMudHggPSAoKGMxICogdGhpcy50eSkgLSAoZDEgKiB0eDEpKSAvIG47XG4gICAgICAgIHRoaXMudHkgPSAtKChhMSAqIHRoaXMudHkpIC0gKGIxICogdHgxKSkgLyBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGlzIE1hdHJpeCB0byBhbiBpZGVudGl0eSAoZGVmYXVsdCkgbWF0cml4LlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgaWRlbnRpdHkoKSB7XG4gICAgICAgIHRoaXMuYSA9IDE7XG4gICAgICAgIHRoaXMuYiA9IDA7XG4gICAgICAgIHRoaXMuYyA9IDA7XG4gICAgICAgIHRoaXMuZCA9IDE7XG4gICAgICAgIHRoaXMudHggPSAwO1xuICAgICAgICB0aGlzLnR5ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gQSBjb3B5IG9mIHRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgICAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICAgICAgbWF0cml4LmMgPSB0aGlzLmM7XG4gICAgICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgICAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgICAgICBtYXRyaXgudHkgPSB0aGlzLnR5O1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gdGhpcyBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gY29weSB0by5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hdHJpeCBnaXZlbiBpbiBwYXJhbWV0ZXIgd2l0aCBpdHMgdmFsdWVzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgY29weVRvKG1hdHJpeCkge1xuICAgICAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICAgICAgbWF0cml4LmIgPSB0aGlzLmI7XG4gICAgICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgICAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICAgICAgbWF0cml4LnR4ID0gdGhpcy50eDtcbiAgICAgICAgbWF0cml4LnR5ID0gdGhpcy50eTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlcyBvZiB0aGUgbWF0cml4IHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBvbmVzIGluIGdpdmVuIG1hdHJpeFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IGZyb20uXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBjb3B5RnJvbShtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5hID0gbWF0cml4LmE7XG4gICAgICAgIHRoaXMuYiA9IG1hdHJpeC5iO1xuICAgICAgICB0aGlzLmMgPSBtYXRyaXguYztcbiAgICAgICAgdGhpcy5kID0gbWF0cml4LmQ7XG4gICAgICAgIHRoaXMudHggPSBtYXRyaXgudHg7XG4gICAgICAgIHRoaXMudHkgPSBtYXRyaXgudHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IChpZGVudGl0eSkgbWF0cml4XG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0XG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBJREVOVElUWSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEEgdGVtcCBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRFTVBfTUFUUklYKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLk1hdHJpeCA9IE1hdHJpeDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBTdGF0ZV8xID0gcmVxdWlyZShcIi4vU3RhdGVcIik7XG5jb25zdCBQb2x5Z29uXzEgPSByZXF1aXJlKFwiLi9Qb2x5Z29uXCIpO1xuY29uc3QgTWVzaEJhdGNoVXZzXzEgPSByZXF1aXJlKFwiLi9NZXNoQmF0Y2hVdnNcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XG5jb25zdCBEcmF3TW9kZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EcmF3TW9kZVNldHRpbmdzXCIpO1xuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIE1lc2ggZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBzaGFkZXIsIHN0YXRlID0gbnVsbCwgZHJhd01vZGUgPSBEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLlRSSUFOR0xFUykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNsdWRlcyB2ZXJ0ZXggcG9zaXRpb25zLCBmYWNlIGluZGljZXMsIG5vcm1hbHMsIGNvbG9ycywgVVZzLCBhbmRcbiAgICAgICAgICogY3VzdG9tIGF0dHJpYnV0ZXMgd2l0aGluIGJ1ZmZlcnMsIHJlZHVjaW5nIHRoZSBjb3N0IG9mIHBhc3NpbmcgYWxsXG4gICAgICAgICAqIHRoaXMgZGF0YSB0byB0aGUgR1BVLiBDYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgTWVzaCBvYmplY3RzLlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdlb21ldHJ5fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgZ2VvbWV0cnkucmVmQ291bnQrKztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycyB0aGF0IHByb2Nlc3NlcyB0aGUgZ2VvbWV0cnkgYW5kIHJ1bnMgb24gdGhlIEdQVS5cbiAgICAgICAgICogQ2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIE1lc2ggb2JqZWN0cy5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ8UElYSS5NZXNoTWF0ZXJpYWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIFdlYkdMIHN0YXRlIHRoZSBNZXNoIHJlcXVpcmVkIHRvIHJlbmRlciwgZXhjbHVkZXMgc2hhZGVyIGFuZCBnZW9tZXRyeS4gRS5nLixcbiAgICAgICAgICogYmxlbmQgbW9kZSwgY3VsbGluZywgZGVwdGggdGVzdGluZywgZGlyZWN0aW9uIG9mIHJlbmRlcmluZyB0cmlhbmdsZXMsIGJhY2tmYWNlLCBldGMuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU3RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwgU3RhdGVfMS5TdGF0ZS5mb3IyZCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdheSB0aGUgTWVzaCBzaG91bGQgYmUgZHJhd24sIGNhbiBiZSBhbnkgb2YgdGhlIHtAbGluayBQSVhJLkRSQVdfTU9ERVN9IGNvbnN0YW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAc2VlIFBJWEkuRFJBV19NT0RFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHlwaWNhbGx5IHRoZSBpbmRleCBvZiB0aGUgSW5kZXhCdWZmZXIgd2hlcmUgdG8gc3RhcnQgZHJhd2luZy5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBtdWNoIG9mIHRoZSBnZW9tZXRyeSB0byBkcmF3LCBieSBkZWZhdWx0IGAwYCByZW5kZXJzIGV2ZXJ5dGhpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZWFzZSBhcmUgdXNlZCBhcyBlYXN5IGFjY2VzcyBmb3IgYmF0Y2hpbmdcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlYXNlIGFyZSB1c2VkIGFzIGVhc3kgYWNjZXNzIGZvciBiYXRjaGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGlzIGlzIHRoZSBjYWNoaW5nIGxheWVyIHVzZWQgYnkgdGhlIGJhdGNoZXJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGdlb21ldHJ5IGlzIGNoYW5nZWQgdXNlZCB0byBkZWNpZGUgdG8gcmUtdHJhbnNmb3JtXG4gICAgICAgICAqIHRoZSB2ZXJ0ZXhEYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnRleERpcnR5ID0gMDtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICAgICAgLy8gSW5oZXJpdGVkIGZyb20gRGlzcGxheU1vZGUsIHNldCBkZWZhdWx0c1xuICAgICAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgcm91bmRQaXhlbHMgZmllbGRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJPVU5EX1BJWEVMUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoZWQgVVYncyBhcmUgY2FjaGVkIGZvciBhdGxhcyB0ZXh0dXJlc1xuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1lc2hCYXRjaFV2c31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmF0Y2hVdnMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBjaGFuZ2UgbWVzaCB1didzLCBjaGFuZ2UgaXRzIHV2QnVmZmVyIGRhdGEgYW5kIGluY3JlbWVudCBpdHMgX3VwZGF0ZUlELlxuICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCB1dkJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXS5kYXRhO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVG8gY2hhbmdlIG1lc2ggdmVydGljZXMsIGNoYW5nZSBpdHMgdXZCdWZmZXIgZGF0YSBhbmQgaW5jcmVtZW50IGl0cyBfdXBkYXRlSUQuXG4gICAgICogSW5jcmVtZW50aW5nIF91cGRhdGVJRCBpcyBvcHRpb25hbCBiZWNhdXNlIG1vc3Qgb2YgTWVzaCBvYmplY3RzIGRvIGl0IGFueXdheS5cbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJ1ZmZlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgdmVydGljZXNCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF0uZGF0YTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgUElYSS5NZXNoI3NoYWRlcn0uXG4gICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ8UElYSS5NZXNoTWF0ZXJpYWx9XG4gICAgICovXG4gICAgc2V0IG1hdGVyaWFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlcjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIE1lc2guIEFwcGx5IGEgdmFsdWUgb2ZcbiAgICAgKiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAqL1xuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCBibGVuZE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmJsZW5kTW9kZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIElmIHRydWUgUGl4aUpTIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAgICogQWR2YW50YWdlcyBjYW4gaW5jbHVkZSBzaGFycGVyIGltYWdlIHF1YWxpdHkgKGxpa2UgdGV4dCkgYW5kIGZhc3RlciByZW5kZXJpbmcgb24gY2FudmFzLlxuICAgICAqIFRoZSBtYWluIGRpc2FkdmFudGFnZSBpcyBtb3ZlbWVudCBvZiBvYmplY3RzIG1heSBhcHBlYXIgbGVzcyBzbW9vdGguXG4gICAgICogVG8gc2V0IHRoZSBnbG9iYWwgZGVmYXVsdCwgY2hhbmdlIHtAbGluayBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMU31cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgbXVsdGlwbHkgdGludCBhcHBsaWVkIHRvIHRoZSBNZXNoLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mXG4gICAgICogYDB4RkZGRkZGYCB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICBnZXQgdGludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyLnRpbnQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGludCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNoYWRlci50aW50ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBNZXNoIHVzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IHRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlci50ZXh0dXJlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zaGFkZXIudGV4dHVyZSA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgcmVuZGVyZXIgZHJhdy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBmb3IgYmF0Y2hpbmcuLlxuICAgICAgICAvLyBUT0RPIGNvdWxkIHVzZSBhIGRpZmZlcmVudCB3YXkgdG8gZ3JhYiB2ZXJ0cz9cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzBdLmRhdGE7XG4gICAgICAgIC8vIFRPRE8gYmVuY2htYXJrIGNoZWNrIGZvciBhdHRyaWJ1dGUgc2l6ZS4uXG4gICAgICAgIGlmICh0aGlzLnNoYWRlci5iYXRjaGFibGUgJiYgdGhpcy5kcmF3TW9kZSA9PT0gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRVMgJiYgdmVydGljZXMubGVuZ3RoIDwgTWVzaC5CQVRDSEFCTEVfU0laRSAqIDIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyRGVmYXVsdChyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIG5vbi1iYXRjaGluZyB3YXkgb2YgcmVuZGVyaW5nLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gSW5zdGFuY2UgdG8gcmVuZGVyZXIuXG4gICAgICovXG4gICAgX3JlbmRlckRlZmF1bHQocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgICAgICBzaGFkZXIuYWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgICAgIGlmIChzaGFkZXIudXBkYXRlKSB7XG4gICAgICAgICAgICBzaGFkZXIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgICAgaWYgKHNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhLnRyYW5zbGF0aW9uTWF0cml4KSB7XG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpbmQgYW5kIHN5bmMgdW5pZm9ybXMuLlxuICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZChzaGFkZXIpO1xuICAgICAgICAvLyBzZXQgc3RhdGUuLlxuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgICAgICAgLy8gYmluZCB0aGUgZ2VvbWV0cnkuLi5cbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLmdlb21ldHJ5LCBzaGFkZXIpO1xuICAgICAgICAvLyB0aGVuIHJlbmRlciBpdFxuICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KHRoaXMuZHJhd01vZGUsIHRoaXMuc2l6ZSwgdGhpcy5zdGFydCwgdGhpcy5nZW9tZXRyeS5pbnN0YW5jZUNvdW50KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcmluZyBieSB1c2luZyB0aGUgQmF0Y2ggc3lzdGVtLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gSW5zdGFuY2UgdG8gcmVuZGVyZXIuXG4gICAgICovXG4gICAgX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyLnV2TWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRlci51dk1hdHJpeC51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVXZzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHByb3BlcnRpZXMgZm9yIGJhdGNoaW5nLi5cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhO1xuICAgICAgICB0aGlzLl90aW50UkdCID0gdGhpcy5zaGFkZXIuX3RpbnRSR0I7XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLnNoYWRlci50ZXh0dXJlO1xuICAgICAgICB2YXIgcGx1Z2luTmFtZSA9IHRoaXMubWF0ZXJpYWwucGx1Z2luTmFtZTtcbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXSk7XG4gICAgICAgIHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB2ZXJ0ZXhEYXRhIGZpZWxkIGJhc2VkIG9uIHRyYW5zZm9ybSBhbmQgdmVydGljZXNcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYnVmZmVyc1swXS5kYXRhO1xuICAgICAgICBpZiAoZ2VvbWV0cnkudmVydGV4RGlydHlJZCA9PT0gdGhpcy52ZXJ0ZXhEaXJ0eSAmJiB0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhEYXRhLmxlbmd0aCAhPT0gdmVydGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciBhID0gd3QuYTtcbiAgICAgICAgdmFyIGIgPSB3dC5iO1xuICAgICAgICB2YXIgYyA9IHd0LmM7XG4gICAgICAgIHZhciBkID0gd3QuZDtcbiAgICAgICAgdmFyIHR4ID0gd3QudHg7XG4gICAgICAgIHZhciB0eSA9IHd0LnR5O1xuICAgICAgICB2YXIgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhEYXRhLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1soaSAqIDIpXTtcbiAgICAgICAgICAgIHZhciB5ID0gdmVydGljZXNbKGkgKiAyKSArIDFdO1xuICAgICAgICAgICAgdmVydGV4RGF0YVsoaSAqIDIpXSA9IChhICogeCkgKyAoYyAqIHkpICsgdHg7XG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhWyhpICogMikgKyAxXSA9IChiICogeCkgKyAoZCAqIHkpICsgdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB2ZXJ0ZXhEYXRhLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEYXRhW2kkMV0gPSBNYXRoLnJvdW5kKHZlcnRleERhdGFbaSQxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJ0ZXhEaXJ0eSA9IGdlb21ldHJ5LnZlcnRleERpcnR5SWQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHV2IGZpZWxkIGJhc2VkIG9uIGZyb20gZ2VvbWV0cnkgdXYncyBvciBiYXRjaFV2c1xuICAgICAqL1xuICAgIGNhbGN1bGF0ZVV2cygpIHtcbiAgICAgICAgdmFyIGdlb21VdnMgPSB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV07XG4gICAgICAgIGlmICghdGhpcy5zaGFkZXIudXZNYXRyaXguaXNTaW1wbGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5iYXRjaFV2cykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hVdnMgPSBuZXcgTWVzaEJhdGNoVXZzXzEuTWVzaEJhdGNoVXZzKGdlb21VdnMsIHRoaXMuc2hhZGVyLnV2TWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmF0Y2hVdnMudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnV2cyA9IHRoaXMuYmF0Y2hVdnMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXZzID0gZ2VvbVV2cy5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIG1lc2ggYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cbiAgICAgKiB0aGVyZSBtdXN0IGJlIGEgYVZlcnRleFBvc2l0aW9uIGF0dHJpYnV0ZSBwcmVzZW50IGluIHRoZSBnZW9tZXRyeSBmb3IgYm91bmRzIHRvIGJlIGNhbGN1bGF0ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZFZlcnRleERhdGEodGhpcy52ZXJ0ZXhEYXRhLCAwLCB0aGlzLnZlcnRleERhdGEubGVuZ3RoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgbWVzaC4gV29ya3Mgb25seSBmb3IgUElYSS5EUkFXX01PREVTLlRSSUFOR0xFUy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9pbnQgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICBpZiAoIXRoaXMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMocG9pbnQueCwgcG9pbnQueSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgTWVzaC50ZW1wUG9pbnQkMik7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nKS5kYXRhO1xuICAgICAgICB2YXIgcG9pbnRzID0gTWVzaC50ZW1wUG9seWdvbi5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5nZW9tZXRyeS5nZXRJbmRleCgpLmRhdGE7XG4gICAgICAgIHZhciBsZW4gPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLmRyYXdNb2RlID09PSA0ID8gMyA6IDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMiA8IGxlbjsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICB2YXIgaW5kMCA9IGluZGljZXNbaV0gKiAyO1xuICAgICAgICAgICAgdmFyIGluZDEgPSBpbmRpY2VzW2kgKyAxXSAqIDI7XG4gICAgICAgICAgICB2YXIgaW5kMiA9IGluZGljZXNbaSArIDJdICogMjtcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHZlcnRpY2VzW2luZDBdO1xuICAgICAgICAgICAgcG9pbnRzWzFdID0gdmVydGljZXNbaW5kMCArIDFdO1xuICAgICAgICAgICAgcG9pbnRzWzJdID0gdmVydGljZXNbaW5kMV07XG4gICAgICAgICAgICBwb2ludHNbM10gPSB2ZXJ0aWNlc1tpbmQxICsgMV07XG4gICAgICAgICAgICBwb2ludHNbNF0gPSB2ZXJ0aWNlc1tpbmQyXTtcbiAgICAgICAgICAgIHBvaW50c1s1XSA9IHZlcnRpY2VzW2luZDIgKyAxXTtcbiAgICAgICAgICAgIGlmIChNZXNoLnRlbXBQb2x5Z29uLmNvbnRhaW5zKE1lc2gudGVtcFBvaW50JDIueCwgTWVzaC50ZW1wUG9pbnQkMi55KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBNZXNoIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsXG4gICAgICogIG9wdGlvbnMgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmVcbiAgICAgKiAgdGhlaXIgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKi9cbiAgICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5yZWZDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5nZW9tZXRyeS5yZWZDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMudXZzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuTWVzaC50ZW1wUG9seWdvbiA9IG5ldyBQb2x5Z29uXzEuUG9seWdvbigpO1xuTWVzaC50ZW1wUG9pbnQkMiA9IG5ldyBQb2ludF8xLlBvaW50KCk7XG4vKipcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcyB0byBjb25zaWRlciBiYXRjaGFibGUuIEdlbmVyYWxseSwgdGhlIGNvbXBsZXhpdHlcbiAqIG9mIHRoZSBnZW9tZXRyeS5cbiAqIEBtZW1iZXJvZiBQSVhJLk1lc2hcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXIge251bWJlcn0gQkFUQ0hBQkxFX1NJWkVcbiAqL1xuTWVzaC5CQVRDSEFCTEVfU0laRSA9IDEwMDtcbmV4cG9ydHMuTWVzaCA9IE1lc2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIE1lc2hCYXRjaFV2cyB7XG4gICAgY29uc3RydWN0b3IodXZCdWZmZXIsIHV2TWF0cml4KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEJ1ZmZlciB3aXRoIG5vcm1hbGl6ZWQgVVYnc1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICB0aGlzLnV2QnVmZmVyID0gdXZCdWZmZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXRlcmlhbCBVViBtYXRyaXhcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlTWF0cml4fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51dk1hdHJpeCA9IHV2TWF0cml4O1xuICAgICAgICAvKipcbiAgICAgICAgICogVVYgQnVmZmVyIGRhdGFcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID0gLTE7XG4gICAgICAgIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9IC0xO1xuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVwZGF0ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VVcGRhdGUgLSBmb3JjZSB0aGUgdXBkYXRlXG4gICAgICovXG4gICAgdXBkYXRlKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgIGlmICghZm9yY2VVcGRhdGVcbiAgICAgICAgICAgICYmIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID09PSB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRFxuICAgICAgICAgICAgJiYgdGhpcy5fdGV4dHVyZVVwZGF0ZUlkID09PSB0aGlzLnV2TWF0cml4Ll91cGRhdGVJRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID0gdGhpcy51dkJ1ZmZlci5fdXBkYXRlSUQ7XG4gICAgICAgIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9IHRoaXMudXZNYXRyaXguX3VwZGF0ZUlEO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMudXZCdWZmZXIuZGF0YTtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmxlbmd0aCAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXZNYXRyaXgubXVsdGlwbHlVdnMoZGF0YSwgdGhpcy5kYXRhKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQrKztcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5NZXNoQmF0Y2hVdnMgPSBNZXNoQmF0Y2hVdnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcbmNvbnN0IEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNsYXNzIE1lc2hHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5XzEuR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKHZlcnRpY2VzID0gbnVsbCwgdXZzID0gbnVsbCwgaW5kZXggPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHZhciB2ZXJ0aWNlc0J1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodmVydGljZXMpO1xuICAgICAgICB2YXIgdXZzQnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih1dnMsIHRydWUpO1xuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKGluZGV4LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIHZlcnRpY2VzQnVmZmVyLCAyLCBmYWxzZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQpXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlKCdhVGV4dHVyZUNvb3JkJywgdXZzQnVmZmVyLCAyLCBmYWxzZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQpXG4gICAgICAgICAgICAuYWRkSW5kZXgoaW5kZXhCdWZmZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlydHkgZmxhZyB0byBsaW1pdCB1cGRhdGUgY2FsbHMgb24gTWVzaC4gRm9yIGV4YW1wbGUsXG4gICAgICAgICAqIGxpbWl0aW5nIHVwZGF0ZXMgb24gYSBzaW5nbGUgTWVzaCBpbnN0YW5jZSB3aXRoIGEgc2hhcmVkIEdlb21ldHJ5XG4gICAgICAgICAqIHdpdGhpbiB0aGUgcmVuZGVyIGxvb3AuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgLTFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlkID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB2ZXJ0ZXggcG9zaXRpb24gaXMgdXBkYXRlZC5cbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgdmVydGV4RGlydHlJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1swXS5fdXBkYXRlSUQ7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuTWVzaEdlb21ldHJ5ID0gTWVzaEdlb21ldHJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4vUHJvZ3JhbVwiKTtcbmNvbnN0IFRleHR1cmVNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVNYXRyaXhcIik7XG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xuY2xhc3MgTWVzaE1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyXzEuU2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1U2FtcGxlciwgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0ge1xuICAgICAgICAgICAgdVNhbXBsZXI6IHVTYW1wbGVyLFxuICAgICAgICAgICAgYWxwaGE6IDEsXG4gICAgICAgICAgICB1VGV4dHVyZU1hdHJpeDogTWF0cml4XzEuTWF0cml4LklERU5USVRZLFxuICAgICAgICAgICAgdUNvbG9yOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNldCBkZWZhdWx0c1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB0aW50OiAweEZGRkZGRixcbiAgICAgICAgICAgIGFscGhhOiAxLFxuICAgICAgICAgICAgcGx1Z2luTmFtZTogJ2JhdGNoJyxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLnVuaWZvcm1zKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHVuaWZvcm1zLCBvcHRpb25zLnVuaWZvcm1zKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihvcHRpb25zLnByb2dyYW0gfHwgUHJvZ3JhbV8xLlByb2dyYW0uZnJvbShNZXNoTWF0ZXJpYWwudmVydGV4JDYsIE1lc2hNYXRlcmlhbC5mcmFnbWVudCQ4KSwgdW5pZm9ybXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogT25seSBkbyB1cGRhdGUgaWYgdGludCBvciBhbHBoYSBjaGFuZ2VzLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGV4dHVyZU1hdHJpeCBpbnN0YW5jZSBmb3IgdGhpcyBNZXNoLCB1c2VkIHRvIHRyYWNrIFRleHR1cmUgY2hhbmdlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51dk1hdHJpeCA9IG5ldyBUZXh0dXJlTWF0cml4XzEuVGV4dHVyZU1hdHJpeCh1U2FtcGxlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgdHJ1ZWAgaWYgc2hhZGVyIGNhbiBiZSBiYXRjaCB3aXRoIHRoZSByZW5kZXJlcidzIGJhdGNoIHN5c3RlbS5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXRjaGFibGUgPSBvcHRpb25zLnByb2dyYW0gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmRlcmVyIHBsdWdpbiBmb3IgYmF0Y2hpbmdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnYmF0Y2gnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsdWdpbk5hbWUgPSBvcHRpb25zLnBsdWdpbk5hbWU7XG4gICAgICAgIHRoaXMudGludCA9IG9wdGlvbnMudGludDtcbiAgICAgICAgdGhpcy5hbHBoYSA9IG9wdGlvbnMuYWxwaGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgdGV4dHVyZSBiZWluZyByZW5kZXJlZC5cbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IHRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXMudVNhbXBsZXIgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnV2TWF0cml4LnRleHR1cmUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhpcyBnZXRzIGF1dG9tYXRpY2FsbHkgc2V0IGJ5IHRoZSBvYmplY3QgdXNpbmcgdGhpcy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fYWxwaGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbHBoYSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCBhbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdGludCBmb3IgdGhlIG1hdGVyaWFsLlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAqL1xuICAgIHNldCB0aW50KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fdGludCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RpbnQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdGludFJHQiA9ICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiAweGZmMDApICsgKCh2YWx1ZSAmIDB4ZmYpIDw8IDE2KTtcbiAgICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgdGludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBNZXNoLiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGZvciBjdXN0b21cbiAgICAgKiBNZXNoTWF0ZXJpYWwgb2JqZWN0cy5cbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvckRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xvckRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgICAgICBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5wcmVtdWx0aXBseVRpbnRUb1JnYmEodGhpcy5fdGludCwgdGhpcy5fYWxwaGEsIHRoaXMudW5pZm9ybXMudUNvbG9yLCBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51dk1hdHJpeC51cGRhdGUoKSkge1xuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy51VGV4dHVyZU1hdHJpeCA9IHRoaXMudXZNYXRyaXgubWFwQ29vcmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xufVxuTWVzaE1hdGVyaWFsLnZlcnRleCQ2ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIHVUZXh0dXJlTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VGV4dHVyZU1hdHJpeCAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxyXFxufVxcclxcblwiO1xuTWVzaE1hdGVyaWFsLmZyYWdtZW50JDggPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdUNvbG9yO1xcclxcbn1cXHJcXG5cIjtcbmV4cG9ydHMuTWVzaE1hdGVyaWFsID0gTWVzaE1hdGVyaWFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jbGFzcyBNb3VzZUV2ZW50IGV4dGVuZHMgRXZlbnRfMS5FdmVudCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYnViYmxlcyA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIGJ1YmJsZXMpO1xuICAgICAgICB0aGlzLm1vdmVtZW50WCA9IDA7XG4gICAgICAgIHRoaXMubW92ZW1lbnRZID0gMDtcbiAgICB9XG59XG5Nb3VzZUV2ZW50LkNMSUNLID0gXCJjbGlja1wiO1xuTW91c2VFdmVudC5NT1VTRV9ET1dOID0gXCJtb3VzZURvd25cIjtcbk1vdXNlRXZlbnQuTU9VU0VfVVAgPSBcIm1vdXNlVXBcIjtcbk1vdXNlRXZlbnQuTUlERExFX0NMSUNLID0gXCJtaWRkbGVDbGlja1wiO1xuTW91c2VFdmVudC5NSURETEVfTU9VU0VfRE9XTiA9IFwibWlkZGxlTW91c2VEb3duXCI7XG5Nb3VzZUV2ZW50Lk1JRERMRV9NT1VTRV9VUCA9IFwibWlkZGxlTW91c2VVcFwiO1xuTW91c2VFdmVudC5SSUdIVF9DTElDSyA9IFwicmlnaHRDbGlja1wiO1xuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9ET1dOID0gXCJyaWdodE1vdXNlRG93blwiO1xuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9VUCA9IFwicmlnaHRNb3VzZVVwXCI7XG5Nb3VzZUV2ZW50Lk1PVVNFX01PVkUgPSBcIm1vdXNlTW92ZVwiO1xuTW91c2VFdmVudC5NT1VTRV9PVkVSID0gXCJtb3VzZU92ZXJcIjtcbk1vdXNlRXZlbnQuTU9VU0VfT1VUID0gXCJtb3VzZU91dFwiO1xuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9VUF9PVVRTSURFID0gXCJyaWdodHVwb3V0c2lkZVwiO1xuTW91c2VFdmVudC5NT1VTRV9VUF9PVVRTSURFID0gXCJtb3VzZXVwb3V0c2lkZVwiO1xuTW91c2VFdmVudC5QT0lOVEVSX09WRVIgPSBcInBvaW50ZXJvdmVyXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfRU5URVIgPSBcInBvaW50ZXJlbnRlclwiO1xuTW91c2VFdmVudC5QT0lOVEVSX0RPV04gPSBcInBvaW50ZXJkb3duXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSA9IFwicG9pbnRlcm1vdmVcIjtcbk1vdXNlRXZlbnQuUE9JTlRFUl9VUCA9IFwicG9pbnRlcnVwXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfQ0FOQ0VMID0gXCJwb2ludGVyY2FuY2VsXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfT1VUID0gXCJwb2ludGVyb3V0XCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfTEVBVkUgPSBcInBvaW50ZXJsZWF2ZVwiO1xuTW91c2VFdmVudC5QT0lOVEVSX0NBUFRVUkUgPSBcImdvdHBvaW50ZXJjYXB0dXJlXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfTE9TVCA9IFwibG9zdHBvaW50ZXJjYXB0dXJlXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfVVBfT1VUU0lERSA9IFwicG9pbnRlcnVwb3V0c2lkZVwiO1xuTW91c2VFdmVudC5QT0lOVEVSX1RBUCA9IFwicG9pbnRlcnRhcFwiO1xuTW91c2VFdmVudC5UT1VDSF9TVEFSVCA9IFwidG91Y2hzdGFydFwiO1xuTW91c2VFdmVudC5UT1VDSF9FTkQgPSBcInRvdWNoZW5kXCI7XG5Nb3VzZUV2ZW50LlRPVUNIX0VORF9PVVRTSURFID0gXCJ0b3VjaGVuZG91dHNpZGVcIjtcbk1vdXNlRXZlbnQuVE9VQ0hfTU9WRSA9IFwidG91Y2htb3ZlXCI7XG5Nb3VzZUV2ZW50LlRPVUNIX0NBTkNFTCA9IFwidG91Y2hjYW5jZWxcIjtcbk1vdXNlRXZlbnQuVE9VQ0hfVEFQID0gXCJ0YXBcIjtcbmV4cG9ydHMuTW91c2VFdmVudCA9IE1vdXNlRXZlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFVybF8xID0gcmVxdWlyZShcIi4vVXJsXCIpO1xuY2xhc3MgTmV0d29ya1NldHRpbmdzIHtcbiAgICBzdGF0aWMgZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCwgZGVmYXVsdFZhbHVlID0gbnVsbCkge1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IE5ldHdvcmtTZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModXJsKTtcbiAgICAgICAgaWYgKHJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHJlc29sdXRpb25bMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IDE7XG4gICAgfVxuICAgIHN0YXRpYyBkZXRlcm1pbmVDcm9zc09yaWdpbih1cmwkMSwgbG9jID0gbnVsbCkge1xuICAgICAgICBpZiAobG9jID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGxvYyA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsJDEuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGxvYyA9IGxvYyB8fCB3aW5kb3cubG9jYXRpb247XG4gICAgICAgIGlmICghTmV0d29ya1NldHRpbmdzLnRlbXBBbmNob3IpIHtcbiAgICAgICAgICAgIE5ldHdvcmtTZXR0aW5ncy50ZW1wQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICB9XG4gICAgICAgIE5ldHdvcmtTZXR0aW5ncy50ZW1wQW5jaG9yLmhyZWYgPSB1cmwkMTtcbiAgICAgICAgdXJsJDEgPSBOZXR3b3JrU2V0dGluZ3MudXJsLnBhcnNlKE5ldHdvcmtTZXR0aW5ncy50ZW1wQW5jaG9yLmhyZWYpO1xuICAgICAgICB2YXIgc2FtZVBvcnQgPSAoIXVybCQxLnBvcnQgJiYgbG9jLnBvcnQgPT09ICcnKSB8fCAodXJsJDEucG9ydCA9PT0gbG9jLnBvcnQpO1xuICAgICAgICBpZiAodXJsJDEuaG9zdG5hbWUgIT09IGxvYy5ob3N0bmFtZSB8fCAhc2FtZVBvcnQgfHwgdXJsJDEucHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5OZXR3b3JrU2V0dGluZ3MuUkVUSU5BX1BSRUZJWCA9IC9AKFswLTlcXC5dKyl4Lztcbk5ldHdvcmtTZXR0aW5ncy51cmwgPSB7XG4gICAgcGFyc2U6IFVybF8xLlVybC51cmxQYXJzZSxcbiAgICByZXNvbHZlOiBVcmxfMS5VcmwudXJsUmVzb2x2ZSxcbiAgICByZXNvbHZlT2JqZWN0OiBVcmxfMS5VcmwudXJsUmVzb2x2ZU9iamVjdCxcbiAgICBmb3JtYXQ6IFVybF8xLlVybC51cmxGb3JtYXQsXG4gICAgVXJsOiBVcmxfMS5Vcmxcbn07XG5leHBvcnRzLk5ldHdvcmtTZXR0aW5ncyA9IE5ldHdvcmtTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jbGFzcyBPYmplY3RSZW5kZXJlciBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgLy8gc2V0IHRoZSBzaGFkZXIuLlxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3RvcHMgdGhlIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTdHViIG1ldGhvZCBmb3IgcmVuZGVyaW5nIGNvbnRlbnQgYW5kIGVtcHR5aW5nIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgICAqXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIC8vIGZsdXNoIVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIHJlbmRlci5cbiAgICAgKi9cbiAgICByZW5kZXIob2JqZWN0KSB7XG4gICAgICAgIC8vIHJlbmRlciB0aGUgb2JqZWN0XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuT2JqZWN0UmVuZGVyZXIgPSBPYmplY3RSZW5kZXJlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgT2JzZXJ2YWJsZVBvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihjYiwgc2NvcGUsIHggPSAwLCB5ID0gMCkge1xuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIHRoaXMuY2IgPSBjYjtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludC5cbiAgICAgKiBUaGUgY2FsbGJhY2sgYW5kIHNjb3BlIHBhcmFtcyBjYW4gYmUgb3ZlcmlkZGVuIG90aGVyd2lzZSB0aGV5IHdpbGwgZGVmYXVsdFxuICAgICAqIHRvIHRoZSBjbG9uZSBvYmplY3QncyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2I9bnVsbF0gLSBjYWxsYmFjayB3aGVuIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Njb3BlPW51bGxdIC0gb3duZXIgb2YgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk9ic2VydmFibGVQb2ludH0gYSBjb3B5IG9mIHRoZSBwb2ludFxuICAgICAqL1xuICAgIGNsb25lKGNiLCBzY29wZSkge1xuICAgICAgICBpZiAoY2IgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY2IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29wZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzY29wZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jYiA9IGNiIHx8IHRoaXMuY2I7XG4gICAgICAgIHZhciBfc2NvcGUgPSBzY29wZSB8fCB0aGlzLnNjb3BlO1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQb2ludChfY2IsIF9zY29wZSwgdGhpcy5feCwgdGhpcy5feSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyB4IGFuZCB5IHBvc2l0aW9uLlxuICAgICAqIElmIHkgaXMgb21pdHRlZCwgYm90aCB4IGFuZCB5IHdpbGwgYmUgc2V0IHRvIHguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXG4gICAgICovXG4gICAgc2V0KHgsIHkpIHtcbiAgICAgICAgdmFyIF94ID0geCB8fCAwO1xuICAgICAgICB2YXIgX3kgPSB5IHx8ICgoeSAhPT0gMCkgPyBfeCA6IDApO1xuICAgICAgICBpZiAodGhpcy5feCAhPT0gX3ggfHwgdGhpcy5feSAhPT0gX3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBfeDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBfeTtcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ29waWVzIHggYW5kIHkgZnJvbSB0aGUgZ2l2ZW4gcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY29weSBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgY29weUZyb20ocCkge1xuICAgICAgICBpZiAodGhpcy5feCAhPT0gcC54IHx8IHRoaXMuX3kgIT09IHAueSkge1xuICAgICAgICAgICAgdGhpcy5feCA9IHAueDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBwLnk7XG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb3BpZXMgeCBhbmQgeSBpbnRvIHRoZSBnaXZlbiBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjb3B5LlxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gR2l2ZW4gcG9pbnQgd2l0aCB2YWx1ZXMgdXBkYXRlZFxuICAgICAqL1xuICAgIGNvcHlUbyhwKSB7XG4gICAgICAgIHAuc2V0KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBwb2ludCBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAgICovXG4gICAgZXF1YWxzKHApIHtcbiAgICAgICAgcmV0dXJuIChwLnggPT09IHRoaXMuX3gpICYmIChwLnkgPT09IHRoaXMuX3kpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB4IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHgodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9XG4gICAgO1xuICAgIHNldCB5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl95ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuT2JzZXJ2YWJsZVBvaW50ID0gT2JzZXJ2YWJsZVBvaW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vR2VvbWV0cnlcIik7XG5jb25zdCBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBQYXJ0aWNsZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIHNpemUpIHtcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBwYXJ0aWNsZXMgdGhlIGJ1ZmZlciBjYW4gaG9sZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGR5bmFtaWMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHN0YXRpYy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgLy8gTWFrZSBjb3B5IG9mIHByb3BlcnRpZXMgb2JqZWN0IHNvIHRoYXQgd2hlbiB3ZSBlZGl0IHRoZSBvZmZzZXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgLy8gY2hhbmdlIGFsbCBvdGhlciBpbnN0YW5jZXMgb2YgdGhlIG9iamVjdCBsaXRlcmFsXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiBwcm9wZXJ0eS5hdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgIHNpemU6IHByb3BlcnR5LnNpemUsXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGU6IHByb3BlcnR5LnR5cGUgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwcm9wZXJ0eS5vZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNQcm9wZXJ0eUZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICAgICAgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRCdWZmZXJzKCkge1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgICB2YXIgZHluYW1pY09mZnNldCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyB0aGUgaW5kaWNlcyBvZiB0aGUgZ2VvbWV0cnkgKHF1YWRzKSB0byBkcmF3XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHRoaXMuc2l6ZSksIHRydWUsIHRydWUpO1xuICAgICAgICBnZW9tZXRyeS5hZGRJbmRleCh0aGlzLmluZGV4QnVmZmVyKTtcbiAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHkub2Zmc2V0ID0gZHluYW1pY09mZnNldDtcbiAgICAgICAgICAgIGR5bmFtaWNPZmZzZXQgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSArPSBwcm9wZXJ0eS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkeW5CdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5zaXplICogdGhpcy5keW5hbWljU3RyaWRlICogNCAqIDQpO1xuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheShkeW5CdWZmZXIpO1xuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGR5bkJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodGhpcy5keW5hbWljRGF0YSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgLy8gc3RhdGljIC8vXG4gICAgICAgIHZhciBzdGF0aWNPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkkMSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpJDFdO1xuICAgICAgICAgICAgcHJvcGVydHkkMS5vZmZzZXQgPSBzdGF0aWNPZmZzZXQ7XG4gICAgICAgICAgICBzdGF0aWNPZmZzZXQgKz0gcHJvcGVydHkkMS5zaXplO1xuICAgICAgICAgICAgdGhpcy5zdGF0aWNTdHJpZGUgKz0gcHJvcGVydHkkMS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSAqIHRoaXMuc3RhdGljU3RyaWRlICogNCAqIDQpO1xuICAgICAgICB0aGlzLnN0YXRpY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXRCdWZmZXIpO1xuICAgICAgICB0aGlzLnN0YXRpY0RhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoc3RhdEJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih0aGlzLnN0YXRpY0RhdGEsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7ICsraSQyKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkkMiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaSQyXTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZShwcm9wZXJ0eSQyLmF0dHJpYnV0ZU5hbWUsIHRoaXMuZHluYW1pY0J1ZmZlciwgMCwgcHJvcGVydHkkMi50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eSQyLnR5cGUsIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQsIHByb3BlcnR5JDIub2Zmc2V0ICogNCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpJDMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSQzID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2kkM107XG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUocHJvcGVydHkkMy5hdHRyaWJ1dGVOYW1lLCB0aGlzLnN0YXRpY0J1ZmZlciwgMCwgcHJvcGVydHkkMy50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eSQzLnR5cGUsIHRoaXMuc3RhdGljU3RyaWRlICogNCwgcHJvcGVydHkkMy5vZmZzZXQgKiA0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgZHluYW1pYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIFRoZSBjaGlsZHJlbiB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSBUaGUgaW5kZXggdG8gc3RhcnQgYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBudW1iZXIgdG8gdXBsb2FkLlxuICAgICAqL1xuICAgIHVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBwcm9wZXJ0eS50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5keW5hbWljRGF0YVVpbnQzMiA6IHRoaXMuZHluYW1pY0RhdGEsIHRoaXMuZHluYW1pY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR5bmFtaWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSBzdGF0aWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4gdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IHRvIHN0YXJ0IGF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBUaGUgbnVtYmVyIHRvIHVwbG9hZC5cbiAgICAgKi9cbiAgICB1cGxvYWRTdGF0aWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHkudXBsb2FkRnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgcHJvcGVydHkudHlwZSA9PT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSA/IHRoaXMuc3RhdGljRGF0YVVpbnQzMiA6IHRoaXMuc3RhdGljRGF0YSwgdGhpcy5zdGF0aWNTdHJpZGUsIHByb3BlcnR5Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgUGFydGljbGVCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5keW5hbWljQnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLnN0YXRpY0J1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICAgICAgLy8gYWxsIGJ1ZmZlcnMgYXJlIGRlc3Ryb3llZCBpbnNpZGUgZ2VvbWV0cnlcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5kZXN0cm95KCk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUGFydGljbGVCdWZmZXIgPSBQYXJ0aWNsZUJ1ZmZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jbGFzcyBQYXJ0aWNsZUNvbnRhaW5lciBleHRlbmRzIENvbnRhaW5lcl8xLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDE1MDAsIHByb3BlcnRpZXMgPSBudWxsLCBiYXRjaFNpemUgPSAxNjM4NCwgYXV0b1Jlc2l6ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtYXhTaXplID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG1heFNpemUgPSAxNTAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaFNpemUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gMTYzODQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dG9SZXNpemUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYXV0b1Jlc2l6ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIE1ha2luZyBzdXJlIHRoZSBiYXRjaCBzaXplIGlzIHZhbGlkXG4gICAgICAgIC8vIDY1NTM1IGlzIG1heCB2ZXJ0ZXggaW5kZXggaW4gdGhlIGluZGV4IGJ1ZmZlciAoc2VlIFBhcnRpY2xlUmVuZGVyZXIpXG4gICAgICAgIC8vIHNvIG1heCBudW1iZXIgb2YgcGFydGljbGVzIGlzIDY1NTM2IC8gNCA9IDE2Mzg0XG4gICAgICAgIHZhciBtYXhCYXRjaFNpemUgPSAxNjM4NDtcbiAgICAgICAgaWYgKGJhdGNoU2l6ZSA+IG1heEJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gbWF4QmF0Y2hTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICBiYXRjaFNpemUgPSBtYXhTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgcHJvcGVydGllcyB0byBiZSBkeW5hbWljICh0cnVlKSAvIHN0YXRpYyAoZmFsc2UpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW5bXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbZmFsc2UsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheTxQSVhJLkJ1ZmZlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZvciBldmVyeSBiYXRjaCBzdG9yZXMgX3VwZGF0ZUlEIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxhc3QgY2hhbmdlIGluIHRoYXQgYmF0Y2hcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idWZmZXJVcGRhdGVJRHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZW4gY2hpbGQgaW5zZXJ0ZWQsIHJlbW92ZWQgb3IgY2hhbmdlcyBwb3NpdGlvbiB0aGlzIG51bWJlciBnb2VzIHVwXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGBcbiAgICAgICAgICogdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBjb250YWluZXIgYWxsb2NhdGVzIG1vcmUgYmF0Y2hlcyBpbiBjYXNlIHRoZXJlIGFyZSBtb3JlIHRoYW4gYG1heFNpemVgIHBhcnRpY2xlcy5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IGF1dG9SZXNpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAgICAgKiBBZHZhbnRhZ2VzIGNhbiBpbmNsdWRlIHNoYXJwZXIgaW1hZ2UgcXVhbGl0eSAobGlrZSB0ZXh0KSBhbmQgZmFzdGVyIHJlbmRlcmluZyBvbiBjYW52YXMuXG4gICAgICAgICAqIFRoZSBtYWluIGRpc2FkdmFudGFnZSBpcyBtb3ZlbWVudCBvZiBvYmplY3RzIG1heSBhcHBlYXIgbGVzcyBzbW9vdGguXG4gICAgICAgICAqIERlZmF1bHQgdG8gdHJ1ZSBoZXJlIGFzIHBlcmZvcm1hbmNlIGlzIHVzdWFsbHkgdGhlIHByaW9yaXR5IGZvciBwYXJ0aWNsZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm91bmRQaXhlbHMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgdXNlZCB0byByZW5kZXIgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7QmFzZVRleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgY29udGFpbmVyLlxuICAgICAgICAgKiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGludCA9IDA7XG4gICAgICAgIHRoaXMudGludFJnYiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcml2YXRlIHByb3BlcnRpZXMgYXJyYXkgdG8gZHluYW1pYyAvIHN0YXRpYyBiYXNlZCBvbiB0aGUgcGFzc2VkIHByb3BlcnRpZXMgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIFRoZSBwcm9wZXJ0aWVzIHRvIGJlIHVwbG9hZGVkXG4gICAgICovXG4gICAgc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzBdID0gJ3ZlcnRpY2VzJyBpbiBwcm9wZXJ0aWVzIHx8ICdzY2FsZScgaW4gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgID8gISFwcm9wZXJ0aWVzLnZlcnRpY2VzIHx8ICEhcHJvcGVydGllcy5zY2FsZSA6IHRoaXMuX3Byb3BlcnRpZXNbMF07XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzFdID0gJ3Bvc2l0aW9uJyBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnBvc2l0aW9uIDogdGhpcy5fcHJvcGVydGllc1sxXTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbMl0gPSAncm90YXRpb24nIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMucm90YXRpb24gOiB0aGlzLl9wcm9wZXJ0aWVzWzJdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1szXSA9ICd1dnMnIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudXZzIDogdGhpcy5fcHJvcGVydGllc1szXTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbNF0gPSAndGludCcgaW4gcHJvcGVydGllcyB8fCAnYWxwaGEnIGluIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICA/ICEhcHJvcGVydGllcy50aW50IHx8ICEhcHJvcGVydGllcy5hbHBoYSA6IHRoaXMuX3Byb3BlcnRpZXNbNF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAvLyBUT0RPIGRvbid0IG5lZWQgdG8hXG4gICAgICAgIC8vIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAvLyAgUElYSS5Db250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBjb250YWluZXIuIFRoaXMgaXMgYSBoZXggdmFsdWUuXG4gICAgICogQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAgICoqIElNUE9SVEFOVDogVGhpcyBpcyBhIFdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICAgICovXG4gICAgZ2V0IHRpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW50O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGludCA9IHZhbHVlO1xuICAgICAgICBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5oZXgycmdiKHZhbHVlLCB0aGlzLnRpbnRSZ2IpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY29udGFpbmVyIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHdlYmdsIHJlbmRlcmVyXG4gICAgICovXG4gICAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5iYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IHRoaXMuY2hpbGRyZW5bMF0uX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9uY2UoJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5vbkNoaWxkcmVuQ2hhbmdlKDApOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLnBhcnRpY2xlKTtcbiAgICAgICAgcmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZS5yZW5kZXIodGhpcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZsYWcgdGhhdCBzdGF0aWMgZGF0YSBzaG91bGQgYmUgdXBkYXRlZCB0byB0cnVlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbWFsbGVzdENoaWxkSW5kZXggLSBUaGUgc21hbGxlc3QgY2hpbGQgaW5kZXhcbiAgICAgKi9cbiAgICBvbkNoaWxkcmVuQ2hhbmdlKHNtYWxsZXN0Q2hpbGRJbmRleCkge1xuICAgICAgICB2YXIgYnVmZmVySW5kZXggPSBNYXRoLmZsb29yKHNtYWxsZXN0Q2hpbGRJbmRleCAvIHRoaXMuX2JhdGNoU2l6ZSk7XG4gICAgICAgIHdoaWxlICh0aGlzLl9idWZmZXJVcGRhdGVJRHMubGVuZ3RoIDwgYnVmZmVySW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEc1tidWZmZXJJbmRleF0gPSArK3RoaXMuX3VwZGF0ZUlEO1xuICAgIH1cbiAgICA7XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnNbaV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcbiAgICAgKiAgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcyA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUGFydGljbGVDb250YWluZXIgPSBQYXJ0aWNsZUNvbnRhaW5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgT2JqZWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL09iamVjdFJlbmRlcmVyXCIpO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcbmNvbnN0IFBhcnRpY2xlQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZUJ1ZmZlclwiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBQYXJ0aWNsZVJlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXJfMS5PYmplY3RSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvLyA2NTUzNSBpcyBtYXggdmVydGV4IGluZGV4IGluIHRoZSBpbmRleCBidWZmZXIgKHNlZSBQYXJ0aWNsZVJlbmRlcmVyKVxuICAgICAgICAvLyBzbyBtYXggbnVtYmVyIG9mIHBhcnRpY2xlcyBpcyA2NTUzNiAvIDQgPSAxNjM4NFxuICAgICAgICAvLyBhbmQgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIHRoZSBpbmRleCBidWZmZXIgaXMgMTYzODQgKiA2ID0gOTgzMDRcbiAgICAgICAgLy8gQ3JlYXRpbmcgYSBmdWxsIGluZGV4IGJ1ZmZlciwgb3ZlcmhlYWQgaXMgOTgzMDQgKiAyID0gMTk2S29cbiAgICAgICAgLy8gbGV0IG51bUluZGljZXMgPSA5ODMwNDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHNoYWRlciB0aGF0IGlzIHVzZWQgaWYgYSBzcHJpdGUgZG9lc24ndCBoYXZlIGEgbW9yZSBzcGVjaWZpYyBvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU2hhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBNYXRyaXggPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgIC8vIHZlcnRpY2VzRGF0YVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhVmVydGV4UG9zaXRpb24nLFxuICAgICAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVmVydGljZXMsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uRGF0YVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhUG9zaXRpb25Db29yZCcsXG4gICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcm90YXRpb25EYXRhXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogJ2FSb3RhdGlvbicsXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRSb3RhdGlvbixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdXZzRGF0YVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhVGV4dHVyZUNvb3JkJyxcbiAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFV2cyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdGludERhdGFcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnYUNvbG9yJyxcbiAgICAgICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVGludCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuc2hhZGVyID0gU2hhZGVyXzEuU2hhZGVyLmZyb20oUGFydGljbGVSZW5kZXJlci52ZXJ0ZXgkMiwgUGFydGljbGVSZW5kZXJlci5mcmFnbWVudCQxLCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHBhcnRpY2xlIGNvbnRhaW5lciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICAgICAqL1xuICAgIHJlbmRlcihjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuO1xuICAgICAgICB2YXIgbWF4U2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsQ2hpbGRyZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b3RhbENoaWxkcmVuID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgdG90YWxDaGlsZHJlbiA9IG1heFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBjb250YWluZXIuX2J1ZmZlcnM7XG4gICAgICAgIGlmICghYnVmZmVycykge1xuICAgICAgICAgICAgYnVmZmVycyA9IGNvbnRhaW5lci5fYnVmZmVycyA9IHRoaXMuZ2VuZXJhdGVCdWZmZXJzKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gY2hpbGRyZW5bMF0uX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIC8vIGlmIHRoZSB1dnMgaGF2ZSBub3QgdXBkYXRlZCB0aGVuIG5vIHBvaW50IHJlbmRlcmluZyBqdXN0IHlldCFcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGF0ZS5zZXRCbGVuZE1vZGUoQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLmNvcnJlY3RCbGVuZE1vZGUoY29udGFpbmVyLmJsZW5kTW9kZSwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSkpO1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIG0gPSBjb250YWluZXIud29ybGRUcmFuc2Zvcm0uY29weVRvKHRoaXMudGVtcE1hdHJpeCk7XG4gICAgICAgIG0ucHJlcGVuZChyZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSBtLnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVDb2xvciA9IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5UmdiYShjb250YWluZXIudGludFJnYiwgY29udGFpbmVyLndvcmxkQWxwaGEsIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVDb2xvciwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gYmFzZVRleHR1cmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcy5zaGFkZXIpO1xuICAgICAgICB2YXIgdXBkYXRlU3RhdGljID0gZmFsc2U7XG4gICAgICAgIC8vIG5vdyBsZXRzIHVwbG9hZCBhbmQgcmVuZGVyIHRoZSBidWZmZXJzLi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgdG90YWxDaGlsZHJlbjsgaSArPSBiYXRjaFNpemUsIGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIGFtb3VudCA9ICh0b3RhbENoaWxkcmVuIC0gaSk7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPj0gYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5hdXRvUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2godGhpcy5fZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG4gICAgICAgICAgICAvLyB3ZSBhbHdheXMgdXBsb2FkIHRoZSBkeW5hbWljXG4gICAgICAgICAgICBidWZmZXIudXBsb2FkRHluYW1pYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcbiAgICAgICAgICAgIHZhciBiaWQgPSBjb250YWluZXIuX2J1ZmZlclVwZGF0ZUlEc1tqXSB8fCAwO1xuICAgICAgICAgICAgdXBkYXRlU3RhdGljID0gdXBkYXRlU3RhdGljIHx8IChidWZmZXIuX3VwZGF0ZUlEIDwgYmlkKTtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgdXBsb2FkIHRoZSBzdGF0aWMgY29udGVudCB3aGVuIHdlIGhhdmUgdG8hXG4gICAgICAgICAgICBpZiAodXBkYXRlU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLl91cGRhdGVJRCA9IGNvbnRhaW5lci5fdXBkYXRlSUQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnVwbG9hZFN0YXRpYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChidWZmZXIuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgYW1vdW50ICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9uZSBwYXJ0aWNsZSBidWZmZXIgZm9yIGVhY2ggY2hpbGQgaW4gdGhlIGNvbnRhaW5lciB3ZSB3YW50IHRvIHJlbmRlciBhbmQgdXBkYXRlcyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1BJWEkuUGFydGljbGVCdWZmZXJbXX0gVGhlIGJ1ZmZlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdlbmVyYXRlQnVmZmVycyhjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdmFyIHNpemUgPSBjb250YWluZXIuX21heFNpemU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZTtcbiAgICAgICAgdmFyIGR5bmFtaWNQcm9wZXJ0eUZsYWdzID0gY29udGFpbmVyLl9wcm9wZXJ0aWVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2gobmV3IFBhcnRpY2xlQnVmZmVyXzEuUGFydGljbGVCdWZmZXIodGhpcy5wcm9wZXJ0aWVzLCBkeW5hbWljUHJvcGVydHlGbGFncywgYmF0Y2hTaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9uZSBtb3JlIHBhcnRpY2xlIGJ1ZmZlciwgYmVjYXVzZSBjb250YWluZXIgaGFzIGF1dG9SZXNpemUgZmVhdHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBhcnRpY2xlQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRvIHJlbmRlciB1c2luZyB0aGlzIFBhcnRpY2xlUmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBhcnRpY2xlQnVmZmVyfSBnZW5lcmF0ZWQgYnVmZmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemU7XG4gICAgICAgIHZhciBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJ0aWNsZUJ1ZmZlcl8xLlBhcnRpY2xlQnVmZmVyKHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSB2ZXJ0aWNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHZlcnRpY2VzIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICAgKi9cbiAgICB1cGxvYWRWZXJ0aWNlcyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHcwID0gMDtcbiAgICAgICAgdmFyIHcxID0gMDtcbiAgICAgICAgdmFyIGgwID0gMDtcbiAgICAgICAgdmFyIGgxID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICAgICAgICAgICAgdmFyIHN4ID0gc3ByaXRlLnNjYWxlLng7XG4gICAgICAgICAgICB2YXIgc3kgPSBzcHJpdGUuc2NhbGUueTtcbiAgICAgICAgICAgIHZhciB0cmltID0gdGV4dHVyZS50cmltO1xuICAgICAgICAgICAgdmFyIG9yaWcgPSB0ZXh0dXJlLm9yaWc7XG4gICAgICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCBhbmQgaXMgbm90IGEgdGlsaW5nc3ByaXRlIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc3ByaXRlIGNvb3Jkcy4uXG4gICAgICAgICAgICAgICAgdzEgPSB0cmltLnggLSAoc3ByaXRlLmFuY2hvci54ICogb3JpZy53aWR0aCk7XG4gICAgICAgICAgICAgICAgdzAgPSB3MSArIHRyaW0ud2lkdGg7XG4gICAgICAgICAgICAgICAgaDEgPSB0cmltLnkgLSAoc3ByaXRlLmFuY2hvci55ICogb3JpZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGgwID0gaDEgKyB0cmltLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHcwID0gKG9yaWcud2lkdGgpICogKDEgLSBzcHJpdGUuYW5jaG9yLngpO1xuICAgICAgICAgICAgICAgIHcxID0gKG9yaWcud2lkdGgpICogLXNwcml0ZS5hbmNob3IueDtcbiAgICAgICAgICAgICAgICBoMCA9IG9yaWcuaGVpZ2h0ICogKDEgLSBzcHJpdGUuYW5jaG9yLnkpO1xuICAgICAgICAgICAgICAgIGgxID0gb3JpZy5oZWlnaHQgKiAtc3ByaXRlLmFuY2hvci55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHcxICogc3g7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IGgxICogc3k7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdzAgKiBzeDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gaDEgKiBzeTtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSB3MCAqIHN4O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSBoMCAqIHN5O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDMpXSA9IHcxICogc3g7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMykgKyAxXSA9IGgwICogc3k7XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBwb3NpdGlvbnMgdXBsb2FkZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxuICAgICAqL1xuICAgIHVwbG9hZFBvc2l0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlUG9zaXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucG9zaXRpb247XG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IHNwcml0ZVBvc2l0aW9uLng7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMikgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnk7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMyldID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSByb3RpYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXG4gICAgICovXG4gICAgdXBsb2FkUm90YXRpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzcHJpdGVSb3RhdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5yb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSBVdnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHJvdGF0aW9uIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICAgKi9cbiAgICB1cGxvYWRVdnMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlVXZzID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLl90ZXh0dXJlLl91dnM7XG4gICAgICAgICAgICBpZiAodGV4dHVyZVV2cykge1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSB0ZXh0dXJlVXZzLngwO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gdGV4dHVyZVV2cy55MDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdGV4dHVyZVV2cy54MTtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IHRleHR1cmVVdnMueTE7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IHRleHR1cmVVdnMueDI7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSB0ZXh0dXJlVXZzLnkyO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSB0ZXh0dXJlVXZzLngzO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gdGV4dHVyZVV2cy55MztcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8geW91IGtub3cgdGhpcyBjYW4gYmUgZWFzaWVyIVxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSAwO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gMDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gMDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IDA7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IDA7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSAwO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSAwO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgdGludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHJvdGF0aW9uIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICAgKi9cbiAgICB1cGxvYWRUaW50KGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldO1xuICAgICAgICAgICAgdmFyIHByZW11bHRpcGxpZWQgPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IHNwcml0ZS5hbHBoYTtcbiAgICAgICAgICAgIC8vIHdlIGRvbnQgY2FsbCBleHRyYSBmdW5jdGlvbiBpZiBhbHBoYSBpcyAxLjAsIHRoYXQncyBmYXN0ZXJcbiAgICAgICAgICAgIHZhciBhcmdiID0gYWxwaGEgPCAxLjAgJiYgcHJlbXVsdGlwbGllZCA/IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludChzcHJpdGUuX3RpbnRSR0IsIGFscGhhKVxuICAgICAgICAgICAgICAgIDogc3ByaXRlLl90aW50UkdCICsgKGFscGhhICogMjU1IDw8IDI0KTtcbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSBhcmdiO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IGFyZ2I7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMildID0gYXJnYjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSBhcmdiO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBQYXJ0aWNsZVJlbmRlcmVyLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW1wTWF0cml4ID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuUGFydGljbGVSZW5kZXJlci52ZXJ0ZXgkMiA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcclxcblxcclxcbmF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbkNvb3JkO1xcclxcbmF0dHJpYnV0ZSBmbG9hdCBhUm90YXRpb247XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgIGZsb2F0IHggPSAoYVZlcnRleFBvc2l0aW9uLngpICogY29zKGFSb3RhdGlvbikgLSAoYVZlcnRleFBvc2l0aW9uLnkpICogc2luKGFSb3RhdGlvbik7XFxyXFxuICAgIGZsb2F0IHkgPSAoYVZlcnRleFBvc2l0aW9uLngpICogc2luKGFSb3RhdGlvbikgKyAoYVZlcnRleFBvc2l0aW9uLnkpICogY29zKGFSb3RhdGlvbik7XFxyXFxuXFxyXFxuICAgIHZlYzIgdiA9IHZlYzIoeCwgeSk7XFxyXFxuICAgIHYgPSB2ICsgYVBvc2l0aW9uQ29vcmQ7XFxyXFxuXFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgodHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKHYsIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcbiAgICB2Q29sb3IgPSBhQ29sb3IgKiB1Q29sb3I7XFxyXFxufVxcclxcblwiO1xuUGFydGljbGVSZW5kZXJlci5mcmFnbWVudCQxID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKXtcXHJcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcclxcbn1cIjtcbmV4cG9ydHMuUGFydGljbGVSZW5kZXJlciA9IFBhcnRpY2xlUmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgeCBhbmQgeSBwb3NpdGlvbi5cbiAgICAgKiBJZiB5IGlzIG9taXR0ZWQsIGJvdGggeCBhbmQgeSB3aWxsIGJlIHNldCB0byB4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xuICAgICAqL1xuICAgIHNldCh4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xuICAgICAgICB0aGlzLnkgPSB5IHx8ICgoeSAhPT0gMCkgPyB0aGlzLnggOiAwKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBwb2ludCBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAgICovXG4gICAgZXF1YWxzKHApIHtcbiAgICAgICAgcmV0dXJuIChwLnggPT09IHRoaXMueCkgJiYgKHAueSA9PT0gdGhpcy55KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENvcGllcyB4IGFuZCB5IGludG8gdGhlIGdpdmVuIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNvcHkuXG4gICAgICogQHJldHVybnMge1BJWEkuSVBvaW50fSBHaXZlbiBwb2ludCB3aXRoIHZhbHVlcyB1cGRhdGVkXG4gICAgICovXG4gICAgY29weVRvKHApIHtcbiAgICAgICAgcC5zZXQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENvcGllcyB4IGFuZCB5IGZyb20gdGhlIGdpdmVuIHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNvcHkgZnJvbVxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgY29weUZyb20ocCkge1xuICAgICAgICB0aGlzLnNldChwLngsIHAueSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IGEgY29weSBvZiB0aGUgcG9pbnRcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcbmNsYXNzIFBvbHlnb24ge1xuICAgIGNvbnN0cnVjdG9yKGFyZyA9IG51bGwpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgcG9pbnRzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW4tLSkge1xuICAgICAgICAgICAgcG9pbnRzW2xlbl0gPSBhcmd1bWVudHMkMVtsZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvaW50c1swXSkpIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGFycmF5IG9mIHBvaW50cywgY29udmVydCBpdCB0byBhIGZsYXQgYXJyYXkgb2YgbnVtYmVyc1xuICAgICAgICBpZiAocG9pbnRzWzBdIGluc3RhbmNlb2YgUG9pbnRfMS5Qb2ludCkge1xuICAgICAgICAgICAgdmFyIHAgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcC5wdXNoKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMgPSBwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB0aGUgcG9pbnRzIG9mIHRoaXMgcG9seWdvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkT25seVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5QT0xZXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5QT0xZO1xuICAgICAgICAvKipcbiAgICAgICAgICogYGZhbHNlYCBhZnRlciBtb3ZlVG8sIGB0cnVlYCBhZnRlciBgY2xvc2VQYXRoYC4gSW4gYWxsIG90aGVyIGNhc2VzIGl0IGlzIGB0cnVlYC5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZVN0cm9rZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb25cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9seWdvbn0gYSBjb3B5IG9mIHRoZSBwb2x5Z29uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24odGhpcy5wb2ludHMuc2xpY2UoKSk7XG4gICAgICAgIHBvbHlnb24uY2xvc2VTdHJva2UgPSB0aGlzLmNsb3NlU3Ryb2tlO1xuICAgICAgICByZXR1cm4gcG9seWdvbjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcG9seWdvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uXG4gICAgICovXG4gICAgY29udGFpbnMoeCwgeSkge1xuICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgICAgIC8vIHVzZSBzb21lIHJheWNhc3RpbmcgdG8gdGVzdCBoaXRzXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9wb2ludC1pbi1wb2x5Z29uL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgICAgIHZhciB4aSA9IHRoaXMucG9pbnRzW2kgKiAyXTtcbiAgICAgICAgICAgIHZhciB5aSA9IHRoaXMucG9pbnRzWyhpICogMikgKyAxXTtcbiAgICAgICAgICAgIHZhciB4aiA9IHRoaXMucG9pbnRzW2ogKiAyXTtcbiAgICAgICAgICAgIHZhciB5aiA9IHRoaXMucG9pbnRzWyhqICogMikgKyAxXTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSAoKHlpID4geSkgIT09ICh5aiA+IHkpKSAmJiAoeCA8ICgoeGogLSB4aSkgKiAoKHkgLSB5aSkgLyAoeWogLSB5aSkpKSArIHhpKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VQcmVwYXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlUHJlcGFyZVwiKTtcbi8vIGltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljc1wiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcbmNsYXNzIFByZXBhcmUgZXh0ZW5kcyBCYXNlUHJlcGFyZV8xLkJhc2VQcmVwYXJlIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgICAgIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIC8vIEFkZCB0ZXh0dXJlcyBhbmQgZ3JhcGhpY3MgdG8gdXBsb2FkXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhQcmVwYXJlLmZpbmRHcmFwaGljcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKFByZXBhcmUudXBsb2FkQmFzZVRleHR1cmVzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soUHJlcGFyZS51cGxvYWRHcmFwaGljcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kR3JhcGhpY3MoaXRlbSwgcXVldWUpIHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHcmFwaGljc18xLkdyYXBoaWNzKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgdXBsb2FkQmFzZVRleHR1cmVzKHJlbmRlcmVyLCBpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKCFpdGVtLl9nbFRleHR1cmVzW3JlbmRlcmVyLkNPTlRFWFRfVUlEXSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmVNYW5hZ2VyLnVwZGF0ZVRleHR1cmUoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyB1cGxvYWRHcmFwaGljcyhyZW5kZXJlciwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdyYXBoaWNzXzEuR3JhcGhpY3MpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmRpcnR5IHx8IGl0ZW0uY2xlYXJEaXJ0eSB8fCAhaXRlbS5fd2ViR0xbcmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy5DT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzLnVwZGF0ZUdyYXBoaWNzKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJlcGFyZSA9IFByZXBhcmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4vU2hhZGVyXCIpO1xuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBQcm9ncmFtIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lID0gJ3BpeGktc2hhZGVyJykge1xuICAgICAgICB0aGlzLmlkID0gUHJvZ3JhbS5VSUQkMysrO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZlcnRleCBzaGFkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjIHx8IFByb2dyYW0uZGVmYXVsdFZlcnRleFNyYztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYyB8fCBQcm9ncmFtLmRlZmF1bHRGcmFnbWVudFNyYztcbiAgICAgICAgdGhpcy52ZXJ0ZXhTcmMgPSB0aGlzLnZlcnRleFNyYy50cmltKCk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSB0aGlzLmZyYWdtZW50U3JjLnRyaW0oKTtcbiAgICAgICAgaWYgKHRoaXMudmVydGV4U3JjLnN1YnN0cmluZygwLCA4KSAhPT0gJyN2ZXJzaW9uJykge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xuICAgICAgICAgICAgaWYgKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLm5hbWVDYWNoZVtuYW1lXSkge1xuICAgICAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLm5hbWVDYWNoZVtuYW1lXSsrO1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCItXCIgKyAoQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MubmFtZUNhY2hlW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLm5hbWVDYWNoZVtuYW1lXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZlcnRleFNyYyA9IFwiI2RlZmluZSBTSEFERVJfTkFNRSBcIiArIG5hbWUgKyBcIlxcblwiICsgKHRoaXMudmVydGV4U3JjKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBcIiNkZWZpbmUgU0hBREVSX05BTUUgXCIgKyBuYW1lICsgXCJcXG5cIiArICh0aGlzLmZyYWdtZW50U3JjKTtcbiAgICAgICAgICAgIHRoaXMudmVydGV4U3JjID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3Muc2V0UHJlY2lzaW9uKHRoaXMudmVydGV4U3JjLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5QUkVDSVNJT05fVkVSVEVYKTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5zZXRQcmVjaXNpb24odGhpcy5mcmFnbWVudFNyYywgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuUFJFQ0lTSU9OX0ZSQUdNRU5UKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PSBcInBpeGktc2hhZGVyLTRcIikge1xuICAgICAgICB9XG4gICAgICAgIC8vIGN1cnJlbnRseSB0aGlzIGRvZXMgbm90IGV4dHJhY3Qgc3RydWN0cyBvbmx5IGRlZmF1bHQgdHlwZXNcbiAgICAgICAgdGhpcy5leHRyYWN0RGF0YSh0aGlzLnZlcnRleFNyYywgdGhpcy5mcmFnbWVudFNyYyk7XG4gICAgICAgIC8vIHRoaXMgaXMgd2hlcmUgd2Ugc3RvcmUgc2hhZGVyIHJlZmVyZW5jZXMuLlxuICAgICAgICB0aGlzLmdsUHJvZ3JhbXMgPSB7fTtcbiAgICAgICAgdGhpcy5zeW5jVW5pZm9ybXMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgZGF0YSBmb3IgYSBidXkgY3JlYXRpbmcgYSBzbWFsbCB0ZXN0IHByb2dyYW1cbiAgICAgKiBvciByZWFkaW5nIHRoZSBzcmMgZGlyZWN0bHkuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2ZXJ0ZXhTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZyYWdtZW50U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cbiAgICAgKi9cbiAgICBleHRyYWN0RGF0YSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKSB7XG4gICAgICAgIHZhciBnbCA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmdldFRlc3RDb250ZXh0KCk7XG4gICAgICAgIGlmIChnbCkge1xuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBQcm9ncmFtLmNvbXBpbGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlRGF0YSA9IHRoaXMuZ2V0QXR0cmlidXRlRGF0YShwcm9ncmFtLCBnbCk7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1EYXRhID0gdGhpcy5nZXRVbmlmb3JtRGF0YShwcm9ncmFtLCBnbCk7XG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtRGF0YSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVEYXRhID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGF0dHJpYnV0ZSBkYXRhIGZyb20gdGhlIHByb2dyYW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtXZWJHTFByb2dyYW19IFtwcm9ncmFtXSAtIHRoZSBXZWJHTCBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFtnbF0gLSB0aGUgV2ViR0wgY29udGV4dFxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGF0dHJpYnV0ZSBkYXRhIGZvciB0aGlzIHByb2dyYW1cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVEYXRhKHByb2dyYW0sIGdsKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzQXJyYXkgPSBbXTtcbiAgICAgICAgdmFyIHRvdGFsQXR0cmlidXRlcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQXR0cmlidXRlczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmliRGF0YSA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MubWFwVHlwZShnbCwgYXR0cmliRGF0YS50eXBlKTtcbiAgICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgbmFtZTogYXR0cmliRGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgIHNpemU6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLm1hcFNpemUodHlwZSksXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyaWJEYXRhLm5hbWVdID0gZGF0YTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNBcnJheS5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZXNBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYS5uYW1lID4gYi5uYW1lKSA/IDEgOiAtMTsgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZnVzaW5nLWFycm93XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGF0dHJpYnV0ZXNBcnJheS5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzQXJyYXlbaSQxXS5sb2NhdGlvbiA9IGkkMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHVuaWZvcm0gZGF0YSBmcm9tIHRoZSBwcm9ncmFtXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7d2ViR0wtcHJvZ3JhbX0gW3Byb2dyYW1dIC0gdGhlIHdlYmdsIHByb2dyYW1cbiAgICAgKiBAcGFyYW0ge2NvbnRleHR9IFtnbF0gLSB0aGUgV2ViR0wgY29udGV4dFxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIHVuaWZvcm0gZGF0YSBmb3IgdGhpcyBwcm9ncmFtXG4gICAgICovXG4gICAgZ2V0VW5pZm9ybURhdGEocHJvZ3JhbSwgZ2wpIHtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XG4gICAgICAgIHZhciB0b3RhbFVuaWZvcm1zID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfVU5JRk9STVMpO1xuICAgICAgICAvLyBUT0RPIGV4cG9zZSB0aGlzIGFzIGEgcHJvcD9cbiAgICAgICAgLy8gY29uc3QgbWFza1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXihwcm9qZWN0aW9uTWF0cml4fHVTYW1wbGVyfHRyYW5zbGF0aW9uTWF0cml4KSQnKTtcbiAgICAgICAgLy8gY29uc3QgbWFza1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXihwcm9qZWN0aW9uTWF0cml4fHVTYW1wbGVyfHRyYW5zbGF0aW9uTWF0cml4KSQnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbFVuaWZvcm1zOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB1bmlmb3JtRGF0YSA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSk7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHVuaWZvcm1EYXRhLm5hbWUucmVwbGFjZSgvXFxbLio/XFxdLywgJycpO1xuICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSB1bmlmb3JtRGF0YS5uYW1lLm1hdGNoKC9cXFsuKj9cXF0vLCAnJyk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLm1hcFR5cGUoZ2wsIHVuaWZvcm1EYXRhLnR5cGUpO1xuICAgICAgICAgICAgLyplc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgICAgICAgdW5pZm9ybXNbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBzaXplOiB1bmlmb3JtRGF0YS5zaXplLFxuICAgICAgICAgICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmRlZmF1bHRWYWx1ZSh0eXBlLCB1bmlmb3JtRGF0YS5zaXplKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaWZvcm1zO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdmVydGV4IHNoYWRlciBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xuICAgICAgICByZXR1cm4gUHJvZ3JhbS5kZWZhdWx0VmVydGV4O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGRlZmF1bHRGcmFnbWVudFNyYygpIHtcbiAgICAgICAgcmV0dXJuIFByb2dyYW0uZGVmYXVsdEZyYWdtZW50O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBzaG9ydCBoYW5kIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHByb2dyYW0gYmFzZWQgb2YgYSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlclxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYSBjYWNoZWQgcHJvZ3JhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmVydGV4U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcmFnbWVudFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt1bmlmb3Jtc10gLSBDdXN0b20gdW5pZm9ybXMgdG8gdXNlIHRvIGF1Z21lbnQgdGhlIGJ1aWx0LWluIG9uZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UElYSS5Qcm9ncmFtfSBhbiBzaGlueSBuZXcgUGl4aSBzaGFkZXIhXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmVydGV4U3JjLCBmcmFnbWVudFNyYywgbmFtZSA9IFwicGl4aS1zaGFkZXJcIikge1xuICAgICAgICB2YXIga2V5ID0gdmVydGV4U3JjICsgZnJhZ21lbnRTcmM7XG4gICAgICAgIHZhciBwcm9ncmFtID0gQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuUHJvZ3JhbUNhY2hlW2tleV07XG4gICAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuUHJvZ3JhbUNhY2hlW2tleV0gPSBwcm9ncmFtID0gbmV3IFByb2dyYW0odmVydGV4U3JjLCBmcmFnbWVudFNyYywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIEBtZXRob2QgY29tcGlsZVByb2dyYW1cbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCB7V2ViR0xQcm9ncmFtfVxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBmcmFnbWVudFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICogQHBhcmFtIGF0dHJpYnV0ZUxvY2F0aW9ucyB7T2JqZWN0fSBBbiBhdHRyaWJ1dGUgbG9jYXRpb24gbWFwIHRoYXQgbGV0cyB5b3UgbWFudWFsbHkgc2V0IHRoZSBhdHRyaWJ1dGUgbG9jYXRpb25zXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19IHRoZSBzaGFkZXIgcHJvZ3JhbVxuICovXG4gICAgc3RhdGljIGNvbXBpbGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBhdHRyaWJ1dGVMb2NhdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHZhciBnbFZlcnRTaGFkZXIgPSBTaGFkZXJfMS5TaGFkZXIuY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U3JjKTtcbiAgICAgICAgdmFyIGdsRnJhZ1NoYWRlciA9IFNoYWRlcl8xLlNoYWRlci5jb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U3JjKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBnbFZlcnRTaGFkZXIpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xGcmFnU2hhZGVyKTtcbiAgICAgICAgLy8gb3B0aW9uYWxseSwgc2V0IHRoZSBhdHRyaWJ1dGVzIG1hbnVhbGx5IGZvciB0aGUgcHJvZ3JhbSByYXRoZXIgdGhhbiBsZXR0aW5nIFdlYkdMIGRlY2lkZS4uXG4gICAgICAgIGlmIChhdHRyaWJ1dGVMb2NhdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYXR0cmlidXRlTG9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZUxvY2F0aW9uc1tpXSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIC8vIGlmIGxpbmtpbmcgZmFpbHMsIHRoZW4gbG9nIGFuZCBjbGVhbnVwXG4gICAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BpeGkuanMgRXJyb3I6IENvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlci4nKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdnbC5nZXRFcnJvcigpJywgZ2wuZ2V0RXJyb3IoKSk7XG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHByb2dyYW0gaW5mbyBsb2csIGxvZyBpdFxuICAgICAgICAgICAgaWYgKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGl4aS5qcyBXYXJuaW5nOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgIHByb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNsZWFuIHVwIHNvbWUgc2hhZGVyc1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0U2hhZGVyKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGdsRnJhZ1NoYWRlcik7XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbn1cblByb2dyYW0uVUlEJDMgPSAwO1xuUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKXtcXHJcXG4gICBnbF9GcmFnQ29sb3IgKj0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG59XCI7XG5Qcm9ncmFtLmRlZmF1bHRWZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKXtcXHJcXG4gICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG4gICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXHJcXG59XFxyXFxuXCI7XG5leHBvcnRzLlByb2dyYW0gPSBQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jbGFzcyBQcm9ncmVzc0V2ZW50IGV4dGVuZHMgRXZlbnRfMS5FdmVudCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYnViYmxlcyA9IGZhbHNlLCBjYW5jZWxhYmxlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBQcm9ncmVzc0V2ZW50LmdldFByb2dyZXNzRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XG4gICAgICAgIGV2ZW50LmJ5dGVzTG9hZGVkID0gdGhpcy5ieXRlc0xvYWRlZDtcbiAgICAgICAgZXZlbnQuYnl0ZXNUb3RhbCA9IHRoaXMuYnl0ZXNUb3RhbDtcbiAgICAgICAgZXZlbnQucGVyY2VudCA9IHRoaXMucGVyY2VudDtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBnZXQgaXNEaXNwb3NhYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIGdldFByb2dyZXNzRXZlbnQodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKFByb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHRlID0gUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGVbUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBQcm9ncmVzc0V2ZW50LlByb2dyZXNzRXZlbnRDYWNoZS5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgIHRlLnJlc2V0KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XG4gICAgICAgICAgICByZXR1cm4gdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmVzc0V2ZW50KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLl9sZWdhY3lUYXJnZXQgPSBudWxsO1xuICAgICAgICBsZXQgaW5kZXggPSBQcm9ncmVzc0V2ZW50LlByb2dyZXNzRXZlbnRDYWNoZS5pbmRleE9mKHRoaXMpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBQcm9ncmVzc0V2ZW50LlByb2dyZXNzRXZlbnRDYWNoZS5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUgPSBbXTtcblByb2dyZXNzRXZlbnQuUFJPR1JFU1MgPSBcInByb2dyZXNzXCI7XG5leHBvcnRzLlByb2dyZXNzRXZlbnQgPSBQcm9ncmVzc0V2ZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY2xhc3MgUHJvamVjdGlvblN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdGluYXRpb24gZnJhbWVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvdXJjZSBmcmFtZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgZGVzdGluYXRpb24gZnJhbWVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0RnJhbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvamVjdCBtYXRyaXhcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0cmFuc2Zvcm0gdGhhdCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgICAgICAgKiBpZiBudWxsLCBub3RoaW5nIHdpbGwgYmUgYXBwbGllZFxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcHJvamVjdGlvbiBtYXRyaXggYmFzZWQgb24gYSBwcm9qZWN0aW9uIGZyYW1lICh3aGljaCBpcyBhIHJlY3RhbmdsZSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGRlc3RpbmF0aW9uRnJhbWUgLSBUaGUgZGVzdGluYXRpb24gZnJhbWUuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gc291cmNlRnJhbWUgLSBUaGUgc291cmNlIGZyYW1lLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZXNvbHV0aW9uIC0gUmVzb2x1dGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcm9vdCAtIElmIGlzIHJvb3RcbiAgICAgKi9cbiAgICB1cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZWZhdWx0RnJhbWU7XG4gICAgICAgIHRoaXMuc291cmNlRnJhbWUgPSBzb3VyY2VGcmFtZSB8fCB0aGlzLnNvdXJjZUZyYW1lIHx8IGRlc3RpbmF0aW9uRnJhbWU7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbih0aGlzLmRlc3RpbmF0aW9uRnJhbWUsIHRoaXMuc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpO1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnVwZGF0ZSgpO1xuICAgICAgICAvLyB0aGlzIHdpbGwgd29yayBmb3Igbm93XG4gICAgICAgIC8vIGJ1dCB3b3VsZCBiZSBzd2VldCB0byBzdGljayBhbmQgZXZlbiBvbiB0aGUgZ2xvYmFsIHVuaWZvcm1zLi5cbiAgICAgICAgaWYgKHJlbmRlcmVyLnNoYWRlci5zaGFkZXIpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5zeW5jVW5pZm9ybUdyb3VwKHJlbmRlcmVyLnNoYWRlci5zaGFkZXIudW5pZm9ybXMuZ2xvYmFscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHByb2plY3Rpb24gbWF0cml4IGJhc2VkIG9uIGEgcHJvamVjdGlvbiBmcmFtZSAod2hpY2ggaXMgYSByZWN0YW5nbGUpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBkZXN0aW5hdGlvbkZyYW1lIC0gVGhlIGRlc3RpbmF0aW9uIGZyYW1lLlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHNvdXJjZUZyYW1lIC0gVGhlIHNvdXJjZSBmcmFtZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVzb2x1dGlvbiAtIFJlc29sdXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvb3QgLSBJZiBpcyByb290XG4gICAgICovXG4gICAgY2FsY3VsYXRlUHJvamVjdGlvbihkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSwgcmVzb2x1dGlvbiwgcm9vdCkge1xuICAgICAgICB2YXIgcG0gPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgIC8vIEkgZG9uJ3QgdGhpbmsgd2Ugd2lsbCBuZWVkIHRoaXMgbGluZS4uXG4gICAgICAgIC8vIHBtLmlkZW50aXR5KCk7XG4gICAgICAgIGlmICghcm9vdCkge1xuICAgICAgICAgICAgcG0uYSA9ICgxIC8gZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIDIpICogcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHBtLmQgPSAoMSAvIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogMikgKiByZXNvbHV0aW9uO1xuICAgICAgICAgICAgcG0udHggPSAtMSAtIChzb3VyY2VGcmFtZS54ICogcG0uYSk7XG4gICAgICAgICAgICBwbS50eSA9IC0xIC0gKHNvdXJjZUZyYW1lLnkgKiBwbS5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBtLmEgPSAoMSAvIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiAyKSAqIHJlc29sdXRpb247XG4gICAgICAgICAgICBwbS5kID0gKC0xIC8gZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgKiAyKSAqIHJlc29sdXRpb247XG4gICAgICAgICAgICBwbS50eCA9IC0xIC0gKHNvdXJjZUZyYW1lLnggKiBwbS5hKTtcbiAgICAgICAgICAgIHBtLnR5ID0gMSAtIChzb3VyY2VGcmFtZS55ICogcG0uZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRyYW5zZm9ybSBvZiB0aGUgYWN0aXZlIHJlbmRlciB0YXJnZXQgdG8gdGhlIGdpdmVuIG1hdHJpeFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgICAqL1xuICAgIHNldFRyYW5zZm9ybSgpIHtcbiAgICAgICAgLy8gdGhpcy5fYWN0aXZlUmVuZGVyVGFyZ2V0LnRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5Qcm9qZWN0aW9uU3lzdGVtID0gUHJvamVjdGlvblN5c3RlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0dlb21ldHJ5XCIpO1xuY2xhc3MgUXVhZCBleHRlbmRzIEdlb21ldHJ5XzEuR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKS5hZGRJbmRleChbMCwgMSwgMywgMl0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUXVhZCA9IFF1YWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcbmNvbnN0IEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xuY2xhc3MgUXVhZFV2IGV4dGVuZHMgR2VvbWV0cnlfMS5HZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB2ZXJ0aWNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICAtMSwgLTEsXG4gICAgICAgICAgICAxLCAtMSxcbiAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAtMSwgMVxuICAgICAgICBdKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBVdnMgb2YgdGhlIHF1YWRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgICAgICAgIDAsIDAsXG4gICAgICAgICAgICAxLCAwLFxuICAgICAgICAgICAgMSwgMSxcbiAgICAgICAgICAgIDAsIDFcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih0aGlzLnZlcnRpY2VzKTtcbiAgICAgICAgdGhpcy51dkJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodGhpcy51dnMpO1xuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgdGhpcy52ZXJ0ZXhCdWZmZXIpXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlKCdhVGV4dHVyZUNvb3JkJywgdGhpcy51dkJ1ZmZlcilcbiAgICAgICAgICAgIC5hZGRJbmRleChbMCwgMSwgMiwgMCwgMiwgM10pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXBzIHR3byBSZWN0YW5nbGUgdG8gdGhlIHF1YWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSB0YXJnZXRUZXh0dXJlRnJhbWUgLSB0aGUgZmlyc3QgcmVjdGFuZ2xlXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZGVzdGluYXRpb25GcmFtZSAtIHRoZSBzZWNvbmQgcmVjdGFuZ2xlXG4gICAgICogQHJldHVybiB7UElYSS5RdWFkfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cbiAgICBtYXAodGFyZ2V0VGV4dHVyZUZyYW1lLCBkZXN0aW5hdGlvbkZyYW1lKSB7XG4gICAgICAgIHZhciB4ID0gMDsgLy8gZGVzdGluYXRpb25GcmFtZS54IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoO1xuICAgICAgICB2YXIgeSA9IDA7IC8vIGRlc3RpbmF0aW9uRnJhbWUueSAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMudXZzWzBdID0geDtcbiAgICAgICAgdGhpcy51dnNbMV0gPSB5O1xuICAgICAgICB0aGlzLnV2c1syXSA9IHggKyAoZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aCk7XG4gICAgICAgIHRoaXMudXZzWzNdID0geTtcbiAgICAgICAgdGhpcy51dnNbNF0gPSB4ICsgKGRlc3RpbmF0aW9uRnJhbWUud2lkdGggLyB0YXJnZXRUZXh0dXJlRnJhbWUud2lkdGgpO1xuICAgICAgICB0aGlzLnV2c1s1XSA9IHkgKyAoZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy51dnNbNl0gPSB4O1xuICAgICAgICB0aGlzLnV2c1s3XSA9IHkgKyAoZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgeCA9IGRlc3RpbmF0aW9uRnJhbWUueDtcbiAgICAgICAgeSA9IGRlc3RpbmF0aW9uRnJhbWUueTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1swXSA9IHg7XG4gICAgICAgIHRoaXMudmVydGljZXNbMV0gPSB5O1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzJdID0geCArIGRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XG4gICAgICAgIHRoaXMudmVydGljZXNbM10gPSB5O1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzRdID0geCArIGRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XG4gICAgICAgIHRoaXMudmVydGljZXNbNV0gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMudmVydGljZXNbNl0gPSB4O1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzddID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBsZWdhY3kgdXBsb2FkIG1ldGhvZCwganVzdCBtYXJrcyBidWZmZXJzIGRpcnR5XG4gICAgICogQHJldHVybnMge1BJWEkuUXVhZFV2fSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cbiAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlci5fdXBkYXRlSUQrKztcbiAgICAgICAgdGhpcy51dkJ1ZmZlci5fdXBkYXRlSUQrKztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUXVhZFV2ID0gUXVhZFV2O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NcIik7XG5jbGFzcyBRdWFkcmF0aWNVdGlscyB7XG4gICAgc3RhdGljIGN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKSB7XG4gICAgICAgIHZhciBheCA9IGZyb21YIC0gKDIuMCAqIGNwWCkgKyB0b1g7XG4gICAgICAgIHZhciBheSA9IGZyb21ZIC0gKDIuMCAqIGNwWSkgKyB0b1k7XG4gICAgICAgIHZhciBieCA9ICgyLjAgKiBjcFgpIC0gKDIuMCAqIGZyb21YKTtcbiAgICAgICAgdmFyIGJ5ID0gKDIuMCAqIGNwWSkgLSAoMi4wICogZnJvbVkpO1xuICAgICAgICB2YXIgYSA9IDQuMCAqICgoYXggKiBheCkgKyAoYXkgKiBheSkpO1xuICAgICAgICB2YXIgYiA9IDQuMCAqICgoYXggKiBieCkgKyAoYXkgKiBieSkpO1xuICAgICAgICB2YXIgYyA9IChieCAqIGJ4KSArIChieSAqIGJ5KTtcbiAgICAgICAgdmFyIHMgPSAyLjAgKiBNYXRoLnNxcnQoYSArIGIgKyBjKTtcbiAgICAgICAgdmFyIGEyID0gTWF0aC5zcXJ0KGEpO1xuICAgICAgICB2YXIgYTMyID0gMi4wICogYSAqIGEyO1xuICAgICAgICB2YXIgYzIgPSAyLjAgKiBNYXRoLnNxcnQoYyk7XG4gICAgICAgIHZhciBiYSA9IGIgLyBhMjtcbiAgICAgICAgcmV0dXJuICgoYTMyICogcylcbiAgICAgICAgICAgICsgKGEyICogYiAqIChzIC0gYzIpKVxuICAgICAgICAgICAgKyAoKCg0LjAgKiBjICogYSkgLSAoYiAqIGIpKVxuICAgICAgICAgICAgICAgICogTWF0aC5sb2coKCgyLjAgKiBhMikgKyBiYSArIHMpIC8gKGJhICsgYzIpKSkpIC8gKDQuMCAqIGEzMik7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxuICAgICAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcG9pbnRzIC0gUG9pbnRzIHRvIGFkZCBzZWdtZW50cyB0by5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgdG9YLCB0b1ksIHBvaW50cykge1xuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbiA9IHNldHRpbmdzXzEuc2V0dGluZ3MuR1JBUEhJQ1NfQ1VSVkVTLl9zZWdtZW50c0NvdW50KFF1YWRyYXRpY1V0aWxzLmN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKSk7XG4gICAgICAgIHZhciB4YSA9IDA7XG4gICAgICAgIHZhciB5YSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSkge1xuICAgICAgICAgICAgdmFyIGogPSBpIC8gbjtcbiAgICAgICAgICAgIHhhID0gZnJvbVggKyAoKGNwWCAtIGZyb21YKSAqIGopO1xuICAgICAgICAgICAgeWEgPSBmcm9tWSArICgoY3BZIC0gZnJvbVkpICogaik7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh4YSArICgoKGNwWCArICgodG9YIC0gY3BYKSAqIGopKSAtIHhhKSAqIGopLCB5YSArICgoKGNwWSArICgodG9ZIC0gY3BZKSAqIGopKSAtIHlhKSAqIGopKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlF1YWRyYXRpY1V0aWxzID0gUXVhZHJhdGljVXRpbHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XG5jbGFzcyBSZWN0YW5nbGUge1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueCA9IE51bWJlcih4KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0gTnVtYmVyKHkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpZHRoID0gTnVtYmVyKHdpZHRoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBOdW1iZXIoaGVpZ2h0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuUkVDVFxuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUkVDVDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgbGVmdCBlZGdlIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCByaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSB0b3AgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIGJvdHRvbSBlZGdlIG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIGNvbnN0YW50IGVtcHR5IHJlY3RhbmdsZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEVNUFRZKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IGEgY29weSBvZiB0aGUgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYW5vdGhlciByZWN0YW5nbGUgdG8gdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgY29weUZyb20ocmVjdGFuZ2xlKSB7XG4gICAgICAgIHRoaXMueCA9IHJlY3RhbmdsZS54O1xuICAgICAgICB0aGlzLnkgPSByZWN0YW5nbGUueTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSByZWN0YW5nbGUuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGlzIHJlY3RhbmdsZSB0byBhbm90aGVyIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gY29weSB0by5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gUmV0dXJucyBnaXZlbiBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgY29weVRvKHJlY3RhbmdsZSkge1xuICAgICAgICByZWN0YW5nbGUueCA9IHRoaXMueDtcbiAgICAgICAgcmVjdGFuZ2xlLnkgPSB0aGlzLnk7XG4gICAgICAgIHJlY3RhbmdsZS53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIHJlY3RhbmdsZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgUmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPj0gdGhpcy54ICYmIHggPCB0aGlzLnggKyB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICBpZiAoeSA+PSB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUGFkcyB0aGUgcmVjdGFuZ2xlIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdYIC0gVGhlIGhvcml6b250YWwgcGFkZGluZyBhbW91bnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdZIC0gVGhlIHZlcnRpY2FsIHBhZGRpbmcgYW1vdW50LlxuICAgICAqL1xuICAgIHBhZChwYWRkaW5nWCwgcGFkZGluZ1kpIHtcbiAgICAgICAgcGFkZGluZ1ggPSBwYWRkaW5nWCB8fCAwO1xuICAgICAgICBwYWRkaW5nWSA9IHBhZGRpbmdZIHx8ICgocGFkZGluZ1kgIT09IDApID8gcGFkZGluZ1ggOiAwKTtcbiAgICAgICAgdGhpcy54IC09IHBhZGRpbmdYO1xuICAgICAgICB0aGlzLnkgLT0gcGFkZGluZ1k7XG4gICAgICAgIHRoaXMud2lkdGggKz0gcGFkZGluZ1ggKiAyO1xuICAgICAgICB0aGlzLmhlaWdodCArPSBwYWRkaW5nWSAqIDI7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBGaXRzIHRoaXMgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgcGFzc2VkIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gZml0LlxuICAgICAqL1xuICAgIGZpdChyZWN0YW5nbGUpIHtcbiAgICAgICAgdmFyIHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0YW5nbGUueCk7XG4gICAgICAgIHZhciB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcbiAgICAgICAgdmFyIHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0YW5nbGUueSk7XG4gICAgICAgIHZhciB5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xuICAgICAgICB0aGlzLnggPSB4MTtcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHgyIC0geDEsIDApO1xuICAgICAgICB0aGlzLnkgPSB5MTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh5MiAtIHkxLCAwKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEVubGFyZ2VzIHJlY3RhbmdsZSB0aGF0IHdheSBpdHMgY29ybmVycyBsaWUgb24gZ3JpZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIHJlc29sdXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Vwcz0wLjAwMV0gcHJlY2lzaW9uXG4gICAgICovXG4gICAgY2VpbChyZXNvbHV0aW9uLCBlcHMpIHtcbiAgICAgICAgaWYgKHJlc29sdXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVwcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBlcHMgPSAwLjAwMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeDIgPSBNYXRoLmNlaWwoKHRoaXMueCArIHRoaXMud2lkdGggLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgeTIgPSBNYXRoLmNlaWwoKHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vcigodGhpcy54ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vcigodGhpcy55ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHgyIC0gdGhpcy54O1xuICAgICAgICB0aGlzLmhlaWdodCA9IHkyIC0gdGhpcy55O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRW5sYXJnZXMgdGhpcyByZWN0YW5nbGUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIHJlY3RhbmdsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gaW5jbHVkZS5cbiAgICAgKi9cbiAgICBlbmxhcmdlKHJlY3RhbmdsZSkge1xuICAgICAgICB2YXIgeDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3RhbmdsZS54KTtcbiAgICAgICAgdmFyIHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpO1xuICAgICAgICB2YXIgeTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3RhbmdsZS55KTtcbiAgICAgICAgdmFyIHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XG4gICAgICAgIHRoaXMueCA9IHgxO1xuICAgICAgICB0aGlzLndpZHRoID0geDIgLSB4MTtcbiAgICAgICAgdGhpcy55ID0geTE7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0geTIgLSB5MTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XG5jb25zdCBCYXNlUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVJlbmRlclRleHR1cmVcIik7XG5jbGFzcyBSZW5kZXJUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZV8xLlRleHR1cmUge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VSZW5kZXJUZXh0dXJlID0gbnVsbCwgZnJhbWUgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSk7XG4gICAgICAgIHZhciBfbGVnYWN5UmVuZGVyZXIgPSBudWxsO1xuICAgICAgICBpZiAoIShiYXNlUmVuZGVyVGV4dHVyZSBpbnN0YW5jZW9mIEJhc2VSZW5kZXJUZXh0dXJlXzEuQmFzZVJlbmRlclRleHR1cmUpKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMsIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgc2NhbGVNb2RlID0gYXJndW1lbnRzWzNdO1xuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhcmd1bWVudHNbNF07XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGFuIG9sZCByZW5kZXIgdGV4dHVyZS4uXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oKFwiUGxlYXNlIHVzZSBSZW5kZXJUZXh0dXJlLmNyZWF0ZShcIiArIHdpZHRoICsgXCIsIFwiICsgaGVpZ2h0ICsgXCIpIGluc3RlYWQgb2YgdGhlIGN0b3IgZGlyZWN0bHkuXCIpKTtcbiAgICAgICAgICAgIF9sZWdhY3lSZW5kZXJlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcHJlZmVyLXJlc3QtcGFyYW1zLCBuby1jb25zb2xlICovXG4gICAgICAgICAgICBmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICBiYXNlUmVuZGVyVGV4dHVyZSA9IG5ldyBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgc2NhbGVNb2RlOiBzY2FsZU1vZGUsXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVnYWN5UmVuZGVyZXIgPSBfbGVnYWN5UmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgbGV0IHRoZSByZW5kZXJlciBrbm93IGlmIHRoZSB0ZXh0dXJlIGlzIHZhbGlkLiBJZiBpdCdzIG5vdCB0aGVuIGl0IGNhbm5vdCBiZSByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlsdGVyU3lzdGVtIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckZyYW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICogVGhlIGtleSBmb3IgcG9vbGVkIHRleHR1cmUgb2YgRmlsdGVyU3lzdGVtXG4gICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJQb29sS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgKiBSZXNpemVzIHRoZSBSZW5kZXJUZXh0dXJlLlxuICAgICpcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCB0byByZXNpemUgdG8uXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byByZXNpemUgdG8uXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNpemVCYXNlVGV4dHVyZT10cnVlXSAtIFNob3VsZCB0aGUgYmFzZVRleHR1cmUud2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgYmUgcmVzaXplZCBhcyB3ZWxsP1xuICAgICovXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc2l6ZUJhc2VUZXh0dXJlKSB7XG4gICAgICAgIGlmIChyZXNpemVCYXNlVGV4dHVyZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXNpemVCYXNlVGV4dHVyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcbiAgICAgICAgLy8gVE9ETyAtIGNvdWxkIGJlIG5vdCByZXF1aXJlZC4uXG4gICAgICAgIHRoaXMudmFsaWQgPSAod2lkdGggPiAwICYmIGhlaWdodCA+IDApO1xuICAgICAgICB0aGlzLl9mcmFtZS53aWR0aCA9IHRoaXMub3JpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9mcmFtZS5oZWlnaHQgPSB0aGlzLm9yaWcuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBpZiAocmVzaXplQmFzZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlVXZzKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgcmVuZGVyIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53aWR0aD0xMDBdIC0gVGhlIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTAwXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZSBiZWluZyBnZW5lcmF0ZWRcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlbmRlclRleHR1cmV9IFRoZSBuZXcgcmVuZGVyIHRleHR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKG9wdGlvbnMsIGhlaWdodCA9IG51bGwsIHNjYWxlTW9kZSA9IG51bGwsIHJlc29sdXRpb24gPSBudWxsKSB7XG4gICAgICAgIC8vIGZhbGxiYWNrLCBvbGQtc3R5bGU6IGNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24pXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6IGFyZ3VtZW50c1syXSxcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uOiBhcmd1bWVudHNbM10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlbmRlclRleHR1cmUobmV3IEJhc2VSZW5kZXJUZXh0dXJlXzEuQmFzZVJlbmRlclRleHR1cmUob3B0aW9ucykpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xuY2xhc3MgUmVuZGVyVGV4dHVyZVN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsZWFyIGJhY2tncm91bmQgY29sb3IgYXMgcmdiYVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IHJlbmRlcmVyLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhO1xuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyBwcm9wZXJ0eSBzb21ld2hlcmUgZWxzZSFcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgbWFza3MgZm9yIHRoZSBTdGVuY2lsU3lzdGVtXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NbXX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRNYXNrU3RhY2sgPSBbXTtcbiAgICAgICAgLy8gZW1wdHkgcmVuZGVyIHRleHR1cmU/XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGV4dHVyZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlbmRlclRleHR1cmV9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvdXJjZSBmcmFtZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdGluYXRpb24gZnJhbWVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaW5kIHRoZSBjdXJyZW50IHJlbmRlciB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IHJlbmRlclRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBzb3VyY2VGcmFtZVxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGRlc3RpbmF0aW9uRnJhbWVcbiAgICAgKi9cbiAgICBiaW5kKHJlbmRlclRleHR1cmUsIHNvdXJjZUZyYW1lID0gbnVsbCwgZGVzdGluYXRpb25GcmFtZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKHJlbmRlclRleHR1cmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gcmVuZGVyVGV4dHVyZTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIHJlc29sdXRpb247XG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IGJhc2VUZXh0dXJlLnJlc29sdXRpb247XG4gICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBSZW5kZXJUZXh0dXJlU3lzdGVtLnRlbXBSZWN0LndpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xuICAgICAgICAgICAgICAgIFJlbmRlclRleHR1cmVTeXN0ZW0udGVtcFJlY3QuaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkZyYW1lID0gUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc291cmNlRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VGcmFtZSA9IGRlc3RpbmF0aW9uRnJhbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmZyYW1lYnVmZmVyLmJpbmQoYmFzZVRleHR1cmUuZnJhbWVidWZmZXIsIGRlc3RpbmF0aW9uRnJhbWUpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnVwZGF0ZShkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSwgcmVzb2x1dGlvbiwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnNldE1hc2tTdGFjayhiYXNlVGV4dHVyZS5zdGVuY2lsTWFza1N0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgICAgICAvLyBUT0RPIHRoZXNlIHZhbGlkYXRpb24gY2hlY2tzIGhhcHBlbiBkZWVwZXIgZG93bi4uXG4gICAgICAgICAgICAvLyB0aGluZyB0aGV5IGNhbiBiZSBhdm9pZGVkLi5cbiAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgICAgIFJlbmRlclRleHR1cmVTeXN0ZW0udGVtcFJlY3Qud2lkdGggPSByZW5kZXJlci53aWR0aDtcbiAgICAgICAgICAgICAgICBSZW5kZXJUZXh0dXJlU3lzdGVtLnRlbXBSZWN0LmhlaWdodCA9IHJlbmRlcmVyLmhlaWdodDtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkZyYW1lID0gUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc291cmNlRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VGcmFtZSA9IGRlc3RpbmF0aW9uRnJhbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlci5mcmFtZWJ1ZmZlci5iaW5kKG51bGwsIGRlc3RpbmF0aW9uRnJhbWUpO1xuICAgICAgICAgICAgLy8gVE9ETyBzdG9yZSB0aGlzLi5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi51cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnNldE1hc2tTdGFjayh0aGlzLmRlZmF1bHRNYXNrU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlRnJhbWUuY29weUZyb20oc291cmNlRnJhbWUpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueCA9IGRlc3RpbmF0aW9uRnJhbWUueCAvIHJlc29sdXRpb247XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS55ID0gZGVzdGluYXRpb25GcmFtZS55IC8gcmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHJlc29sdXRpb247XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIHJlc29sdXRpb247XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFcmFzZXMgdGhlIHJlbmRlciB0ZXh0dXJlIGFuZCBmaWxscyB0aGUgZHJhd2luZyBhcmVhIHdpdGggYSBjb2xvdXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IFtjbGVhckNvbG9yXSAtIFRoZSBjb2xvciBhcyByZ2JhLCBkZWZhdWx0IHRvIHVzZSB0aGUgcmVuZGVyZXIgYmFja2dyb3VuZENvbG9yXG4gICAgICogQHJldHVybiB7UElYSS5SZW5kZXJlcn0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgY2xlYXIoY2xlYXJDb2xvciA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgY2xlYXJDb2xvciA9IGNsZWFyQ29sb3IgfHwgdGhpcy5jdXJyZW50LmJhc2VUZXh0dXJlLmNsZWFyQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhckNvbG9yID0gY2xlYXJDb2xvciB8fCB0aGlzLmNsZWFyQ29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5jbGVhcihjbGVhckNvbG9yWzBdLCBjbGVhckNvbG9yWzFdLCBjbGVhckNvbG9yWzJdLCBjbGVhckNvbG9yWzNdKTtcbiAgICB9XG4gICAgO1xuICAgIHJlc2l6ZSgpIHtcbiAgICAgICAgLy8gcmVzaXplIHRoZSByb290IG9ubHkhXG4gICAgICAgIHRoaXMuYmluZChudWxsKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyByZW5kZXJUZXh0dXJlIHN0YXRlXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuYmluZChudWxsKTtcbiAgICB9XG4gICAgO1xufVxuUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcbmV4cG9ydHMuUmVuZGVyVGV4dHVyZVN5c3RlbSA9IFJlbmRlclRleHR1cmVTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFic3RyYWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0UmVuZGVyZXJcIik7XG5jb25zdCBVbmlmb3JtR3JvdXBfMSA9IHJlcXVpcmUoXCIuL1VuaWZvcm1Hcm91cFwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY29uc3QgQmF0Y2hSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vQmF0Y2hSZW5kZXJlclwiKTtcbmNvbnN0IEJhdGNoU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9CYXRjaFN5c3RlbVwiKTtcbmNvbnN0IFJlbmRlclRleHR1cmVTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlbmRlclRleHR1cmVTeXN0ZW1cIik7XG5jb25zdCBGaWx0ZXJTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclN5c3RlbVwiKTtcbmNvbnN0IFRleHR1cmVHQ1N5c3RlbV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZUdDU3lzdGVtXCIpO1xuY29uc3QgUHJvamVjdGlvblN5c3RlbV8xID0gcmVxdWlyZShcIi4vUHJvamVjdGlvblN5c3RlbVwiKTtcbmNvbnN0IFN0ZW5jaWxTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N0ZW5jaWxTeXN0ZW1cIik7XG5jb25zdCBGcmFtZWJ1ZmZlclN5c3RlbV8xID0gcmVxdWlyZShcIi4vRnJhbWVidWZmZXJTeXN0ZW1cIik7XG5jb25zdCBHZW9tZXRyeVN5c3RlbV8xID0gcmVxdWlyZShcIi4vR2VvbWV0cnlTeXN0ZW1cIik7XG5jb25zdCBUZXh0dXJlU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlU3lzdGVtXCIpO1xuY29uc3QgU2hhZGVyU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJTeXN0ZW1cIik7XG5jb25zdCBTdGF0ZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3RhdGVTeXN0ZW1cIik7XG5jb25zdCBDb250ZXh0U3lzdGVtXzEgPSByZXF1aXJlKFwiLi9Db250ZXh0U3lzdGVtXCIpO1xuY29uc3QgTWFza1N5c3RlbV8xID0gcmVxdWlyZShcIi4vTWFza1N5c3RlbVwiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgVGlsaW5nU3ByaXRlUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL1RpbGluZ1Nwcml0ZVJlbmRlcmVyXCIpO1xuY29uc3QgQWNjZXNzaWJpbGl0eU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0FjY2Vzc2liaWxpdHlNYW5hZ2VyXCIpO1xuY29uc3QgRXh0cmFjdF8xID0gcmVxdWlyZShcIi4vRXh0cmFjdFwiKTtcbmNvbnN0IEludGVyYWN0aW9uTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xuY29uc3QgUGFydGljbGVSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vUGFydGljbGVSZW5kZXJlclwiKTtcbmNvbnN0IFByZXBhcmVfMSA9IHJlcXVpcmUoXCIuL1ByZXBhcmVcIik7XG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcbmNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQWJzdHJhY3RSZW5kZXJlcl8xLkFic3RyYWN0UmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoJ1dlYkdMJywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVOREVSRVJfVFlQRS5XRUJHTDtcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSAwO1xuICAgICAgICB0aGlzLnJ1bm5lcnMgPSB7XG4gICAgICAgICAgICBkZXN0cm95OiBuZXcgUnVubmVyXzEuUnVubmVyKCdkZXN0cm95JyksXG4gICAgICAgICAgICBjb250ZXh0Q2hhbmdlOiBuZXcgUnVubmVyXzEuUnVubmVyKCdjb250ZXh0Q2hhbmdlJywgMSksXG4gICAgICAgICAgICByZXNldDogbmV3IFJ1bm5lcl8xLlJ1bm5lcigncmVzZXQnKSxcbiAgICAgICAgICAgIHVwZGF0ZTogbmV3IFJ1bm5lcl8xLlJ1bm5lcigndXBkYXRlJyksXG4gICAgICAgICAgICBwb3N0cmVuZGVyOiBuZXcgUnVubmVyXzEuUnVubmVyKCdwb3N0cmVuZGVyJyksXG4gICAgICAgICAgICBwcmVyZW5kZXI6IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ3ByZXJlbmRlcicpLFxuICAgICAgICAgICAgcmVzaXplOiBuZXcgUnVubmVyXzEuUnVubmVyKCdyZXNpemUnLCAyKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nbG9iYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAoe1xuICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogbmV3IE1hdHJpeF8xLk1hdHJpeCgpLFxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGRTeXN0ZW0oTWFza1N5c3RlbV8xLk1hc2tTeXN0ZW0sICdtYXNrJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oQ29udGV4dFN5c3RlbV8xLkNvbnRleHRTeXN0ZW0sICdjb250ZXh0JylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oU3RhdGVTeXN0ZW1fMS5TdGF0ZVN5c3RlbSwgJ3N0YXRlJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oU2hhZGVyU3lzdGVtXzEuU2hhZGVyU3lzdGVtLCAnc2hhZGVyJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oVGV4dHVyZVN5c3RlbV8xLlRleHR1cmVTeXN0ZW0sICd0ZXh0dXJlJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oR2VvbWV0cnlTeXN0ZW1fMS5HZW9tZXRyeVN5c3RlbSwgJ2dlb21ldHJ5JylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oRnJhbWVidWZmZXJTeXN0ZW1fMS5GcmFtZWJ1ZmZlclN5c3RlbSwgJ2ZyYW1lYnVmZmVyJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oU3RlbmNpbFN5c3RlbV8xLlN0ZW5jaWxTeXN0ZW0sICdzdGVuY2lsJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oUHJvamVjdGlvblN5c3RlbV8xLlByb2plY3Rpb25TeXN0ZW0sICdwcm9qZWN0aW9uJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oVGV4dHVyZUdDU3lzdGVtXzEuVGV4dHVyZUdDU3lzdGVtLCAndGV4dHVyZUdDJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oRmlsdGVyU3lzdGVtXzEuRmlsdGVyU3lzdGVtLCAnZmlsdGVyJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oUmVuZGVyVGV4dHVyZVN5c3RlbV8xLlJlbmRlclRleHR1cmVTeXN0ZW0sICdyZW5kZXJUZXh0dXJlJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oQmF0Y2hTeXN0ZW1fMS5CYXRjaFN5c3RlbSwgJ2JhdGNoJyk7XG4gICAgICAgIHRoaXMuaW5pdFBsdWdpbnMoUmVuZGVyZXIuX19wbHVnaW5zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluaXRGcm9tQ29udGV4dChvcHRpb25zLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluaXRGcm9tT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgICAgICAgICAgYW50aWFsaWFzOiBvcHRpb25zLmFudGlhbGlhcyxcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuICAgICAgICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZTogdGhpcy5vcHRpb25zLnBvd2VyUHJlZmVyZW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyaW5nVG9TY3JlZW4gPSB0cnVlO1xuICAgICAgICAvLyAgICAgc2F5SGVsbG8odGhpcy5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMiA/ICdXZWJHTCAyJyA6ICdXZWJHTCAxJyk7XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMub3B0aW9ucy53aWR0aCwgdGhpcy5vcHRpb25zLmhlaWdodCk7XG4gICAgfVxuICAgIHN0YXRpYyByZWdpc3RlclBsdWdpbihwbHVnaW5OYW1lLCBjdG9yKSB7XG4gICAgICAgIFJlbmRlcmVyLl9fcGx1Z2lucyA9IFJlbmRlcmVyLl9fcGx1Z2lucyB8fCB7fTtcbiAgICAgICAgUmVuZGVyZXIuX19wbHVnaW5zW3BsdWdpbk5hbWVdID0gY3RvcjtcbiAgICB9XG4gICAgO1xuICAgIGluaXRQbHVnaW5zKHN0YXRpY01hcCkge1xuICAgICAgICBmb3IgKHZhciBvIGluIHN0YXRpY01hcCkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dID0gbmV3IChzdGF0aWNNYXBbb10pKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBhZGRTeXN0ZW0oQ2xhc3NSZWYsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gQ2xhc3NSZWYubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3lzdGVtID0gbmV3IENsYXNzUmVmKHRoaXMpO1xuICAgICAgICBpZiAodGhpc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIldob29wcyEgVGhlIG5hbWUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyBhbHJlYWR5IGluIHVzZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tuYW1lXSA9IHN5c3RlbTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJ1bm5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMucnVubmVyc1tpXS5hZGQoc3lzdGVtKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nIGZpbmlzaGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5SZW5kZXJlciNwb3N0cmVuZGVyXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgYmVmb3JlIHJlbmRlcmluZyBzdGFydHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLlJlbmRlcmVyI3ByZXJlbmRlclxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhlIFdlYkdMIGNvbnRleHQgaXMgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5SZW5kZXJlciNjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFdlYkdMIGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8vIHByb3RlY3RlZCBoYW5kbGVDb250ZXh0Q2hhbmdlID0gKGV2ZW50OkV2ZW50KT0+XG4gICAgLy8ge1xuICAgIC8vIFx0dGhpcy5wbHVnaW5zLnBhcnRpY2xlLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxuICAgIC8vIFx0dGhpcy5mcmFtZWJ1ZmZlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcdFx0XG4gICAgLy8gXHR0aGlzLnNoYWRlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcbiAgICAvLyBcdHRoaXMuZ2VvbWV0cnkuY29udGV4dENoYW5nZSgpO1xuICAgIC8vIFx0dGhpcy5zdGF0ZS5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcbiAgICAvLyBcdHRoaXMudGV4dHVyZS5jb250ZXh0Q2hhbmdlKCk7XG4gICAgLy8gXHR0aGlzLmZyYW1lYnVmZmVyLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxuICAgIC8vIFx0dGhpcy5zdGVuY2lsLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxuICAgIC8vIFx0dGhpcy5wcm9qZWN0aW9uLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxuICAgIC8vIFx0dGhpcy50ZXh0dXJlR0MuY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXG4gICAgLy8gXHR0aGlzLmZpbHRlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcbiAgICAvLyBcdHRoaXMucmVuZGVyVGV4dHVyZS5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcbiAgICAvLyBcdHRoaXMuYmF0Y2guY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXG4gICAgLy8gXHR0aGlzLm1hc2suY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpO1xuICAgIC8vIFx0dGhpcy5wbHVnaW5zLmJhdGNoLmNvbnRleHRDaGFuZ2UoKTtcdFx0XG4gICAgLy8gXHR0aGlzLnBsdWdpbnMudGlsaW5nU3ByaXRlLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVx0XHRcbiAgICAvLyB9XG4gICAgcmVuZGVyKGRpc3BsYXlPYmplY3QsIHJlbmRlclRleHR1cmUgPSBudWxsLCBjbGVhciA9IHRydWUsIHRyYW5zZm9ybSA9IG51bGwsIHNraXBVcGRhdGVUcmFuc2Zvcm0gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmluZ1RvU2NyZWVuID0gIXJlbmRlclRleHR1cmU7XG4gICAgICAgIHRoaXMucnVubmVycy5wcmVyZW5kZXIucnVuKCk7XG4gICAgICAgIC8vIHRoaXMuZW1pdCgncHJlcmVuZGVyJyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwicHJlcmVuZGVyXCIpKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pc0xvc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IGRpc3BsYXlPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVQYXJlbnQgPSBkaXNwbGF5T2JqZWN0LnBhcmVudDtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5wYXJlbnQgPSBjYWNoZVBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKTtcbiAgICAgICAgdGhpcy5iYXRjaC5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcbiAgICAgICAgaWYgKGNsZWFyICE9PSB1bmRlZmluZWQgPyBjbGVhciA6IHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BsYXlPYmplY3QucmVuZGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmJhdGNoLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bm5lcnMucG9zdHJlbmRlci5ydW4oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJwb3N0cmVuZGVyXCIpKTtcbiAgICB9XG4gICAgO1xuICAgIHJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyLnJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5ydW5uZXJzLnJlc2l6ZS5ydW4oc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCk7XG4gICAgICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudC5nZXRFdmVudChcInJlc2l6ZVwiKSk7XG4gICAgfVxuICAgIDtcbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5ydW5uZXJzLnJlc2V0LnJ1bigpO1xuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJyZXNldFwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIuYmluZCgpO1xuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyLmNsZWFyKCk7XG4gICAgfVxuICAgIDtcbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucnVubmVycy5kZXN0cm95LnJ1bigpO1xuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJkZXN0cm95XCIpKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cblJlbmRlcmVyLl9fcGx1Z2lucyA9IHt9O1xuZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuY2xhc3MgUmVuZGVyZXJQbHVnaW5zIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLnBhcnRpY2xlID0gbmV3IFBhcnRpY2xlUmVuZGVyZXJfMS5QYXJ0aWNsZVJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy50aWxpbmdTcHJpdGUgPSBuZXcgVGlsaW5nU3ByaXRlUmVuZGVyZXJfMS5UaWxpbmdTcHJpdGVSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgICAgIHRoaXMuYWNjZXNzaWJpbGl0eSA9IG5ldyBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xLkFjY2Vzc2liaWxpdHlNYW5hZ2VyKHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5leHRyYWN0ID0gbmV3IEV4dHJhY3RfMS5FeHRyYWN0KHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBJbnRlcmFjdGlvbk1hbmFnZXJfMS5JbnRlcmFjdGlvbk1hbmFnZXIocmVuZGVyZXIpO1xuICAgICAgICB0aGlzLnByZXBhcmUgPSBuZXcgUHJlcGFyZV8xLlByZXBhcmUocmVuZGVyZXIpO1xuICAgICAgICB0aGlzLmJhdGNoID0gbmV3IEJhdGNoUmVuZGVyZXJfMS5CYXRjaFJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICAgICAgLy8gTG9hZGVyJDIucmVnaXN0ZXJQbHVnaW4oQml0bWFwRm9udExvYWRlcik7XG4gICAgICAgIC8vIExvYWRlciQyLnJlZ2lzdGVyUGx1Z2luKFNwcml0ZXNoZWV0TG9hZGVyKTtcdFxuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcbmNsYXNzIFJlc291cmNlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIHdpZHRoIG9mIHRoZSByZXNvdXJjZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBoZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcmVzb3VyY2UgaGFzIGJlZW4gZGVzdHJveWVkXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB0cnVlYCBpZiByZXNvdXJjZSBpcyBjcmVhdGVkIGJ5IEJhc2VUZXh0dXJlXG4gICAgICAgICAqIHVzZWZ1bCBmb3IgZG9pbmcgY2xlYW51cCB3aXRoIEJhc2VUZXh0dXJlIGRlc3Ryb3lcbiAgICAgICAgICogYW5kIG5vdCBjbGVhbmluZyB1cCByZXNvdXJjZXMgdGhhdCB3ZXJlIGNyZWF0ZWRcbiAgICAgICAgICogZXh0ZXJuYWxseS5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWluaS1ydW5uZXIgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UnVubmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdGhpcy5vblJlc2l6ZSA9IEV2ZW50LmdldEV2ZW50KFwic2V0UmVhbFNpemVcIilcbiAgICAgICAgLy8gUnVubmVyKCdzZXRSZWFsU2l6ZScsIDIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWluaS1ydW5uZXIgZm9yIGhhbmRsaW5nIHVwZGF0ZSBldmVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UnVubmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdGhpcy5vblVwZGF0ZSA9IEV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpXG4gICAgICAgIC8vIG5ldyBSdW5uZXIoJ3VwZGF0ZScpO1xuICAgICAgICB0aGlzLm9uUmVzaXplID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignc2V0UmVhbFNpemUnLCAyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1pbmktcnVubmVyIGZvciBoYW5kbGluZyB1cGRhdGUgZXZlbnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1J1bm5lcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgUnVubmVyXzEuUnVubmVyKCd1cGRhdGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCB0byBhIHBhcmVudCBCYXNlVGV4dHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFBhcmVudCB0ZXh0dXJlXG4gICAgICovXG4gICAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgICAgICB0aGlzLm9uUmVzaXplLmFkZChiYXNlVGV4dHVyZSk7XG4gICAgICAgIHRoaXMub25VcGRhdGUuYWRkKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgLy8gQ2FsbCBhIHJlc2l6ZSBpbW1lZGlhdGUgaWYgd2UgYWxyZWFkeVxuICAgICAgICAvLyBoYXZlIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxuICAgICAgICBpZiAodGhpcy5fd2lkdGggfHwgdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVzaXplLnJ1bih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLm9uUmVzaXplLmFkZChiYXNlVGV4dHVyZSk7XG4gICAgICAgIC8vIHRoaXMub25VcGRhdGUuYWRkKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgLy8gQ2FsbCBhIHJlc2l6ZSBpbW1lZGlhdGUgaWYgd2UgYWxyZWFkeVxuICAgICAgICAvLyBoYXZlIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxuICAgICAgICAvLyBpZiAodGhpcy5fd2lkdGggfHwgdGhpcy5faGVpZ2h0KVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vIFx0dGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50LmdldEV2ZW50KFwic2V0UmVhbFNpemVcIikpXG4gICAgICAgIC8vICAgICAvLyB0aGlzLm9uUmVzaXplLnJ1bih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVW5iaW5kIHRvIGEgcGFyZW50IEJhc2VUZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUGFyZW50IHRleHR1cmVcbiAgICAgKi9cbiAgICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xuICAgICAgICB0aGlzLm9uVXBkYXRlLnJlbW92ZShiYXNlVGV4dHVyZSk7XG4gICAgICAgIC8vIHRoaXMub25SZXNpemUucmVtb3ZlKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgLy8gdGhpcy5vblVwZGF0ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh3aWR0aCAhPT0gdGhpcy5fd2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLm9uUmVzaXplLnJ1bih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwic2V0UmVhbFNpemVcIikpO1xuICAgICAgICAgICAgLy8gRXZlbnQuZ2V0RXZlbnQoXCJzZXRSZWFsU2l6ZVwiKVxuICAgICAgICAgICAgLy8gdGhpcy5vblJlc2l6ZS5ydW4od2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhcyBiZWVuIHZhbGlkYXRlZFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl93aWR0aCAmJiAhIXRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhcyBiZWVuIHVwZGF0ZWQgdHJpZ2dlciBldmVudFxuICAgICAqL1xuICAgIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIHRvIHN0YXJ0IHByZWxvYWRpbmcgYSByZXNvdXJjZVxuICAgICAqIG9yIGRvIGFueSBvdGhlciBwcmVwYXJlIHN0ZXAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIHRleHR1cmUgb3IgcmV0dXJucyBmYWxzZSBpZiBpdCBjYW50IGZvciBzb21lIHJlYXNvbi4gT3ZlcnJpZGUgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB5ZWFoLCByZW5kZXJlciFcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmUgLSB0ZXh0dXJlIGluc3RhbmNlIGZvciB0aGlzIHdlYmdsIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAgICovXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdHlsZSwgb3B0aW9uYWwgdG8gb3ZlcnJpZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB5ZWFoLCByZW5kZXJlciFcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmUgLSB0ZXh0dXJlIGluc3RhbmNlIGZvciB0aGlzIHdlYmdsIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlzIHN1Y2Nlc3NcbiAgICAgKi9cbiAgICBzdHlsZShyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCBhbnl0aGluZywgdGhpcyBoYXBwZW5zIHdoZW4gZGVzdHJveWluZyBpcyByZWFkeS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICAvLyBvdmVycmlkZVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FsbCB3aGVuIGRlc3Ryb3lpbmcgcmVzb3VyY2UsIHVuYmluZCBhbnkgQmFzZVRleHR1cmUgb2JqZWN0XG4gICAgICogYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFzIHJlZmVyZW5jZSBjb3VudHMgYXJlIG1haW50YWluZWRcbiAgICAgKiBpbnRlcm5hbGx5LlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25SZXNpemUucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLm9uUmVzaXplID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLm9uVXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUmVzb3VyY2UgPSBSZXNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jb25zdCBQcm9ncmVzc0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0V2ZW50XCIpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jbGFzcyBSZXNvdXJjZUxvYWRlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocmVxdWVzdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBMb2dnZXJfMS50cmFjZShcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSB3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5faW1hZ2VFbGVtZW50LCAwLCAwLCB0aGlzLl9pbWFnZUVsZW1lbnQud2lkdGgsIHRoaXMuX2ltYWdlRWxlbWVudC5oZWlnaHQpO1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKHRoaXMub25JbWFnZUJpdG1hcENyZWF0ZWQpLmNhdGNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25JbWFnZUJpdG1hcENyZWF0ZWQgPSAoaW1hZ2UpID0+IHtcbiAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKFwib25JbWFnZUJpdG1hcENyZWF0ZWRcIik7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZURhdGEgPSBpbWFnZTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25UaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hYm9ydCgnTG9hZCB0aW1lZCBvdXQuJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX29uUHJvZ3Jlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudCAmJiBldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBlID0gUHJvZ3Jlc3NFdmVudF8xLlByb2dyZXNzRXZlbnQuZ2V0UHJvZ3Jlc3NFdmVudChQcm9ncmVzc0V2ZW50XzEuUHJvZ3Jlc3NFdmVudC5QUk9HUkVTUyk7XG4gICAgICAgICAgICAgICAgcGUuYnl0ZXNMb2FkZWQgPSBldmVudC5sb2FkZWQ7XG4gICAgICAgICAgICAgICAgcGUuYnl0ZXNUb3RhbCA9IGV2ZW50LnRvdGFsO1xuICAgICAgICAgICAgICAgIHBlLnBlcmNlbnQgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9vbkVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFib3J0KCdGYWlsZWQgdG8gbG9hZCBlbGVtZW50IHVzaW5nOiAnICsgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuX2ZsYWdzID0gMDtcbiAgICAgICAgdGhpcy5fc2V0RmxhZyhSZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MuREFUQV9VUkwsIHRoaXMuX3JlcXVlc3QudXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IHRoaXMuX2dldEV4dGVuc2lvbigpO1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gcmVxdWVzdC5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICdhbm9ueW1vdXMnIDogXCJcIjtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0IHx8IDA7XG4gICAgICAgIHRoaXMubG9hZFR5cGUgPSB0aGlzLl9kZXRlcm1pbmVMb2FkVHlwZSgpO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLlVOS05PV047XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDaHVuayA9IDA7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lciA9IDA7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSByZXF1ZXN0LnJlcXVlc3RNZXRhRGF0YTtcbiAgICAgICAgdGhpcy54aHJUeXBlID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyB0aGlzLl9kZXF1ZXVlID0gUmVzb3VyY2VMb2FkZXIuX25vb3A7XG4gICAgICAgIC8vIHRoaXMuX29uTG9hZEJpbmRpbmcgPSBudWxsO1xuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNPTVBMRVRFKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RmxhZyhSZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MuTE9BRElORywgdHJ1ZSk7XG4gICAgICAgIGlmICghdGhpcy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHRoaXMuX2RldGVybWluZUNyb3NzT3JpZ2luKHRoaXMuX3JlcXVlc3QudXJsKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMubG9hZFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFOlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuSU1BR0U7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZEVsZW1lbnQoJ2ltYWdlJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5BVURJTzpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLkFVRElPO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2xvYWRTb3VyY2VFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuVklERU86XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2VMb2FkZXIuVFlQRS5WSURFTztcbiAgICAgICAgICAgICAgICAvLyB0aGlzLl9sb2FkU291cmNlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLlhIUjpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKFJlc291cmNlTG9hZGVyLnVzZVhkciAmJiB0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRYZHIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRYaHIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gX2xvYWRTb3VyY2VFbGVtZW50XG4gICAgICAgIC8vIF9sb2FkWGRyXG4gICAgICAgIC8vIF9sb2FkWGhyXG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBlbGVtZW50IHRoYXQgaGFzIG11bHRpcGxlIHNvdXJjZXMsXG4gICAgICogbGlrZSBhbiBIVE1MQXVkaW9FbGVtZW50IG9yIEhUTUxWaWRlb0VsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZWxlbWVudCB0byB1c2UuXG4gICAgICovXG4gICAgLy8gcHJvdGVjdGVkIF9sb2FkU291cmNlRWxlbWVudCh0eXBlKTp2b2lkXG4gICAgLy8ge1xuICAgIC8vICAgICBpZiAodGhpcy5tZXRhZGF0YS5sb2FkRWxlbWVudCkgXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMubWV0YWRhdGEubG9hZEVsZW1lbnQ7XG4gICAgLy8gICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiB0eXBlb2Ygd2luZG93WydBdWRpbyddICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEF1ZGlvKCk7XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICB0aGlzLmRhdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmICh0aGlzLmRhdGEgPT09IG51bGwpIHtcbiAgICAvLyAgICAgICAgIHRoaXMuYWJvcnQoJ1Vuc3VwcG9ydGVkIGVsZW1lbnQ6ICcgKyB0eXBlKTtcbiAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZiAodGhpcy5jcm9zc09yaWdpbikge1xuICAgIC8vICAgICAgICAgdGhpcy5kYXRhLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZiAoIXRoaXMubWV0YWRhdGEuc2tpcFNvdXJjZSkge1xuICAgIC8vICAgICAgICAgLy8gc3VwcG9ydCBmb3IgQ29jb29uSlMgQ2FudmFzKyBydW50aW1lLCBsYWNrcyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKVxuICAgIC8vICAgICAgICAgaWYgKG5hdmlnYXRvclsnaXNDb2Nvb25KUyddKSB7XG4gICAgLy8gICAgICAgICAgICAgdGhpcy5kYXRhLnNyYyA9IEFycmF5LmlzQXJyYXkodGhpcy5fcmVxdWVzdC51cmwpID8gdGhpcy5fcmVxdWVzdC51cmxbMF0gOiB0aGlzLl9yZXF1ZXN0LnVybDtcbiAgICAvLyAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9yZXF1ZXN0LnVybCkpIHtcbiAgICAvLyAgICAgICAgICAgICB2YXIgbWltZVR5cGVzID0gdGhpcy5tZXRhZGF0YS5taW1lVHlwZTtcbiAgICAvLyAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3JlcXVlc3QudXJsLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTb3VyY2UodHlwZSwgdGhpcy5fcmVxdWVzdC51cmxbaV0sIEFycmF5LmlzQXJyYXkobWltZVR5cGVzKSA/IG1pbWVUeXBlc1tpXSA6IG1pbWVUeXBlcykpO1xuICAgIC8vICAgICAgICAgICAgIH1cbiAgICAvLyAgICAgICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICAgICAgdmFyIF9taW1lVHlwZXMgPSB0aGlzLm1ldGFkYXRhLm1pbWVUeXBlO1xuICAgIC8vICAgICAgICAgICAgIHRoaXMuZGF0YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTb3VyY2UodHlwZSwgdGhpcy5fcmVxdWVzdC51cmwsIEFycmF5LmlzQXJyYXkoX21pbWVUeXBlcykgPyBfbWltZVR5cGVzWzBdIDogX21pbWVUeXBlcykpO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kT25FcnJvciwgZmFsc2UpO1xuICAgIC8vICAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kQ29tcGxldGUsIGZhbHNlKTtcbiAgICAvLyAgICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XG4gICAgLy8gICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuX2JvdW5kQ29tcGxldGUsIGZhbHNlKTtcbiAgICAvLyAgICAgdGhpcy5kYXRhLmxvYWQoKTtcbiAgICAvLyAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgIC8vICAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9ib3VuZE9uVGltZW91dCwgdGhpcy50aW1lb3V0KTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH07XG4gICAgX2NsZWFyRXZlbnRzKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZWxlbWVudFRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuX2ltYWdlRWxlbWVudCAmJiB0aGlzLl9pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25FcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuY29tcGxldGUpO1xuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fb25Qcm9ncmVzcyk7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLmNvbXBsZXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy54aHIpIHtcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZFhock9uRXJyb3IsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1lb3V0JywgdGhpcy5fYm91bmRYaHJPblRpbWVvdXQsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRoaXMuX2JvdW5kWGhyT25BYm9ydCwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kWGhyT25Mb2FkLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIub25wcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgX2xvYWRFbGVtZW50KHR5cGUpIHtcbiAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJfbG9hZEVsZW1lbnQgXCIgKyB0eXBlKTtcbiAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgICAgaWYgKHRoaXMuY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnNyYyA9IHRoaXMuX3JlcXVlc3QudXJsO1xuICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vbkVycm9yKTtcbiAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmNvbXBsZXRlKTtcbiAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fb25Qcm9ncmVzcyk7XG4gICAgICAgIC8vIGlmICh0aGlzLnRpbWVvdXQgPiAwKSBcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdGhpcy5fZWxlbWVudFRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIHRoaXMudGltZW91dCk7XG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgO1xuICAgIGdldCBpbWFnZURhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZURhdGE7XG4gICAgfVxuICAgIGFib3J0KG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9jbGVhckV2ZW50cygpO1xuICAgICAgICBpZiAodGhpcy54aHIpIHtcbiAgICAgICAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy54ZHIpIHtcbiAgICAgICAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLnNyYykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcmMgPSBSZXNvdXJjZUxvYWRlci5FTVBUWV9HSUY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5kYXRhLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLnJlbW92ZUNoaWxkKHRoaXMuZGF0YS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmluaXNoKCk7XG4gICAgfVxuICAgIDtcbiAgICBfZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RmxhZyhSZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MuQ09NUExFVEUsIHRydWUpO1xuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5MT0FESU5HLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ09NUExFVEUpKTtcbiAgICB9XG4gICAgO1xuICAgIF9kZXRlcm1pbmVDcm9zc09yaWdpbih1cmwsIGxvYyA9IG51bGwpIHtcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvd1snb3JpZ2luJ10gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAnYW5vbnltb3VzJztcbiAgICAgICAgfVxuICAgICAgICBsb2MgPSBsb2MgfHwgd2luZG93LmxvY2F0aW9uO1xuICAgICAgICBpZiAoIVJlc291cmNlTG9hZGVyLnRlbXBBbmNob3IpIHtcbiAgICAgICAgICAgIFJlc291cmNlTG9hZGVyLnRlbXBBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVzb3VyY2VMb2FkZXIudGVtcEFuY2hvci5ocmVmID0gdXJsO1xuICAgICAgICBsZXQgdXJpID0gUmVzb3VyY2VMb2FkZXIucGFyc2VVcmkoUmVzb3VyY2VMb2FkZXIudGVtcEFuY2hvci5ocmVmLCB0cnVlKTtcbiAgICAgICAgbGV0IHNhbWVQb3J0ID0gIXVyaS5wb3J0ICYmIGxvYy5wb3J0ID09PSAnJyB8fCB1cmkucG9ydCA9PT0gbG9jLnBvcnQ7XG4gICAgICAgIGxldCBwcm90b2NvbCA9IHVyaS5wcm90b2NvbCA/IHVyaS5wcm90b2NvbCArICc6JyA6ICcnO1xuICAgICAgICBpZiAodXJpLmhvc3QgIT09IGxvYy5ob3N0bmFtZSB8fCAhc2FtZVBvcnQgfHwgcHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgO1xuICAgIHN0YXRpYyBwYXJzZVVyaShzdHIsIHN0cmljdCA9IHRydWUpIHtcbiAgICAgICAgbGV0IG8gPSB7XG4gICAgICAgICAgICBrZXk6IFsnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvciddLFxuICAgICAgICAgICAgcToge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdxdWVyeUtleScsXG4gICAgICAgICAgICAgICAgcGFyc2VyOiAvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2dcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJzZXI6IHtcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oKCgoPzpbXj8jXFwvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS8sXG4gICAgICAgICAgICAgICAgbG9vc2U6IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKFteOlxcLz8jLl0rKTopPyg/OlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pL1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgbSA9IG8ucGFyc2VyW3N0cmljdCA/ICdzdHJpY3QnIDogJ2xvb3NlJ10uZXhlYyhzdHIpO1xuICAgICAgICBsZXQgdXJpID0gbmV3IFVSSURhdGEoKTtcbiAgICAgICAgdXJpLnNvdXJjZSA9IG1bXCJzb3VyY2VcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5wcm90b2NvbCA9IG1bXCJwcm90b2NvbFwiXSB8fCAnJztcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IG1bXCJhdXRob3JpdHlcIl0gfHwgJyc7XG4gICAgICAgIHVyaS51c2VySW5mbyA9IG1bXCJ1c2VySW5mb1wiXSB8fCAnJztcbiAgICAgICAgdXJpLnVzZXIgPSBtW1widXNlclwiXSB8fCAnJztcbiAgICAgICAgdXJpLnBhc3N3b3JkID0gbVtcInBhc3N3b3JkXCJdIHx8ICcnO1xuICAgICAgICB1cmkuaG9zdCA9IG1bXCJob3N0XCJdIHx8ICcnO1xuICAgICAgICB1cmkucG9ydCA9IG1bXCJwb3J0XCJdIHx8ICcnO1xuICAgICAgICB1cmkucmVsYXRpdmUgPSBtW1wicmVsYXRpdmVcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5wYXRoID0gbVtcInBhdGhcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5kaXJlY3RvcnkgPSBtW1wiZGlyZWN0b3J5XCJdIHx8ICcnO1xuICAgICAgICB1cmkuZmlsZSA9IG1bXCJmaWxlXCJdIHx8ICcnO1xuICAgICAgICB1cmkucXVlcnkgPSBtW1wicXVlcnlcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5hbmNob3IgPSBtW1wiYW5jaG9yXCJdIHx8ICcnO1xuICAgICAgICB1cmlbby5xLm5hbWVdID0ge307XG4gICAgICAgIHVyaVtvLmtleVsxMl1dLnJlcGxhY2Uoby5xLnBhcnNlciwgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcbiAgICAgICAgICAgIGlmICgkMSkge1xuICAgICAgICAgICAgICAgIHVyaVtvLnEubmFtZV1bJDFdID0gJDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgIH1cbiAgICA7XG4gICAgX2RldGVybWluZUxvYWRUeXBlKCkge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXIuX2xvYWRUeXBlTWFwW3RoaXMuZXh0ZW5zaW9uXSB8fCBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuWEhSO1xuICAgIH1cbiAgICA7XG4gICAgX2dldEV4dGVuc2lvbigpIHtcbiAgICAgICAgbGV0IHVybCA9IHRoaXMuX3JlcXVlc3QudXJsO1xuICAgICAgICBsZXQgZXh0ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmlzRGF0YVVybCkge1xuICAgICAgICAgICAgbGV0IHNsYXNoSW5kZXggPSB1cmwuaW5kZXhPZignLycpO1xuICAgICAgICAgICAgZXh0ID0gdXJsLnN1YnN0cmluZyhzbGFzaEluZGV4ICsgMSwgdXJsLmluZGV4T2YoJzsnLCBzbGFzaEluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XG4gICAgICAgICAgICBsZXQgaGFzaFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IE1hdGgubWluKHF1ZXJ5U3RhcnQgPiAtMSA/IHF1ZXJ5U3RhcnQgOiB1cmwubGVuZ3RoLCBoYXNoU3RhcnQgPiAtMSA/IGhhc2hTdGFydCA6IHVybC5sZW5ndGgpO1xuICAgICAgICAgICAgdXJsID0gdXJsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICBleHQgPSB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZignLicpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICA7XG4gICAgX2hhc0ZsYWcoZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgZmxhZykgIT09IDA7XG4gICAgfVxuICAgIDtcbiAgICBfc2V0RmxhZyhmbGFnLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mbGFncyA9IHZhbHVlID8gdGhpcy5fZmxhZ3MgfCBmbGFnIDogdGhpcy5fZmxhZ3MgJiB+ZmxhZztcbiAgICB9XG4gICAgO1xuICAgIHN0YXRpYyBzZXRFeHRNYXAobWFwLCBleHRuYW1lLCB2YWwpIHtcbiAgICAgICAgaWYgKGV4dG5hbWUgJiYgZXh0bmFtZS5pbmRleE9mKCcuJykgPT09IDApIHtcbiAgICAgICAgICAgIGV4dG5hbWUgPSBleHRuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4dG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBtYXBbZXh0bmFtZV0gPSB2YWw7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRFeHRlbnNpb25Mb2FkVHlwZShleHRuYW1lLCBsb2FkVHlwZSkge1xuICAgICAgICBSZXNvdXJjZUxvYWRlci5zZXRFeHRNYXAoUmVzb3VyY2VMb2FkZXIuX2xvYWRUeXBlTWFwLCBleHRuYW1lLCBsb2FkVHlwZSk7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0aWMgc2V0RXh0ZW5zaW9uWGhyVHlwZShleHRuYW1lLCB4aHJUeXBlKSB7XG4gICAgICAgIFJlc291cmNlTG9hZGVyLnNldEV4dE1hcChSZXNvdXJjZUxvYWRlci5feGhyVHlwZU1hcCwgZXh0bmFtZSwgeGhyVHlwZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBRdWljayBoZWxwZXIgdG8gZ2V0IHN0cmluZyB4aHIgdHlwZS5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0fFhEb21haW5SZXF1ZXN0fSB4aHIgLSBUaGUgcmVxdWVzdCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0eXBlLlxuICAgICAqL1xuICAgIHN0YXRpYyByZXFUeXBlKHhocikge1xuICAgICAgICByZXR1cm4geGhyLnRvU3RyaW5nKCkucmVwbGFjZSgnb2JqZWN0ICcsICcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gWE1MSHR0cFJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9sb2FkWGhyKCkge1xuICAgICAgICAvLyAvLyBpZiB1bnNldCwgZGV0ZXJtaW5lIHRoZSB2YWx1ZVxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMueGhyVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gICAgIHRoaXMueGhyVHlwZSA9IHRoaXMuX2RldGVybWluZVhoclR5cGUoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgLy8gLy8gc2V0IHRoZSByZXF1ZXN0IHR5cGUgYW5kIHVybFxuICAgICAgICAvLyB4aHIub3BlbignR0VUJywgdGhpcy5fcmVxdWVzdC51cmwsIHRydWUpO1xuICAgICAgICAvLyB4aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgLy8gLy8gbG9hZCBqc29uIGFzIHRleHQgYW5kIHBhcnNlIGl0IG91cnNlbHZlcy4gV2UgZG8gdGhpcyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgLy8gLy8gKmNvdWdoKiBzYWZhcmkgKmNvdWdoKiBjYW4ndCBkZWFsIHdpdGggaXQuXG4gICAgICAgIC8vIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkpTT04gfHwgdGhpcy54aHJUeXBlID09PSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCkge1xuICAgICAgICAvLyAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IDxhbnk+UmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLnhoclR5cGU7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8geGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRYaHJPbkVycm9yLCBmYWxzZSk7XG4gICAgICAgIC8vIHhoci5hZGRFdmVudExpc3RlbmVyKCd0aW1lb3V0JywgdGhpcy5fYm91bmRYaHJPblRpbWVvdXQsIGZhbHNlKTtcbiAgICAgICAgLy8geGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0LCBmYWxzZSk7XG4gICAgICAgIC8vIHhoci5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX2JvdW5kT25Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgICAvLyB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kWGhyT25Mb2FkLCBmYWxzZSk7XG4gICAgICAgIC8vIHhoci5zZW5kKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBYRG9tYWluUmVxdWVzdC4gVGhpcyBpcyBoZXJlIGJlY2F1c2Ugd2UgbmVlZCB0byBzdXBwb3J0IElFOSAoZ3Jvc3MpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbG9hZFhkcigpIHtcbiAgICAgICAgLy8gLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcbiAgICAgICAgLy8gaWYgKHR5cGVvZiB0aGlzLnhoclR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnhoclR5cGUgPSB0aGlzLl9kZXRlcm1pbmVYaHJUeXBlKCk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gdmFyIHhkciA9IHRoaXMueGhyID0gbmV3IHdpbmRvd1snWERvbWFpblJlcXVlc3QnXSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICAgIC8vIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZldyBxdWlya3MuIE9jY2FzaW9uYWxseSBpdCB3aWxsIGFib3J0IHJlcXVlc3RzXG4gICAgICAgIC8vIC8vIEEgd2F5IHRvIGF2b2lkIHRoaXMgaXMgdG8gbWFrZSBzdXJlIEFMTCBjYWxsYmFja3MgYXJlIHNldCBldmVuIGlmIG5vdCB1c2VkXG4gICAgICAgIC8vIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE1Nzg2OTY2L3hkb21haW5yZXF1ZXN0LWFib3J0cy1wb3N0LW9uLWllLTlcbiAgICAgICAgLy8geGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQgfHwgNTAwMDsgLy8gWERSIG5lZWRzIGEgdGltZW91dCB2YWx1ZSBvciBpdCBicmVha3MgaW4gSUU5XG4gICAgICAgIC8vIHhkci5vbmVycm9yID0gdGhpcy5fYm91bmRYaHJPbkVycm9yO1xuICAgICAgICAvLyB4ZHIub250aW1lb3V0ID0gdGhpcy5fYm91bmRYaHJPblRpbWVvdXQ7XG4gICAgICAgIC8vIHhkci5vbnByb2dyZXNzID0gdGhpcy5fYm91bmRPblByb2dyZXNzO1xuICAgICAgICAvLyB4ZHIub25sb2FkID0gdGhpcy5fYm91bmRYaHJPbkxvYWQ7XG4gICAgICAgIC8vIHhkci5vcGVuKCdHRVQnLCB0aGlzLl9yZXF1ZXN0LnVybCwgdHJ1ZSk7XG4gICAgICAgIC8vIC8vIE5vdGU6IFRoZSB4ZHIuc2VuZCgpIGNhbGwgaXMgd3JhcHBlZCBpbiBhIHRpbWVvdXQgdG8gcHJldmVudCBhblxuICAgICAgICAvLyAvLyBpc3N1ZSB3aXRoIHRoZSBpbnRlcmZhY2Ugd2hlcmUgc29tZSByZXF1ZXN0cyBhcmUgbG9zdCBpZiBtdWx0aXBsZVxuICAgICAgICAvLyAvLyBYRG9tYWluUmVxdWVzdHMgYXJlIGJlaW5nIHNlbnQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgICAgLy8gLy8gU29tZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvaXNzdWVzLzEyNDhcbiAgICAgICAgLy8gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4geGRyLnNlbmQoKTtcbiAgICAgICAgLy8gfSwgMSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc291cmNlIHVzZWQgaW4gbG9hZGluZyB2aWEgYW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZWxlbWVudCB0eXBlICh2aWRlbyBvciBhdWRpbykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBzb3VyY2UgVVJMIHRvIGxvYWQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21pbWVdIC0gVGhlIG1pbWUgdHlwZSBvZiB0aGUgdmlkZW9cbiAgICAgKiBAcmV0dXJuIHtIVE1MU291cmNlRWxlbWVudH0gVGhlIHNvdXJjZSBlbGVtZW50LlxuICAgICAqL1xuICAgIF9jcmVhdGVTb3VyY2UodHlwZSwgdXJsLCBtaW1lKSB7XG4gICAgICAgIC8vIGlmICghbWltZSkge1xuICAgICAgICAvLyAgICAgbWltZSA9IHR5cGUgKyAnLycgKyB0aGlzLl9nZXRFeHRlbnNpb24odXJsKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB2YXIgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG4gICAgICAgIC8vIHNvdXJjZS5zcmMgPSB1cmw7XG4gICAgICAgIC8vIHNvdXJjZS50eXBlID0gbWltZTtcbiAgICAgICAgLy8gcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBpZiBhbiBlcnJvciBldmVudCBmaXJlcyBmb3IgeGhyL3hkci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3hock9uRXJyb3IoKSB7XG4gICAgICAgIHZhciB4aHIgPSB0aGlzLnhocjtcbiAgICAgICAgdGhpcy5hYm9ydChSZXNvdXJjZUxvYWRlci5yZXFUeXBlKHhocikgKyAnIFJlcXVlc3QgZmFpbGVkLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzICsgJywgdGV4dDogXCInICsgeGhyLnN0YXR1c1RleHQgKyAnXCInKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBpZiBhbiBlcnJvciBldmVudCBmaXJlcyBmb3IgeGhyL3hkci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3hock9uVGltZW91dCgpIHtcbiAgICAgICAgdmFyIHhociA9IHRoaXMueGhyO1xuICAgICAgICB0aGlzLmFib3J0KFJlc291cmNlTG9hZGVyLnJlcVR5cGUoeGhyKSArICcgUmVxdWVzdCB0aW1lZCBvdXQuJyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgaWYgYW4gYWJvcnQgZXZlbnQgZmlyZXMgZm9yIHhoci94ZHIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF94aHJPbkFib3J0KCkge1xuICAgICAgICB2YXIgeGhyID0gdGhpcy54aHI7XG4gICAgICAgIHRoaXMuYWJvcnQoUmVzb3VyY2VMb2FkZXIucmVxVHlwZSh4aHIpICsgJyBSZXF1ZXN0IHdhcyBhYm9ydGVkIGJ5IHRoZSB1c2VyLicpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gZGF0YSBzdWNjZXNzZnVsbHkgbG9hZHMgZnJvbSBhbiB4aHIveGRyIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3RMb2FkRXZlbnR8RXZlbnR9IGV2ZW50IC0gTG9hZCBldmVudFxuICAgICAqL1xuICAgIF94aHJPbkxvYWQoKSB7XG4gICAgICAgIC8vIHZhciB4aHIgPSB0aGlzLnhocjtcbiAgICAgICAgLy8gdmFyIHRleHQgPSAnJztcbiAgICAgICAgLy8gdmFyIHN0YXR1cyA9IHR5cGVvZiB4aHIuc3RhdHVzID09PSAndW5kZWZpbmVkJyA/IFJlc291cmNlTG9hZGVyLlNUQVRVU19PSyA6IHhoci5zdGF0dXM7IC8vIFhEUiBoYXMgbm8gYC5zdGF0dXNgLCBhc3N1bWUgMjAwLlxuICAgICAgICAvLyAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIC8vIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgdHlwZW9mIHhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vICAgICB0ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyAvLyBzdGF0dXMgY2FuIGJlIDAgd2hlbiB1c2luZyB0aGUgYGZpbGU6Ly9gIHByb3RvY29sIHNvIHdlIGFsc28gY2hlY2sgaWYgYSByZXNwb25zZSBpcyBzZXQuXG4gICAgICAgIC8vIC8vIElmIGl0IGhhcyBhIHJlc3BvbnNlLCB3ZSBhc3N1bWUgMjAwOyBvdGhlcndpc2UgYSAwIHN0YXR1cyBjb2RlIHdpdGggbm8gY29udGVudHMgaXMgYW4gYWJvcnRlZCByZXF1ZXN0LlxuICAgICAgICAvLyBpZiAoc3RhdHVzID09PSBSZXNvdXJjZUxvYWRlci5TVEFUVVNfTk9ORSAmJiAodGV4dC5sZW5ndGggPiAwIHx8IHhoci5yZXNwb25zZVR5cGUgPT09IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUikpIHtcbiAgICAgICAgLy8gICAgIHN0YXR1cyA9IFJlc291cmNlTG9hZGVyLlNUQVRVU19PSztcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyAvLyBoYW5kbGUgSUU5IGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDA0Njk3Mi9tc2llLXJldHVybnMtc3RhdHVzLWNvZGUtb2YtMTIyMy1mb3ItYWpheC1yZXF1ZXN0XG4gICAgICAgIC8vIGVsc2UgaWYgKHN0YXR1cyA9PT0gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0lFX0JVR19FTVBUWSkge1xuICAgICAgICAvLyAgICAgICAgIHN0YXR1cyA9IFJlc291cmNlTG9hZGVyLlNUQVRVU19FTVBUWTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gdmFyIHN0YXR1c1R5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xuICAgICAgICAvLyBpZiAoc3RhdHVzVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX1RZUEVfT0spIHtcbiAgICAgICAgLy8gICAgIC8vIGlmIHRleHQsIGp1c3QgcmV0dXJuIGl0XG4gICAgICAgIC8vICAgICBpZiAodGhpcy54aHJUeXBlID09PSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhUKSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5kYXRhID0gdGV4dDtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLlRFWFQ7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICAvLyBpZiBqc29uLCBwYXJzZSBpbnRvIGpzb24gb2JqZWN0XG4gICAgICAgIC8vICAgICBlbHNlIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkpTT04pIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLkpTT047XG4gICAgICAgIC8vICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBsb2FkZWQganNvbjogJyArIGUpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgIC8vIGlmIHhtbCwgcGFyc2UgaW50byBhbiB4bWwgZG9jdW1lbnQgb3IgZGl2IGVsZW1lbnRcbiAgICAgICAgLy8gICAgICAgICBlbHNlIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3dbJ0RPTVBhcnNlciddKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21wYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRvbXBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgJ3RleHQveG1sJyk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGV4dDtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGl2O1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLlhNTDtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgbG9hZGVkIHhtbDogJyArIGUpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgICAgICAvLyBvdGhlciB0eXBlcyBqdXN0IHJldHVybiB0aGUgcmVzcG9uc2VcbiAgICAgICAgLy8gICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0geGhyLnJlc3BvbnNlIHx8IHRleHQ7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICB0aGlzLmFib3J0KCdbJyArIHhoci5zdGF0dXMgKyAnXSAnICsgeGhyLnN0YXR1c1RleHQgKyAnOiAnICsgeGhyLnJlc3BvbnNlVVJMKTtcbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSByZXNwb25zZVR5cGUgb2YgYW4gWEhSIHJlcXVlc3QgYmFzZWQgb24gdGhlIGV4dGVuc2lvbiBvZiB0aGVcbiAgICAgKiByZXNvdXJjZSBiZWluZyBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSBUaGUgcmVzcG9uc2VUeXBlIHRvIHVzZS5cbiAgICAgKi9cbiAgICBfZGV0ZXJtaW5lWGhyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlc291cmNlTG9hZGVyLl94aHJUeXBlTWFwW3RoaXMuZXh0ZW5zaW9uXSB8fCBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhUO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbG9hZFR5cGUgb2YgYSByZXNvdXJjZSBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uIG9mIHRoZVxuICAgICAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7UmVzb3VyY2UuTE9BRF9UWVBFfSBUaGUgbG9hZFR5cGUgdG8gdXNlLlxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIG1pbWUgdHlwZSBvZiBhbiBYSFIgcmVxdWVzdCBiYXNlZCBvbiB0aGUgcmVzcG9uc2VUeXBlIG9mXG4gICAgICogcmVzb3VyY2UgYmVpbmcgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1Jlc291cmNlLlhIUl9SRVNQT05TRV9UWVBFfSB0eXBlIC0gVGhlIHR5cGUgdG8gZ2V0IGEgbWltZSB0eXBlIGZvci5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtaW1lIHR5cGUgdG8gdXNlLlxuICAgICAqL1xuICAgIF9nZXRNaW1lRnJvbVhoclR5cGUodHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vb2N0ZXQtYmluYXJ5JztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2Jsb2InO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3htbCc7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkpTT046XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuREVGQVVMVDpcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDpcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0ZXh0L3BsYWluJztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZ2V0IGlzRGF0YVVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZsYWcoUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTLkRBVEFfVVJMKTtcbiAgICB9XG4gICAgZ2V0IGlzQ29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5DT01QTEVURSk7XG4gICAgfVxuICAgIGdldCBpc0xvYWRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5MT0FESU5HKTtcbiAgICB9XG59XG5SZXNvdXJjZUxvYWRlci5TVEFUVVNfTk9ORSA9IDA7XG5SZXNvdXJjZUxvYWRlci5TVEFUVVNfT0sgPSAyMDA7XG5SZXNvdXJjZUxvYWRlci5TVEFUVVNfRU1QVFkgPSAyMDQ7XG5SZXNvdXJjZUxvYWRlci5TVEFUVVNfSUVfQlVHX0VNUFRZID0gMTIyMztcblJlc291cmNlTG9hZGVyLlNUQVRVU19UWVBFX09LID0gMjtcblJlc291cmNlTG9hZGVyLnVzZVhkciA9ICEhKHdpbmRvd1snWERvbWFpblJlcXVlc3QnXSAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKSk7XG5SZXNvdXJjZUxvYWRlci5FTVBUWV9HSUYgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBUC8vL3dBQUFDSDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUNSQUVBT3c9PSc7XG5SZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUgPSB7XG4gICAgWEhSOiAxLFxuICAgIElNQUdFOiAyLFxuICAgIEFVRElPOiAzLFxuICAgIFZJREVPOiA0XG59O1xuUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUgPSB7XG4gICAgREVGQVVMVDogJ3RleHQnLFxuICAgIEJVRkZFUjogJ2FycmF5YnVmZmVyJyxcbiAgICBCTE9COiAnYmxvYicsXG4gICAgRE9DVU1FTlQ6ICdkb2N1bWVudCcsXG4gICAgSlNPTjogJ2pzb24nLFxuICAgIFRFWFQ6ICd0ZXh0J1xufTtcblJlc291cmNlTG9hZGVyLl94aHJUeXBlTWFwID0ge1xuICAgIHhodG1sOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICBodG1sOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICBodG06IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIHhtbDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG4gICAgdG14OiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICBzdmc6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIHRzeDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG4gICAgZ2lmOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgIHBuZzogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICBibXA6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAganBnOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgIGpwZWc6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgdGlmOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgIHRpZmY6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgd2VicDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICB0Z2E6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAganNvbjogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTixcbiAgICB0ZXh0OiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhULFxuICAgIHR4dDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCxcbiAgICB0dGY6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUixcbiAgICBvdGY6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUlxufTtcblJlc291cmNlTG9hZGVyLl9sb2FkVHlwZU1hcCA9IHtcbiAgICBnaWY6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICBwbmc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICBibXA6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICBqcGc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICBqcGVnOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXG4gICAgdGlmOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXG4gICAgdGlmZjogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgIHdlYnA6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICB0Z2E6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICBzdmc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICAnc3ZnK3htbCc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICBtcDM6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5BVURJTyxcbiAgICBvZ2c6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5BVURJTyxcbiAgICB3YXY6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5BVURJTyxcbiAgICBtcDQ6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5WSURFTyxcbiAgICB3ZWJtOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuVklERU9cbn07XG5SZXNvdXJjZUxvYWRlci5UWVBFID0ge1xuICAgIFVOS05PV046IDAsXG4gICAgSlNPTjogMSxcbiAgICBYTUw6IDIsXG4gICAgSU1BR0U6IDMsXG4gICAgQVVESU86IDQsXG4gICAgVklERU86IDUsXG4gICAgVEVYVDogNlxufTtcblJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUyA9IHtcbiAgICBOT05FOiAwLFxuICAgIERBVEFfVVJMOiAxIDw8IDAsXG4gICAgQ09NUExFVEU6IDEgPDwgMSxcbiAgICBMT0FESU5HOiAxIDw8IDJcbn07XG5leHBvcnRzLlJlc291cmNlTG9hZGVyID0gUmVzb3VyY2VMb2FkZXI7XG5jbGFzcyBVUklEYXRhIHtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vSW1hZ2VSZXNvdXJjZVwiKTtcbmNvbnN0IENhbnZhc1Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9DYW52YXNSZXNvdXJjZVwiKTtcbmNvbnN0IFZpZGVvUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL1ZpZGVvUmVzb3VyY2VcIik7XG5jb25zdCBTVkdSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vU1ZHUmVzb3VyY2VcIik7XG5jb25zdCBCdWZmZXJSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQnVmZmVyUmVzb3VyY2VcIik7XG5jb25zdCBDdWJlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0N1YmVSZXNvdXJjZVwiKTtcbmNvbnN0IEFycmF5UmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0FycmF5UmVzb3VyY2VcIik7XG5jbGFzcyBSZXNvdXJjZVNldHRpbmdzIHtcbiAgICBzdGF0aWMgYXV0b0RldGVjdFJlc291cmNlKHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAoL1xcLihcXHd7Myw0fSkoPzokfFxcP3wjKS9pKS5leGVjKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IFJlc291cmNlU2V0dGluZ3MuSU5TVEFMTEVELmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICB2YXIgUmVzb3VyY2VQbHVnaW4gPSBSZXNvdXJjZVNldHRpbmdzLklOU1RBTExFRFtpXTtcbiAgICAgICAgICAgIGlmIChSZXNvdXJjZVBsdWdpbi50ZXN0ICYmIFJlc291cmNlUGx1Z2luLnRlc3Qoc291cmNlLCBleHRlbnNpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvdXJjZVBsdWdpbihzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VSZXNvdXJjZV8xLkltYWdlUmVzb3VyY2Uoc291cmNlLCBvcHRpb25zKTtcbiAgICB9XG59XG5SZXNvdXJjZVNldHRpbmdzLklOU1RBTExFRCA9IFtcbiAgICBJbWFnZVJlc291cmNlXzEuSW1hZ2VSZXNvdXJjZSxcbiAgICBDYW52YXNSZXNvdXJjZV8xLkNhbnZhc1Jlc291cmNlLFxuICAgIFZpZGVvUmVzb3VyY2VfMS5WaWRlb1Jlc291cmNlLFxuICAgIFNWR1Jlc291cmNlXzEuU1ZHUmVzb3VyY2UsXG4gICAgQnVmZmVyUmVzb3VyY2VfMS5CdWZmZXJSZXNvdXJjZSxcbiAgICBDdWJlUmVzb3VyY2VfMS5DdWJlUmVzb3VyY2UsXG4gICAgQXJyYXlSZXNvdXJjZV8xLkFycmF5UmVzb3VyY2Vcbl07XG5leHBvcnRzLlJlc291cmNlU2V0dGluZ3MgPSBSZXNvdXJjZVNldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNZXNoR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL01lc2hHZW9tZXRyeVwiKTtcbmNsYXNzIFJvcGVHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeV8xLk1lc2hHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3Iod2lkdGggPSAyMDAsIHBvaW50cyA9IG51bGwpIHtcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHdpZHRoID0gMjAwO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpLCBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KSwgbmV3IFVpbnQxNkFycmF5KChwb2ludHMubGVuZ3RoIC0gMSkgKiA2KSk7XG4gICAgICAgIC8qKlxuICAgICAgICAqIEFuIGFycmF5IG9mIHBvaW50cyB0aGF0IGRldGVybWluZSB0aGUgcm9wZVxuICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnRbXX1cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIC8qKlxuICAgICAgICAqIFRoZSB3aWR0aCAoaS5lLiwgdGhpY2tuZXNzKSBvZiB0aGUgcm9wZS5cbiAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFJlZnJlc2hlcyBSb3BlIGluZGljZXMgYW5kIHV2c1xuICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIGJ1aWxkKCkge1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIGlmICghcG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nKTtcbiAgICAgICAgdmFyIHV2QnVmZmVyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FUZXh0dXJlQ29vcmQnKTtcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgICAvLyBpZiB0b28gbGl0dGxlIHBvaW50cywgb3IgdGV4dHVyZSBoYXNuJ3QgZ290IFVWcyBzZXQgeWV0IGp1c3QgbW92ZSBvbi5cbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIG51bWJlciBvZiBwb2ludHMgaGFzIGNoYW5nZWQgd2Ugd2lsbCBuZWVkIHRvIHJlY3JlYXRlIHRoZSBhcnJheWJ1ZmZlcnNcbiAgICAgICAgaWYgKHZlcnRleEJ1ZmZlci5kYXRhLmxlbmd0aCAvIDQgIT09IHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XG4gICAgICAgICAgICB1dkJ1ZmZlci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XG4gICAgICAgICAgICBpbmRleEJ1ZmZlci5kYXRhID0gbmV3IFVpbnQxNkFycmF5KChwb2ludHMubGVuZ3RoIC0gMSkgKiA2KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXZzID0gdXZCdWZmZXIuZGF0YTtcbiAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleEJ1ZmZlci5kYXRhO1xuICAgICAgICB1dnNbMF0gPSAwO1xuICAgICAgICB1dnNbMV0gPSAwO1xuICAgICAgICB1dnNbMl0gPSAwO1xuICAgICAgICB1dnNbM10gPSAxO1xuICAgICAgICAvLyBpbmRpY2VzWzBdID0gMDtcbiAgICAgICAgLy8gaW5kaWNlc1sxXSA9IDE7XG4gICAgICAgIHZhciB0b3RhbCA9IHBvaW50cy5sZW5ndGg7IC8vIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyB0aW1lIHRvIGRvIHNvbWUgc21hcnQgZHJhd2luZyFcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGkgKiA0O1xuICAgICAgICAgICAgdmFyIGFtb3VudCA9IGkgLyAodG90YWwgLSAxKTtcbiAgICAgICAgICAgIHV2c1tpbmRleF0gPSBhbW91bnQ7XG4gICAgICAgICAgICB1dnNbaW5kZXggKyAxXSA9IDA7XG4gICAgICAgICAgICB1dnNbaW5kZXggKyAyXSA9IGFtb3VudDtcbiAgICAgICAgICAgIHV2c1tpbmRleCArIDNdID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRvdGFsIC0gMTsgaSQxKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCQxID0gaSQxICogMjtcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4JDE7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCQxICsgMTtcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4JDEgKyAyO1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMSArIDI7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCQxICsgMTtcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4JDEgKyAzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBjaGFuZ2VzIGFyZSB1cGxvYWRlZFxuICAgICAgICB1dkJ1ZmZlci51cGRhdGUoKTtcbiAgICAgICAgaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmVydGljZXMoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICogcmVmcmVzaGVzIHZlcnRpY2VzIG9mIFJvcGUgbWVzaFxuICAgICovXG4gICAgdXBkYXRlVmVydGljZXMoKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxhc3RQb2ludCA9IHBvaW50c1swXTtcbiAgICAgICAgdmFyIG5leHRQb2ludDtcbiAgICAgICAgdmFyIHBlcnBYID0gMDtcbiAgICAgICAgdmFyIHBlcnBZID0gMDtcbiAgICAgICAgLy8gdGhpcy5jb3VudCAtPSAwLjI7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuYnVmZmVyc1swXS5kYXRhO1xuICAgICAgICB2YXIgdG90YWwgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGkgKiA0O1xuICAgICAgICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlcnBZID0gLShuZXh0UG9pbnQueCAtIGxhc3RQb2ludC54KTtcbiAgICAgICAgICAgIHBlcnBYID0gbmV4dFBvaW50LnkgLSBsYXN0UG9pbnQueTtcbiAgICAgICAgICAgIHZhciBwZXJwTGVuZ3RoID0gTWF0aC5zcXJ0KChwZXJwWCAqIHBlcnBYKSArIChwZXJwWSAqIHBlcnBZKSk7XG4gICAgICAgICAgICB2YXIgbnVtID0gdGhpcy53aWR0aCAvIDI7IC8vICgyMCArIE1hdGguYWJzKE1hdGguc2luKChpICsgdGhpcy5jb3VudCkgKiAwLjMpICogNTApICkqIHJhdGlvO1xuICAgICAgICAgICAgcGVycFggLz0gcGVycExlbmd0aDtcbiAgICAgICAgICAgIHBlcnBZIC89IHBlcnBMZW5ndGg7XG4gICAgICAgICAgICBwZXJwWCAqPSBudW07XG4gICAgICAgICAgICBwZXJwWSAqPSBudW07XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpbmRleF0gPSBwb2ludC54ICsgcGVycFg7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpbmRleCArIDFdID0gcG9pbnQueSArIHBlcnBZO1xuICAgICAgICAgICAgdmVydGljZXNbaW5kZXggKyAyXSA9IHBvaW50LnggLSBwZXJwWDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2luZGV4ICsgM10gPSBwb2ludC55IC0gcGVycFk7XG4gICAgICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlcnNbMF0udXBkYXRlKCk7XG4gICAgfVxuICAgIDtcbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVmVydGljZXMoKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5Sb3BlR2VvbWV0cnkgPSBSb3BlR2VvbWV0cnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XG5jbGFzcyBSb3VuZGVkUmVjdGFuZ2xlIHtcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCwgcmFkaXVzID0gMjApIHtcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhZGl1cyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByYWRpdXMgPSAyMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLlJSRUNcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlJSRUM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IGEgY29weSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VuZGVkUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yYWRpdXMpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxuICAgICAqL1xuICAgIGNvbnRhaW5zKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHkgPj0gdGhpcy55ICsgdGhpcy5yYWRpdXMgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodCAtIHRoaXMucmFkaXVzKVxuICAgICAgICAgICAgICAgICAgICB8fCAoeCA+PSB0aGlzLnggKyB0aGlzLnJhZGl1cyAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGggLSB0aGlzLnJhZGl1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkeCA9IHggLSAodGhpcy54ICsgdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIHZhciByYWRpdXMyID0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcbiAgICAgICAgICAgICAgICBpZiAoKGR4ICogZHgpICsgKGR5ICogZHkpIDw9IHJhZGl1czIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLndpZHRoIC0gdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIGlmICgoZHggKiBkeCkgKyAoZHkgKiBkeSkgPD0gcmFkaXVzMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHkgPSB5IC0gKHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIGlmICgoZHggKiBkeCkgKyAoZHkgKiBkeSkgPD0gcmFkaXVzMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHggPSB4IC0gKHRoaXMueCArIHRoaXMucmFkaXVzKTtcbiAgICAgICAgICAgICAgICBpZiAoKGR4ICogZHgpICsgKGR5ICogZHkpIDw9IHJhZGl1czIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5Sb3VuZGVkUmVjdGFuZ2xlID0gUm91bmRlZFJlY3RhbmdsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUnVubmVyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZW1pdDtcbiAgICAgICAgdGhpcy5ydW4gPSB0aGlzLmVtaXQ7XG4gICAgfVxuICAgIGVtaXQoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXggYXJndW1lbnRzIHJlYWNoZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICAgICAgdmFyIGl0ZW1zID0gcmVmLml0ZW1zO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGl0ZW1zW2ldW25hbWVdKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciB0byB0aGUgUnVubmVyXG4gICAgICpcbiAgICAgKiBSdW5uZXJzIGRvIG5vdCBuZWVkIHRvIGhhdmUgc2NvcGUgb3IgZnVuY3Rpb25zIHBhc3NlZCB0byB0aGVtLlxuICAgICAqIEFsbCB0aGF0IGlzIHJlcXVpcmVkIGlzIHRvIHBhc3MgdGhlIGxpc3RlbmluZyBvYmplY3QgYW5kIGVuc3VyZSB0aGF0IGl0IGhhcyBjb250YWlucyBhIGZ1bmN0aW9uIHRoYXQgaGFzIHRoZSBzYW1lIG5hbWVcbiAgICAgKiBhcyB0aGUgbmFtZSBwcm92aWRlZCB0byB0aGUgUnVubmVyIHdoZW4gaXQgd2FzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBFZyBBIGxpc3RlbmVyIHBhc3NlZCB0byB0aGlzIFJ1bm5lciB3aWxsIHJlcXVpcmUgYSAnY29tcGxldGUnIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgY29tcGxldGUgPSBuZXcgUElYSS5SdW5uZXIoJ2NvbXBsZXRlJyk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgc2NvcGUgdXNlZCB3aWxsIGJlIHRoZSBvYmplY3QgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSBsaXN0ZW5pbmcuXG4gICAgICovXG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW1bdGhpcy5fbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc2luZ2xlIGxpc3RlbmVyIGZyb20gdGhlIGRpc3BhdGNoIHF1ZXVlLlxuICAgICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIGxpc3RlbnIgdGhhdCB5b3Ugd291bGQgbGlrZSB0byByZW1vdmUuXG4gICAgICovXG4gICAgcmVtb3ZlKGl0ZW0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGlzIGFscmVhZHkgaW4gdGhlIFJ1bm5lclxuICAgICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIGxpc3RlbmVyIHRoYXQgeW91IHdvdWxkIGxpa2UgdG8gY2hlY2suXG4gICAgICovXG4gICAgY29udGFpbnMoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZyb20gdGhlIFJ1bm5lclxuICAgICAqL1xuICAgIHJlbW92ZUFsbCgpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5sZW5ndGggPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgcmVmZXJlbmNlcywgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX25hbWUgPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogYHRydWVgIGlmIHRoZXJlIGFyZSBubyB0aGlzIFJ1bm5lciBjb250YWlucyBubyBsaXN0ZW5lcnNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgcnVubmVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5SdW5uZXIgPSBSdW5uZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VJbWFnZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CYXNlSW1hZ2VSZXNvdXJjZVwiKTtcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY2xhc3MgU1ZHUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHN1cGVyKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhc2U2NCBlbmNvZGVkIFNWRyBlbGVtZW50IG9yIFVSTCBmb3IgU1ZHIGZpbGVcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ZnID0gc291cmNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNvdXJjZSBzY2FsZSB0byBhcHBseSB0byByZW5kZXJcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIHdoZW4gY29tcGxldGVseSBsb2FkZWRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb21pc2Ugd2hlbiBsb2FkaW5nXG4gICAgICAgICAqIEBtZW1iZXIge1Byb21pc2U8dm9pZD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvYWQoKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoaXMgdW50aWwgYWZ0ZXIgbG9hZCBpcyBmaW5pc2hlZFxuICAgICAgICAgICAgdGhpcyQxLl9yZXNvbHZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5yZXNpemUodGhpcyQxLnNvdXJjZS53aWR0aCwgdGhpcyQxLnNvdXJjZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyQxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDb252ZXJ0IFNWRyBpbmxpbmUgc3RyaW5nIHRvIGRhdGEtdXJpXG4gICAgICAgICAgICBpZiAoKC9eXFw8c3ZnLykudGVzdCh0aGlzJDEuc3ZnLnRyaW0oKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEuc3ZnID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIiArICh0aGlzJDEuc3ZnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrcyBpZiBgc291cmNlYCBpcyBhbiBTVkcgaW1hZ2UgYW5kIHdoZXRoZXIgaXQnc1xuICAgICAgICAgICAgLy8gbG9hZGVkIHZpYSBhIFVSTCBvciBhIGRhdGEgVVJJLiBUaGVuIGNhbGxzXG4gICAgICAgICAgICAvLyBgX2xvYWREYXRhVXJpYCBvciBgX2xvYWRYaHJgLlxuICAgICAgICAgICAgdmFyIGRhdGFVcmkgPSBzZXR0aW5nc18xLnNldHRpbmdzLmRlY29tcG9zZURhdGFVcmkodGhpcyQxLnN2Zyk7XG4gICAgICAgICAgICBpZiAoZGF0YVVyaSkge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5fbG9hZERhdGFVcmkoZGF0YVVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnb3QgYW4gVVJMLCBzbyB3ZSBuZWVkIHRvIGRvIGFuIFhIUiB0byBjaGVjayB0aGUgc3ZnIHNpemVcbiAgICAgICAgICAgICAgICB0aGlzJDEuX2xvYWRYaHIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVhZHMgYW4gU1ZHIHN0cmluZyBmcm9tIGRhdGEgVVJJIGFuZCB0aGVuIGNhbGxzIGBfbG9hZFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVyaSAtIFRoZSBkYXRhIHVyaSB0byBsb2FkIGZyb20uXG4gICAgICovXG4gICAgX2xvYWREYXRhVXJpKGRhdGFVcmkpIHtcbiAgICAgICAgdmFyIHN2Z1N0cmluZztcbiAgICAgICAgaWYgKGRhdGFVcmkuZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgICAgICBpZiAoIWF0b2IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCBiYXNlNjQgY29udmVyc2lvbnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdmdTdHJpbmcgPSBhdG9iKGRhdGFVcmkuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdmdTdHJpbmcgPSBkYXRhVXJpLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9hZFN0cmluZyhzdmdTdHJpbmcpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gU1ZHIHN0cmluZyBmcm9tIGBpbWFnZVVybGAgdXNpbmcgWEhSIGFuZCB0aGVuIGNhbGxzIGBfbG9hZFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9sb2FkWGhyKCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgdmFyIHN2Z1hociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAvLyBUaGlzIHRocm93cyBlcnJvciBvbiBJRSwgc28gU1ZHIERvY3VtZW50IGNhbid0IGJlIHVzZWRcbiAgICAgICAgLy8gc3ZnWGhyLnJlc3BvbnNlVHlwZSA9ICdkb2N1bWVudCc7XG4gICAgICAgIC8vIFRoaXMgaXMgbm90IG5lZWRlZCBzaW5jZSB3ZSBsb2FkIHRoZSBzdmcgYXMgc3RyaW5nIChicmVha3MgSUUgdG9vKVxuICAgICAgICAvLyBidXQgb3ZlcnJpZGVNaW1lVHlwZSgpIGNhbiBiZSB1c2VkIHRvIGZvcmNlIHRoZSByZXNwb25zZSB0byBiZSBwYXJzZWQgYXMgWE1MXG4gICAgICAgIC8vIHN2Z1hoci5vdmVycmlkZU1pbWVUeXBlKCdpbWFnZS9zdmcreG1sJyk7XG4gICAgICAgIHN2Z1hoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc3ZnWGhyLnJlYWR5U3RhdGUgIT09IHN2Z1hoci5ET05FIHx8IHN2Z1hoci5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgU1ZHIHVzaW5nIFhIUi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMkMS5fbG9hZFN0cmluZyhzdmdYaHIucmVzcG9uc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBzdmdYaHIub25lcnJvciA9ICgpID0+IHRoaXMuZW1pdCgnZXJyb3InLCB0aGlzKTtcbiAgICAgICAgc3ZnWGhyLm9wZW4oJ0dFVCcsIHRoaXMuc3ZnLCB0cnVlKTtcbiAgICAgICAgc3ZnWGhyLnNlbmQoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRleHR1cmUgdXNpbmcgYW4gU1ZHIHN0cmluZy4gVGhlIG9yaWdpbmFsIFNWRyBJbWFnZSBpcyBzdG9yZWQgYXMgYG9yaWdTb3VyY2VgIGFuZCB0aGVcbiAgICAgKiBjcmVhdGVkIGNhbnZhcyBpcyB0aGUgbmV3IGBzb3VyY2VgLiBUaGUgU1ZHIGlzIHNjYWxlZCB1c2luZyBgc291cmNlU2NhbGVgLiBDYWxsZWQgYnlcbiAgICAgKiBgX2xvYWRYaHJgIG9yIGBfbG9hZERhdGFVcmlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN2Z1N0cmluZyBTVkcgc291cmNlIGFzIHN0cmluZ1xuICAgICAqXG4gICAgICogQGZpcmVzIGxvYWRlZFxuICAgICAqL1xuICAgIF9sb2FkU3RyaW5nKHN2Z1N0cmluZykge1xuICAgICAgICB2YXIgc3ZnU2l6ZSA9IFNWR1Jlc291cmNlLmdldFNpemUoc3ZnU3RyaW5nKTtcbiAgICAgICAgLy8gVE9ETyBkbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoaXMgdG8gbG9hZD9cbiAgICAgICAgLy8gc2VlbXMgaW5zdGFudCFcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIHRlbXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0ZW1wSW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL3N2Zyt4bWwsXCIgKyBzdmdTdHJpbmc7XG4gICAgICAgIHZhciBzdmdXaWR0aCA9IHN2Z1NpemUud2lkdGg7XG4gICAgICAgIHZhciBzdmdIZWlnaHQgPSBzdmdTaXplLmhlaWdodDtcbiAgICAgICAgaWYgKCFzdmdXaWR0aCB8fCAhc3ZnSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBTVkcgaW1hZ2UgbXVzdCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgZGVmaW5lZCAoaW4gcGl4ZWxzKSwgY2FudmFzIEFQSSBuZWVkcyB0aGVtLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNjYWxlIHJlYWxXaWR0aCBhbmQgcmVhbEhlaWdodFxuICAgICAgICB0aGlzLl93aWR0aCA9IE1hdGgucm91bmQoc3ZnV2lkdGggKiB0aGlzLnNjYWxlKTtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5yb3VuZChzdmdIZWlnaHQgKiB0aGlzLnNjYWxlKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY2FudmFzIGVsZW1lbnRcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuc291cmNlO1xuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgY2FudmFzLl9waXhpSWQgPSBcImNhbnZhc19cIiArIChNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MudWlkKCkpO1xuICAgICAgICAvLyBEcmF3IHRoZSBTdmcgdG8gdGhlIGNhbnZhc1xuICAgICAgICBjYW52YXNcbiAgICAgICAgICAgIC5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICAuZHJhd0ltYWdlKHRlbXBJbWFnZSwgMCwgMCwgc3ZnV2lkdGgsIHN2Z0hlaWdodCwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlKCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVHlwZWRlZiBmb3IgU2l6ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5yZXNvdXJjZXMuU1ZHUmVzb3VyY2VcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBTaXplXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggY29tcG9uZW50XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBjb21wb25lbnRcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBHZXQgc2l6ZSBmcm9tIGFuIHN2ZyBzdHJpbmcgdXNpbmcgcmVnZXhwLlxuICAgICAqXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdmdTdHJpbmcgLSBhIHNlcmlhbGl6ZWQgc3ZnIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtQSVhJLnJlc291cmNlcy5TVkdSZXNvdXJjZS5TaXplfSBpbWFnZSBleHRlbnNpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U2l6ZShzdmdTdHJpbmcpIHtcbiAgICAgICAgdmFyIHNpemVNYXRjaCA9IFNWR1Jlc291cmNlLlNWR19TSVpFLmV4ZWMoc3ZnU3RyaW5nKTtcbiAgICAgICAgdmFyIHNpemUgPSB7fTtcbiAgICAgICAgaWYgKHNpemVNYXRjaCkge1xuICAgICAgICAgICAgc2l6ZVtzaXplTWF0Y2hbMV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFszXSkpO1xuICAgICAgICAgICAgc2l6ZVtzaXplTWF0Y2hbNV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFs3XSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXV0by1kZXRlY3QgdGhlIHR5cGUgb2YgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb24gLSBUaGUgZXh0ZW5zaW9uIG9mIHNvdXJjZSwgaWYgc2V0XG4gICAgICovXG4gICAgc3RhdGljIHRlc3Qoc291cmNlLCBleHRlbnNpb24pIHtcbiAgICAgICAgLy8gdXJsIGZpbGUgZXh0ZW5zaW9uIGlzIFNWR1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uID09PSAnc3ZnJ1xuICAgICAgICAgICAgLy8gc291cmNlIGlzIFNWRyBkYXRhLXVyaVxuICAgICAgICAgICAgfHwgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIHNvdXJjZS5pbmRleE9mKCdkYXRhOmltYWdlL3N2Zyt4bWwnKSA9PT0gMCk7XG4gICAgfVxuICAgIDtcbn1cbi8qKlxuKiBSZWdFeHAgZm9yIFNWRyBzaXplLlxuKlxuKiBAc3RhdGljXG4qIEBjb25zdGFudCB7UmVnRXhwfHN0cmluZ30gU1ZHX1NJWkVcbiogQG1lbWJlcm9mIFBJWEkucmVzb3VyY2VzLlNWR1Jlc291cmNlXG4qIEBleGFtcGxlICZsdDtzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiZndDsmbHQ7L3N2ZyZndDtcbiovXG5TVkdSZXNvdXJjZS5TVkdfU0laRSA9IC88c3ZnW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKj4vaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXG5leHBvcnRzLlNWR1Jlc291cmNlID0gU1ZHUmVzb3VyY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFVuaWZvcm1Hcm91cF8xID0gcmVxdWlyZShcIi4vVW5pZm9ybUdyb3VwXCIpO1xuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4vUHJvZ3JhbVwiKTtcbmNsYXNzIFNoYWRlciB7XG4gICAgY29uc3RydWN0b3IocHJvZ3JhbSwgdW5pZm9ybXMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICAgICAgLy8gbGV0cyBzZWUgd2hhdHMgYmVlbiBwYXNzZWQgaW5cbiAgICAgICAgLy8gdW5pZm9ybXMgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIHVuaWZvcm0gZ3JvdXBcbiAgICAgICAgaWYgKHVuaWZvcm1zKSB7XG4gICAgICAgICAgICBpZiAodW5pZm9ybXMgaW5zdGFuY2VvZiBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IHVuaWZvcm1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSBuZXcgVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwKHVuaWZvcm1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybUdyb3VwID0gbmV3IFVuaWZvcm1Hcm91cF8xLlVuaWZvcm1Hcm91cCh7fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGltZSB0byBidWlsZCBzb21lIGdldHRlcnMgYW5kIHNldHRlcnMhXG4gICAgICAgIC8vIEkgZ3Vlc3MgZG93biB0aGUgbGluZSB0aGlzIGNvdWxkIHNvcnQgb2YgZ2VuZXJhdGUgYW4gaW5zdHJ1Y3Rpb24gbGlzdCByYXRoZXIgdGhhbiB1c2UgZGlydHkgaWRzP1xuICAgICAgICAvLyBkb2VzIHRoZSB0cmljayBmb3Igbm93IHRob3VnaCFcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9ncmFtLnVuaWZvcm1EYXRhKSB7XG4gICAgICAgICAgICBpZiAodGhpcy51bmlmb3JtR3JvdXAudW5pZm9ybXNbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zW2ldID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVuaWZvcm1Hcm91cC51bmlmb3Jtc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVE9ETyBtb3ZlIHRvIHNoYWRlciBzeXN0ZW0uLlxuICAgIGNoZWNrVW5pZm9ybUV4aXN0cyhuYW1lLCBncm91cCkge1xuICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgaW4gZ3JvdXAudW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHZhciB1bmlmb3JtID0gZ3JvdXAudW5pZm9ybXNbaV07XG4gICAgICAgICAgICBpZiAodW5pZm9ybS5ncm91cCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrVW5pZm9ybUV4aXN0cyhuYW1lLCB1bmlmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICA7XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gdXNhZ2UgY291bnQgb24gcHJvZ3JhbXM/XG4gICAgICAgIC8vIHJlbW92ZSBpZiBub3QgdXNlZCFcbiAgICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2hhZGVyIHVuaWZvcm0gdmFsdWVzLCBzaG9ydGN1dCBmb3IgYHVuaWZvcm1Hcm91cC51bmlmb3Jtc2BcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0IHVuaWZvcm1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3JtR3JvdXAudW5pZm9ybXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0IGhhbmQgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2hhZGVyIGJhc2VkIG9mIGEgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmVydGV4U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcmFnbWVudFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt1bmlmb3Jtc10gLSBDdXN0b20gdW5pZm9ybXMgdG8gdXNlIHRvIGF1Z21lbnQgdGhlIGJ1aWx0LWluIG9uZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UElYSS5TaGFkZXJ9IGFuIHNoaW55IG5ldyBQaXhpIHNoYWRlciFcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCB1bmlmb3Jtcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20odmVydGV4U3JjLCBmcmFnbWVudFNyYyk7XG4gICAgICAgIHJldHVybiBuZXcgU2hhZGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0IHtXZWJHTFByb2dyYW19XG4gKiBAcGFyYW0gdHlwZSB7TnVtYmVyfSB0aGUgdHlwZSwgY2FuIGJlIGVpdGhlciBWRVJURVhfU0hBREVSIG9yIEZSQUdNRU5UX1NIQURFUlxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSB0aGUgc2hhZGVyXG4gKi9cbiAgICBzdGF0aWMgY29tcGlsZVNoYWRlcihnbCwgdHlwZSwgc3JjKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihzcmMpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9XG59XG5leHBvcnRzLlNoYWRlciA9IFNoYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmFtXCIpO1xuY29uc3QgR0xQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9HTFByb2dyYW1cIik7XG5jb25zdCBTdGF0ZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3RhdGVTeXN0ZW1cIik7XG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNsYXNzIFNoYWRlclN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvLyBWYWxpZGF0aW9uIGNoZWNrIHRoYXQgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0IGBuZXcgRnVuY3Rpb25gXG4gICAgICAgIHRoaXMuc3lzdGVtQ2hlY2soKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IFdlYkdMIHJlbmRlcmluZyBjb250ZXh0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWNoZSB0byBob2xkcyB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9ucy4gU3RvcmVkIGFnYWluc3QgVW5pZm9ybU9iamVjdHMgdW5pcXVlIHNpZ25hdHVyZVxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmlkID0gU3RhdGVTeXN0ZW1fMS5TdGF0ZVN5c3RlbS5VSUQkNCsrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZWFibGUgZnVuY3Rpb24gYnkgYEBwaXhpL3Vuc2FmZS1ldmFsYCB0byBzaWxlbmNlXG4gICAgICogdGhyb3dpbmcgYW4gZXJyb3IgaWYgcGxhdGZvcm0gZG9lc24ndCBzdXBwb3J0IHVuc2FmZS1ldmFscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3lzdGVtQ2hlY2soKSB7XG4gICAgICAgIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbFN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3QgYWxsb3cgdW5zYWZlLWV2YWwsICdcbiAgICAgICAgICAgICAgICArICdwbGVhc2UgdXNlIEBwaXhpL3Vuc2FmZS1ldmFsIG1vZHVsZSB0byBlbmFibGUgc3VwcG9ydC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgY29udGV4dENoYW5nZShnbCkge1xuICAgICAgICB0aGlzLmdsID0gZ2w7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNoYWRlciB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlNoYWRlcn0gc2hhZGVyIC0gdGhlIG5ldyBzaGFkZXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRTeW5jIC0gZmFsc2UgaWYgdGhlIHNoYWRlciBzaG91bGQgYXV0b21hdGljYWxseSBzeW5jIGl0cyB1bmlmb3Jtcy5cbiAgICAgKiBAcmV0dXJucyB7UElYSS5HTFByb2dyYW19IHRoZSBnbFByb2dyYW0gdGhhdCBiZWxvbmdzIHRvIHRoZSBzaGFkZXIuXG4gICAgICovXG4gICAgYmluZChzaGFkZXIsIGRvbnRTeW5jID0gZmFsc2UpIHtcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLmdsb2JhbHMgPSB0aGlzLnJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtO1xuICAgICAgICB2YXIgZ2xQcm9ncmFtID0gcHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdIHx8IHRoaXMuZ2VuZXJhdGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XG4gICAgICAgIC8vIFRPRE8gLSBzb21lIGN1cnJlbnQgUGl4aSBwbHVnaW5zIGJ5cGFzcyB0aGlzLi4gc28gaXQgbm90IHNhZmUgdG8gdXNlIHlldC4uXG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gIT09IHByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0oZ2xQcm9ncmFtLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZG9udFN5bmMpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY1VuaWZvcm1Hcm91cChzaGFkZXIudW5pZm9ybUdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2xQcm9ncmFtO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgdW5pZm9ybXMgdmFsdWVzIHRvIHRoZSBjdXJyZW50bHkgYm91bmQgc2hhZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHVuaWZvcm1zIC0gdGhlIHVuaWZvcm1zIHZhbHVlcyB0aGF0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2hhZGVyXG4gICAgICovXG4gICAgc2V0VW5pZm9ybXModW5pZm9ybXMpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuc2hhZGVyLnByb2dyYW07XG4gICAgICAgIHZhciBnbFByb2dyYW0gPSBzaGFkZXIuZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgc2hhZGVyLnN5bmNVbmlmb3JtcyhnbFByb2dyYW0udW5pZm9ybURhdGEsIHVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyKTtcbiAgICB9XG4gICAgO1xuICAgIHN5bmNVbmlmb3JtR3JvdXAoZ3JvdXApIHtcbiAgICAgICAgdmFyIGdsUHJvZ3JhbSA9IHRoaXMuZ2V0Z2xQcm9ncmFtKCk7XG4gICAgICAgIGlmICghZ3JvdXAuc3RhdGljIHx8IGdyb3VwLmRpcnR5SWQgIT09IGdsUHJvZ3JhbS51bmlmb3JtR3JvdXBzW2dyb3VwLmlkXSkge1xuICAgICAgICAgICAgZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdID0gZ3JvdXAuZGlydHlJZDtcbiAgICAgICAgICAgIHRoaXMuc3luY1VuaWZvcm1zKGdyb3VwLCBnbFByb2dyYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBPdmVycmlkZWFibGUgYnkgdGhlIEBwaXhpL3Vuc2FmZS1ldmFsIHBhY2thZ2UgdG8gdXNlIHN0YXRpY1xuICAgICAqIHN5bmNVbmZvcm1zIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN5bmNVbmlmb3Jtcyhncm91cCwgZ2xQcm9ncmFtKSB7XG4gICAgICAgIHZhciBzeW5jRnVuYyA9IGdyb3VwLnN5bmNVbmlmb3Jtc1t0aGlzLnNoYWRlci5wcm9ncmFtLmlkXSB8fCB0aGlzLmNyZWF0ZVN5bmNHcm91cHMoZ3JvdXApO1xuICAgICAgICBzeW5jRnVuYyhnbFByb2dyYW0udW5pZm9ybURhdGEsIGdyb3VwLnVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyKTtcbiAgICB9XG4gICAgO1xuICAgIGNyZWF0ZVN5bmNHcm91cHMoZ3JvdXApIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRTaWduYXR1cmUoZ3JvdXAsIHRoaXMuc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEpO1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVbaWRdKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlW2lkXSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmdlbmVyYXRlVW5pZm9ybXNTeW5jKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF0gPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgICAgcmV0dXJuIGdyb3VwLnN5bmNVbmlmb3Jtc1t0aGlzLnNoYWRlci5wcm9ncmFtLmlkXTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRha2VzIGEgdW5pZm9ybSBncm91cCBhbmQgZGF0YSBhbmQgZ2VuZXJhdGVzIGEgdW5pcXVlIHNpZ25hdHVyZSBmb3IgdGhlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Vbmlmb3JtR3JvdXB9IGdyb3VwIHRoZSB1bmlmb3JtIGdyb3VwIHRvIGdldCBzaWduYXR1cmUgb2ZcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybURhdGEgdW5pZm9ybSBpbmZvcm1hdGlvbiBnZW5lcmF0ZWQgYnkgdGhlIHNoYWRlclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFVuaXF1ZSBzaWduYXR1cmUgb2YgdGhlIHVuaWZvcm0gZ3JvdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldFNpZ25hdHVyZShncm91cCwgdW5pZm9ybURhdGEpIHtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0gZ3JvdXAudW5pZm9ybXM7XG4gICAgICAgIHZhciBzdHJpbmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gdW5pZm9ybXMpIHtcbiAgICAgICAgICAgIHN0cmluZ3MucHVzaChpKTtcbiAgICAgICAgICAgIGlmICh1bmlmb3JtRGF0YVtpXSkge1xuICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaCh1bmlmb3JtRGF0YVtpXS50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5ncy5qb2luKCctJyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIEdMU2hhZGUgcm9mIHRoZSBjdXJyZW50bHkgYm91bmQgc2hhZGVyLlxuICAgICAqIFRoaXMgY2FuIGJlIGhhbmR5IGZvciB3aGVuIHlvdSB0byBoYXZlIGEgbGl0dGxlIG1vcmUgY29udHJvbCBvdmVyIHRoZSBzZXR0aW5nIG9mIHlvdXIgdW5pZm9ybXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdMUHJvZ3JhbX0gdGhlIGdsUHJvZ3JhbSBmb3IgdGhlIGN1cnJlbnRseSBib3VuZCBTaGFkZXIgZm9yIHRoaXMgY29udGV4dFxuICAgICAqL1xuICAgIGdldGdsUHJvZ3JhbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXIucHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgZ2xQcm9ncmFtIHZlcnNpb24gb2YgdGhlIFNoYWRlciBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLlNoYWRlcn0gc2hhZGVyIHRoZSBzaGFkZXIgdGhhdCB0aGUgZ2xQcm9ncmFtIHdpbGwgYmUgYmFzZWQgb24uXG4gICAgICogQHJldHVybiB7UElYSS5HTFByb2dyYW19IEEgc2hpbnkgbmV3IGdsUHJvZ3JhbSFcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVNoYWRlcihzaGFkZXIpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBzaGFkZXIucHJvZ3JhbTtcbiAgICAgICAgdmFyIGF0dHJpYk1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpIGluIHByb2dyYW0uYXR0cmlidXRlRGF0YSkge1xuICAgICAgICAgICAgYXR0cmliTWFwW2ldID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2ldLmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkZXJQcm9ncmFtID0gUHJvZ3JhbV8xLlByb2dyYW0uY29tcGlsZVByb2dyYW0oZ2wsIHByb2dyYW0udmVydGV4U3JjLCBwcm9ncmFtLmZyYWdtZW50U3JjLCBhdHRyaWJNYXApO1xuICAgICAgICB2YXIgdW5pZm9ybURhdGEgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSQxIGluIHByb2dyYW0udW5pZm9ybURhdGEpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gcHJvZ3JhbS51bmlmb3JtRGF0YVtpJDFdO1xuICAgICAgICAgICAgdW5pZm9ybURhdGFbaSQxXSA9IHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIGkkMSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmRlZmF1bHRWYWx1ZShkYXRhLnR5cGUsIGRhdGEuc2l6ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBnbFByb2dyYW0gPSBuZXcgR0xQcm9ncmFtXzEuR0xQcm9ncmFtKHNoYWRlclByb2dyYW0sIHVuaWZvcm1EYXRhKTtcbiAgICAgICAgcHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdID0gZ2xQcm9ncmFtO1xuICAgICAgICByZXR1cm4gZ2xQcm9ncmFtO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzZXRzIFNoYWRlclN5c3RlbSBzdGF0ZSwgZG9lcyBub3QgYWZmZWN0IFdlYkdMIHN0YXRlXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgU3lzdGVtIGFuZCByZW1vdmVzIGFsbCBpdHMgdGV4dHVyZXNcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBkZXN0cm95IG1ldGhvZCBmb3IgU2hhZGVyU3lzdGVtXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5TaGFkZXJTeXN0ZW0gPSBTaGFkZXJTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFNoYXBlU2V0dGluZ3Mge1xufVxuLyoqXG4qIENvbnN0YW50cyB0aGF0IGlkZW50aWZ5IHNoYXBlcywgbWFpbmx5IHRvIHByZXZlbnQgYGluc3RhbmNlb2ZgIGNhbGxzLlxuKlxuKiBAc3RhdGljXG4qIEBjb25zdGFudFxuKiBAbmFtZSBTSEFQRVNcbiogQG1lbWJlcm9mIFBJWElcbiogQHR5cGUge29iamVjdH1cbiogQHByb3BlcnR5IHtudW1iZXJ9IFBPTFkgUG9seWdvblxuKiBAcHJvcGVydHkge251bWJlcn0gUkVDVCBSZWN0YW5nbGVcbiogQHByb3BlcnR5IHtudW1iZXJ9IENJUkMgQ2lyY2xlXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBFTElQIEVsbGlwc2VcbiogQHByb3BlcnR5IHtudW1iZXJ9IFJSRUMgUm91bmRlZCBSZWN0YW5nbGVcbiovXG5TaGFwZVNldHRpbmdzLlNIQVBFUyA9IHtcbiAgICBQT0xZOiAwLFxuICAgIFJFQ1Q6IDEsXG4gICAgQ0lSQzogMixcbiAgICBFTElQOiAzLFxuICAgIFJSRUM6IDQsXG59O1xuZXhwb3J0cy5TaGFwZVNldHRpbmdzID0gU2hhcGVTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4vTWVzaFwiKTtcbmNvbnN0IFJvcGVHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vUm9wZUdlb21ldHJ5XCIpO1xuY29uc3QgTWVzaE1hdGVyaWFsXzEgPSByZXF1aXJlKFwiLi9NZXNoTWF0ZXJpYWxcIik7XG5jbGFzcyBTaW1wbGVSb3BlIGV4dGVuZHMgTWVzaF8xLk1lc2gge1xuICAgIGNvbnN0cnVjdG9yKHRleHR1cmUsIHBvaW50cykge1xuICAgICAgICB2YXIgcm9wZUdlb21ldHJ5ID0gbmV3IFJvcGVHZW9tZXRyeV8xLlJvcGVHZW9tZXRyeSh0ZXh0dXJlLmhlaWdodCwgcG9pbnRzKTtcbiAgICAgICAgdmFyIG1lc2hNYXRlcmlhbCA9IG5ldyBNZXNoTWF0ZXJpYWxfMS5NZXNoTWF0ZXJpYWwodGV4dHVyZSk7XG4gICAgICAgIHN1cGVyKHJvcGVHZW9tZXRyeSwgbWVzaE1hdGVyaWFsKTtcbiAgICAgICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgICBpZiAodGhpcy5hdXRvVXBkYXRlXG4gICAgICAgICAgICB8fCB0aGlzLmdlb21ldHJ5LndpZHRoICE9PSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS53aWR0aCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5TaW1wbGVSb3BlID0gU2ltcGxlUm9wZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBPYnNlcnZhYmxlUG9pbnRfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVQb2ludFwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSB0ZXh0dXJlIGlzIHVwZGF0ZWQsIHRoaXMgZXZlbnQgd2lsbCBmaXJlIHRvIHVwZGF0ZSB0aGUgc2NhbGUgYW5kIGZyYW1lXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXJfMS50cmFjZShcIlNwcml0ZSB1cGRhdGVcIik7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xuICAgICAgICAgICAgLy8gcmV2ZWFsKHRoaXMuX3RleHR1cmUpXG4gICAgICAgICAgICB0aGlzLnV2cyA9IHRoaXMuX3RleHR1cmUuX3V2cy51dnNGbG9hdDMyO1xuICAgICAgICAgICAgLy8gc28gaWYgX3dpZHRoIGlzIDAgdGhlbiB3aWR0aCB3YXMgbm90IHNldC4uXG4gICAgICAgICAgICBpZiAodGhpcy5fd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnggPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLngpICogdGhpcy5fd2lkdGggLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnNpZ24odGhpcy5zY2FsZS55KSAqIHRoaXMuX2hlaWdodCAvIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW5jaG9yIHNldHMgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgaXMgMCwwIG9yIHRha2VuIGZyb20gdGhlIHtAbGluayBQSVhJLlRleHR1cmUjZGVmYXVsdEFuY2hvcnxUZXh0dXJlfVxuICAgICAgICAgKiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBBIHZhbHVlIG9mIDAsMCBtZWFucyB0aGUgdGV4dHVyZSdzIG9yaWdpbiBpcyB0aGUgdG9wIGxlZnQuXG4gICAgICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAwLjUsMC41IG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIGNlbnRlcmVkLlxuICAgICAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gMSwxIHdvdWxkIG1lYW4gdGhlIHRleHR1cmUncyBvcmlnaW4gcG9pbnQgd2lsbCBiZSB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lci5cbiAgICAgICAgICogTm90ZTogVXBkYXRpbmcgdGhlIHtAbGluayBQSVhJLlRleHR1cmUjZGVmYXVsdEFuY2hvcn0gYWZ0ZXIgYSBUZXh0dXJlIGlzXG4gICAgICAgICAqIGNyZWF0ZWQgZG9lcyBfbm90XyB1cGRhdGUgdGhlIFNwcml0ZSdzIGFuY2hvciB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYW5jaG9yID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCh0aGlzLl9vbkFuY2hvclVwZGF0ZSwgdGhpcywgKHRleHR1cmUgPyB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueCA6IDApLCAodGV4dHVyZSA/IHRleHR1cmUuZGVmYXVsdEFuY2hvci55IDogMCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fd2lkdGggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlICh0aGlzIGlzIGluaXRpYWxseSBzZXQgYnkgdGhlIHRleHR1cmUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEEgdmFsdWUgb2YgMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90aW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGludFJHQiA9IG51bGw7XG4gICAgICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2hhZGVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlbmRlciB0aGUgc3ByaXRlLiBTZXQgdG8gbnVsbCB0byByZW1vdmUgYSBjdXJyZW50IHNoYWRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWx0ZXJ8UElYSS5TaGFkZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlcm5hbCBjYWNoZWQgdmFsdWUgb2YgdGhlIHRpbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xuICAgICAgICB0aGlzLnV2cyA9IG51bGw7XG4gICAgICAgIC8vIGNhbGwgdGV4dHVyZSBzZXR0ZXJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZSB8fCBUZXh0dXJlXzEuVGV4dHVyZS5FTVBUWTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgdmVydGV4IGRhdGEgb2YgdGhlIHNwcml0ZSAoYmFzaWNhbGx5IGEgcXVhZClcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0IElGIGl0IGlzIGEgdHJpbW1lZCBzcHJpdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSAtMTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xuICAgICAgICAvLyBCYXRjaGFibGUgc3R1ZmYuLlxuICAgICAgICAvLyBUT0RPIGNvdWxkIG1ha2UgdGhpcyBhIG1peGluP1xuICAgICAgICB0aGlzLmluZGljZXMgPSBTcHJpdGUuaW5kaWNlcztcbiAgICAgICAgdGhpcy5zaXplID0gNDtcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbHVnaW4gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICogQWxsb3dzIHRvIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3Mgd2l0aG91dCBvdmVycmlkaW5nICdfcmVuZGVyJyAmICdfcmVuZGVyQ2FudmFzJyBtZXRob2RzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdzcHJpdGUnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsdWdpbk5hbWUgPSAnYmF0Y2gnO1xuICAgICAgICAvKipcbiAgICAgICAgICogdXNlZCB0byBmYXN0IGNoZWNrIGlmIGEgc3ByaXRlIGlzLi4gYSBzcHJpdGUhXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU3ByaXRlID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIHJvdW5kUGl4ZWxzIGZpZWxkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yb3VuZFBpeGVscyA9IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5ST1VORF9QSVhFTFM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBhbmNob3IgcG9zaXRpb24gdXBkYXRlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uQW5jaG9yVXBkYXRlKCkge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSAtMTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZXMgd29ybGRUcmFuc2Zvcm0gKiB2ZXJ0aWNlcywgc3RvcmUgaXQgaW4gdmVydGV4RGF0YVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVZlcnRpY2VzKCkge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQgJiYgdGhpcy5fdGV4dHVyZUlEID09PSB0ZXh0dXJlLl91cGRhdGVJRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IHRleHR1cmUuX3VwZGF0ZUlEO1xuICAgICAgICAvLyBzZXQgdGhlIHZlcnRleCBkYXRhXG4gICAgICAgIHZhciB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgYSA9IHd0LmE7XG4gICAgICAgIHZhciBiID0gd3QuYjtcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xuICAgICAgICB2YXIgZCA9IHd0LmQ7XG4gICAgICAgIHZhciB0eCA9IHd0LnR4O1xuICAgICAgICB2YXIgdHkgPSB3dC50eTtcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgICAgIHZhciB0cmltID0gdGV4dHVyZS50cmltO1xuICAgICAgICB2YXIgb3JpZyA9IHRleHR1cmUub3JpZztcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcbiAgICAgICAgdmFyIHcwID0gMDtcbiAgICAgICAgdmFyIHcxID0gMDtcbiAgICAgICAgdmFyIGgwID0gMDtcbiAgICAgICAgdmFyIGgxID0gMDtcbiAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCBhbmQgaXMgbm90IGEgdGlsaW5nc3ByaXRlIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlIGV4dHJhXG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBzcHJpdGUgY29vcmRzLlxuICAgICAgICAgICAgdzEgPSB0cmltLnggLSAoYW5jaG9yLl94ICogb3JpZy53aWR0aCk7XG4gICAgICAgICAgICB3MCA9IHcxICsgdHJpbS53aWR0aDtcbiAgICAgICAgICAgIGgxID0gdHJpbS55IC0gKGFuY2hvci5feSAqIG9yaWcuaGVpZ2h0KTtcbiAgICAgICAgICAgIGgwID0gaDEgKyB0cmltLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHcxID0gLWFuY2hvci5feCAqIG9yaWcud2lkdGg7XG4gICAgICAgICAgICB3MCA9IHcxICsgb3JpZy53aWR0aDtcbiAgICAgICAgICAgIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xuICAgICAgICAgICAgaDAgPSBoMSArIG9yaWcuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIHh5XG4gICAgICAgIHZlcnRleERhdGFbMF0gPSAoYSAqIHcxKSArIChjICogaDEpICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbMV0gPSAoZCAqIGgxKSArIChiICogdzEpICsgdHk7XG4gICAgICAgIC8vIHh5XG4gICAgICAgIHZlcnRleERhdGFbMl0gPSAoYSAqIHcwKSArIChjICogaDEpICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbM10gPSAoZCAqIGgxKSArIChiICogdzApICsgdHk7XG4gICAgICAgIC8vIHh5XG4gICAgICAgIHZlcnRleERhdGFbNF0gPSAoYSAqIHcwKSArIChjICogaDApICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbNV0gPSAoZCAqIGgwKSArIChiICogdzApICsgdHk7XG4gICAgICAgIC8vIHh5XG4gICAgICAgIHZlcnRleERhdGFbNl0gPSAoYSAqIHcxKSArIChjICogaDApICsgdHg7XG4gICAgICAgIHZlcnRleERhdGFbN10gPSAoZCAqIGgwKSArIChiICogdzEpICsgdHk7XG4gICAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEYXRhW2ldID0gTWF0aC5yb3VuZCh2ZXJ0ZXhEYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlcyB3b3JsZFRyYW5zZm9ybSAqIHZlcnRpY2VzIGZvciBhIG5vbiB0ZXh0dXJlIHdpdGggYSB0cmltLiBzdG9yZSBpdCBpbiB2ZXJ0ZXhUcmltbWVkRGF0YVxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgdHJ1ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIGEgdHJpbW1lZCB0ZXh0dXJlIGlzIHJlc3BlY3RlZFxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVRyaW1tZWRWZXJ0aWNlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZlcnRleFRyaW1tZWREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleFRyaW1tZWREYXRhID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEICYmIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPT09IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSB0aGlzLl90ZXh0dXJlLl91cGRhdGVJRDtcbiAgICAgICAgLy8gbGV0cyBkbyBzb21lIHNwZWNpYWwgdHJpbSBjb2RlIVxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YTtcbiAgICAgICAgdmFyIG9yaWcgPSB0ZXh0dXJlLm9yaWc7XG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9hbmNob3I7XG4gICAgICAgIC8vIGxldHMgY2FsY3VsYXRlIHRoZSBuZXcgdW50cmltbWVkIGJvdW5kcy4uXG4gICAgICAgIHZhciB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgYSA9IHd0LmE7XG4gICAgICAgIHZhciBiID0gd3QuYjtcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xuICAgICAgICB2YXIgZCA9IHd0LmQ7XG4gICAgICAgIHZhciB0eCA9IHd0LnR4O1xuICAgICAgICB2YXIgdHkgPSB3dC50eTtcbiAgICAgICAgdmFyIHcxID0gLWFuY2hvci5feCAqIG9yaWcud2lkdGg7XG4gICAgICAgIHZhciB3MCA9IHcxICsgb3JpZy53aWR0aDtcbiAgICAgICAgdmFyIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xuICAgICAgICB2YXIgaDAgPSBoMSArIG9yaWcuaGVpZ2h0O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzBdID0gKGEgKiB3MSkgKyAoYyAqIGgxKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzFdID0gKGQgKiBoMSkgKyAoYiAqIHcxKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzJdID0gKGEgKiB3MCkgKyAoYyAqIGgxKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzNdID0gKGQgKiBoMSkgKyAoYiAqIHcwKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzRdID0gKGEgKiB3MCkgKyAoYyAqIGgwKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzVdID0gKGQgKiBoMCkgKyAoYiAqIHcwKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzZdID0gKGEgKiB3MSkgKyAoYyAqIGgwKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzddID0gKGQgKiBoMCkgKyAoYiAqIHcxKSArIHR5O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgKlxuICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICpcbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgd2ViZ2wgcmVuZGVyZXIgdG8gdXNlLlxuICAgICovXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXSk7XG4gICAgICAgIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIHNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgICAgICB2YXIgdHJpbSA9IHRoaXMuX3RleHR1cmUudHJpbTtcbiAgICAgICAgdmFyIG9yaWcgPSB0aGlzLl90ZXh0dXJlLm9yaWc7XG4gICAgICAgIC8vIEZpcnN0IGxldHMgY2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHRleHR1cmUgaGFzIGEgdHJpbS4uXG4gICAgICAgIGlmICghdHJpbSB8fCAodHJpbS53aWR0aCA9PT0gb3JpZy53aWR0aCAmJiB0cmltLmhlaWdodCA9PT0gb3JpZy5oZWlnaHQpKSB7XG4gICAgICAgICAgICAvLyBubyB0cmltISBsZXRzIHVzZSB0aGUgdXN1YWwgY2FsY3VsYXRpb25zLi5cbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBsZXRzIGNhbGN1bGF0ZSBhIHNwZWNpYWwgdHJpbW1lZCBib3VuZHMuLi5cbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVHJpbW1lZFZlcnRpY2VzKCk7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleFRyaW1tZWREYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBzcHJpdGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdCAtIFRoZSBvdXRwdXQgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBUaGUgYm91bmRzLlxuICAgICAqL1xuICAgIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICAgICAgLy8gd2UgY2FuIGRvIGEgZmFzdCBsb2NhbCBib3VuZHMgaWYgdGhlIHNwcml0ZSBoYXMgbm8gY2hpbGRyZW4hXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAtdGhpcy5fYW5jaG9yLl94O1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogLXRoaXMuX2FuY2hvci5feTtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5tYXhYID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3kpO1xuICAgICAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbnRhaW5lcl8xLkNvbnRhaW5lci5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgc3ByaXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgU3ByaXRlLnRlbXBQb2ludCk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgIHZhciB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLng7XG4gICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgIGlmIChTcHJpdGUudGVtcFBvaW50LnggPj0geDEgJiYgU3ByaXRlLnRlbXBQb2ludC54IDwgeDEgKyB3aWR0aCkge1xuICAgICAgICAgICAgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcbiAgICAgICAgICAgIGlmIChTcHJpdGUudGVtcFBvaW50LnkgPj0geTEgJiYgU3ByaXRlLnRlbXBQb2ludC55IDwgeTEgKyBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHNwcml0ZSBhbmQgb3B0aW9uYWxseSBpdHMgdGV4dHVyZSBhbmQgY2hpbGRyZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgICAqICAgICAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqL1xuICAgIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICAvLyB0aGlzLl90ZXh0dXJlLm9mZigndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fYW5jaG9yID0gbnVsbDtcbiAgICAgICAgdmFyIGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zICYmIG9wdGlvbnMudGV4dHVyZTtcbiAgICAgICAgaWYgKGRlc3Ryb3lUZXh0dXJlKSB7XG4gICAgICAgICAgICB2YXIgZGVzdHJveUJhc2VUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zICYmIG9wdGlvbnMuYmFzZVRleHR1cmU7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koISFkZXN0cm95QmFzZVRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAqIEFkdmFudGFnZXMgY2FuIGluY2x1ZGUgc2hhcnBlciBpbWFnZSBxdWFsaXR5IChsaWtlIHRleHQpIGFuZCBmYXN0ZXIgcmVuZGVyaW5nIG9uIGNhbnZhcy5cbiAgICAgKiBUaGUgbWFpbiBkaXNhZHZhbnRhZ2UgaXMgbW92ZW1lbnQgb2Ygb2JqZWN0cyBtYXkgYXBwZWFyIGxlc3Mgc21vb3RoLlxuICAgICAqIFRvIHNldCB0aGUgZ2xvYmFsIGRlZmF1bHQsIGNoYW5nZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5ST1VORF9QSVhFTFN9XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgc2V0IHJvdW5kUGl4ZWxzKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscyAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCByb3VuZFBpeGVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdW5kUGl4ZWxzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICB9XG4gICAgO1xuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgICAgICB2YXIgcyA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcbiAgICAgICAgdGhpcy5zY2FsZS54ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdmFyIHMgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgICAgIHRoaXMuc2NhbGUueSA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHRleHQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRha2VuIGZyb20gdGhlIHtAbGluayBQSVhJLlRleHR1cmV8VGV4dHVyZX1cbiAgICAgKiBhbmQgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGAoMCwwKWAsIHRoaXMgbWVhbnMgdGhlIHRleHQncyBvcmlnaW4gaXMgdGhlIHRvcCBsZWZ0LlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIGAoMC41LDAuNSlgIG1lYW5zIHRoZSB0ZXh0J3Mgb3JpZ2luIGlzIGNlbnRlcmVkLlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIGAoMSwxKWAgd291bGQgbWVhbiB0aGUgdGV4dCdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICAgICAqXG4gICAgICogSWYgeW91IHBhc3Mgb25seSBzaW5nbGUgcGFyYW1ldGVyLCBpdCB3aWxsIHNldCBib3RoIHggYW5kIHkgdG8gdGhlIHNhbWUgdmFsdWUgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUgYmVsb3cuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAgICAgKiBzcHJpdGUuYW5jaG9yLnNldCgwLjUpOyAvLyBUaGlzIHdpbGwgc2V0IHRoZSBvcmlnaW4gdG8gY2VudGVyLiAoMC41KSBpcyBzYW1lIGFzICgwLjUsIDAuNSkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgKi9cbiAgICBnZXQgYW5jaG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGFuY2hvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hbmNob3IuY29weUZyb20odmFsdWUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLlxuICAgICAqIEEgdmFsdWUgb2YgMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICovXG4gICAgZ2V0IHRpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW50O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGludCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl90aW50UkdCID0gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDB4ZmYwMCkgKyAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IHRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlIHx8IFRleHR1cmVfMS5UZXh0dXJlLkVNUFRZO1xuICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcbiAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgdGV4dHVyZSB0byBsb2FkXG4gICAgICAgICAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlLmFkZEV2ZW50TGlzdGVuZXIoJ3VwZGF0ZScsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSk7XG4gICAgICAgICAgICAgICAgLy8gdmFsdWUub25jZSgndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG5TcHJpdGUudGVtcFBvaW50ID0gbmV3IFBvaW50XzEuUG9pbnQoKTtcblNwcml0ZS5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSk7XG4vLyBzb21lIGhlbHBlciBmdW5jdGlvbnMuLlxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICogVGhlIHNvdXJjZSBjYW4gYmUgLSBmcmFtZSBpZCwgaW1hZ2UgdXJsLCB2aWRlbyB1cmwsIGNhbnZhcyBlbGVtZW50LCB2aWRlbyBlbGVtZW50LCBiYXNlIHRleHR1cmVcbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8UElYSS5UZXh0dXJlfEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHNvdXJjZSBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gVGhlIG5ld2x5IGNyZWF0ZWQgc3ByaXRlXG4gKi9cblNwcml0ZS5mcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgdGV4dHVyZSA9IChzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSlcbiAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgOiBUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBTcHJpdGUodGV4dHVyZSk7XG59O1xuZXhwb3J0cy5TcHJpdGUgPSBTcHJpdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jb25zdCBUZXh0dXJlTWF0cml4XzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlTWF0cml4XCIpO1xuY2xhc3MgU3ByaXRlTWFza0ZpbHRlciBleHRlbmRzIEZpbHRlcl8xLkZpbHRlciB7XG4gICAgY29uc3RydWN0b3Ioc3ByaXRlKSB7XG4gICAgICAgIHZhciBtYXNrTWF0cml4ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuICAgICAgICBzdXBlcihTcHJpdGVNYXNrRmlsdGVyLnZlcnRleCwgU3ByaXRlTWFza0ZpbHRlci5mcmFnbWVudCk7XG4gICAgICAgIHNwcml0ZS5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcHJpdGUgbWFza1xuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNwcml0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFza1Nwcml0ZSA9IHNwcml0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hc2sgbWF0cml4XG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXNrTWF0cml4ID0gbWFza01hdHJpeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuc3lzdGVtcy5GaWx0ZXJTeXN0ZW19IGZpbHRlck1hbmFnZXIgLSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IG91dHB1dCAtIFRoZSB0YXJnZXQgdG8gb3V0cHV0IHRvLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXIgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXQuXG4gICAgICovXG4gICAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcbiAgICAgICAgdmFyIG1hc2tTcHJpdGUgPSB0aGlzLm1hc2tTcHJpdGU7XG4gICAgICAgIHZhciB0ZXggPSB0aGlzLm1hc2tTcHJpdGUudGV4dHVyZTtcbiAgICAgICAgaWYgKCF0ZXgudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIG1hcmdpbiA9IDAuMCwgbGV0IGl0IGJsZWVkIGEgYml0LCBzaGFkZXIgY29kZSBiZWNvbWVzIGVhc2llclxuICAgICAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCBhdGxhcyB0ZXh0dXJlcyB3ZXJlIG1hZGUgd2l0aCAxLXBpeGVsIHBhZGRpbmdcbiAgICAgICAgICAgIHRleC50cmFuc2Zvcm0gPSBuZXcgVGV4dHVyZU1hdHJpeF8xLlRleHR1cmVNYXRyaXgodGV4LCAwLjApO1xuICAgICAgICB9XG4gICAgICAgIHRleC50cmFuc2Zvcm0udXBkYXRlKCk7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubnBtQWxwaGEgPSB0ZXguYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IDAuMCA6IDEuMDtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrID0gdGV4O1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm90aGVyTWF0cml4ID0gZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVTcHJpdGVNYXRyaXgodGhpcy5tYXNrTWF0cml4LCBtYXNrU3ByaXRlKVxuICAgICAgICAgICAgLnByZXBlbmQodGV4LnRyYW5zZm9ybS5tYXBDb29yZCk7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYWxwaGEgPSBtYXNrU3ByaXRlLndvcmxkQWxwaGE7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFza0NsYW1wID0gdGV4LnRyYW5zZm9ybS51Q2xhbXBGcmFtZTtcbiAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XG4gICAgfVxuICAgIDtcbn1cblNwcml0ZU1hc2tGaWx0ZXIudmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxyXFxuICAgIHZNYXNrQ29vcmQgPSAoIG90aGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXHJcXG59XFxyXFxuXCI7XG5TcHJpdGVNYXNrRmlsdGVyLmZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXNrO1xcclxcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XFxyXFxudW5pZm9ybSBmbG9hdCBucG1BbHBoYTtcXHJcXG51bmlmb3JtIHZlYzQgbWFza0NsYW1wO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZmxvYXQgY2xpcCA9IHN0ZXAoMy41LFxcclxcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueCwgdk1hc2tDb29yZC54KSArXFxyXFxuICAgICAgICBzdGVwKG1hc2tDbGFtcC55LCB2TWFza0Nvb3JkLnkpICtcXHJcXG4gICAgICAgIHN0ZXAodk1hc2tDb29yZC54LCBtYXNrQ2xhbXAueikgK1xcclxcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLnksIG1hc2tDbGFtcC53KSk7XFxyXFxuXFxyXFxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcclxcbiAgICB2ZWM0IG1hc2t5ID0gdGV4dHVyZTJEKG1hc2ssIHZNYXNrQ29vcmQpO1xcclxcbiAgICBmbG9hdCBhbHBoYU11bCA9IDEuMCAtIG5wbUFscGhhICogKDEuMCAtIG1hc2t5LmEpO1xcclxcblxcclxcbiAgICBvcmlnaW5hbCAqPSAoYWxwaGFNdWwgKiBtYXNreS5yICogYWxwaGEgKiBjbGlwKTtcXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gb3JpZ2luYWw7XFxyXFxufVxcclxcblwiO1xuZXhwb3J0cy5TcHJpdGVNYXNrRmlsdGVyID0gU3ByaXRlTWFza0ZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgTmV0d29ya1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9OZXR3b3JrU2V0dGluZ3NcIik7XG5jbGFzcyBTcHJpdGVzaGVldCB7XG4gICAgY29uc3RydWN0b3IoYmFzZVRleHR1cmUsIGRhdGEsIHJlc29sdXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aHMgc291cmNlIHRleHR1cmVcbiAgICAgICAgICogQHR5cGUge1BJWEkuQmFzZVRleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBjb250YWluaW5nIGFsbCB0ZXh0dXJlcyBvZiB0aGUgc3ByaXRlIHNoZWV0LlxuICAgICAgICAgKiBDYW4gYmUgdXNlZCB0byBjcmVhdGUgYSB7QGxpbmsgUElYSS5TcHJpdGV8U3ByaXRlfTpcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogbmV3IFBJWEkuU3ByaXRlKHNoZWV0LnRleHR1cmVzW1wiaW1hZ2UucG5nXCJdKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIGNvbnRhaW5pbmcgdGhlIHRleHR1cmVzIGZvciBlYWNoIGFuaW1hdGlvbi5cbiAgICAgICAgICogQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuIHtAbGluayBQSVhJLkFuaW1hdGVkU3ByaXRlfEFuaW1hdGVkU3ByaXRlfTpcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogbmV3IFBJWEkuQW5pbWF0ZWRTcHJpdGUoc2hlZXQuYW5pbWF0aW9uc1tcImFuaW1fbmFtZVwiXSlcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBKU09OIGRhdGEuXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIHNwcml0ZXNoZWV0LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gdGhpcy5fdXBkYXRlUmVzb2x1dGlvbihyZXNvbHV0aW9uRmlsZW5hbWVcbiAgICAgICAgICAgIHx8ICh0aGlzLmJhc2VUZXh0dXJlLnJlc291cmNlID8gdGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZS51cmwgOiBudWxsKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2Ygc3ByaXRlc2hlZXQgZnJhbWVzLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZnJhbWVzID0gdGhpcy5kYXRhLmZyYW1lcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgZnJhbWUgbmFtZXMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZyYW1lS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZyYW1lcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IGJhdGNoIGluZGV4IGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2JhdGNoSW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgd2hlbiBwYXJzZSBpcyBjb21wbGV0ZWQuXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gICAgX3VwZGF0ZVJlc29sdXRpb24ocmVzb2x1dGlvbkZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZGF0YS5tZXRhLnNjYWxlO1xuICAgICAgICAvLyBVc2UgYSBkZWZhdWx0VmFsdWUgb2YgYG51bGxgIHRvIGNoZWNrIGlmIGEgdXJsLWJhc2VkIHJlc29sdXRpb24gaXMgc2V0XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gTmV0d29ya1NldHRpbmdzXzEuTmV0d29ya1NldHRpbmdzLmdldFJlc29sdXRpb25PZlVybChyZXNvbHV0aW9uRmlsZW5hbWUsIG51bGwpO1xuICAgICAgICAvLyBObyByZXNvbHV0aW9uIGZvdW5kIHZpYSBVUkxcbiAgICAgICAgaWYgKHJlc29sdXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgc2NhbGUgdmFsdWUgb3IgZGVmYXVsdCB0byAxXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gc2NhbGUgIT09IHVuZGVmaW5lZCA/IHBhcnNlRmxvYXQoc2NhbGUpIDogMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3Igbm9uLTEgcmVzb2x1dGlvbnMsIHVwZGF0ZSBiYXNlVGV4dHVyZVxuICAgICAgICBpZiAocmVzb2x1dGlvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHV0aW9uO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIHJlc29sdXRpb24gZnJvbSB0aGUgZmlsZW5hbWUgb3IgZmFsbGJhY2tcbiAgICAgKiB0byB0aGUgbWV0YS5zY2FsZSBmaWVsZCBvZiB0aGUgSlNPTiBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb2x1dGlvbkZpbGVuYW1lIC0gVGhlIGZpbGVuYW1lIHRvIHVzZSBmb3IgcmVzb2x2aW5nXG4gICAgICogICAgdGhlIGRlZmF1bHQgcmVzb2x1dGlvbi5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24gdG8gdXNlIGZvciBzcHJpdGVzaGVldC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEJBVENIX1NJWkUoKSB7XG4gICAgICAgIHJldHVybiAxMDAwO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUGFyc2VyIHNwcml0ZXNoZWV0IGZyb20gbG9hZGVkIGRhdGEuIFRoaXMgaXMgZG9uZSBhc3luY2hyb25vdXNseVxuICAgICAqIHRvIHByZXZlbnQgY3JlYXRpbmcgdG9vIG1hbnkgVGV4dHVyZSB3aXRoaW4gYSBzaW5nbGUgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgd2hlbiBjb21wbGV0ZSByZXR1cm5zXG4gICAgICogICAgYSBtYXAgb2YgdGhlIFRleHR1cmVzIGZvciB0aGlzIHNwcml0ZXNoZWV0LlxuICAgICAqL1xuICAgIHBhcnNlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodGhpcy5fZnJhbWVLZXlzLmxlbmd0aCA8PSBTcHJpdGVzaGVldC5CQVRDSF9TSVpFKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzRnJhbWVzKDApO1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0FuaW1hdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25leHRCYXRjaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgYmF0Y2ggb2YgZnJhbWVzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbml0aWFsRnJhbWVJbmRleCAtIFRoZSBpbmRleCBvZiBmcmFtZSB0byBzdGFydC5cbiAgICAgKi9cbiAgICBfcHJvY2Vzc0ZyYW1lcyhpbml0aWFsRnJhbWVJbmRleCkge1xuICAgICAgICB2YXIgZnJhbWVJbmRleCA9IGluaXRpYWxGcmFtZUluZGV4O1xuICAgICAgICB2YXIgbWF4RnJhbWVzID0gU3ByaXRlc2hlZXQuQkFUQ0hfU0laRTtcbiAgICAgICAgd2hpbGUgKGZyYW1lSW5kZXggLSBpbml0aWFsRnJhbWVJbmRleCA8IG1heEZyYW1lcyAmJiBmcmFtZUluZGV4IDwgdGhpcy5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9mcmFtZUtleXNbZnJhbWVJbmRleF07XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ZyYW1lc1tpXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZGF0YS5mcmFtZTtcbiAgICAgICAgICAgIGlmIChyZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgdHJpbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVNpemUgPSBkYXRhLnRyaW1tZWQgIT09IGZhbHNlICYmIGRhdGEuc291cmNlU2l6ZVxuICAgICAgICAgICAgICAgICAgICA/IGRhdGEuc291cmNlU2l6ZSA6IGRhdGEuZnJhbWU7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWcgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIE1hdGguZmxvb3Ioc291cmNlU2l6ZS53KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihzb3VyY2VTaXplLmgpIC8gdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5yb3RhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZShNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudHJpbW1lZCAhPT0gZmFsc2UgJiYgZGF0YS5zcHJpdGVTb3VyY2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaW0gPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKE1hdGguZmxvb3IoZGF0YS5zcHJpdGVTb3VyY2VTaXplLngpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LncpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVzW2ldID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIGZyYW1lLCBvcmlnLCB0cmltLCBkYXRhLnJvdGF0ZWQgPyAyIDogMCwgZGF0YS5hbmNob3IpO1xuICAgICAgICAgICAgICAgIC8vIGxldHMgYWxzbyBhZGQgdGhlIGZyYW1lIHRvIHBpeGkncyBnbG9iYWwgY2FjaGUgZm9yIGZyb21GcmFtZSBhbmQgZnJvbUltYWdlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgIFRleHR1cmVfMS5UZXh0dXJlLmFkZFRvQ2FjaGUodGhpcy50ZXh0dXJlc1tpXSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmFtZUluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFBhcnNlIGFuaW1hdGlvbnMgY29uZmlnXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wcm9jZXNzQW5pbWF0aW9ucygpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmRhdGEuYW5pbWF0aW9ucyB8fCB7fTtcbiAgICAgICAgZm9yICh2YXIgYW5pbU5hbWUgaW4gYW5pbWF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zW2FuaW1OYW1lXSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRpb25zW2FuaW1OYW1lXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZU5hbWUgPSBhbmltYXRpb25zW2FuaW1OYW1lXVtpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdLnB1c2godGhpcy50ZXh0dXJlc1tmcmFtZU5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHBhcnNlIGhhcyBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wYXJzZUNvbXBsZXRlKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLnRleHR1cmVzKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEJlZ2luIHRoZSBuZXh0IGJhdGNoIG9mIHRleHR1cmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmV4dEJhdGNoKCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgdGhpcy5fcHJvY2Vzc0ZyYW1lcyh0aGlzLl9iYXRjaEluZGV4ICogU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSk7XG4gICAgICAgIHRoaXMuX2JhdGNoSW5kZXgrKztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcyQxLl9iYXRjaEluZGV4ICogU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSA8IHRoaXMkMS5fZnJhbWVLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5fbmV4dEJhdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEuX3Byb2Nlc3NBbmltYXRpb25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcyQxLl9wYXJzZUNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBTcHJpdGVzaGVldCBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXN0cm95QmFzZT1mYWxzZV0gV2hldGhlciB0byBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgYXMgd2VsbFxuICAgICAqL1xuICAgIGRlc3Ryb3koZGVzdHJveUJhc2UpIHtcbiAgICAgICAgaWYgKGRlc3Ryb3lCYXNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlc3Ryb3lCYXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnRleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mcmFtZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9mcmFtZUtleXMgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVzID0gbnVsbDtcbiAgICAgICAgaWYgKGRlc3Ryb3lCYXNlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5TcHJpdGVzaGVldCA9IFNwcml0ZXNoZWV0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBTdGFnZU9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNoYXJlZExvYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvcmNlQ2FudmFzID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuYW50aWFsaWFzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9yY2VGWEFBID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0RlbnNpdHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9SZXNpemUgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gMHgwMDAwMDA7XG4gICAgICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmF1dG9TdGFydCA9IHRydWU7XG4gICAgICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2lkdGggPSAxMDI0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IDc2ODtcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcbiAgICAgICAgdGhpcy5sZWdhY3kgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb3VuZFBpeGVscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNoYXJlZFRpY2tlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2l6ZVRvID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3dlclByZWZlcmVuY2UgPSBcImhpZ2gtcGVyZm9ybWFuY2VcIjtcbiAgICB9XG59XG5leHBvcnRzLlN0YWdlT3B0aW9ucyA9IFN0YWdlT3B0aW9ucztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUG9seWdvbl8xID0gcmVxdWlyZShcIi4vUG9seWdvblwiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY2xhc3MgU3RhciBleHRlbmRzIFBvbHlnb25fMS5Qb2x5Z29uIHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBwb2ludHMsIHJhZGl1cywgaW5uZXJSYWRpdXMsIHJvdGF0aW9uKSB7XG4gICAgICAgIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgcmFkaXVzIC8gMjtcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSAoLTEgKiBNYXRoLlBJIC8gMikgKyByb3RhdGlvbjtcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cyAqIDI7XG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5QSV8yIC8gbGVuO1xuICAgICAgICB2YXIgcG9seWdvbiA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgciA9IGkgJSAyID8gaW5uZXJSYWRpdXMgOiByYWRpdXM7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSAoaSAqIGRlbHRhKSArIHN0YXJ0QW5nbGU7XG4gICAgICAgICAgICBwb2x5Z29uLnB1c2goeCArIChyICogTWF0aC5jb3MoYW5nbGUpKSwgeSArIChyICogTWF0aC5zaW4oYW5nbGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocG9seWdvbik7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFyID0gU3RhcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jbGFzcyBTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IDA7XG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5ibGVuZCA9IHRydWU7XG4gICAgICAgIC8vICB0aGlzLmRlcHRoVGVzdCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyBibGVuZGluZyBvZiB0aGUgY29tcHV0ZWQgZnJhZ21lbnQgY29sb3IgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBibGVuZCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkJMRU5EKSk7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYmxlbmQodmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkJMRU5EKSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgXj0gKDEgPDwgU3RhdGUuQkxFTkQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgYWRkaW5nIGFuIG9mZnNldCB0byBkZXB0aCB2YWx1ZXMgb2YgcG9seWdvbidzIGZyYWdtZW50c1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBvZmZzZXRzKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuT0ZGU0VUKSk7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgb2Zmc2V0cyh2YWx1ZSkge1xuICAgICAgICBpZiAoISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuT0ZGU0VUKSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgXj0gKDEgPDwgU3RhdGUuT0ZGU0VUKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIGN1bGxpbmcgb2YgcG9seWdvbnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZ2V0IGN1bGxpbmcoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5DVUxMSU5HKSk7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgY3VsbGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuQ1VMTElORykpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhIF49ICgxIDw8IFN0YXRlLkNVTExJTkcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgZGVwdGggY29tcGFyaXNvbnMgYW5kIHVwZGF0ZXMgdG8gdGhlIGRlcHRoIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBnZXQgZGVwdGhUZXN0KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuREVQVEhfVEVTVCkpO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGRlcHRoVGVzdCh2YWx1ZSkge1xuICAgICAgICBpZiAoISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuREVQVEhfVEVTVCkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhIF49ICgxIDw8IFN0YXRlLkRFUFRIX1RFU1QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgZnJvbnQgb3IgYmFjay1mYWNpbmcgcG9seWdvbnMgY2FuIGJlIGN1bGxlZC5cbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZ2V0IGNsb2Nrd2lzZUZyb250RmFjZSgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLldJTkRJTkcpKTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBjbG9ja3dpc2VGcm9udEZhY2UodmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLldJTkRJTkcpKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSBePSAoMSA8PCBTdGF0ZS5XSU5ESU5HKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB3aGVuIHRoaXMgc3RhdGUgaXMgc2V0LiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXG4gICAgICogU2V0dGluZyB0aGlzIG1vZGUgdG8gYW55dGhpbmcgb3RoZXIgdGhhbiBOT19CTEVORCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIGJsZW5kaW5nIG9uLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAqL1xuICAgIGdldCBibGVuZE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibGVuZE1vZGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmxlbmQgPSAodmFsdWUgIT09IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT05FKTtcbiAgICAgICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9seWdvbiBvZmZzZXQuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byBhbnl0aGluZyBvdGhlciB0aGFuIDAgd2lsbCBhdXRvbWF0aWNhbGx5IGVuYWJsZSBwb2x5Z29uIG9mZnNldCBmaWxsLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBnZXQgcG9seWdvbk9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvbHlnb25PZmZzZXQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcG9seWdvbk9mZnNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm9mZnNldHMgPSAhIXZhbHVlO1xuICAgICAgICB0aGlzLl9wb2x5Z29uT2Zmc2V0ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0aWMgZm9yMmQoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgICAgICBzdGF0ZS5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuYmxlbmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIDtcbn1cblN0YXRlLkJMRU5EID0gMDtcblN0YXRlLk9GRlNFVCA9IDE7XG5TdGF0ZS5DVUxMSU5HID0gMjtcblN0YXRlLkRFUFRIX1RFU1QgPSAzO1xuU3RhdGUuV0lORElORyA9IDQ7XG5leHBvcnRzLlN0YXRlID0gU3RhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jbGFzcyBTdGF0ZVN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR0wgY29udGV4dFxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGF0ZSBJRFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZUlkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvbHlnb24gb2Zmc2V0XG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmxlbmQgbW9kZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9ORVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PTkU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGN1cnJlbnQgYmxlbmQgZXF1YXRpb24gaXMgZGlmZmVyZW50XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2JsZW5kRXEgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgY2FsbHNcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb25bXX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcCA9IFtdO1xuICAgICAgICAvLyBtYXAgZnVuY3Rpb25zIGZvciB3aGVuIHdlIHNldCBzdGF0ZS4uXG4gICAgICAgIHRoaXMubWFwW1N0YXRlU3lzdGVtLkJMRU5EJDFdID0gdGhpcy5zZXRCbGVuZDtcbiAgICAgICAgdGhpcy5tYXBbU3RhdGVTeXN0ZW0uT0ZGU0VUJDFdID0gdGhpcy5zZXRPZmZzZXQ7XG4gICAgICAgIHRoaXMubWFwW1N0YXRlU3lzdGVtLkNVTExJTkckMV0gPSB0aGlzLnNldEN1bGxGYWNlO1xuICAgICAgICB0aGlzLm1hcFtTdGF0ZVN5c3RlbS5ERVBUSF9URVNUJDFdID0gdGhpcy5zZXREZXB0aFRlc3Q7XG4gICAgICAgIHRoaXMubWFwW1N0YXRlU3lzdGVtLldJTkRJTkckMV0gPSB0aGlzLnNldEZyb250RmFjZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgY2hlY2sgY2FsbHNcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb25bXX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBXZWJHTCBTdGF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlN0YXRlfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gbmV3IFN0YXRlXzEuU3RhdGUoKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUuYmxlbmQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZS5kZXB0aCA9IHRydWU7XG4gICAgfVxuICAgIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZXMgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MubWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpKGdsKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmRlZmF1bHRTdGF0ZSk7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc3RhdGUgLSBUaGUgc3RhdGUgdG8gc2V0LlxuICAgICAqL1xuICAgIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5kZWZhdWx0U3RhdGU7XG4gICAgICAgIC8vIFRPRE8gbWF5YmUgdG8gYW4gb2JqZWN0IGNoZWNrPyAoIHRoaXMuc3RhdGUgPT09IHN0YXRlICk/XG4gICAgICAgIGlmICh0aGlzLnN0YXRlSWQgIT09IHN0YXRlLmRhdGEpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gdGhpcy5zdGF0ZUlkIF4gc3RhdGUuZGF0YTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIC8vIG9yZGVyIGZyb20gbGVhc3QgdG8gbW9zdCBjb21tb25cbiAgICAgICAgICAgIHdoaWxlIChkaWZmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgJiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlIGNoYW5nZSFcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBbaV0uY2FsbCh0aGlzLCAhIShzdGF0ZS5kYXRhICYgKDEgPDwgaSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlmZiA9IGRpZmYgPj4gMTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlSWQgPSBzdGF0ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBhYm92ZSBzZXR0aW5ncyB3ZSBjaGVjayBmb3Igc3BlY2lmaWMgbW9kZXMuLlxuICAgICAgICAvLyBmb3IgZXhhbXBsZSBpZiBibGVuZCBpcyBhY3RpdmUgd2UgY2hlY2sgYW5kIHNldCB0aGUgYmxlbmQgbW9kZXNcbiAgICAgICAgLy8gb3Igb2YgcG9seWdvbiBvZmZzZXQgaXMgYWN0aXZlIHdlIGNoZWNrIHRoZSBwb2x5IGRlcHRoLlxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLmNoZWNrcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrc1tpJDFdKHRoaXMsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhdGUsIHdoZW4gcHJldmlvdXMgc3RhdGUgaXMgdW5rbm93blxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXRcbiAgICAgKi9cbiAgICBmb3JjZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5kZWZhdWx0U3RhdGU7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubWFwW2ldLmNhbGwodGhpcywgISEoc3RhdGUuZGF0YSAmICgxIDw8IGkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5jaGVja3MubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgdGhpcy5jaGVja3NbaSQxXSh0aGlzLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZUlkID0gc3RhdGUuZGF0YTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZWQgYmxlbmRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHVybiBvbiBvciBvZmYgd2ViZ2wgYmxlbmRpbmcuXG4gICAgICovXG4gICAgc2V0QmxlbmQodmFsdWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDaGVjayhTdGF0ZVN5c3RlbS5jaGVja0JsZW5kTW9kZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuQkxFTkQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlIHBvbHlnb24gb2Zmc2V0IGZpbGxcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBwb2x5Z29uIG9mZnNldCB0ZXN0aW5nLlxuICAgICAqL1xuICAgIHNldE9mZnNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgZGVwdGggdGVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBkZXB0aCB0ZXN0aW5nLlxuICAgICAqL1xuICAgIHNldERlcHRoVGVzdCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuREVQVEhfVEVTVCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgY3VsbCBmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGN1bGwgZmFjZS5cbiAgICAgKi9cbiAgICBzZXRDdWxsRmFjZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdsIGZyb250IGZhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gdHJ1ZSBpcyBjbG9ja3dpc2UgYW5kIGZhbHNlIGlzIGNvdW50ZXItY2xvY2t3aXNlXG4gICAgICovXG4gICAgc2V0RnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZ2wuZnJvbnRGYWNlKHRoaXMuZ2xbdmFsdWUgPyAnQ1cnIDogJ0NDVyddKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJsZW5kIG1vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgYmxlbmQgbW9kZSB0byBzZXQgdG8uXG4gICAgICovXG4gICAgc2V0QmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5ibGVuZE1vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IHZhbHVlO1xuICAgICAgICB2YXIgbW9kZSA9IHRoaXMuYmxlbmRNb2Rlc1t2YWx1ZV07XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGlmIChtb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKG1vZGVbMF0sIG1vZGVbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUobW9kZVswXSwgbW9kZVsxXSwgbW9kZVsyXSwgbW9kZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGUubGVuZ3RoID09PSA2KSB7XG4gICAgICAgICAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShtb2RlWzRdLCBtb2RlWzVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9ibGVuZEVxKSB7XG4gICAgICAgICAgICB0aGlzLl9ibGVuZEVxID0gZmFsc2U7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcG9seWdvbiBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgcG9seWdvbiBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgLSB0aGUgcG9seWdvbiBvZmZzZXQgc2NhbGVcbiAgICAgKi9cbiAgICBzZXRQb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSkge1xuICAgICAgICB0aGlzLmdsLnBvbHlnb25PZmZzZXQodmFsdWUsIHNjYWxlKTtcbiAgICB9XG4gICAgO1xuICAgIC8vIHVzZWRcbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIHRoZSBsb2dpYyBhbmQgZGlzYWJsZXMgdGhlIHZhb3NcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5mb3JjZVN0YXRlKDApO1xuICAgICAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSAtMTtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoMCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBjaGVja3MgdG8gc2VlIHdoaWNoIHVwZGF0ZXMgc2hvdWxkIGJlIGNoZWNrZWQgYmFzZWQgb24gd2hpY2ggc2V0dGluZ3MgaGF2ZSBiZWVuIGFjdGl2YXRlZC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYmxlbmQgaXMgZW5hYmxlZCB0aGVuIHdlIHNob3VsZCBjaGVjayB0aGUgYmxlbmQgbW9kZXMgZWFjaCB0aW1lIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkXG4gICAgICogb3IgaWYgcG9seWdvbiBmaWxsIGlzIGFjdGl2YXRlZCB0aGVuIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHBvbHlnb24gb2Zmc2V0IGNoYW5nZXMuXG4gICAgICogVGhlIGlkZWEgaXMgdGhhdCB3ZSBvbmx5IGNoZWNrIHdoYXQgd2UgaGF2ZSB0b28uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jICB0aGUgY2hlY2tpbmcgZnVuY3Rpb24gdG8gYWRkIG9yIHJlbW92ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgIHNob3VsZCB0aGUgY2hlY2sgZnVuY3Rpb24gYmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVDaGVjayhmdW5jLCB2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoZWNrcy5pbmRleE9mKGZ1bmMpO1xuICAgICAgICBpZiAodmFsdWUgJiYgaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcy5wdXNoKGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF2YWx1ZSAmJiBpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEEgcHJpdmF0ZSBsaXR0bGUgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdlIGNhbGwgdG8gY2hlY2sgdGhlIGJsZW5kIG1vZGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3RhdGVTeXN0ZW19IFN5c3RlbSAgdGhlIFN5c3RlbSB0byBwZXJmb3JtIHRoZSBzdGF0ZSBjaGVjayBvblxuICAgICAqIEBwYXJhbSB7UElYSS5TdGF0ZX0gc3RhdGUgIHRoZSBzdGF0ZSB0aGF0IHRoZSBibGVuZE1vZGUgd2lsbCBwdWxsZWQgZnJvbVxuICAgICAqL1xuICAgIHN0YXRpYyBjaGVja0JsZW5kTW9kZShzeXN0ZW0sIHN0YXRlKSB7XG4gICAgICAgIHN5c3RlbS5zZXRCbGVuZE1vZGUoc3RhdGUuYmxlbmRNb2RlKTtcbiAgICB9XG4gICAgO1xufVxuU3RhdGVTeXN0ZW0uVUlEJDQgPSAwO1xuU3RhdGVTeXN0ZW0uQkxFTkQkMSA9IDA7XG5TdGF0ZVN5c3RlbS5PRkZTRVQkMSA9IDE7XG5TdGF0ZVN5c3RlbS5DVUxMSU5HJDEgPSAyO1xuU3RhdGVTeXN0ZW0uREVQVEhfVEVTVCQxID0gMztcblN0YXRlU3lzdGVtLldJTkRJTkckMSA9IDQ7XG5leHBvcnRzLlN0YXRlU3lzdGVtID0gU3RhdGVTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xuY2xhc3MgU3RlbmNpbFN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgbWFzayBzdGFjayB0aGF0IGlzIHVzZWQgYnkgdGhpcyBTeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NbXX0gc3RlbmNpbE1hc2tTdGFjayAtIFRoZSBtYXNrIHN0YWNrXG4gICAgICovXG4gICAgc2V0TWFza1N0YWNrKHN0ZW5jaWxNYXNrU3RhY2spIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgaWYgKHN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoICE9PSB0aGlzLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc3RlbmNpbE1hc2tTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBzdGVuY2lsTWFza1N0YWNrO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBzdGVuY2lsIHN0YWNrLiBAYWx2aW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc30gZ3JhcGhpY3MgLSBUaGUgbWFza1xuICAgICAqL1xuICAgIHB1c2hTdGVuY2lsKGdyYXBoaWNzKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciBwcmV2TWFza0NvdW50ID0gdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aDtcbiAgICAgICAgaWYgKHByZXZNYXNrQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2tTdGFjay5wdXNoKGdyYXBoaWNzKTtcbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2Ugc3RlbmNpbCB2YWx1ZSB3aGVyZSB0aGUgbmV3IG1hc2sgb3ZlcmxhcHMgd2l0aCB0aGUgb2xkIG9uZXMuXG4gICAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCBwcmV2TWFza0NvdW50LCB0aGlzLl9nZXRCaXR3aXNlTWFzaygpKTtcbiAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLklOQ1IpO1xuICAgICAgICBncmFwaGljcy5yZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgZ3JhcGhpY3MucmVuZGVyKHRoaXMucmVuZGVyZXIpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgIGdyYXBoaWNzLnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdXNlQ3VycmVudCgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBtYXNrIGZyb20gdGhlIHN0ZW5jaWwgc3RhY2suIEBhbHZpblxuICAgICAqL1xuICAgIHBvcFN0ZW5jaWwoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciBncmFwaGljcyA9IHRoaXMuc3RlbmNpbE1hc2tTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayBpcyBlbXB0eSFcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWNyZW1lbnQgdGhlIHJlZmVyZW5jZSBzdGVuY2lsIHZhbHVlIHdoZXJlIHRoZSBwb3BwZWQgbWFzayBvdmVybGFwcyB3aXRoIHRoZSBvdGhlciBvbmVzXG4gICAgICAgICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLkRFQ1IpO1xuICAgICAgICAgICAgZ3JhcGhpY3MucmVuZGVyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBncmFwaGljcy5yZW5kZXIodGhpcy5yZW5kZXJlcik7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgICAgICBncmFwaGljcy5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl91c2VDdXJyZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHVwIHJlbmRlcmVyIHRvIHVzZSB0aGUgY3VycmVudCBzdGVuY2lsIGRhdGEuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXNlQ3VycmVudCgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCwgdGhpcy5fZ2V0Qml0d2lzZU1hc2soKSk7XG4gICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEZpbGwgMXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBhY2l0dmUgc3RlbmNpbCBtYXNrcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJpdHdpc2UgbWFzay5cbiAgICAgKi9cbiAgICBfZ2V0Qml0d2lzZU1hc2soKSB7XG4gICAgICAgIHJldHVybiAoMSA8PCB0aGlzLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoKSAtIDE7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgbWFzayBzdGFjay5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5TdGVuY2lsU3lzdGVtID0gU3RlbmNpbFN5c3RlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XG5jbGFzcyBTeXN0ZW0gZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyID0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLmFkZCh0aGlzKTtcbiAgICB9XG4gICAgY29udGV4dENoYW5nZShnbCkge1xuICAgIH1cbiAgICA7XG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlN5c3RlbSA9IFN5c3RlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi9TcHJpdGVcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBUZXh0TWV0cmljc18xID0gcmVxdWlyZShcIi4vVGV4dE1ldHJpY3NcIik7XG5jb25zdCBUZXh0U3R5bGVfMSA9IHJlcXVpcmUoXCIuL1RleHRTdHlsZVwiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jb25zdCBDYW52YXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FudmFzU2V0dGluZ3NcIik7XG5jb25zdCBUZXh0U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1RleHRTZXR0aW5nc1wiKTtcbmNvbnN0IENsZWFuVXBTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2xlYW5VcFNldHRpbmdzXCIpO1xuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcbmNsYXNzIFRleHQgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlID0gbnVsbCwgY2FudmFzID0gbnVsbCkge1xuICAgICAgICBjYW52YXMgPSBjYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDM7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAzO1xuICAgICAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmVfMS5UZXh0dXJlLmZyb20oY2FudmFzKTtcbiAgICAgICAgdGV4dHVyZS5vcmlnID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgICAgICB0ZXh0dXJlLnRyaW0gPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XG4gICAgICAgIHN1cGVyKHRleHR1cmUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0b1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoXG4gICAgICAgICAqIEBtZW1iZXIge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgICAgICAgKiBUaGlzIGlzIHNldCB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIHRoZSByZW5kZXJlciByZXNvbHV0aW9uIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIG1hbnVhbGx5LlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICAgICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90ZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgbGlzdGVuZXIgdG8gdHJhY2sgc3R5bGUgY2hhbmdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdHlsZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgZm9udC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZm9udCA9ICcnO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGV4dCBhbmQgdXBkYXRlcyBpdCB3aGVuIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXNwZWN0RGlydHkgLSBXaGV0aGVyIHRvIGFib3J0IHVwZGF0aW5nIHRoZSB0ZXh0IGlmIHRoZSBUZXh0IGlzbid0IGRpcnR5IGFuZCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZVRleHQocmVzcGVjdERpcnR5KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICAvLyBjaGVjayBpZiBzdHlsZSBoYXMgY2hhbmdlZC4uXG4gICAgICAgIGlmICh0aGlzLmxvY2FsU3R5bGVJRCAhPT0gc3R5bGUuc3R5bGVJRCkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IHN0eWxlLnN0eWxlSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvbnQgPSB0aGlzLl9zdHlsZS50b0ZvbnRTdHJpbmcoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIFRleHRNZXRyaWNzXzEuVGV4dE1ldHJpY3MuaW5pdCgpO1xuICAgICAgICB2YXIgbWVhc3VyZWQgPSBUZXh0TWV0cmljc18xLlRleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRoaXMuX3RleHQgfHwgJyAnLCB0aGlzLl9zdHlsZSwgdGhpcy5fc3R5bGUud29yZFdyYXAsIHRoaXMuY2FudmFzKTtcbiAgICAgICAgdmFyIHdpZHRoID0gbWVhc3VyZWQud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHQ7XG4gICAgICAgIHZhciBsaW5lcyA9IG1lYXN1cmVkLmxpbmVzO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IG1lYXN1cmVkLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBsaW5lV2lkdGhzID0gbWVhc3VyZWQubGluZVdpZHRocztcbiAgICAgICAgdmFyIG1heExpbmVXaWR0aCA9IG1lYXN1cmVkLm1heExpbmVXaWR0aDtcbiAgICAgICAgdmFyIGZvbnRQcm9wZXJ0aWVzID0gbWVhc3VyZWQuZm9udFByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKChNYXRoLm1heCgxLCB3aWR0aCkgKyAoc3R5bGUucGFkZGluZyAqIDIpKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoKE1hdGgubWF4KDEsIGhlaWdodCkgKyAoc3R5bGUucGFkZGluZyAqIDIpKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMuX3Jlc29sdXRpb24sIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5mb250ID0gdGhpcy5fZm9udDtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICBjb250ZXh0LmxpbmVKb2luID0gc3R5bGUubGluZUpvaW47XG4gICAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQ7XG4gICAgICAgIHZhciBsaW5lUG9zaXRpb25YO1xuICAgICAgICB2YXIgbGluZVBvc2l0aW9uWTtcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgIHZhciBkcm9wU2hhZG93Q29sb3IgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XG4gICAgICAgICAgICB2YXIgcmdiID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuaGV4MnJnYih0eXBlb2YgZHJvcFNoYWRvd0NvbG9yID09PSAnbnVtYmVyJyA/IGRyb3BTaGFkb3dDb2xvciA6IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zdHJpbmcyaGV4KGRyb3BTaGFkb3dDb2xvcikpO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwicmdiYShcIiArIChyZ2JbMF0gKiAyNTUpICsgXCIsXCIgKyAocmdiWzFdICogMjU1KSArIFwiLFwiICsgKHJnYlsyXSAqIDI1NSkgKyBcIixcIiArIChzdHlsZS5kcm9wU2hhZG93QWxwaGEpICsgXCIpXCI7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBNYXRoLnNpbihzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IDA7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGNhbnZhcyB0ZXh0IHN0eWxlc1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX2dlbmVyYXRlRmlsbFN0eWxlKHN0eWxlLCBsaW5lcyk7XG4gICAgICAgIC8vIGRyYXcgbGluZXMgbGluZSBieSBsaW5lXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9ICgoc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMikgKyAoaSAqIGxpbmVIZWlnaHQpKSArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudDtcbiAgICAgICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZS5maWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgdGV4dCB3aXRoIGxldHRlci1zcGFjaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gZHJhd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJva2U9ZmFsc2VdIC0gSXMgdGhpcyBkcmF3aW5nIGZvciB0aGUgb3V0c2lkZSBzdHJva2Ugb2YgdGhlXG4gICAgICogIHRleHQ/IElmIG5vdCwgaXQncyBmb3IgdGhlIGluc2lkZSBmaWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkcmF3TGV0dGVyU3BhY2luZyh0ZXh0LCB4LCB5LCBpc1N0cm9rZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChpc1N0cm9rZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpc1N0cm9rZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICAvLyBsZXR0ZXJTcGFjaW5nIG9mIDAgbWVhbnMgbm9ybWFsXG4gICAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcbiAgICAgICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyYWN0ZXJzID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdC5jYWxsKHRleHQsICcnKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHg7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50ID0gJyc7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gY2hhcmFjdGVyc1tpbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KGN1cnJlbnQsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoY3VycmVudCwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoY3VycmVudCkud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRleHR1cmUgc2l6ZSBiYXNlZCBvbiBjYW52YXMgc2l6ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0dXJlKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZS50cmltKSB7XG4gICAgICAgICAgICB2YXIgdHJpbW1lZCA9IENhbnZhc1NldHRpbmdzXzEuQ2FudmFzU2V0dGluZ3MudHJpbUNhbnZhcyhjYW52YXMpO1xuICAgICAgICAgICAgaWYgKHRyaW1tZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRyaW1tZWQud2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5wdXRJbWFnZURhdGEodHJpbW1lZC5kYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICB2YXIgcGFkZGluZyA9IHN0eWxlLnRyaW0gPyAwIDogc3R5bGUucGFkZGluZztcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uO1xuICAgICAgICB0ZXh0dXJlLnRyaW0uaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIHRleHR1cmUudHJpbS54ID0gLXBhZGRpbmc7XG4gICAgICAgIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmc7XG4gICAgICAgIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gKHBhZGRpbmcgKiAyKTtcbiAgICAgICAgdGV4dHVyZS5vcmlnLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAtIChwYWRkaW5nICogMik7XG4gICAgICAgIC8vIGNhbGwgc3ByaXRlIG9uVGV4dHVyZVVwZGF0ZSB0byB1cGRhdGUgc2NhbGUgaWYgX3dpZHRoIG9yIF9oZWlnaHQgd2VyZSBzZXRcbiAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgICAgIGJhc2VUZXh0dXJlLnNldFJlYWxTaXplKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgdGhpcy5fcmVzb2x1dGlvbik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgICAgICBzdXBlci5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgICAgICAvLyBzdXBlci5fcmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgdGV4dCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFRoZSBvdXRwdXQgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhlIGJvdW5kcy5cbiAgICAgKi9cbiAgICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldExvY2FsQm91bmRzKHJlY3QpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBUZXh0IGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIHRoZSB3b3JsZFRyYW5zZm9ybSBpbnRvIGFjY291bnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFscmVhZHkgZG9uZSB0aGlzIG9uIFRISVMgZnJhbWUuXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4RGF0YSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gYmUgY2FsbGVkIHVwb24gYSBUZXh0U3R5bGUgY2hhbmdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uU3R5bGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBmaWxsIHN0eWxlLiBDYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIGdyYWRpZW50IGJhc2VkIG9uIHRoZSBmaWxsIHN0eWxlIGJlaW5nIGFuIGFycmF5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZSAtIFRoZSBzdHlsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsaW5lcyAtIFRoZSBsaW5lcyBvZiB0ZXh0LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xudW1iZXJ8Q2FudmFzR3JhZGllbnR9IFRoZSBmaWxsIHN0eWxlXG4gICAgICovXG4gICAgX2dlbmVyYXRlRmlsbFN0eWxlKHN0eWxlLCBsaW5lcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUuZmlsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZS5maWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBncmFkaWVudCB3aWxsIGJlIGV2ZW5seSBzcGFjZWQgb3V0IGFjY29yZGluZyB0byBob3cgbGFyZ2UgdGhlIGFycmF5IGlzLlxuICAgICAgICAvLyBbJyNGRjAwMDAnLCAnIzAwRkYwMCcsICcjMDAwMEZGJ10gd291bGQgY3JlYXRlZCBzdG9wcyBhdCAwLjI1LCAwLjUgYW5kIDAuNzVcbiAgICAgICAgdmFyIGdyYWRpZW50O1xuICAgICAgICB2YXIgdG90YWxJdGVyYXRpb25zO1xuICAgICAgICB2YXIgY3VycmVudEl0ZXJhdGlvbjtcbiAgICAgICAgdmFyIHN0b3A7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5fcmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBzdHlsZSBzZXR0aW5ncywgc28gd2UgY2FuIG1hbmlwdWxhdGUgdGhlbSBsYXRlclxuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGwuc2xpY2UoKTtcbiAgICAgICAgdmFyIGZpbGxHcmFkaWVudFN0b3BzID0gc3R5bGUuZmlsbEdyYWRpZW50U3RvcHMuc2xpY2UoKTtcbiAgICAgICAgLy8gd2FudGluZyB0byBldmVubHkgZGlzdHJpYnV0ZSB0aGUgZmlsbHMuIFNvIGFuIGFycmF5IG9mIDQgY29sb3VycyBzaG91bGQgZ2l2ZSBmaWxscyBvZiAwLjI1LCAwLjUgYW5kIDAuNzVcbiAgICAgICAgaWYgKCFmaWxsR3JhZGllbnRTdG9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGhQbHVzMSA9IGZpbGwubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoUGx1czE7ICsraSkge1xuICAgICAgICAgICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goaSAvIGxlbmd0aFBsdXMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdG9wIHRoZSBibGVlZGluZyBvZiB0aGUgbGFzdCBncmFkaWVudCBvbiB0aGUgbGluZSBhYm92ZSB0byB0aGUgdG9wIGdyYWRpZW50IG9mIHRoZSB0aGlzIGxpbmVcbiAgICAgICAgLy8gYnkgaGFyZCBkZWZpbmluZyB0aGUgZmlyc3QgZ3JhZGllbnQgY29sb3VyIGF0IHBvaW50IDAsIGFuZCBsYXN0IGdyYWRpZW50IGNvbG91ciBhdCBwb2ludCAxXG4gICAgICAgIGZpbGwudW5zaGlmdChzdHlsZS5maWxsWzBdKTtcbiAgICAgICAgZmlsbEdyYWRpZW50U3RvcHMudW5zaGlmdCgwKTtcbiAgICAgICAgZmlsbC5wdXNoKHN0eWxlLmZpbGxbc3R5bGUuZmlsbC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goMSk7XG4gICAgICAgIGlmIChzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBUZXh0U2V0dGluZ3NfMS5UZXh0U2V0dGluZ3MuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBncmFkaWVudCBhdCB0aGUgdG9wIGNlbnRlciBvZiB0aGUgY2FudmFzLCBhbmQgZW5kIGF0IHRoZSBib3R0b20gbWlkZGxlIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHdpZHRoIC8gMiwgMCwgd2lkdGggLyAyLCBoZWlnaHQpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXBlYXQgdGhlIGdyYWRpZW50IHNvIHRoYXQgZWFjaCBpbmRpdmlkdWFsIGxpbmUgb2YgdGV4dCBoYXMgdGhlIHNhbWUgdmVydGljYWwgZ3JhZGllbnQgZWZmZWN0XG4gICAgICAgICAgICAvLyBbJyNGRjAwMDAnLCAnIzAwRkYwMCcsICcjMDAwMEZGJ10gb3ZlciAyIGxpbmVzIHdvdWxkIGNyZWF0ZSBzdG9wcyBhdCAwLjEyNSwgMC4yNSwgMC4zNzUsIDAuNjI1LCAwLjc1LCAwLjg3NVxuICAgICAgICAgICAgdG90YWxJdGVyYXRpb25zID0gKGZpbGwubGVuZ3RoICsgMSkgKiBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uICs9IDE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbal0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gKGZpbGxHcmFkaWVudFN0b3BzW2pdIC8gbGluZXMubGVuZ3RoKSArIChpJDEgLyBsaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbal0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIGdyYWRpZW50IGF0IHRoZSBjZW50ZXIgbGVmdCBvZiB0aGUgY2FudmFzLCBhbmQgZW5kIGF0IHRoZSBjZW50ZXIgcmlnaHQgb2YgdGhlIGNhbnZhc1xuICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgLy8gY2FuIGp1c3QgZXZlbmx5IHNwYWNlIG91dCB0aGUgZ3JhZGllbnRzIGluIHRoaXMgY2FzZSwgYXMgbXVsdGlwbGUgbGluZXMgbWFrZXMgbm8gZGlmZmVyZW5jZVxuICAgICAgICAgICAgLy8gdG8gYW4gZXZlbiBsZWZ0IHRvIHJpZ2h0IGdyYWRpZW50XG4gICAgICAgICAgICB0b3RhbEl0ZXJhdGlvbnMgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uID0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGZpbGwubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbaSQyXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGZpbGxHcmFkaWVudFN0b3BzW2kkMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gY3VycmVudEl0ZXJhdGlvbiAvIHRvdGFsSXRlcmF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbaSQyXSk7XG4gICAgICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dCBvYmplY3QuXG4gICAgICogTm90ZSogVW5saWtlIGEgU3ByaXRlLCBhIFRleHQgb2JqZWN0IHdpbGwgYXV0b21hdGljYWxseSBkZXN0cm95IGl0cyBiYXNlVGV4dHVyZSBhbmQgdGV4dHVyZSBhc1xuICAgICAqIHRoZSBtYWpvcml0eSBvZiB0aGUgdGltZSB0aGUgdGV4dHVyZSB3aWxsIG5vdCBiZSBzaGFyZWQgd2l0aCBhbnkgb3RoZXIgU3ByaXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcbiAgICAgKiAgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqL1xuICAgIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgY2hpbGRyZW46IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgQ2xlYW5VcFNldHRpbmdzXzEuQ2xlYW5VcFNldHRpbmdzLmRlZmF1bHREZXN0cm95T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCB0aGUgdGhlIGNvbnRleHQgYW5kIGNhbnZhcy4uIGRvbnQgd2FudCB0aGlzIGhhbmdpbmcgYXJvdW5kIGluIG1lbW9yeSFcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgdmFyIHMgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgICAgIHRoaXMuc2NhbGUueCA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgdmFyIHMgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgICAgIHRoaXMuc2NhbGUueSA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdHlsZSBvZiB0aGUgdGV4dC4gU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGUgc3R5bGVcbiAgICAgKiBvYmplY3QgYW5kIG1hcmsgdGhlIHRleHQgYXMgZGlydHkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R8UElYSS5UZXh0U3R5bGV9XG4gICAgICovXG4gICAgZ2V0IHN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICAgICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICAgICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29weSBmb3IgdGhlIHRleHQgb2JqZWN0LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHQodGV4dCkge1xuICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiB0ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX3RleHQgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgICAqIFRoaXMgaXMgc2V0IHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggdGhlIHJlbmRlcmVyIHJlc29sdXRpb24gYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgbWFudWFsbHkuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb247XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlRleHQgPSBUZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBUZXh0TWV0cmljcyB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0LCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICghVGV4dE1ldHJpY3MuY2FudmFzKSB7XG4gICAgICAgICAgICBUZXh0TWV0cmljcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLmNhbnZhcy53aWR0aCA9IFRleHRNZXRyaWNzLmNhbnZhcy5oZWlnaHQgPSAxMDtcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLl9jYW52YXMgPSBUZXh0TWV0cmljcy5jYW52YXM7XG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fY29udGV4dCA9IFRleHRNZXRyaWNzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLm1heExpbmVXaWR0aCA9IG1heExpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5mb250UHJvcGVydGllcyA9IGZvbnRQcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdCgpIHtcbiAgICAgICAgaWYgKCFUZXh0TWV0cmljcy5jYW52YXMpIHtcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgVGV4dE1ldHJpY3MuY2FudmFzLndpZHRoID0gVGV4dE1ldHJpY3MuY2FudmFzLmhlaWdodCA9IDEwO1xuICAgICAgICAgICAgVGV4dE1ldHJpY3MuX2NhbnZhcyA9IFRleHRNZXRyaWNzLmNhbnZhcztcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLl9jb250ZXh0ID0gVGV4dE1ldHJpY3MuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVhc3VyZXMgdGhlIHN1cHBsaWVkIHN0cmluZyBvZiB0ZXh0IGFuZCByZXR1cm5zIGEgUmVjdGFuZ2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgdGV4dCB0byBtZWFzdXJlLlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IHN0eWxlIC0gdGhlIHRleHQgc3R5bGUgdG8gdXNlIGZvciBtZWFzdXJpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3b3JkV3JhcF0gLSBvcHRpb25hbCBvdmVycmlkZSBmb3IgaWYgd29yZC13cmFwIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtjYW52YXNdIC0gb3B0aW9uYWwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY2FudmFzIHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dE1ldHJpY3N9IG1lYXN1cmVkIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHRleHQuXG4gICAgICovXG4gICAgc3RhdGljIG1lYXN1cmVUZXh0KHRleHQsIHN0eWxlLCB3b3JkV3JhcCwgY2FudmFzID0gVGV4dE1ldHJpY3MuX2NhbnZhcykge1xuICAgICAgICB3b3JkV3JhcCA9ICh3b3JkV3JhcCA9PT0gdW5kZWZpbmVkIHx8IHdvcmRXcmFwID09PSBudWxsKSA/IHN0eWxlLndvcmRXcmFwIDogd29yZFdyYXA7XG4gICAgICAgIHZhciBmb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gICAgICAgIHZhciBmb250UHJvcGVydGllcyA9IFRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgICAgICAvLyBmYWxsYmFjayBpbiBjYXNlIFVBIGRpc2FsbG93IGNhbnZhcyBkYXRhIGV4dHJhY3Rpb25cbiAgICAgICAgLy8gKHRvRGF0YVVSSSwgZ2V0SW1hZ2VEYXRhIGZ1bmN0aW9ucylcbiAgICAgICAgaWYgKGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICBmb250UHJvcGVydGllcy5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgICAgICAgICAgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gc3R5bGUuZm9udFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICAgICAgdmFyIG91dHB1dFRleHQgPSB3b3JkV3JhcCA/IFRleHRNZXRyaWNzLndvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMpIDogdGV4dDtcbiAgICAgICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG4gICAgICAgIHZhciBsaW5lV2lkdGhzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGggKyAoKGxpbmVzW2ldLmxlbmd0aCAtIDEpICogc3R5bGUubGV0dGVyU3BhY2luZyk7XG4gICAgICAgICAgICBsaW5lV2lkdGhzW2ldID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgIHdpZHRoICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQgfHwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcylcbiAgICAgICAgICAgICsgKChsaW5lcy5sZW5ndGggLSAxKSAqIChsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZykpO1xuICAgICAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHRNZXRyaWNzKHRleHQsIHN0eWxlLCB3aWR0aCwgaGVpZ2h0LCBsaW5lcywgbGluZVdpZHRocywgbGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcsIG1heExpbmVXaWR0aCwgZm9udFByb3BlcnRpZXMpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBuZXdsaW5lcyB0byBhIHN0cmluZyB0byBoYXZlIGl0IG9wdGltYWxseSBmaXQgaW50byB0aGUgaG9yaXpvbnRhbFxuICAgICAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBTdHJpbmcgdG8gYXBwbHkgd29yZCB3cmFwcGluZyB0b1xuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IHN0eWxlIC0gdGhlIHN0eWxlIHRvIHVzZSB3aGVuIHdyYXBwaW5nXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW2NhbnZhc10gLSBvcHRpb25hbCBzcGVjaWZpY2F0aW9uIG9mIHRoZSBjYW52YXMgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBOZXcgc3RyaW5nIHdpdGggbmV3IGxpbmVzIGFwcGxpZWQgd2hlcmUgcmVxdWlyZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykge1xuICAgICAgICBpZiAoY2FudmFzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IFRleHRNZXRyaWNzLl9jYW52YXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGxpbmUgPSAnJztcbiAgICAgICAgdmFyIGxpbmVzID0gJyc7XG4gICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmc7XG4gICAgICAgIHZhciB3aGl0ZVNwYWNlID0gc3R5bGUud2hpdGVTcGFjZTtcbiAgICAgICAgLy8gSG93IHRvIGhhbmRsZSB3aGl0ZXNwYWNlc1xuICAgICAgICB2YXIgY29sbGFwc2VTcGFjZXMgPSBUZXh0TWV0cmljcy5jb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKTtcbiAgICAgICAgdmFyIGNvbGxhcHNlTmV3bGluZXMgPSBUZXh0TWV0cmljcy5jb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpO1xuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCBzcGFjZXMgbWF5IGJlIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgbGluZXNcbiAgICAgICAgdmFyIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgICAgIC8vIFRoZXJlIGlzIGxldHRlclNwYWNpbmcgYWZ0ZXIgZXZlcnkgY2hhciBleGNlcHQgdGhlIGxhc3Qgb25lXG4gICAgICAgIC8vIHRfaF9pX3NfJyAnX2lfc18nICdfYV9uXycgJ19lX3hfYV9tX3BfbF9lXycgJ18hXG4gICAgICAgIC8vIHNvIGZvciBjb252ZW5pZW5jZSB0aGUgYWJvdmUgbmVlZHMgdG8gYmUgY29tcGFyZWQgdG8gd2lkdGggKyAxIGV4dHJhIGxldHRlclNwYWNlXG4gICAgICAgIC8vIHRfaF9pX3NfJyAnX2lfc18nICdfYV9uXycgJ19lX3hfYV9tX3BfbF9lXycgJ18hX1xuICAgICAgICAvLyBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cbiAgICAgICAgLy8gQW5kIHRoZW4gdGhlIGZpbmFsIHNwYWNlIGlzIHNpbXBseSBubyBhcHBlbmRlZCB0byBlYWNoIGxpbmVcbiAgICAgICAgdmFyIHdvcmRXcmFwV2lkdGggPSBzdHlsZS53b3JkV3JhcFdpZHRoICsgbGV0dGVyU3BhY2luZztcbiAgICAgICAgLy8gYnJlYWsgdGV4dCBpbnRvIHdvcmRzLCBzcGFjZXMgYW5kIG5ld2xpbmUgY2hhcnNcbiAgICAgICAgdmFyIHRva2VucyA9IFRleHRNZXRyaWNzLnRva2VuaXplKHRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSB3b3JkLCBzcGFjZSBvciBuZXdsaW5lQ2hhclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gaWYgd29yZCBpcyBhIG5ldyBsaW5lXG4gICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuaXNOZXdsaW5lKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKCFjb2xsYXBzZU5ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ldyBsaW5lc1xuICAgICAgICAgICAgICAgIC8vIHdlIHNpbXBseSBjb252ZXJ0IGl0IGludG8gYSBzcGFjZVxuICAgICAgICAgICAgICAgIHRva2VuID0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIHJlcGVhdGVkIHdoaXRlc3BhY2VzXG4gICAgICAgICAgICBpZiAoY29sbGFwc2VTcGFjZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBib3RoIHRoaXMgYW5kIHRoZSBsYXN0IHRva2VucyBmb3Igc3BhY2VzXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJJc0JyZWFraW5nU3BhY2UgPSBUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0SXNCcmVha2luZ1NwYWNlID0gVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGxpbmVbbGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJJc0JyZWFraW5nU3BhY2UgJiYgbGFzdElzQnJlYWtpbmdTcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgd29yZCB3aWR0aCBmcm9tIGNhY2hlIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICB2YXIgdG9rZW5XaWR0aCA9IFRleHRNZXRyaWNzLmdldEZyb21DYWNoZSh0b2tlbiwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgLy8gd29yZCBpcyBsb25nZXIgdGhhbiBkZXNpcmVkIGJvdW5kc1xuICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBhbHJlYWR5IGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG5ld2xpbmVzIGZvciBvdmVyZmxvdyB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYnJlYWsgbGFyZ2Ugd29yZCBvdmVyIG11bHRpcGxlIGxpbmVzXG4gICAgICAgICAgICAgICAgaWYgKFRleHRNZXRyaWNzLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIHdvcmQgaW50byBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzID0gdG9rZW4uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRoZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhcmFjdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBjaGFyYWN0ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCBhdCB0aGUgZW5kIG9mIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3RlcnNbaiArIGtdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gY2hhcmFjdGVyc1tqICsga107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RDaGFyID0gY2hhcltjaGFyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgc3BsaXQgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVRleHRNZXRyaWNzLmNhbkJyZWFrQ2hhcnMobGFzdENoYXIsIG5leHRDaGFyLCB0b2tlbiwgaiwgc3R5bGUuYnJlYWtXb3JkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tYmluZSBjaGFycyAmIG1vdmUgZm9yd2FyZCBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhciArPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IGNoYXIubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJXaWR0aCA9IFRleHRNZXRyaWNzLmdldEZyb21DYWNoZShjaGFyLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcnVuIHdvcmQgb3V0IG9mIHRoZSBib3VuZHNcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHdvcmRzIGluIHRoaXMgbGluZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmlzaCB0aGF0IGxpbmUgYW5kIHN0YXJ0IGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIGl0IGl0cyBvd24gbGluZSBpZiBpdCdzIG5vdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUodG9rZW4sICFpc0xhc3RUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd29yZCBjb3VsZCBmaXRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdvcmQgd29uJ3QgZml0IGJlY2F1c2Ugb2YgZXhpc3Rpbmcgd29yZHNcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXRzIGEgc3BhY2Ugd2UgZG9uJ3Qgd2FudCBpdFxuICAgICAgICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBzcGFjZXMgdG8gdGhlIGJlZ2lubmluZyBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDAgfHwgIVRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbikgfHwgY2FuUHJlcGVuZFNwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHdvcmQgdG8gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgd2lkdGggY291bnRlclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSB0b2tlbldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ29udmllbmllbmNlIGZ1bmN0aW9uIGZvciBsb2dnaW5nIGVhY2ggbGluZSBhZGRlZCBkdXJpbmcgdGhlIHdvcmRXcmFwXG4gICAgICogbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBsaW5lICAgIC0gVGhlIGxpbmUgb2YgdGV4dCB0byBhZGRcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgbmV3TGluZSAtIEFkZCBuZXcgbGluZSBjaGFyYWN0ZXIgdG8gZW5kXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgIEEgZm9ybWF0dGVkIGxpbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTGluZShsaW5lLCBuZXdMaW5lID0gdHJ1ZSkge1xuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBuZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gVGV4dE1ldHJpY3MudHJpbVJpZ2h0KGxpbmUpO1xuICAgICAgICBsaW5lID0gKG5ld0xpbmUpID8gKGxpbmUgKyBcIlxcblwiKSA6IGxpbmU7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0cyAmIHNldHMgdGhlIHdpZHRocyBvZiBjYWxjdWxhdGVkIGNoYXJhY3RlcnMgaW4gYSBjYWNoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICBrZXkgICAgICAgIFRoZSBrZXlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmcgIFRoZSBsZXR0ZXIgc3BhY2luZ1xuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgY2FjaGUgICAgICBUaGUgY2FjaGVcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICBjb250ZXh0ICAgIFRoZSBjYW52YXMgY29udGV4dFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgVGhlIGZyb20gY2FjaGUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEZyb21DYWNoZShrZXksIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGNhY2hlW2tleV07XG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BhY2luZyA9ICgoa2V5Lmxlbmd0aCkgKiBsZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgICAgIHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChrZXkpLndpZHRoICsgc3BhY2luZztcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIGJyZWFraW5nIHNwYWNlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgd2hpdGVTcGFjZSAgVGhlIFRleHRTdHlsZSBwcm9wZXJ0eSB3aGl0ZVNwYWNlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIHNob3VsZCBjb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiAod2hpdGVTcGFjZSA9PT0gJ25vcm1hbCcgfHwgd2hpdGVTcGFjZSA9PT0gJ3ByZS1saW5lJyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ld0xpbmUgY2hhcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIHdoaXRlU3BhY2UgIFRoZSB3aGl0ZSBzcGFjZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBzaG91bGQgY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiAod2hpdGVTcGFjZSA9PT0gJ25vcm1hbCcpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogdHJpbXMgYnJlYWtpbmcgd2hpdGVzcGFjZXMgZnJvbSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdGV4dCAgVGhlIHRleHRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICB0cmltbWVkIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyB0cmltUmlnaHQodGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGlmICghVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBuZXdsaW5lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjaGFyICBUaGUgY2hhcmFjdGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgbmV3bGluZSwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc05ld2xpbmUoY2hhcikge1xuICAgICAgICBpZiAodHlwZW9mIGNoYXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChUZXh0TWV0cmljcy5fbmV3bGluZXMuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpID49IDApO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBjaGFyIGlzIGEgYnJlYWtpbmcgd2hpdGVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgY2hhciAgVGhlIGNoYXJhY3RlclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHdoaXRlc3BhY2UsIEZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCcmVha2luZ1NwYWNlKGNoYXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzLmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKSA+PSAwKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIHdvcmRzLCBicmVha2luZy1zcGFjZXMgYW5kIG5ld0xpbmUgY2hhcmFjdGVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0ZXh0ICAgVGhlIHRleHRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gIEEgdG9rZW5pemVkIGFycmF5XG4gICAgICovXG4gICAgc3RhdGljIHRva2VuaXplKHRleHQpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW4gPSAnJztcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGlmIChUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhcikgfHwgVGV4dE1ldHJpY3MuaXNOZXdsaW5lKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gKz0gY2hhcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gIT09ICcnKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4aXN0cyB0byBiZSBlYXNpbHkgb3ZlcnJpZGRlblxuICAgICAqIEl0IGFsbG93cyBvbmUgdG8gY3VzdG9taXNlIHdoaWNoIHdvcmRzIHNob3VsZCBicmVha1xuICAgICAqIEV4YW1wbGVzIGFyZSBpZiB0aGUgdG9rZW4gaXMgQ0pLIG9yIG51bWJlcnMuXG4gICAgICogSXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0b2tlbiAgIFRoZSB0b2tlblxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBicmVha1dvcmRzICBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FuQnJlYWtXb3Jkcyh0b2tlbiwgYnJlYWtXb3Jkcykge1xuICAgICAgICByZXR1cm4gYnJlYWtXb3JkcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4aXN0cyB0byBiZSBlYXNpbHkgb3ZlcnJpZGRlblxuICAgICAqIEl0IGFsbG93cyBvbmUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwYWlyIG9mIGNoYXJhY3RlcnNcbiAgICAgKiBzaG91bGQgYmUgYnJva2VuIGJ5IG5ld2xpbmVzXG4gICAgICogRm9yIGV4YW1wbGUgY2VydGFpbiBjaGFyYWN0ZXJzIGluIENKSyBsYW5ncyBvciBudW1iZXJzLlxuICAgICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgY2hhciAgVGhlIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG5leHRDaGFyICBUaGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0b2tlbiBUaGUgdG9rZW4vd29yZCB0aGUgY2hhcmFjdGVycyBhcmUgZnJvbVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gIGluZGV4IFRoZSBpbmRleCBpbiB0aGUgdG9rZW4gb2YgdGhlIGNoYXJcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgYnJlYWtXb3JkcyAgVGhlIHN0eWxlIGF0dHIgYnJlYWsgd29yZHNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRvIGJyZWFrIHdvcmQgb3Igbm90XG4gICAgICovXG4gICAgc3RhdGljIGNhbkJyZWFrQ2hhcnMoY2hhciwgbmV4dENoYXIsIHRva2VuLCBpbmRleCwgYnJlYWtXb3Jkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFzY2VudCwgZGVzY2VudCBhbmQgZm9udFNpemUgb2YgYSBnaXZlbiBmb250LXN0eWxlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBvZiB0aGUgZm9udFxuICAgICAqIEByZXR1cm4ge1BJWEkuSUZvbnRNZXRyaWNzfSBGb250IHByb3BlcnRpZXMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1lYXN1cmVGb250KGZvbnQpIHtcbiAgICAgICAgLy8gYXMgdGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcHJlcGFyaW5nIGFzc2V0cywgZG9uJ3QgcmVjYWxjdWxhdGUgdGhpbmdzIGlmIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgaWYgKFRleHRNZXRyaWNzLl9mb250c1tmb250XSkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHRNZXRyaWNzLl9mb250c1tmb250XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICB2YXIgY2FudmFzID0gVGV4dE1ldHJpY3MuX2NhbnZhcztcbiAgICAgICAgdmFyIGNvbnRleHQgPSBUZXh0TWV0cmljcy5fY29udGV4dDtcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICAgICAgdmFyIG1ldHJpY3NTdHJpbmcgPSBUZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyArIFRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTDtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQobWV0cmljc1N0cmluZykud2lkdGgpO1xuICAgICAgICB2YXIgYmFzZWxpbmUgPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChUZXh0TWV0cmljcy5CQVNFTElORV9TWU1CT0wpLndpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IDIgKiBiYXNlbGluZTtcbiAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSAqIFRleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgfCAwO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2YwMCc7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChtZXRyaWNzU3RyaW5nLCAwLCBiYXNlbGluZSk7XG4gICAgICAgIHZhciBpbWFnZWRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmUgPSB3aWR0aCAqIDQ7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBzdG9wID0gZmFsc2U7XG4gICAgICAgIC8vIGFzY2VudC4gc2NhbiBmcm9tIHRvcCB0byBib3R0b20gdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2VsaW5lOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZTsgaiArPSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpO1xuICAgICAgICBpZHggPSBwaXhlbHMgLSBsaW5lO1xuICAgICAgICBzdG9wID0gZmFsc2U7XG4gICAgICAgIC8vIGRlc2NlbnQuIHNjYW4gZnJvbSBib3R0b20gdG8gdG9wIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXG4gICAgICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyAtLWkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IGxpbmU7IGokMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqJDFdICE9PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcCkge1xuICAgICAgICAgICAgICAgIGlkeCAtPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcGVydGllcy5kZXNjZW50ID0gaSAtIGJhc2VsaW5lO1xuICAgICAgICBwcm9wZXJ0aWVzLmZvbnRTaXplID0gcHJvcGVydGllcy5hc2NlbnQgKyBwcm9wZXJ0aWVzLmRlc2NlbnQ7XG4gICAgICAgIFRleHRNZXRyaWNzLl9mb250c1tmb250XSA9IHByb3BlcnRpZXM7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2xlYXIgZm9udCBtZXRyaWNzIGluIG1ldHJpY3MgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmb250XSAtIGZvbnQgbmFtZS4gSWYgZm9udCBuYW1lIG5vdCBzZXQgdGhlbiBjbGVhciBjYWNoZSBmb3IgYWxsIGZvbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjbGVhck1ldHJpY3MoZm9udCkge1xuICAgICAgICBpZiAoZm9udCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmb250ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBUZXh0TWV0cmljcy5fZm9udHNbZm9udF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG4vKipcbiAqIEludGVybmFsIHJldHVybiBvYmplY3QgZm9yIHtAbGluayBQSVhJLlRleHRNZXRyaWNzLm1lYXN1cmVGb250IGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udGB9LlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZvbnRNZXRyaWNzXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXNjZW50IC0gVGhlIGFzY2VudCBkaXN0YW5jZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbnQgLSBUaGUgZGVzY2VudCBkaXN0YW5jZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZvbnRTaXplIC0gRm9udCBzaXplIGZyb20gYXNjZW50IHRvIGRlc2NlbnRcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAcHJpdmF0ZVxuICovXG4vKipcbiAqIENhY2hlIG9mIHtAc2VlIFBJWEkuVGV4dE1ldHJpY3MuRm9udE1ldHJpY3N9IG9iamVjdHMuXG4gKiBAbWVtYmVyb2YgUElYSS5UZXh0TWV0cmljc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblRleHRNZXRyaWNzLl9mb250cyA9IHt9O1xuLyoqXG4gKiBTdHJpbmcgdXNlZCBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAbmFtZSBNRVRSSUNTX1NUUklOR1xuICogQHR5cGUge3N0cmluZ31cbiAqIEBkZWZhdWx0IHzDiXFcbiAqL1xuVGV4dE1ldHJpY3MuTUVUUklDU19TVFJJTkcgPSAnfMOJcSc7XG4vKipcbiAqIEJhc2VsaW5lIHN5bWJvbCBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAbmFtZSBCQVNFTElORV9TWU1CT0xcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZGVmYXVsdCBNXG4gKi9cblRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCA9ICdNJztcbi8qKlxuICogQmFzZWxpbmUgbXVsdGlwbGllciBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAbmFtZSBCQVNFTElORV9NVUxUSVBMSUVSXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgMS40XG4gKi9cblRleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgPSAxLjQ7XG4vKipcbiAqIENhY2hlIG9mIG5ldyBsaW5lIGNoYXJzLlxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcbiAqIEB0eXBlIHtudW1iZXJbXX1cbiAqIEBwcml2YXRlXG4gKi9cblRleHRNZXRyaWNzLl9uZXdsaW5lcyA9IFtcbiAgICAweDAwMEEsXG4gICAgMHgwMDBEXG5dO1xuLyoqXG4gKiBDYWNoZSBvZiBicmVha2luZyBzcGFjZXMuXG4gKiBAbWVtYmVyb2YgUElYSS5UZXh0TWV0cmljc1xuICogQHR5cGUge251bWJlcltdfVxuICogQHByaXZhdGVcbiAqL1xuVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzID0gW1xuICAgIDB4MDAwOSxcbiAgICAweDAwMjAsXG4gICAgMHgyMDAwLFxuICAgIDB4MjAwMSxcbiAgICAweDIwMDIsXG4gICAgMHgyMDAzLFxuICAgIDB4MjAwNCxcbiAgICAweDIwMDUsXG4gICAgMHgyMDA2LFxuICAgIDB4MjAwOCxcbiAgICAweDIwMDksXG4gICAgMHgyMDBBLFxuICAgIDB4MjA1RixcbiAgICAweDMwMDBcbl07XG5leHBvcnRzLlRleHRNZXRyaWNzID0gVGV4dE1ldHJpY3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFRleHRTZXR0aW5ncyB7XG59XG5UZXh0U2V0dGluZ3MuVEVYVF9HUkFESUVOVCA9IHtcbiAgICBMSU5FQVJfVkVSVElDQUw6IDAsXG4gICAgTElORUFSX0hPUklaT05UQUw6IDEsXG59O1xuVGV4dFNldHRpbmdzLmRlZmF1bHRTdHlsZSA9IHtcbiAgICBhbGlnbjogJ2xlZnQnLFxuICAgIGJyZWFrV29yZHM6IGZhbHNlLFxuICAgIGRyb3BTaGFkb3c6IGZhbHNlLFxuICAgIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgICBkcm9wU2hhZG93QW5nbGU6IE1hdGguUEkgLyA2LFxuICAgIGRyb3BTaGFkb3dCbHVyOiAwLFxuICAgIGRyb3BTaGFkb3dDb2xvcjogJ2JsYWNrJyxcbiAgICBkcm9wU2hhZG93RGlzdGFuY2U6IDUsXG4gICAgZmlsbDogJ2JsYWNrJyxcbiAgICBmaWxsR3JhZGllbnRUeXBlOiBUZXh0U2V0dGluZ3MuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXG4gICAgZmlsbEdyYWRpZW50U3RvcHM6IFtdLFxuICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgZm9udFNpemU6IDI2LFxuICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgZm9udFZhcmlhbnQ6ICdub3JtYWwnLFxuICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgIGxldHRlclNwYWNpbmc6IDAsXG4gICAgbGluZUhlaWdodDogMCxcbiAgICBsaW5lSm9pbjogJ21pdGVyJyxcbiAgICBtaXRlckxpbWl0OiAxMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICBzdHJva2VUaGlja25lc3M6IDAsXG4gICAgdGV4dEJhc2VsaW5lOiAnYWxwaGFiZXRpYycsXG4gICAgdHJpbTogZmFsc2UsXG4gICAgd2hpdGVTcGFjZTogJ3ByZScsXG4gICAgd29yZFdyYXA6IGZhbHNlLFxuICAgIHdvcmRXcmFwV2lkdGg6IDEwMCxcbiAgICBsZWFkaW5nOiAwLFxufTtcbmV4cG9ydHMuVGV4dFNldHRpbmdzID0gVGV4dFNldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBUZXh0U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1RleHRTZXR0aW5nc1wiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xuY2xhc3MgVGV4dFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihzdHlsZSkge1xuICAgICAgICB0aGlzLnN0eWxlSUQgPSAwO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLmRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBzdHlsZSwgc3R5bGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHRTdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dFN0eWxlfSBOZXcgY2xvbmVkIFRleHRTdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGNsb25lZFByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MuZGVlcENvcHlQcm9wZXJ0aWVzKGNsb25lZFByb3BlcnRpZXMsIHRoaXMsIFRleHRTZXR0aW5nc18xLlRleHRTZXR0aW5ncy5kZWZhdWx0U3R5bGUpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTdHlsZShjbG9uZWRQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgcHJvcGVydGllcyB0byB0aGUgZGVmYXVsdHMgc3BlY2lmaWVkIGluIFRleHRTdHlsZS5wcm90b3R5cGUuX2RlZmF1bHRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MuZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIFRleHRTZXR0aW5nc18xLlRleHRTZXR0aW5ncy5kZWZhdWx0U3R5bGUsIFRleHRTZXR0aW5nc18xLlRleHRTZXR0aW5ncy5kZWZhdWx0U3R5bGUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBhbGlnbihhbGlnbikge1xuICAgICAgICBpZiAodGhpcy5fYWxpZ24gIT09IGFsaWduKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGlnbiA9IGFsaWduO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBsaW5lcyBjYW4gYmUgd3JhcHBlZCB3aXRoaW4gd29yZHMsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBicmVha1dvcmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtXb3JkcztcbiAgICB9XG4gICAgO1xuICAgIHNldCBicmVha1dvcmRzKGJyZWFrV29yZHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2JyZWFrV29yZHMgPSBicmVha1dvcmRzO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCBhIGRyb3Agc2hhZG93IGZvciB0aGUgdGV4dFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3c7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZHJvcFNoYWRvdyhkcm9wU2hhZG93KSB7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93ICE9PSBkcm9wU2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93ID0gZHJvcFNoYWRvdztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgYWxwaGEgZm9yIHRoZSBkcm9wIHNoYWRvd1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkcm9wU2hhZG93QWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93QWxwaGE7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZHJvcFNoYWRvd0FscGhhKGRyb3BTaGFkb3dBbHBoYSkge1xuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0FscGhhICE9PSBkcm9wU2hhZG93QWxwaGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSA9IGRyb3BTaGFkb3dBbHBoYTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3dcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvd0FuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGRyb3BTaGFkb3dBbmdsZShkcm9wU2hhZG93QW5nbGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSAhPT0gZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93QW5nbGUgPSBkcm9wU2hhZG93QW5nbGU7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IGEgc2hhZG93IGJsdXIgcmFkaXVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGRyb3BTaGFkb3dCbHVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0JsdXI7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZHJvcFNoYWRvd0JsdXIoZHJvcFNoYWRvd0JsdXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dCbHVyICE9PSBkcm9wU2hhZG93Qmx1cikge1xuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvd0NvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0NvbG9yO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGRyb3BTaGFkb3dDb2xvcihkcm9wU2hhZG93Q29sb3IpIHtcbiAgICAgICAgdmFyIG91dHB1dENvbG9yID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dDb2xvciAhPT0gb3V0cHV0Q29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dDb2xvciA9IG91dHB1dENvbG9yO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCBhIGRpc3RhbmNlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkcm9wU2hhZG93RGlzdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZHJvcFNoYWRvd0Rpc3RhbmNlKGRyb3BTaGFkb3dEaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlICE9PSBkcm9wU2hhZG93RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSA9IGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZS5nICdyZWQnLCAnIzAwRkYwMCcuXG4gICAgICogQ2FuIGJlIGFuIGFycmF5IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGVnIFsnIzAwMDAwMCcsJyNGRkZGRkYnXVxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZpbGxTdHlsZXxNRE59XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59XG4gICAgICovXG4gICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZpbGwoZmlsbCkge1xuICAgICAgICB2YXIgb3V0cHV0Q29sb3IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5nZXRDb2xvcihmaWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsID0gb3V0cHV0Q29sb3I7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGNhbiBjaGFuZ2UgdGhlIHR5cGUvZGlyZWN0aW9uIG9mIHRoZSBncmFkaWVudC5cbiAgICAgKiBTZWUge0BsaW5rIFBJWEkuVEVYVF9HUkFESUVOVH1cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZmlsbEdyYWRpZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZmlsbEdyYWRpZW50VHlwZShmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9maWxsR3JhZGllbnRUeXBlICE9PSBmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnRUeXBlID0gZmlsbEdyYWRpZW50VHlwZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJZiBmaWxsIGlzIGFuIGFycmF5IG9mIGNvbG91cnMgdG8gY3JlYXRlIGEgZ3JhZGllbnQsIHRoaXMgYXJyYXkgY2FuIHNldCB0aGUgc3RvcCBwb2ludHNcbiAgICAgKiAobnVtYmVycyBiZXR3ZWVuIDAgYW5kIDEpIGZvciB0aGUgY29sb3IsIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIGV2ZW5seSBzcGFjaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgZmlsbEdyYWRpZW50U3RvcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsR3JhZGllbnRTdG9wcztcbiAgICB9XG4gICAgO1xuICAgIHNldCBmaWxsR3JhZGllbnRTdG9wcyhmaWxsR3JhZGllbnRTdG9wcykge1xuICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLmFyZUFycmF5c0VxdWFsKHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzLCBmaWxsR3JhZGllbnRTdG9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzID0gZmlsbEdyYWRpZW50U3RvcHM7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGZvbnQgZmFtaWx5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0IGZvbnRGYW1pbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250RmFtaWx5O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgICAgICBpZiAodGhpcy5mb250RmFtaWx5ICE9PSBmb250RmFtaWx5KSB7XG4gICAgICAgICAgICB0aGlzLl9mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9udCBzaXplXG4gICAgICogKGFzIGEgbnVtYmVyIGl0IGNvbnZlcnRzIHRvIHB4LCBidXQgYXMgYSBzdHJpbmcsIGVxdWl2YWxlbnRzIGFyZSAnMjZweCcsJzIwcHQnLCcxNjAlJyBvciAnMS42ZW0nKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBmb250U2l6ZShmb250U2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5fZm9udFNpemUgIT09IGZvbnRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBmb250IHN0eWxlXG4gICAgICogKCdub3JtYWwnLCAnaXRhbGljJyBvciAnb2JsaXF1ZScpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGZvbnRTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBmb250U3R5bGUoZm9udFN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb250U3R5bGUgIT09IGZvbnRTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBmb250IHZhcmlhbnRcbiAgICAgKiAoJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmb250VmFyaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRWYXJpYW50O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZvbnRWYXJpYW50KGZvbnRWYXJpYW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9mb250VmFyaWFudCAhPT0gZm9udFZhcmlhbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRWYXJpYW50ID0gZm9udFZhcmlhbnQ7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGZvbnQgd2VpZ2h0XG4gICAgICogKCdub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicgYW5kICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc3MDAnLCA4MDAnIG9yICc5MDAnKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmb250V2VpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIHNldCBmb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRXZWlnaHQgIT09IGZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMsIGRlZmF1bHQgaXMgMFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgICB9XG4gICAgO1xuICAgIHNldCBsZXR0ZXJTcGFjaW5nKGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xldHRlclNwYWNpbmcgIT09IGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGluZUhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbGluZUhlaWdodChsaW5lSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lSGVpZ2h0ICE9PSBsaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgc3BhY2UgYmV0d2VlbiBsaW5lc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZWFkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZGluZztcbiAgICB9XG4gICAgO1xuICAgIHNldCBsZWFkaW5nKGxlYWRpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlYWRpbmcgIT09IGxlYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lSm9pbiBwcm9wZXJ0eSBzZXRzIHRoZSB0eXBlIG9mIGNvcm5lciBjcmVhdGVkLCBpdCBjYW4gcmVzb2x2ZSBzcGlrZWQgdGV4dCBpc3N1ZXMuXG4gICAgICogRGVmYXVsdCBpcyAnbWl0ZXInIChjcmVhdGVzIGEgc2hhcnAgY29ybmVyKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbGluZUpvaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lSm9pbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBsaW5lSm9pbihsaW5lSm9pbikge1xuICAgICAgICBpZiAodGhpcy5fbGluZUpvaW4gIT09IGxpbmVKb2luKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlXG4gICAgICogVGhpcyBjYW4gcmVkdWNlIG9yIGluY3JlYXNlIHRoZSBzcGlraW5lc3Mgb2YgcmVuZGVyZWQgdGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pdGVyTGltaXQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWl0ZXJMaW1pdChtaXRlckxpbWl0KSB7XG4gICAgICAgIGlmICh0aGlzLl9taXRlckxpbWl0ICE9PSBtaXRlckxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl9taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBPY2Nhc2lvbmFsbHkgc29tZSBmb250cyBhcmUgY3JvcHBlZC4gQWRkaW5nIHNvbWUgcGFkZGluZyB3aWxsIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZ1xuICAgICAqIGJ5IGFkZGluZyBwYWRkaW5nIHRvIGFsbCBzaWRlcyBvZiB0aGUgdGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYWRkaW5nICE9PSBwYWRkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlXG4gICAgICogZS5nICdibHVlJywgJyNGQ0ZGMDAnXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzdHJva2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJva2U7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgc3Ryb2tlKHN0cm9rZSkge1xuICAgICAgICB2YXIgb3V0cHV0Q29sb3IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5nZXRDb2xvcihzdHJva2UpO1xuICAgICAgICBpZiAodGhpcy5fc3Ryb2tlICE9PSBvdXRwdXRDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlID0gb3V0cHV0Q29sb3I7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS5cbiAgICAgKiBEZWZhdWx0IGlzIDAgKG5vIHN0cm9rZSlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3Ryb2tlVGhpY2tuZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlVGhpY2tuZXNzO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHN0cm9rZVRoaWNrbmVzcyhzdHJva2VUaGlja25lc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cm9rZVRoaWNrbmVzcyAhPT0gc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2VUaGlja25lc3MgPSBzdHJva2VUaGlja25lc3M7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHRleHRCYXNlbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCB0ZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVyc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaW07XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdHJpbSh0cmltKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmltICE9PSB0cmltKSB7XG4gICAgICAgICAgICB0aGlzLl90cmltID0gdHJpbTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBIb3cgbmV3bGluZXMgYW5kIHNwYWNlcyBzaG91bGQgYmUgaGFuZGxlZC5cbiAgICAgKiBEZWZhdWx0IGlzICdwcmUnIChwcmVzZXJ2ZSwgcHJlc2VydmUpLlxuICAgICAqXG4gICAgICogIHZhbHVlICAgfCBOZXcgbGluZXMgfCAgIFNwYWNlc1xuICAgICAqICAtLS0gICAgIHwgLS0tICAgICAgIHwgICAtLS1cbiAgICAgKiAnbm9ybWFsJyB8IENvbGxhcHNlICB8ICAgQ29sbGFwc2VcbiAgICAgKiAncHJlJyAgICB8IFByZXNlcnZlICB8ICAgUHJlc2VydmVcbiAgICAgKiAncHJlLWxpbmUnICAgfCBQcmVzZXJ2ZSAgfCAgIENvbGxhcHNlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHdoaXRlU3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHdoaXRlU3BhY2Uod2hpdGVTcGFjZSkge1xuICAgICAgICBpZiAodGhpcy5fd2hpdGVTcGFjZSAhPT0gd2hpdGVTcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5fd2hpdGVTcGFjZSA9IHdoaXRlU3BhY2U7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHdvcmQgd3JhcCBzaG91bGQgYmUgdXNlZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgd29yZFdyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcbiAgICB9XG4gICAgO1xuICAgIHNldCB3b3JkV3JhcCh3b3JkV3JhcCkge1xuICAgICAgICBpZiAodGhpcy5fd29yZFdyYXAgIT09IHdvcmRXcmFwKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcCA9IHdvcmRXcmFwO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcCwgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd29yZFdyYXBXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwV2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgd29yZFdyYXBXaWR0aCh3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JkV3JhcFdpZHRoICE9PSB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcFdpZHRoID0gd29yZFdyYXBXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBmb250IHN0eWxlIHN0cmluZyB0byB1c2UgZm9yIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRm9udCBzdHlsZSBzdHJpbmcsIGZvciBwYXNzaW5nIHRvIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYFxuICAgICAqL1xuICAgIHRvRm9udFN0cmluZygpIHtcbiAgICAgICAgLy8gYnVpbGQgY2FudmFzIGFwaSBmb250IHNldHRpbmcgZnJvbSBpbmRpdmlkdWFsIGNvbXBvbmVudHMuIENvbnZlcnQgYSBudW1lcmljIHRoaXMuZm9udFNpemUgdG8gcHhcbiAgICAgICAgdmFyIGZvbnRTaXplU3RyaW5nID0gKHR5cGVvZiB0aGlzLmZvbnRTaXplID09PSAnbnVtYmVyJykgPyAoKHRoaXMuZm9udFNpemUpICsgXCJweFwiKSA6IHRoaXMuZm9udFNpemU7XG4gICAgICAgIC8vIENsZWFuLXVwIGZvbnRGYW1pbHkgcHJvcGVydHkgYnkgcXVvdGluZyBlYWNoIGZvbnQgbmFtZVxuICAgICAgICAvLyB0aGlzIHdpbGwgc3VwcG9ydCBmb250IG5hbWVzIHdpdGggc3BhY2VzXG4gICAgICAgIHZhciBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmZvbnRGYW1pbHkpKSB7XG4gICAgICAgICAgICBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHkuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZm9udEZhbWlsaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyBUcmltIGFueSBleHRyYSB3aGl0ZS1zcGFjZVxuICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZm9udCBhbHJlYWR5IGNvbnRhaW5zIHN0cmluZ3NcbiAgICAgICAgICAgIGlmICghKC8oW1xcXCJcXCddKVteXFwnXFxcIl0rXFwxLykudGVzdChmb250RmFtaWx5KSkge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBcIlxcXCJcIiArIGZvbnRGYW1pbHkgKyBcIlxcXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgodGhpcy5mb250U3R5bGUpICsgXCIgXCIgKyAodGhpcy5mb250VmFyaWFudCkgKyBcIiBcIiArICh0aGlzLmZvbnRXZWlnaHQpICsgXCIgXCIgKyBmb250U2l6ZVN0cmluZyArIFwiIFwiICsgKGZvbnRGYW1pbGllcy5qb2luKCcsJykpKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5UZXh0U3R5bGUgPSBUZXh0U3R5bGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlVXZzXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlVXZzXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vSW1hZ2VSZXNvdXJjZVwiKTtcbmNvbnN0IENhbnZhc1Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9DYW52YXNSZXNvdXJjZVwiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgTmV0d29ya1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9OZXR3b3JrU2V0dGluZ3NcIik7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VUZXh0dXJlLCBmcmFtZSA9IG51bGwsIG9yaWcgPSBudWxsLCB0cmltID0gbnVsbCwgcm90YXRlID0gbnVsbCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBpcyB1cGRhdGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFRoZSBiYXNlIHRleHR1cmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkID0gKGJhc2VUZXh0dXJlKSA9PiB7XG4gICAgICAgICAgICBMb2dnZXJfMS50cmFjZShcIm9uQmFzZVRleHR1cmVVcGRhdGVkXCIpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSUQrKztcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBjb2RlIGxvb2tzIGNvbmZ1c2luZy4uIGJvbyB0byBhYnVzaW5nIGdldHRlcnMgYW5kIHNldHRlcnMhXG4gICAgICAgICAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lID0gdGhpcy5fZnJhbWU7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSB3YXRjaCBvdXQgZm9yIHRoZSBubyBmcmFtZSBvcHRpb25cbiAgICAgICAgICAgICAgICAvLyB1cGRhdGluZyB0aGUgdGV4dHVyZSB3aWxsIHNob3VsZCB1cGRhdGUgdGhlIGZyYW1lIGlmIGl0IHdhcyBzZXQgdG8gbm8gZnJhbWUuLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRoaXMuYmFzZVRleHR1cmUudmFsaWQ7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcInVwZGF0ZVwiKSk7XG4gICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xuICAgICAgICAgICAgLy8gdGhpcy5iYXNlVGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubm9GcmFtZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIWZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm5vRnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlVGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2YgdGhlIEJhc2VUZXh0dXJlIGltYWdlIHRvIGFjdHVhbGx5IGNvcHkgdG8gdGhlIENhbnZhcyAvIFdlYkdMIHdoZW4gcmVuZGVyaW5nLFxuICAgICAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHRyaW1tZWQgYXJlYSBvZiBvcmlnaW5hbCB0ZXh0dXJlLCBiZWZvcmUgaXQgd2FzIHB1dCBpbiBhdGxhc1xuICAgICAgICAgKiBQbGVhc2UgY2FsbCBgdXBkYXRlVXZzKClgIGFmdGVyIHlvdSBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgYHRyaW1gIG1hbnVhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJpbSA9IHRyaW07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgbGV0IHRoZSByZW5kZXJlciBrbm93IGlmIHRoZSB0ZXh0dXJlIGlzIHZhbGlkLiBJZiBpdCdzIG5vdCB0aGVuIGl0IGNhbm5vdCBiZSByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgd2lsbCBsZXQgYSByZW5kZXJlciBrbm93IHRoYXQgYSB0ZXh0dXJlIGhhcyBiZWVuIHVwZGF0ZWQgKHVzZWQgbWFpbmx5IGZvciBXZWJHTCB1diB1cGRhdGVzKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1aXJlc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFdlYkdMIFVWIGRhdGEgY2FjaGUuIENhbiBiZSB1c2VkIGFzIHF1YWQgVVZcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlVXZzfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91dnMgPSBUZXh0dXJlLkRFRkFVTFRfVVZTO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBUZXh0dXJlTWF0cml4IGluc3RhbmNlIGZvciB0aGlzIHRleHR1cmVcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGF0IG9iamVjdCBpcyBub3QgY3JlYXRlZCBiZWNhdXNlIGl0cyBoZWF2eVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnV2TWF0cml4ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2Ygb3JpZ2luYWwgdGV4dHVyZSwgYmVmb3JlIGl0IHdhcyBwdXQgaW4gYXRsYXNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9yaWcgPSBvcmlnIHx8IGZyYW1lOyAvLyBuZXcgUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuICAgICAgICB0aGlzLl9yb3RhdGUgPSBOdW1iZXIocm90YXRlIHx8IDApO1xuICAgICAgICBpZiAocm90YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG9sZCB0ZXh0dXJlcGFja2VyIGxlZ2FjeSwgc29tZSBnYW1lcy9saWJyYXJpZXMgYXJlIHBhc3NpbmcgXCJ0cnVlXCIgZm9yIHJvdGF0ZWQgdGV4dHVyZXNcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0ZSA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcm90YXRlICUgMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0IHRvIHVzZSBkaWFtb25kLXNoYXBlZCBVVnMuIElmIHlvdSBhcmUgc3VyZSwgc2V0IHJvdGF0aW9uIG1hbnVhbGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZyYW1lIHdlIHNob3VsZCBtb25pdG9yIGZvciBhbnkgYmFzZSB0ZXh0dXJlIGNoYW5nZXMuLlxuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCk7XG4gICAgICAgICAgICAgICAgLy8gYmFzZVRleHR1cmUub24oJ3VwZGF0ZScsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmFzZVRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZFwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkKTtcbiAgICAgICAgICAgIC8vIGJhc2VUZXh0dXJlLm9uY2UoJ2xvYWRlZCcsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbmNob3IgcG9pbnQgdGhhdCBpcyB1c2VkIGFzIGRlZmF1bHQgaWYgc3ByaXRlIGlzIGNyZWF0ZWQgd2l0aCB0aGlzIHRleHR1cmUuXG4gICAgICAgICAqIENoYW5naW5nIHRoZSBgZGVmYXVsdEFuY2hvcmAgYXQgYSBsYXRlciBwb2ludCBvZiB0aW1lIHdpbGwgbm90IHVwZGF0ZSBTcHJpdGUncyBhbmNob3IgcG9pbnQuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XG4gICAgICAgICAqIEBkZWZhdWx0IHswLDB9XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBbmNob3IgPSBuZXcgUG9pbnRfMS5Qb2ludChhbmNob3IueCwgYW5jaG9yLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QW5jaG9yID0gbmV3IFBvaW50XzEuUG9pbnQoMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBJRCBpcyBvYnNlcnZlZCBieSBzcHJpdGVzIGFuZCBUZXh0dXJlTWF0cml4IGluc3RhbmNlcy5cbiAgICAgICAgICogQ2FsbCB1cGRhdGVVdnMoKSB0byBpbmNyZW1lbnQgaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGlkcyB1bmRlciB3aGljaCB0aGlzIFRleHR1cmUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHRleHR1cmUgY2FjaGUuIFRoaXMgaXNcbiAgICAgICAgICogYXV0b21hdGljYWxseSBzZXQgYXMgbG9uZyBhcyBUZXh0dXJlLmFkZFRvQ2FjaGUgaXMgdXNlZCwgYnV0IG1heSBub3QgYmUgc2V0IGlmIGFcbiAgICAgICAgICogVGV4dHVyZSBpcyBhZGRlZCBkaXJlY3RseSB0byB0aGUgVGV4dHVyZUNhY2hlIGFycmF5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmdbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhpcyB0ZXh0dXJlIG9uIHRoZSBncHUuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUudXBkYXRlKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rlc3Ryb3lCYXNlPWZhbHNlXSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXG4gICAgICovXG4gICAgZGVzdHJveShkZXN0cm95QmFzZSkge1xuICAgICAgICBpZiAodGhpcy5iYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKGRlc3Ryb3lCYXNlKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSB0ZXh0dXJlIGlmIGl0IGV4aXN0cyBpbiB0aGUgdGV4dHVyZSBjYWNoZS4uXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBvbmx5IG5lZWRzIHRvIGJlIHJlbW92ZWQgaWYgdGhlIGJhc2UgdGV4dHVyZSBpcyBhY3R1YWxseSBkZXN0cm95ZWQgdG9vLi5cbiAgICAgICAgICAgICAgICBpZiAoQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RoaXMuYmFzZVRleHR1cmUuaW1hZ2VVcmxdKSB7XG4gICAgICAgICAgICAgICAgICAgIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuYmFzZVRleHR1cmUuaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMuYmFzZVRleHR1cmUucmVtbygndXBkYXRlJywgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3V2cyA9IG51bGw7XG4gICAgICAgIHRoaXMudHJpbSA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGV4dHVyZSBvYmplY3QgdGhhdCBhY3RzIHRoZSBzYW1lIGFzIHRoaXMgb25lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3IHRleHR1cmVcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIHRoaXMuZnJhbWUsIHRoaXMub3JpZywgdGhpcy50cmltLCB0aGlzLnJvdGF0ZSwgdGhpcy5kZWZhdWx0QW5jaG9yKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLiBVc2UgaXQgYWZ0ZXIgeW91IGNoYW5nZSBgZnJhbWVgIG9yIGB0cmltYCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBDYWxsIGl0IGFmdGVyIGNoYW5naW5nIHRoZSBmcmFtZVxuICAgICAqL1xuICAgIHVwZGF0ZVV2cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3V2cyA9PT0gVGV4dHVyZS5ERUZBVUxUX1VWUykge1xuICAgICAgICAgICAgdGhpcy5fdXZzID0gbmV3IFRleHR1cmVVdnNfMS5UZXh0dXJlVXZzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXZzLnNldCh0aGlzLl9mcmFtZSwgdGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5yb3RhdGUpO1xuICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAgICogVGhlIHNvdXJjZSBjYW4gYmUgLSBmcmFtZSBpZCwgaW1hZ2UgdXJsLCB2aWRlbyB1cmwsIGNhbnZhcyBlbGVtZW50LCB2aWRlbyBlbGVtZW50LCBiYXNlIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fFBJWEkuQmFzZVRleHR1cmV9IHNvdXJjZVxuICAgICAqICAgICAgICBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBjYWNoZUlkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYWNoZUlkID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX3BpeGlJZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5fcGl4aUlkID0gXCJwaXhpaWRfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlSWQgPSBzb3VyY2UuX3BpeGlJZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dHVyZSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtjYWNoZUlkXTtcbiAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1sncmVzb2x1dGlvbiddID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5nZXRSZXNvbHV0aW9uT2ZVcmwoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUuY2FjaGVJZCA9IGNhY2hlSWQ7XG4gICAgICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgY2FjaGVJZCk7XG4gICAgICAgICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgY2FjaGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGV0cyBhc3N1bWUgaXRzIGEgYmFzZSB0ZXh0dXJlIVxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBUZXh0dXJlIHRvIHRoZSBnbG9iYWwgVGV4dHVyZUNhY2hlLiBUaGlzIGNhY2hlIGlzIHNoYXJlZCBhY3Jvc3MgdGhlIHdob2xlIFBJWEkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdGhhdCB0aGUgVGV4dHVyZSB3aWxsIGJlIHN0b3JlZCBhZ2FpbnN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRUb0NhY2hlKHRleHR1cmUsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgaWYgKHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoXCJUZXh0dXJlIGFkZGVkIHRvIHRoZSBjYWNoZSB3aXRoIGFuIGlkIFtcIiArIGlkICsgXCJdIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW2lkXSA9IHRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIFRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIFRleHR1cmVDYWNoZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xQSVhJLlRleHR1cmV9IHRleHR1cmUgLSBpZCBvZiBhIFRleHR1cmUgdG8gYmUgcmVtb3ZlZCwgb3IgYSBUZXh0dXJlIGluc3RhbmNlIGl0c2VsZlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZXxudWxsfSBUaGUgVGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUZyb21DYWNoZSh0ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dHVyZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlRnJvbUNhY2hlID0gQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmVdO1xuICAgICAgICAgICAgaWYgKHRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0ZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbdGV4dHVyZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVGcm9tQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGV4dHVyZSBtYXRjaGVzIHRoZSBvbmUgYmVpbmcgcGFzc2VkIGluIGJlZm9yZSBkZWxldGluZyBpdCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgZnJhbWUgc3BlY2lmaWVzIHRoZSByZWdpb24gb2YgdGhlIGJhc2UgdGV4dHVyZSB0aGF0IHRoaXMgdGV4dHVyZSB1c2VzLlxuICAgICAqIFBsZWFzZSBjYWxsIGB1cGRhdGVVdnMoKWAgYWZ0ZXIgeW91IGNoYW5nZSBjb29yZGluYXRlcyBvZiBgZnJhbWVgIG1hbnVhbGx5LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICovXG4gICAgZ2V0IGZyYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZnJhbWUoZnJhbWUpIHtcbiAgICAgICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcbiAgICAgICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG4gICAgICAgIHZhciB4ID0gZnJhbWUueDtcbiAgICAgICAgdmFyIHkgPSBmcmFtZS55O1xuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGZyYW1lLmhlaWdodDtcbiAgICAgICAgdmFyIHhOb3RGaXQgPSB4ICsgd2lkdGggPiB0aGlzLmJhc2VUZXh0dXJlLndpZHRoO1xuICAgICAgICB2YXIgeU5vdEZpdCA9IHkgKyBoZWlnaHQgPiB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodDtcbiAgICAgICAgaWYgKHhOb3RGaXQgfHwgeU5vdEZpdCkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aW9uc2hpcCA9IHhOb3RGaXQgJiYgeU5vdEZpdCA/ICdhbmQnIDogJ29yJztcbiAgICAgICAgICAgIHZhciBlcnJvclggPSBcIlg6IFwiICsgeCArIFwiICsgXCIgKyB3aWR0aCArIFwiID0gXCIgKyAoeCArIHdpZHRoKSArIFwiID4gXCIgKyAodGhpcy5iYXNlVGV4dHVyZS53aWR0aCk7XG4gICAgICAgICAgICB2YXIgZXJyb3JZID0gXCJZOiBcIiArIHkgKyBcIiArIFwiICsgaGVpZ2h0ICsgXCIgPSBcIiArICh5ICsgaGVpZ2h0KSArIFwiID4gXCIgKyAodGhpcy5iYXNlVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9uczogJ1xuICAgICAgICAgICAgICAgICsgZXJyb3JYICsgXCIgXCIgKyByZWxhdGlvbnNoaXAgKyBcIiBcIiArIGVycm9yWSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZCA9IHdpZHRoICYmIGhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnZhbGlkO1xuICAgICAgICBpZiAoIXRoaXMudHJpbSAmJiAhdGhpcy5yb3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZyA9IGZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGV4dHVyZSBpcyByb3RhdGVkIGluc2lkZSB0aGUgYXRsYXNcbiAgICAgKiBzZXQgdG8gMiB0byBjb21wZW5zYXRlIGZvciB0ZXh0dXJlIHBhY2tlciByb3RhdGlvblxuICAgICAqIHNldCB0byA2IHRvIGNvbXBlbnNhdGUgZm9yIHNwaW5lIHBhY2tlciByb3RhdGlvblxuICAgICAqIGNhbiBiZSB1c2VkIHRvIHJvdGF0ZSBvciBtaXJyb3Igc3ByaXRlc1xuICAgICAqIFNlZSB7QGxpbmsgUElYSS5Hcm91cEQ4fSBmb3IgZXhwbGFuYXRpb25cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcm90YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHJvdGF0ZShyb3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcm90YXRlID0gcm90YXRlO1xuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVVdnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWcud2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnLmhlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFuIGVtcHR5IHRleHR1cmUsIHVzZWQgb2Z0ZW4gdG8gbm90IGhhdmUgdG8gY3JlYXRlIG11bHRpcGxlIGVtcHR5IHRleHR1cmVzLlxuICAgICAqIENhbiBub3QgYmUgZGVzdHJveWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBjb25zdGFudFxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IEVNUFRZKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICogQSB3aGl0ZSB0ZXh0dXJlIG9mIDEweDEwIHNpemUsIHVzZWQgZm9yIGdyYXBoaWNzIGFuZCBvdGhlciB0aGluZ3NcbiAqIENhbiBub3QgYmUgZGVzdHJveWVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBjb25zdGFudFxuICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxuICovXG4gICAgc3RhdGljIGdldCBXSElURSgpIHtcbiAgICAgICAgcmV0dXJuIFRleHR1cmUuY3JlYXRlV2hpdGVUZXh0dXJlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVXaGl0ZVRleHR1cmUoKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gMTY7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxNjtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDE2LCAxNik7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShuZXcgQ2FudmFzUmVzb3VyY2VfMS5DYW52YXNSZXNvdXJjZShjYW52YXMpKSk7XG4gICAgfVxufVxuVGV4dHVyZS5ERUZBVUxUX1VWUyA9IG5ldyBUZXh0dXJlVXZzXzEuVGV4dHVyZVV2cygpO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgVGV4dHVyZSB3aXRoIGEgQnVmZmVyUmVzb3VyY2UgZnJvbSBhIEZsb2F0MzJBcnJheS5cbiAqIFJHQkEgdmFsdWVzIGFyZSBmbG9hdHMgZnJvbSAwIHRvIDEuXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxVaW50OEFycmF5fSBidWZmZXIgVGhlIG9wdGlvbmFsIGFycmF5IHRvIHVzZSwgaWYgbm8gZGF0YVxuICogICAgICAgIGlzIHByb3ZpZGVkLCBhIG5ldyBGbG9hdDMyQXJyYXkgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSByZXNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgcmVzb3VyY2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxuICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgcmVzdWx0aW5nIG5ldyBCYXNlVGV4dHVyZVxuICovXG5UZXh0dXJlLmZyb21CdWZmZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVGV4dHVyZShCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLmZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSk7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSB0ZXh0dXJlIGZyb20gYSBzb3VyY2UgYW5kIGFkZCB0byB0aGUgY2FjaGUuXG4gKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fSBzb3VyY2UgLSBUaGUgaW5wdXQgc291cmNlLlxuICogQHBhcmFtIHtTdHJpbmd9IGltYWdlVXJsIC0gRmlsZSBuYW1lIG9mIHRleHR1cmUsIGZvciBjYWNoZSBhbmQgcmVzb2x2aW5nIHJlc29sdXRpb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gSHVtYW4gcmVhZGFibGUgbmFtZSBmb3IgdGhlIHRleHR1cmUgY2FjaGUuIElmIG5vIG5hbWUgaXNcbiAqICAgICAgICBzcGVjaWZpZWQsIG9ubHkgYGltYWdlVXJsYCB3aWxsIGJlIHVzZWQgYXMgdGhlIGNhY2hlIElELlxuICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBPdXRwdXQgdGV4dHVyZVxuICovXG5UZXh0dXJlLmZyb21Mb2FkZXIgPSBmdW5jdGlvbiBmcm9tTG9hZGVyKHNvdXJjZSwgaW1hZ2VVcmwsIG5hbWUpIHtcbiAgICB2YXIgcmVzb3VyY2UgPSBuZXcgSW1hZ2VSZXNvdXJjZV8xLkltYWdlUmVzb3VyY2Uoc291cmNlKTtcbiAgICByZXNvdXJjZS51cmwgPSBpbWFnZVVybDtcbiAgICB2YXIgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShyZXNvdXJjZSwge1xuICAgICAgICBzY2FsZU1vZGU6IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5TQ0FMRV9NT0RFLFxuICAgICAgICByZXNvbHV0aW9uOiBOZXR3b3JrU2V0dGluZ3NfMS5OZXR3b3JrU2V0dGluZ3MuZ2V0UmVzb2x1dGlvbk9mVXJsKGltYWdlVXJsKSxcbiAgICB9KTtcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGJhc2VUZXh0dXJlKTtcbiAgICAvLyBObyBuYW1lLCB1c2UgaW1hZ2VVcmwgaW5zdGVhZFxuICAgIGlmICghbmFtZSkge1xuICAgICAgICBuYW1lID0gaW1hZ2VVcmw7XG4gICAgfVxuICAgIC8vIGxldHMgYWxzbyBhZGQgdGhlIGZyYW1lIHRvIHBpeGkncyBnbG9iYWwgY2FjaGUgZm9yIGZyb21GcmFtZSBhbmQgZnJvbUltYWdlIGZ1bmN0aW9uc1xuICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBuYW1lKTtcbiAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgbmFtZSk7XG4gICAgLy8gYWxzbyBhZGQgcmVmZXJlbmNlcyBieSB1cmwgaWYgdGhleSBhcmUgZGlmZmVyZW50LlxuICAgIGlmIChuYW1lICE9PSBpbWFnZVVybCkge1xuICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgaW1hZ2VVcmwpO1xuICAgICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgaW1hZ2VVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbn07XG5leHBvcnRzLlRleHR1cmUgPSBUZXh0dXJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcbmNsYXNzIFRleHR1cmVHQ1N5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnRcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgY291bnRcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tDb3VudCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXhpbXVtIGlkbGUgdGltZSwgaW4gc2Vjb25kc1xuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBzZWUgUElYSS5zZXR0aW5ncy5HQ19NQVhfSURMRVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhJZGxlID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HQ19NQVhfSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGl0ZXNtIHRvIGNoZWNrXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLkdDX01BWF9DSEVDS19DT1VOVFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja0NvdW50TWF4ID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HQ19NQVhfQ0hFQ0tfQ09VTlQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IGdhcmFiYWdlIGNvbGxlY3Rpb24gbW9kZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdDX01PREVTfVxuICAgICAgICAgKiBAc2VlIFBJWEkuc2V0dGluZ3MuR0NfTU9ERVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tb2RlID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HQ19NT0RFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWRcbiAgICAgKiBpZiB0aGUgdGV4dHVyZSBoYXMgbm90IGJlZW4gdXNlZCBmb3IgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVVxuICAgICAqL1xuICAgIHBvc3RyZW5kZXIoKSB7XG4gICAgICAgIHRoaXMuY291bnQrKztcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HQ19NT0RFUy5NQU5VQUwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrQ291bnQrKztcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDb3VudCA+IHRoaXMuY2hlY2tDb3VudE1heCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0byBzZWUgd2hlbiB0aGUgbGFzdCB0aW1lIGEgdGV4dHVyZSB3YXMgdXNlZFxuICAgICAqIGlmIHRoZSB0ZXh0dXJlIGhhcyBub3QgYmVlbiB1c2VkIGZvciBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVXG4gICAgICovXG4gICAgcnVuKCkge1xuICAgICAgICB2YXIgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XG4gICAgICAgIHZhciBtYW5hZ2VkVGV4dHVyZXMgPSB0bS5tYW5hZ2VkVGV4dHVyZXM7XG4gICAgICAgIHZhciB3YXNSZW1vdmVkID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG1hbmFnZWRUZXh0dXJlc1tpXTtcbiAgICAgICAgICAgIC8vIG9ubHkgc3VwcG9ydHMgbm9uIGdlbmVyYXRlZCB0ZXh0dXJlcyBhdCB0aGUgbW9tZW50IVxuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlLmZyYW1lYnVmZmVyICYmIHRoaXMuY291bnQgLSB0ZXh0dXJlLnRvdWNoZWQgPiB0aGlzLm1heElkbGUpIHtcbiAgICAgICAgICAgICAgICB0bS5kZXN0cm95VGV4dHVyZSh0ZXh0dXJlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkVGV4dHVyZXNbaV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHdhc1JlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3YXNSZW1vdmVkKSB7XG4gICAgICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBtYW5hZ2VkVGV4dHVyZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VkVGV4dHVyZXNbaSQxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VkVGV4dHVyZXNbaisrXSA9IG1hbmFnZWRUZXh0dXJlc1tpJDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlcy5sZW5ndGggPSBqO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgdGV4dHVyZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZGlzcGxheU9iamVjdCBhbmQgaXRzIGNoaWxkcmVuIGZyb20gdGhlIEdQVVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3QgLSB0aGUgZGlzcGxheU9iamVjdCB0byByZW1vdmUgdGhlIHRleHR1cmVzIGZyb20uXG4gICAgICovXG4gICAgdW5sb2FkKGRpc3BsYXlPYmplY3QpIHtcbiAgICAgICAgLy8gdmFyIHRtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlU3lzdGVtO1xuICAgICAgICB2YXIgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XG4gICAgICAgIC8vIG9ubHkgZGVzdHJveSBub24gZ2VuZXJhdGVkIHRleHR1cmVzXG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0Ll90ZXh0dXJlICYmIGRpc3BsYXlPYmplY3QuX3RleHR1cmUuX2dsUmVuZGVyVGFyZ2V0cykge1xuICAgICAgICAgICAgdG0uZGVzdHJveVRleHR1cmUoZGlzcGxheU9iamVjdC5fdGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMudW5sb2FkKGRpc3BsYXlPYmplY3QuY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuVGV4dHVyZUdDU3lzdGVtID0gVGV4dHVyZUdDU3lzdGVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNsYXNzIFRleHR1cmVNYXRyaXgge1xuICAgIGNvbnN0cnVjdG9yKHRleHR1cmUsIGNsYW1wTWFyZ2luID0gbnVsbCkge1xuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgdGhpcy5tYXBDb29yZCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcbiAgICAgICAgdGhpcy51Q2xhbXBGcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIHRoaXMudUNsYW1wT2Zmc2V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyBUZXh0dXJlIGZyYW1lIGNoYW5nZXNcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyBmcmFtZSBjbGFtcGluZ1xuICAgICAgICAgKiBXb3JrcyB3aXRoIFRpbGluZ1Nwcml0ZSBhbmQgTWVzaFxuICAgICAgICAgKiBDaGFuZ2UgdG8gMS41IGlmIHlvdSB0ZXh0dXJlIGhhcyByZXBlYXRlZCByaWdodCBhbmQgYm90dG9tIGxpbmVzLCB0aGF0IGxlYWRzIHRvIHNtb290aGVyIGJvcmRlcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYW1wT2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZXMgZnJhbWUgY2xhbXBpbmdcbiAgICAgICAgICogV29ya3Mgd2l0aCBUaWxpbmdTcHJpdGUgYW5kIE1lc2hcbiAgICAgICAgICogQ2hhbmdlIHRvIC0wLjUgdG8gYWRkIGEgcGl4ZWwgdG8gdGhlIGVkZ2UsIHJlY29tbWVuZGVkIGZvciB0cmFuc3BhcmVudCB0cmltbWVkIHRleHR1cmVzIGluIGF0bGFzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZWZhdWx0IDAuNVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsYW1wTWFyZ2luID0gKHR5cGVvZiBjbGFtcE1hcmdpbiA9PT0gJ3VuZGVmaW5lZCcpID8gMC41IDogY2xhbXBNYXJnaW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0ZXh0dXJlIHNpemUgaXMgdGhlIHNhbWUgYXMgYmFzZVRleHR1cmVcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU2ltcGxlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRleHR1cmUgcHJvcGVydHlcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IHRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IC0xO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB1dnMgYXJyYXkgdG8gdHJhbnNmb3JtXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHV2cyBtZXNoIHV2c1xuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbb3V0PXV2c10gb3V0cHV0XG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gb3V0cHV0XG4gICAgICovXG4gICAgbXVsdGlwbHlVdnModXZzLCBvdXQpIHtcbiAgICAgICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdXQgPSB1dnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdCA9IHRoaXMubWFwQ29vcmQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXZzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHV2c1tpXTtcbiAgICAgICAgICAgIHZhciB5ID0gdXZzW2kgKyAxXTtcbiAgICAgICAgICAgIG91dFtpXSA9ICh4ICogbWF0LmEpICsgKHkgKiBtYXQuYykgKyBtYXQudHg7XG4gICAgICAgICAgICBvdXRbaSArIDFdID0gKHggKiBtYXQuYikgKyAoeSAqIG1hdC5kKSArIG1hdC50eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogdXBkYXRlcyBtYXRyaWNlcyBpZiB0ZXh0dXJlIHdhcyBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVVwZGF0ZSBpZiB0cnVlLCBtYXRyaWNlcyB3aWxsIGJlIHVwZGF0ZWQgYW55IGNhc2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgaXQgd2FzIHVwZGF0ZWRcbiAgICAgKi9cbiAgICB1cGRhdGUoZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgdmFyIHRleCA9IHRoaXMuX3RleHR1cmU7XG4gICAgICAgIGlmICghdGV4IHx8ICF0ZXgudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvcmNlVXBkYXRlXG4gICAgICAgICAgICAmJiB0aGlzLl91cGRhdGVJRCA9PT0gdGV4Ll91cGRhdGVJRCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gdGV4Ll91cGRhdGVJRDtcbiAgICAgICAgdmFyIHV2cyA9IHRleC5fdXZzO1xuICAgICAgICB0aGlzLm1hcENvb3JkLnNldCh1dnMueDEgLSB1dnMueDAsIHV2cy55MSAtIHV2cy55MCwgdXZzLngzIC0gdXZzLngwLCB1dnMueTMgLSB1dnMueTAsIHV2cy54MCwgdXZzLnkwKTtcbiAgICAgICAgdmFyIG9yaWcgPSB0ZXgub3JpZztcbiAgICAgICAgdmFyIHRyaW0gPSB0ZXgudHJpbTtcbiAgICAgICAgaWYgKHRyaW0pIHtcbiAgICAgICAgICAgIFRleHR1cmVNYXRyaXgudGVtcE1hdC5zZXQob3JpZy53aWR0aCAvIHRyaW0ud2lkdGgsIDAsIDAsIG9yaWcuaGVpZ2h0IC8gdHJpbS5oZWlnaHQsIC10cmltLnggLyB0cmltLndpZHRoLCAtdHJpbS55IC8gdHJpbS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5tYXBDb29yZC5hcHBlbmQoVGV4dHVyZU1hdHJpeC50ZW1wTWF0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4QmFzZSA9IHRleC5iYXNlVGV4dHVyZTtcbiAgICAgICAgdmFyIGZyYW1lID0gdGhpcy51Q2xhbXBGcmFtZTtcbiAgICAgICAgdmFyIG1hcmdpbiA9IHRoaXMuY2xhbXBNYXJnaW4gLyB0ZXhCYXNlLnJlc29sdXRpb247XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmNsYW1wT2Zmc2V0O1xuICAgICAgICBmcmFtZVswXSA9ICh0ZXguX2ZyYW1lLnggKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcbiAgICAgICAgZnJhbWVbMV0gPSAodGV4Ll9mcmFtZS55ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgICAgICBmcmFtZVsyXSA9ICh0ZXguX2ZyYW1lLnggKyB0ZXguX2ZyYW1lLndpZHRoIC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2Uud2lkdGg7XG4gICAgICAgIGZyYW1lWzNdID0gKHRleC5fZnJhbWUueSArIHRleC5fZnJhbWUuaGVpZ2h0IC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xuICAgICAgICB0aGlzLnVDbGFtcE9mZnNldFswXSA9IG9mZnNldCAvIHRleEJhc2UucmVhbFdpZHRoO1xuICAgICAgICB0aGlzLnVDbGFtcE9mZnNldFsxXSA9IG9mZnNldCAvIHRleEJhc2UucmVhbEhlaWdodDtcbiAgICAgICAgdGhpcy5pc1NpbXBsZSA9IHRleC5fZnJhbWUud2lkdGggPT09IHRleEJhc2Uud2lkdGhcbiAgICAgICAgICAgICYmIHRleC5fZnJhbWUuaGVpZ2h0ID09PSB0ZXhCYXNlLmhlaWdodFxuICAgICAgICAgICAgJiYgdGV4LnJvdGF0ZSA9PT0gMDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIDtcbn1cblRleHR1cmVNYXRyaXgudGVtcE1hdCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcbmV4cG9ydHMuVGV4dHVyZU1hdHJpeCA9IFRleHR1cmVNYXRyaXg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR0xUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9HTFRleHR1cmVcIik7XG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY2xhc3MgVGV4dHVyZVN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvLyBUT0RPIHNldCB0byBtYXggdGV4dHVyZXMuLi5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRleHR1cmVzXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQmFzZVRleHR1cmVbXX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgbG9jYXRpb25cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIG1hbmFnZWQgdGV4dHVyZXNcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZVtdfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFuYWdlZFRleHR1cmVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaWQgc29tZW9uZSB0ZW1wZXIgd2l0aCB0ZXh0dXJlcyBzdGF0ZT8gV2UnbGwgb3ZlcndyaXRlIHRoZW0gd2hlbiB3ZSBuZWVkIHRvIHVuYmluZCBzb21ldGhpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFzZVRleHR1cmUgdmFsdWUgdGhhdCBzaG93cyB0aGF0IHdlIGRvbid0IGtub3cgd2hhdCBpcyBib3VuZFxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5rbm93blRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbjtcbiAgICAgICAgdmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aCA9IG1heFRleHR1cmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRoaXMuLiB0byBhIG5pY2UgbWFrZSBlbXB0eSB0ZXh0dXJlcyBjbGFzcy4uXG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlcyA9IHt9O1xuICAgICAgICB2YXIgZW1wdHlUZXh0dXJlMkQgPSBuZXcgR0xUZXh0dXJlXzEuR0xUZXh0dXJlKGdsLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGVtcHR5VGV4dHVyZTJELnRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG5ldyBVaW50OEFycmF5KDQpKTtcbiAgICAgICAgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfMkRdID0gZW1wdHlUZXh0dXJlMkQ7XG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFX0NVQkVfTUFQXSA9IG5ldyBHTFRleHR1cmVfMS5HTFRleHR1cmUoZ2wuY3JlYXRlVGV4dHVyZSgpKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdLnRleHR1cmUpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCA2OyBpJDErKykge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpJDEsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgIHRoaXMuYmluZChudWxsLCBpJDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBCaW5kIGEgdGV4dHVyZSB0byBhIHNwZWNpZmljIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2FudCB0byB1bmJpbmQgc29tZXRoaW5nLCBwbGVhc2UgdXNlIGB1bmJpbmQodGV4dHVyZSlgIGluc3RlYWQgb2YgYGJpbmQobnVsbCwgdGV4dHVyZUxvY2F0aW9uKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfFBJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIGJpbmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvY2F0aW9uPTBdIC0gTG9jYXRpb24gdG8gYmluZCBhdFxuICAgICAqL1xuICAgIGJpbmQodGV4dHVyZSwgbG9jYXRpb24gPSAwKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xuICAgICAgICAgICAgaWYgKHRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnRvdWNoZWQgPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVHQy5jb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmluaXRUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gIT09IHRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIGdsVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdsVGV4dHVyZS5kaXJ0eUlkICE9PSB0ZXh0dXJlLmRpcnR5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gdGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBsb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV8yRF0udGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRleHR1cmUgbG9jYXRpb24gYW5kIGJvdW5kIHRleHR1cmVzXG4gICAgICpcbiAgICAgKiBBY3R1YWwgYGJpbmQobnVsbCwgaSlgIGNhbGxzIHdpbGwgYmUgcGVyZm9ybWVkIGF0IG5leHQgYHVuYmluZCgpYCBjYWxsXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IHRoaXMudW5rbm93blRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVuYmluZCBhIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZXxQSVhJLkJhc2VUZXh0dXJlfSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBiaW5kXG4gICAgICovXG4gICAgdW5iaW5kKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgdmFyIGJvdW5kVGV4dHVyZXMgPSByZWYuYm91bmRUZXh0dXJlcztcbiAgICAgICAgaWYgKHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gc29tZW9uZSBjaGFuZ2VkIHdlYkdMIHN0YXRlLFxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBiZSBzdXJlIHRoYXQgb3VyIHRleHR1cmUgZG9lcyBub3QgYXBwZWFyIGluIG11bHRpLXRleHR1cmUgcmVuZGVyZXIgc2FtcGxlcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChib3VuZFRleHR1cmVzW2ldID09PSB0aGlzLnVua25vd25UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZChudWxsLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoYm91bmRUZXh0dXJlc1tpJDFdID09PSB0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBpJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkkMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gaSQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZXNbdGV4dHVyZS50YXJnZXRdLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGJvdW5kVGV4dHVyZXNbaSQxXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gaW5pdGlhbGl6ZVxuICAgICAqL1xuICAgIGluaXRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIGdsVGV4dHVyZSA9IG5ldyBHTFRleHR1cmVfMS5HTFRleHR1cmUodGhpcy5nbC5jcmVhdGVUZXh0dXJlKCkpO1xuICAgICAgICAvLyBndWFyYW50ZWUgYW4gdXBkYXRlLi5cbiAgICAgICAgZ2xUZXh0dXJlLmRpcnR5SWQgPSAtMTtcbiAgICAgICAgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSA9IGdsVGV4dHVyZTtcbiAgICAgICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgLy8gdGV4dHVyZS5vbignZGlzcG9zZScsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xuICAgICAgICByZXR1cm4gZ2xUZXh0dXJlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIGluaXRpYWxpemVcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGlmICh0ZXh0dXJlLnJlc291cmNlICYmIHRleHR1cmUucmVzb3VyY2UuY2FuVXBsb2FkKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAodGV4dHVyZS5yZXNvdXJjZSAmJiB0ZXh0dXJlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSlcbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZS5yZXNvdXJjZSAmJiB0aGlzLnVwbG9hZFRleHR1cmUocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSwgdGV4dHVyZS5yZXNvdXJjZSkpIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQsIHJlbmRlclRleHR1cmUtbGlrZSBsb2dpY1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGV4dHVyZS5yZWFsV2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dHVyZS5yZWFsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgICAgICBpZiAoZ2xUZXh0dXJlLndpZHRoICE9PSB3aWR0aFxuICAgICAgICAgICAgICAgIHx8IGdsVGV4dHVyZS5oZWlnaHQgIT09IGhlaWdodFxuICAgICAgICAgICAgICAgIHx8IGdsVGV4dHVyZS5kaXJ0eUlkIDwgMCkge1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRCh0ZXh0dXJlLnRhcmdldCwgMCwgdGV4dHVyZS5mb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLnR5cGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxldHMgb25seSB1cGRhdGUgd2hhdCBjaGFuZ2VzLi5cbiAgICAgICAgaWYgKHRleHR1cmUuZGlydHlTdHlsZUlkICE9PSBnbFRleHR1cmUuZGlydHlTdHlsZUlkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBnbFRleHR1cmUuZGlydHlJZCA9IHRleHR1cmUuZGlydHlJZDtcbiAgICB9XG4gICAgO1xuICAgIHVwbG9hZFRleHR1cmUocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHNvdXJjZSkge1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcbiAgICAgICAgLy8gc291cmNlID0gc291cmNlIHx8IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yWyduYW1lJ10gPT0gXCJDYW52YXNSZXNvdXJjZVwiKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5jb25zdHJ1Y3RvclsnbmFtZSddID09IFwiSW1hZ2VSZXNvdXJjZVwiKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5jb25zdHJ1Y3RvclsnbmFtZSddID09IFwiVmlkZW9SZXNvdXJjZVwiKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgaWYoc291cmNlLmNvbnN0cnVjdG9yWyduYW1lJ10gPT0gXCJHcmFkaWVudFJlc291cmNlXCIpXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGlmKCFzb3VyY2Uuc291cmNlKVxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIHJldHVyblxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgc291cmNlID0gc291cmNlLnNvdXJjZVxuICAgICAgICAvLyAgICAgcmV2ZWFsKHNvdXJjZSlcbiAgICAgICAgLy8gfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlcl8xLnJldmVhbChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG4gICAgICAgIGlmIChiYXNlVGV4dHVyZS50YXJnZXQgPT09IGdsLlRFWFRVUkVfMkQgJiYgZ2xUZXh0dXJlLndpZHRoID09PSB3aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byBkZXN0cm95XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFJlbW92ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHNraXAgcmVtb3ZpbmcgdGhlIHRleHR1cmUgZnJvbSB0aGUgVGV4dHVyZU1hbmFnZXIuXG4gICAgICovXG4gICAgZGVzdHJveVRleHR1cmUodGV4dHVyZSwgc2tpcFJlbW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHRleHR1cmU7XG4gICAgICAgIGlmICh0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgICAgICB0aGlzLnVuYmluZCh0ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXS50ZXh0dXJlKTtcbiAgICAgICAgICAgIC8vIHRleHR1cmUub2ZmKCdkaXNwb3NlJywgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyk7XG4gICAgICAgICAgICBkZWxldGUgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgICAgIGlmICghc2tpcFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5tYW5hZ2VkVGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5tYW5hZ2VkVGV4dHVyZXMsIGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRleHR1cmUgc3R5bGUgc3VjaCBhcyBtaXBtYXAgZmxhZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKSB7XG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICBpZiAoIWdsVGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGV4dHVyZS5taXBtYXAgPT09IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLk1JUE1BUF9NT0RFUy5QT1cyIHx8IHRoaXMud2ViR0xWZXJzaW9uICE9PSAyKSAmJiAhdGV4dHVyZS5pc1Bvd2VyT2ZUd28pIHtcbiAgICAgICAgICAgIGdsVGV4dHVyZS5taXBtYXAgPSAwO1xuICAgICAgICAgICAgZ2xUZXh0dXJlLndyYXBNb2RlID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFUy5DTEFNUDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsVGV4dHVyZS5taXBtYXAgPSB0ZXh0dXJlLm1pcG1hcCA+PSAxO1xuICAgICAgICAgICAgZ2xUZXh0dXJlLndyYXBNb2RlID0gdGV4dHVyZS53cmFwTW9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAodGV4dHVyZS5yZXNvdXJjZSAmJiB0ZXh0dXJlLnJlc291cmNlLnN0eWxlKHRoaXMucmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkpXG4gICAgICAgIC8vIHsgOyB9XG4gICAgICAgIC8vIGVsc2VcbiAgICAgICAgLy8ge1xuICAgICAgICB0aGlzLnNldFN0eWxlKHRleHR1cmUsIGdsVGV4dHVyZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgZ2xUZXh0dXJlLmRpcnR5U3R5bGVJZCA9IHRleHR1cmUuZGlydHlTdHlsZUlkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHN0eWxlIGZvciB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHtnbFRleHR1cmV9IGdsVGV4dHVyZVxuICAgICAqL1xuICAgIHNldFN0eWxlKHRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAoZ2xUZXh0dXJlLm1pcG1hcCkge1xuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGV4dHVyZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbFRleHR1cmUud3JhcE1vZGUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfVCwgZ2xUZXh0dXJlLndyYXBNb2RlKTtcbiAgICAgICAgaWYgKGdsVGV4dHVyZS5taXBtYXApIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5UZXh0dXJlU3lzdGVtID0gVGV4dHVyZVN5c3RlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgR3JvdXBEOF8xID0gcmVxdWlyZShcIi4vR3JvdXBEOFwiKTtcbmNsYXNzIFRleHR1cmVVdnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLngwID0gMDtcbiAgICAgICAgdGhpcy55MCA9IDA7XG4gICAgICAgIHRoaXMueDEgPSAxO1xuICAgICAgICB0aGlzLnkxID0gMDtcbiAgICAgICAgdGhpcy54MiA9IDE7XG4gICAgICAgIHRoaXMueTIgPSAxO1xuICAgICAgICB0aGlzLngzID0gMDtcbiAgICAgICAgdGhpcy55MyA9IDE7XG4gICAgICAgIHRoaXMudXZzRmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgfVxuICAgIC8qKlxuICogU2V0cyB0aGUgdGV4dHVyZSBVdnMgYmFzZWQgb24gdGhlIGdpdmVuIGZyYW1lIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGZyYW1lIC0gVGhlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBiYXNlRnJhbWUgLSBUaGUgYmFzZSBmcmFtZSBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0ZSAtIFJvdGF0aW9uIG9mIGZyYW1lLCBzZWUge0BsaW5rIFBJWEkuR3JvdXBEOH1cbiAqL1xuICAgIHNldChmcmFtZSwgYmFzZUZyYW1lLCByb3RhdGUpIHtcbiAgICAgICAgdmFyIHR3ID0gYmFzZUZyYW1lLndpZHRoO1xuICAgICAgICB2YXIgdGggPSBiYXNlRnJhbWUuaGVpZ2h0O1xuICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IGRpdiAyIGRpdiBiYXNlRnJhbWUgc2l6ZVxuICAgICAgICAgICAgdmFyIHcyID0gZnJhbWUud2lkdGggLyAyIC8gdHc7XG4gICAgICAgICAgICB2YXIgaDIgPSBmcmFtZS5oZWlnaHQgLyAyIC8gdGg7XG4gICAgICAgICAgICAvLyBjb29yZGluYXRlcyBvZiBjZW50ZXJcbiAgICAgICAgICAgIHZhciBjWCA9IChmcmFtZS54IC8gdHcpICsgdzI7XG4gICAgICAgICAgICB2YXIgY1kgPSAoZnJhbWUueSAvIHRoKSArIGgyO1xuICAgICAgICAgICAgcm90YXRlID0gR3JvdXBEOF8xLkdyb3VwRDguYWRkKHJvdGF0ZSwgR3JvdXBEOF8xLkdyb3VwRDguTlcpOyAvLyBOVyBpcyB0b3AtbGVmdCBjb3JuZXJcbiAgICAgICAgICAgIHRoaXMueDAgPSBjWCArICh3MiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVYKHJvdGF0ZSkpO1xuICAgICAgICAgICAgdGhpcy55MCA9IGNZICsgKGgyICogR3JvdXBEOF8xLkdyb3VwRDgudVkocm90YXRlKSk7XG4gICAgICAgICAgICByb3RhdGUgPSBHcm91cEQ4XzEuR3JvdXBEOC5hZGQocm90YXRlLCAyKTsgLy8gcm90YXRlIDkwIGRlZ3JlZXMgY2xvY2t3aXNlXG4gICAgICAgICAgICB0aGlzLngxID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcbiAgICAgICAgICAgIHRoaXMueTEgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xuICAgICAgICAgICAgcm90YXRlID0gR3JvdXBEOF8xLkdyb3VwRDguYWRkKHJvdGF0ZSwgMik7XG4gICAgICAgICAgICB0aGlzLngyID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcbiAgICAgICAgICAgIHRoaXMueTIgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xuICAgICAgICAgICAgcm90YXRlID0gR3JvdXBEOF8xLkdyb3VwRDguYWRkKHJvdGF0ZSwgMik7XG4gICAgICAgICAgICB0aGlzLngzID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcbiAgICAgICAgICAgIHRoaXMueTMgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54MCA9IGZyYW1lLnggLyB0dztcbiAgICAgICAgICAgIHRoaXMueTAgPSBmcmFtZS55IC8gdGg7XG4gICAgICAgICAgICB0aGlzLngxID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICAgICAgICAgIHRoaXMueTEgPSBmcmFtZS55IC8gdGg7XG4gICAgICAgICAgICB0aGlzLngyID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICAgICAgICAgIHRoaXMueTIgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcbiAgICAgICAgICAgIHRoaXMueDMgPSBmcmFtZS54IC8gdHc7XG4gICAgICAgICAgICB0aGlzLnkzID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzBdID0gdGhpcy54MDtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzFdID0gdGhpcy55MDtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzJdID0gdGhpcy54MTtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzNdID0gdGhpcy55MTtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzRdID0gdGhpcy54MjtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzVdID0gdGhpcy55MjtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzZdID0gdGhpcy54MztcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzddID0gdGhpcy55MztcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5UZXh0dXJlVXZzID0gVGV4dHVyZVV2cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XG5jb25zdCBUaWNrZXJMaXN0ZW5lcl8xID0gcmVxdWlyZShcIi4vVGlja2VyTGlzdGVuZXJcIik7XG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NcIik7XG5jbGFzcyBUaWNrZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaXJzdCBsaXN0ZW5lci4gQWxsIG5ldyBsaXN0ZW5lcnMgYWRkZWQgYXJlIGNoYWluZWQgb24gdGhpcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge1RpY2tlckxpc3RlbmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGVhZCA9IG5ldyBUaWNrZXJMaXN0ZW5lcl8xLlRpY2tlckxpc3RlbmVyKG51bGwsIG51bGwsIEluZmluaXR5KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGN1cnJlbnQgZnJhbWUgcmVxdWVzdCBJRFxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1pbkZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cbiAgICAgICAgICogVGhpcyBpcyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHVwZGF0ZXMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxMDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1heEZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cbiAgICAgICAgICogVGhpcyBpcyB0aGUgbWluaW11bSBhbGxvd2VkIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHVwZGF0ZXMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgc2hvdWxkIGludm9rZSB0aGUgbWV0aG9kXG4gICAgICAgICAqIHtAbGluayBQSVhJLlRpY2tlciNzdGFydH0gYXV0b21hdGljYWxseVxuICAgICAgICAgKiB3aGVuIGEgbGlzdGVuZXIgaXMgYWRkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGFyIHRpbWUgdmFsdWUgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIFBJWEkuVGlja2VyI21pbkZQU31cbiAgICAgICAgICogYW5kIGlzIHNjYWxlZCB3aXRoIHtAbGluayBQSVhJLlRpY2tlciNzcGVlZH0uXG4gICAgICAgICAqICoqTm90ZToqKiBUaGUgY2FwIG1heSBiZSBleGNlZWRlZCBieSBzY2FsaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsdGFUaW1lID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlciB0aW1lIGVsYXBzZWQgaW4gbWlsbGlzZWNvbmRzIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxuICAgICAgICAgKiBUaGlzIHZhbHVlIGlzIGNhcHBlZCBieSBzZXR0aW5nIHtAbGluayBQSVhJLlRpY2tlciNtaW5GUFN9XG4gICAgICAgICAqIGFuZCBpcyBzY2FsZWQgd2l0aCB7QGxpbmsgUElYSS5UaWNrZXIjc3BlZWR9LlxuICAgICAgICAgKiAqKk5vdGU6KiogVGhlIGNhcCBtYXkgYmUgZXhjZWVkZWQgYnkgc2NhbGluZy5cbiAgICAgICAgICogSWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIERPTUhpZ2hSZXNUaW1lU3RhbXAsXG4gICAgICAgICAqIHRoaXMgdmFsdWUgd2lsbCBoYXZlIGEgcHJlY2lzaW9uIG9mIDEgwrVzLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB0YXJnZXQgZnJhbWUgdGltZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDE2LjY2XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbHRhTVMgPSAxIC8gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWUgZWxhcHNlZCBpbiBtaWxsaXNlY29uZHMgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICAgICAqIE9wcG9zZWQgdG8gd2hhdCB0aGUgc2NhbGFyIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9XG4gICAgICAgICAqIGlzIGJhc2VkLCB0aGlzIHZhbHVlIGlzIG5laXRoZXIgY2FwcGVkIG5vciBzY2FsZWQuXG4gICAgICAgICAqIElmIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyBET01IaWdoUmVzVGltZVN0YW1wLFxuICAgICAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gdGFyZ2V0IGZyYW1lIHRpbWVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxNi42NlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGFwc2VkTVMgPSAxIC8gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHRpbWUge0BsaW5rIFBJWEkuVGlja2VyI3VwZGF0ZX0gd2FzIGludm9rZWQuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgYWxzbyByZXNldCBpbnRlcm5hbGx5IG91dHNpZGUgb2YgaW52b2tpbmdcbiAgICAgICAgICogdXBkYXRlLCBidXQgb25seSB3aGVuIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqIElmIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyBET01IaWdoUmVzVGltZVN0YW1wLFxuICAgICAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmFjdG9yIG9mIGN1cnJlbnQge0BsaW5rIFBJWEkuVGlja2VyI2RlbHRhVGltZX0uXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFNjYWxlcyB0aWNrZXIuZGVsdGFUaW1lIHRvIHdoYXQgd291bGQgYmVcbiAgICAgICAgICogLy8gdGhlIGVxdWl2YWxlbnQgb2YgYXBwcm94aW1hdGVseSAxMjAgRlBTXG4gICAgICAgICAqIHRpY2tlci5zcGVlZCA9IDI7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcGVlZCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkLlxuICAgICAgICAgKiBgdHJ1ZWAgaWYge0BsaW5rIFBJWEkuVGlja2VyI3N0YXJ0fSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICAgICAqIGBmYWxzZWAgaWYge0BsaW5rIFBJWEkuVGlja2VyI3N0b3B9IGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICogV2hpbGUgYGZhbHNlYCwgdGhpcyB2YWx1ZSBtYXkgY2hhbmdlIHRvIGB0cnVlYCBpbiB0aGVcbiAgICAgICAgICogZXZlbnQgb2Yge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gYmVpbmcgYHRydWVgXG4gICAgICAgICAqIGFuZCBhIGxpc3RlbmVyIGlzIGFkZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbmFibGVkLCBkZWxldGluZyBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Byb3RlY3RlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgdGljayBtZXRob2QgYm91bmQgdG8gdGlja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBUaGlzIGlzIGJlY2F1c2UgaW4gZWFybHkgMjAxNSwgRnVuY3Rpb24uYmluZFxuICAgICAgICAgKiBpcyBzdGlsbCA2MCUgc2xvd2VyIGluIGhpZ2ggcGVyZm9ybWFuY2Ugc2NlbmFyaW9zLlxuICAgICAgICAgKiBBbHNvIHNlcGFyYXRpbmcgZnJhbWUgcmVxdWVzdHMgZnJvbSB1cGRhdGUgbWV0aG9kXG4gICAgICAgICAqIHNvIGxpc3RlbmVycyBtYXkgYmUgY2FsbGVkIGF0IGFueSB0aW1lIGFuZCB3aXRoXG4gICAgICAgICAqIGFueSBhbmltYXRpb24gQVBJLCBqdXN0IGludm9rZSB0aWNrZXIudXBkYXRlKHRpbWUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIFRpbWUgc2luY2UgbGFzdCB0aWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzJDEuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcyQxLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgbGlzdGVuZXJzIG5vd1xuICAgICAgICAgICAgICAgIHRoaXMkMS51cGRhdGUodGltZSk7XG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuZXIgc2lkZSBlZmZlY3RzIG1heSBoYXZlIG1vZGlmaWVkIHRpY2tlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcyQxLnN0YXJ0ZWQgJiYgdGhpcyQxLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcyQxLl9oZWFkLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcyQxLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcyQxLl90aWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgYWRkcyB0aGUgZXZlbnQgaGFuZGxlciBzbyB0aGF0IGl0IGNhbiBiZSBzb3J0ZWQgYnkgcHJpb3JpdHkuXG4gICAgICogUHJpb3JpdHkgYWxsb3dzIGNlcnRhaW4gaGFuZGxlciAodXNlciwgQW5pbWF0ZWRTcHJpdGUsIEludGVyYWN0aW9uKSB0byBiZSBydW5cbiAgICAgKiBiZWZvcmUgdGhlIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtUaWNrZXJMaXN0ZW5lcn0gbGlzdGVuZXIgLSBDdXJyZW50IGxpc3RlbmVyIGJlaW5nIGFkZGVkLlxuICAgICAqIEByZXR1cm5zIHtQSVhJLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgICAqL1xuICAgIF9hZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICAvLyBGb3IgYXR0YWNoaW5nIHRvIGhlYWRcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIC8vIEFkZCB0aGUgZmlyc3QgaXRlbVxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR28gZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBwcmlvcml0eVxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIucHJpb3JpdHkgPiBjdXJyZW50LnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3QgeWV0IGNvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lci5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcbiAgICAgKiBjdXJyZW50IHtAbGluayBQSVhJLlRpY2tlciNlbGFwc2VkTVN9LFxuICAgICAqIHRoZSBjdXJyZW50IHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgICAqIGludm9raW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCBjdXJyZW50IGRlbHRhVGltZSxcbiAgICAgKiBhbmQgdGhlbiBmaW5hbGx5IHNldHRpbmcge0BsaW5rIFBJWEkuVGlja2VyI2xhc3RUaW1lfVxuICAgICAqIHdpdGggdGhlIHZhbHVlIG9mIGN1cnJlbnRUaW1lIHRoYXQgd2FzIHByb3ZpZGVkLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXG4gICAgICogZnJhbWUgY2FsbGJhY2tzIGlmIHRoZSB0aWNrZXIgaW5zdGFuY2UgaGFzIGJlZW4gc3RhcnRlZFxuICAgICAqIGFuZCBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50VGltZT1wZXJmb3JtYW5jZS5ub3coKV0gLSB0aGUgY3VycmVudCB0aW1lIG9mIGV4ZWN1dGlvblxuICAgICAqL1xuICAgIHVwZGF0ZShjdXJyZW50VGltZSkge1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxhcHNlZE1TO1xuICAgICAgICAvLyBJZiB0aGUgZGlmZmVyZW5jZSBpbiB0aW1lIGlzIHplcm8gb3IgbmVnYXRpdmUsIHdlIGlnbm9yZSBtb3N0IG9mIHRoZSB3b3JrIGRvbmUgaGVyZS5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdmFsaWQgZGlmZmVyZW5jZSwgdGhlbiBzaG91bGQgYmUgbm8gcmVhc29uIHRvIGxldCBhbnlvbmUga25vdyBhYm91dCBpdC5cbiAgICAgICAgLy8gQSB6ZXJvIGRlbHRhLCBpcyBleGFjdGx5IHRoYXQsIG5vdGhpbmcgc2hvdWxkIHVwZGF0ZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgaW4gdGltZSBjYW4gYmUgbmVnYXRpdmUsIGFuZCBubyB0aGlzIGRvZXMgbm90IG1lYW4gdGltZSB0cmF2ZWxpbmcuXG4gICAgICAgIC8vIFRoaXMgY2FuIGJlIHRoZSByZXN1bHQgb2YgYSByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuIHdoZW4gYW4gYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZFxuICAgICAgICAvLyBvbiB0aGUgY3VycmVudCBKYXZhU2NyaXB0IGVuZ2luZSBldmVudCBsb29wLCBhbmQgd2hlbiB0aGUgdGlja2VyJ3Mgc3RhcnQgbWV0aG9kIGlzIGludm9rZWRcbiAgICAgICAgLy8gKHdoaWNoIGludm9rZXMgdGhlIGludGVybmFsIF9yZXF1ZXN0SWZOZWVkZWQgbWV0aG9kKS4gSWYgYSBmcmFtZSBpcyByZXF1ZXN0ZWQgYmVmb3JlXG4gICAgICAgIC8vIF9yZXF1ZXN0SWZOZWVkZWQgaXMgaW52b2tlZCwgdGhlbiB0aGUgY2FsbGJhY2sgZm9yIHRoZSBhbmltYXRpb24gZnJhbWUgdGhlIHRpY2tlciByZXF1ZXN0cyxcbiAgICAgICAgLy8gY2FuIHJlY2VpdmUgYSB0aW1lIGFyZ3VtZW50IHRoYXQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGFzdFRpbWUgdmFsdWUgdGhhdCB3YXMgc2V0IHdpdGhpblxuICAgICAgICAvLyBfcmVxdWVzdElmTmVlZGVkLiBUaGlzIGRpZmZlcmVuY2UgaXMgaW4gbWljcm9zZWNvbmRzLCBidXQgdGhpcyBpcyBlbm91Z2ggdG8gY2F1c2UgcHJvYmxlbXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgY292ZXJzIHRoaXMgYnJvd3NlciBlbmdpbmUgdGltaW5nIGlzc3VlLCBhcyB3ZWxsIGFzIGlmIGNvbnN1bWVycyBwYXNzIGFuIGludmFsaWRcbiAgICAgICAgLy8gY3VycmVudFRpbWUgdmFsdWUuIFRoaXMgbWF5IGhhcHBlbiBpZiBjb25zdW1lcnMgb3B0LW91dCBvZiB0aGUgYXV0b1N0YXJ0LCBhbmQgdXBkYXRlIHRoZW1zZWx2ZXMuXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA+IHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFNhdmUgdW5jYXBwZWQgZWxhcHNlZE1TIGZvciBtZWFzdXJlbWVudFxuICAgICAgICAgICAgZWxhcHNlZE1TID0gdGhpcy5lbGFwc2VkTVMgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG4gICAgICAgICAgICAvLyBjYXAgdGhlIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHVzZWQgZm9yIGRlbHRhVGltZVxuICAgICAgICAgICAgaWYgKGVsYXBzZWRNUyA+IHRoaXMuX21heEVsYXBzZWRNUykge1xuICAgICAgICAgICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsYXBzZWRNUyAqPSB0aGlzLnNwZWVkO1xuICAgICAgICAgICAgLy8gaWYgbm90IGVub3VnaCB0aW1lIGhhcyBwYXNzZWQsIGV4aXQgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgLy8gV2UgZ2l2ZSBhbiBleHRyYSBtcyB0byBlbGFwc2VkTVMgZm9yIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhlIG5hdHVyZSBvZlxuICAgICAgICAgICAgLy8gcmVxdWVzdCBhbmltYXRpb24gZnJhbWUgbWVhbnMgdGhhdCBub3QgYWxsIGJyb3dzZXJzIHdpbGwgcmV0dXJuIHByZWNpc2UgdmFsdWVzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgYmVjYXVzZSByQUYgd29ya3MgYmFzZWQgb24gdi1zeW5jLCBpdCdzIHdvbid0IGNoYW5nZSB0aGUgZWZmZWN0aXZlIEZQUy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9taW5FbGFwc2VkTVMgJiYgZWxhcHNlZE1TICsgMSA8IHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVsdGFNUyA9IGVsYXBzZWRNUztcbiAgICAgICAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TICogc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcbiAgICAgICAgICAgIC8vIENhY2hlIGEgbG9jYWwgcmVmZXJlbmNlLCBpbi1jYXNlIHRpY2tlciBpcyBkZXN0cm95ZWRcbiAgICAgICAgICAgIC8vIGR1cmluZyB0aGUgZW1pdCwgd2UgY2FuIHN0aWxsIGNoZWNrIGZvciBoZWFkLm5leHRcbiAgICAgICAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIC8vIEludm9rZSBsaXN0ZW5lcnMgYWRkZWQgdG8gaW50ZXJuYWwgZW1pdHRlclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gaGVhZC5uZXh0O1xuICAgICAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5lbWl0KHRoaXMuZGVsdGFUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGVhZC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TID0gdGhpcy5lbGFwc2VkTVMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIHRpY2tlciBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuIENhbGxpbmdcbiAgICAgKiB0aGlzIG1ldGhvZCByZW1vdmVzIGFsbCByZWZlcmVuY2VzIHRvIGludGVybmFsIGV2ZW50cy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb3RlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oZWFkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyByZXF1ZXN0ZWRcbiAgICAgKiBhbiBhbmltYXRpb24gZnJhbWUgaXQgaXMgY2FuY2VsZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyBsaXN0ZW5lcnNcbiAgICAgKiBhIG5ldyBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW55IGhhbmRsZXJzIG1hdGNoaW5nIHRoZSBmdW5jdGlvbiBhbmQgY29udGV4dCBwYXJhbWV0ZXJzLlxuICAgICAqIElmIG5vIGhhbmRsZXJzIGFyZSBsZWZ0IGFmdGVyIHJlbW92aW5nLCB0aGVuIGl0IGNhbmNlbHMgdGhlIGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0IHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcmV0dXJucyB7UElYSS5UaWNrZXJ9IFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICAgKi9cbiAgICByZW1vdmUoZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2gsIGxldHMgcmVtb3ZlIGl0XG4gICAgICAgICAgICAvLyBubyBicmVhayB0byBkZWxldGUgYWxsIHBvc3NpYmxlIG1hdGNoZXNcbiAgICAgICAgICAgIC8vIGluY2FzZSBhIGxpc3RlbmVyIHdhcyBhZGRlZCAyKyB0aW1lc1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm1hdGNoKGZuLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkIGEgaGFuZGxlciBmb3IgdGhlIHRpY2sgZXZlbnQgd2hpY2ggaXMgb25seSBleGVjdXRlIG9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBhZGRlZCBmb3Igb25lIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PVBJWEkuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTF0gLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXG4gICAgICogQHJldHVybnMge1BJWEkuVGlja2VyfSBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXG4gICAgICovXG4gICAgYWRkT25jZShmbiwgY29udGV4dCwgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gVGlja2VyLlVQREFURV9QUklPUklUWS5OT1JNQUw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZExpc3RlbmVyKG5ldyBUaWNrZXJMaXN0ZW5lcl8xLlRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciB0aWNrIGV2ZW50cy4gQ2FsbHMgY29udGludW91c2x5IHVubGVzc1xuICAgICAqIGl0IGlzIHJlbW92ZWQgb3IgdGhlIHRpY2tlciBpcyBzdG9wcGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIHVwZGF0ZXNcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1QSVhJLlVQREFURV9QUklPUklUWS5OT1JNQUxdIC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgICAqIEByZXR1cm5zIHtQSVhJLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgICAqL1xuICAgIGFkZChmbiwgY29udGV4dCA9IG51bGwsIHByaW9yaXR5ID0gbnVsbCkge1xuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBUaWNrZXIuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyXzEuVGlja2VyTGlzdGVuZXIoZm4sIGNvbnRleHQsIHByaW9yaXR5KSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb25kaXRpb25hbGx5IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKiBJZiB0aGUgdGlja2VyIGhhcyBiZWVuIHN0YXJ0ZWQgaXQgY2hlY2tzIGlmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5XG4gICAgICogYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWwgZW1pdHRlciBoYXMgbGlzdGVuZXJzLiBJZiB0aGVzZVxuICAgICAqIGNvbmRpdGlvbnMgYXJlIG1ldCwgYSBuZXcgZnJhbWUgaXMgcmVxdWVzdGVkLiBJZiB0aGUgdGlja2VyIGhhcyBub3RcbiAgICAgKiBiZWVuIHN0YXJ0ZWQsIGJ1dCBhdXRvU3RhcnQgaXMgYHRydWVgLCB0aGVuIHRoZSB0aWNrZXIgc3RhcnRzIG5vdyxcbiAgICAgKiBhbmQgY29udGludWVzIHdpdGggdGhlIHByZXZpb3VzIGNvbmRpdGlvbnMgdG8gcmVxdWVzdCBhIG5ldyBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3N0YXJ0SWZQb3NzaWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hdXRvU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSBjYW5jZWxzIGEgcGVuZGluZyBhbmltYXRpb24gZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYW5jZWxJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gKiBJZiBhIGZyYW1lIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZCwgYW5kIGlmIHRoZSBpbnRlcm5hbFxuICogZW1pdHRlciBoYXMgbGlzdGVuZXJzLCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuICAgIF9yZXF1ZXN0SWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgY2FsbGJhY2tzIGdldCBjb3JyZWN0IGRlbHRhXG4gICAgICAgICAgICB0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZXMgcGVyIHNlY29uZCBhdCB3aGljaCB0aGlzIHRpY2tlciBpcyBydW5uaW5nLlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGFwcHJveGltYXRlbHkgNjAgaW4gbW9zdCBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICogKipOb3RlOioqIFRoaXMgZG9lcyBub3QgZmFjdG9yIGluIHRoZSB2YWx1ZSBvZlxuICAgICAqIHtAbGluayBQSVhJLlRpY2tlciNzcGVlZH0sIHdoaWNoIGlzIHNwZWNpZmljXG4gICAgICogdG8gc2NhbGluZyB7QGxpbmsgUElYSS5UaWNrZXIjZGVsdGFUaW1lfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgRlBTKCkge1xuICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuZWxhcHNlZE1TO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIGFsbG93ZWQgdG9cbiAgICAgKiBlbGFwc2UgYmV0d2VlbiBpbnZva2luZyB7QGxpbmsgUElYSS5UaWNrZXIjdXBkYXRlfS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVzZWQgdG8gY2FwIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgICAqIGJ1dCBkb2VzIG5vdCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayBQSVhJLlRpY2tlciNGUFN9LlxuICAgICAqIFdoZW4gc2V0dGluZyB0aGlzIHByb3BlcnR5IGl0IGlzIGNsYW1wZWQgdG8gYSB2YWx1ZSBiZXR3ZWVuXG4gICAgICogYDBgIGFuZCBgUElYSS5zZXR0aW5ncy5UQVJHRVRfRlBNUyAqIDEwMDBgLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgZ2V0IG1pbkZQUygpIHtcbiAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLl9tYXhFbGFwc2VkTVM7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWluRlBTKGZwcykge1xuICAgICAgICAvLyBNaW5pbXVtIG11c3QgYmUgYmVsb3cgdGhlIG1heEZQU1xuICAgICAgICB2YXIgbWluRlBTID0gTWF0aC5taW4odGhpcy5tYXhGUFMsIGZwcyk7XG4gICAgICAgIC8vIE11c3QgYmUgYXQgbGVhc3QgMCwgYnV0IGJlbG93IDEgLyBzZXR0aW5ncy5UQVJHRVRfRlBNU1xuICAgICAgICB2YXIgbWluRlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDAsIG1pbkZQUykgLyAxMDAwLCBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKTtcbiAgICAgICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMSAvIG1pbkZQTVM7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWF4RlBTKGZwcykge1xuICAgICAgICBpZiAoZnBzIC8gMTAwMCA+PSBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKSB7XG4gICAgICAgICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWF4IG11c3QgYmUgYXQgbGVhc3QgdGhlIG1pbkZQU1xuICAgICAgICAgICAgdmFyIG1heEZQUyA9IE1hdGgubWF4KHRoaXMubWluRlBTLCBmcHMpO1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBhdCBsZWFzdCAxLCBidXQgYmVsb3cgMSAvIHNldHRpbmdzLlRBUkdFVF9GUE1TXG4gICAgICAgICAgICB2YXIgbWF4RlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDEsIG1heEZQUykgLyAxMDAwLCBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKTtcbiAgICAgICAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDEgLyBtYXhGUE1TO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFBJWEkuQW5pbWF0ZWRTcHJpdGV9IGFuZCBieVxuICoge0BsaW5rIFBJWEkuVmlkZW9SZXNvdXJjZX0gdG8gdXBkYXRlIGFuaW1hdGlvbiBmcmFtZXMgLyB2aWRlbyB0ZXh0dXJlcy5cbiAqXG4gKiBJdCBtYXkgYWxzbyBiZSB1c2VkIGJ5IHtAbGluayBQSVhJLkFwcGxpY2F0aW9ufSBpZiBjcmVhdGVkIHdpdGggdGhlIGBzaGFyZWRUaWNrZXJgIG9wdGlvbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cbiAqXG4gKiBUaGUgcHJvcGVydHkge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAqIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB0aWNrZXIgPSBQSVhJLlRpY2tlci5zaGFyZWQ7XG4gKiAvLyBTZXQgdGhpcyB0byBwcmV2ZW50IHN0YXJ0aW5nIHRoaXMgdGlja2VyIHdoZW4gbGlzdGVuZXJzIGFyZSBhZGRlZC5cbiAqIC8vIEJ5IGRlZmF1bHQgdGhpcyBpcyB0cnVlIG9ubHkgZm9yIHRoZSBQSVhJLlRpY2tlci5zaGFyZWQgaW5zdGFuY2UuXG4gKiB0aWNrZXIuYXV0b1N0YXJ0ID0gZmFsc2U7XG4gKiAvLyBGWUksIGNhbGwgdGhpcyB0byBlbnN1cmUgdGhlIHRpY2tlciBpcyBzdG9wcGVkLiBJdCBzaG91bGQgYmUgc3RvcHBlZFxuICogLy8gaWYgeW91IGhhdmUgbm90IGF0dGVtcHRlZCB0byByZW5kZXIgYW55dGhpbmcgeWV0LlxuICogdGlja2VyLnN0b3AoKTtcbiAqIC8vIENhbGwgdGhpcyB3aGVuIHlvdSBhcmUgcmVhZHkgZm9yIGEgcnVubmluZyBzaGFyZWQgdGlja2VyLlxuICogdGlja2VyLnN0YXJ0KCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFlvdSBtYXkgdXNlIHRoZSBzaGFyZWQgdGlja2VyIHRvIHJlbmRlci4uLlxuICogbGV0IHJlbmRlcmVyID0gUElYSS5hdXRvRGV0ZWN0UmVuZGVyZXIoKTtcbiAqIGxldCBzdGFnZSA9IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci52aWV3KTtcbiAqIHRpY2tlci5hZGQoZnVuY3Rpb24gKHRpbWUpIHtcbiAqIHJlbmRlcmVyLnJlbmRlcihzdGFnZSk7XG4gKiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gT3IgeW91IGNhbiBqdXN0IHVwZGF0ZSBpdCBtYW51YWxseS5cbiAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAqIHRpY2tlci5zdG9wKCk7XG4gKiBmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcbiAqIHRpY2tlci51cGRhdGUodGltZSk7XG4gKiByZW5kZXJlci5yZW5kZXIoc3RhZ2UpO1xuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICogfVxuICogYW5pbWF0ZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gKlxuICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XG4gKiBAc3RhdGljXG4gKi9cbiAgICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICAgICAgaWYgKCFUaWNrZXIuX3NoYXJlZCkge1xuICAgICAgICAgICAgdmFyIHNoYXJlZCA9IFRpY2tlci5fc2hhcmVkID0gbmV3IFRpY2tlcigpO1xuICAgICAgICAgICAgc2hhcmVkLmF1dG9TdGFydCA9IHRydWU7XG4gICAgICAgICAgICBzaGFyZWQuX3Byb3RlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRpY2tlci5fc2hhcmVkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHN5c3RlbSB0aWNrZXIgaW5zdGFuY2UgdXNlZCBieSB7QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXJ9IGFuZCBieVxuICAgICAqIHtAbGluayBQSVhJLkJhc2VQcmVwYXJlfSBmb3IgY29yZSB0aW1pbmcgZnVuY3Rpb25hbGl0eSB0aGF0IHNob3VsZG4ndCB1c3VhbGx5IG5lZWQgdG8gYmUgcGF1c2VkLFxuICAgICAqIHVubGlrZSB0aGUgYHNoYXJlZGAgdGlja2VyIHdoaWNoIGRyaXZlcyB2aXN1YWwgYW5pbWF0aW9ucyBhbmQgcmVuZGVyaW5nIHdoaWNoIG1heSB3YW50IHRvIGJlIHBhdXNlZC5cbiAgICAgKlxuICAgICAqIFRoZSBwcm9wZXJ0eSB7QGxpbmsgUElYSS5UaWNrZXIjYXV0b1N0YXJ0fSBpcyBzZXQgdG8gYHRydWVgIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgc3lzdGVtKCkge1xuICAgICAgICBpZiAoIVRpY2tlci5fc3lzdGVtKSB7XG4gICAgICAgICAgICB2YXIgc3lzdGVtID0gVGlja2VyLl9zeXN0ZW0gPSBuZXcgVGlja2VyKCk7XG4gICAgICAgICAgICBzeXN0ZW0uYXV0b1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHN5c3RlbS5fcHJvdGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGlja2VyLl9zeXN0ZW07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYWxsb3dlZCB0b1xuICAgICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9LlxuICAgICAqIFRoaXMgd2lsbCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjRlBTfS5cbiAgICAgKiBXaGVuIHNldHRpbmcgdGhpcyBwcm9wZXJ0eSBpdCBpcyBjbGFtcGVkIHRvIGEgdmFsdWUgYmV0d2VlblxuICAgICAqIGAxYCBhbmQgYFRBUkdFVF9GUE1TICogMTAwMGAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNjBcbiAgICAgKi9cbiAgICBnZXQgbWF4RlBTKCkge1xuICAgICAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuX21pbkVsYXBzZWRNUztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUyAqIDEwMDA7XG4gICAgfVxuICAgIDtcbn1cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdXBkYXRlIHByaW9yaXRpZXMgdXNlZCBieSBpbnRlcm5hbCBQSVhJIGNsYXNzZXMgd2hlbiByZWdpc3RlcmVkIHdpdGhcbiAqIHRoZSB7QGxpbmsgUElYSS5UaWNrZXJ9IG9iamVjdC4gSGlnaGVyIHByaW9yaXR5IGl0ZW1zIGFyZSB1cGRhdGVkIGZpcnN0IGFuZCBsb3dlclxuICogcHJpb3JpdHkgaXRlbXMsIHN1Y2ggYXMgcmVuZGVyLCBzaG91bGQgZ28gbGF0ZXIuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbmFtZSBVUERBVEVfUFJJT1JJVFlcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IElOVEVSQUNUSU9OPTUwIEhpZ2hlc3QgcHJpb3JpdHksIHVzZWQgZm9yIHtAbGluayBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBISUdIPTI1IEhpZ2ggcHJpb3JpdHkgdXBkYXRpbmcsIHtAbGluayBQSVhJLlZpZGVvQmFzZVRleHR1cmV9IGFuZCB7QGxpbmsgUElYSS5BbmltYXRlZFNwcml0ZX1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1JNQUw9MCBEZWZhdWx0IHByaW9yaXR5IGZvciB0aWNrZXIgZXZlbnRzLCBzZWUge0BsaW5rIFBJWEkuVGlja2VyI2FkZH0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9XPS0yNSBMb3cgcHJpb3JpdHkgdXNlZCBmb3Ige0BsaW5rIFBJWEkuQXBwbGljYXRpb259IHJlbmRlcmluZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVVElMSVRZPS01MCBMb3dlc3QgcHJpb3JpdHkgdXNlZCBmb3Ige0BsaW5rIFBJWEkucHJlcGFyZS5CYXNlUHJlcGFyZX0gdXRpbGl0eS5cbiAqL1xuVGlja2VyLlVQREFURV9QUklPUklUWSA9IHtcbiAgICBJTlRFUkFDVElPTjogNTAsXG4gICAgSElHSDogMjUsXG4gICAgTk9STUFMOiAwLFxuICAgIExPVzogLTI1LFxuICAgIFVUSUxJVFk6IC01MCxcbn07XG5leHBvcnRzLlRpY2tlciA9IFRpY2tlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVGlja2VyTGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKGZuLCBjb250ZXh0LCBwcmlvcml0eSwgb25jZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uY2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb25jZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGFuZGxlciBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsaW5nIHRvIGV4ZWN1dGUuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIgeyp9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgcHJpb3JpdHkuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoaXMgc2hvdWxkIG9ubHkgZXhlY3V0ZSBvbmNlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmNlID0gb25jZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuZXh0IGl0ZW0gaW4gY2hhaW4uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1RpY2tlckxpc3RlbmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBpdGVtIGluIGNoYWluLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtUaWNrZXJMaXN0ZW5lcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogYHRydWVgIGlmIHRoaXMgbGlzdGVuZXIgaGFzIGJlZW4gZGVzdHJveWVkIGFscmVhZHkuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBieSBjYWxsaW5nIHRoZSBjdXJyZW50IGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIHRpbWUgc2luY2UgdGhlIGxhc3QgZW1pdC5cbiAgICAgKiBAcmV0dXJuIHtUaWNrZXJMaXN0ZW5lcn0gTmV4dCB0aWNrZXJcbiAgICAgKi9cbiAgICBlbWl0KGRlbHRhVGltZSkge1xuICAgICAgICBpZiAodGhpcy5mbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm4uY2FsbCh0aGlzLmNvbnRleHQsIGRlbHRhVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZuKGRlbHRhVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAodGhpcy5vbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29mdC1kZXN0cm95aW5nIHNob3VsZCByZW1vdmVcbiAgICAgICAgLy8gdGhlIG5leHQgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXJkID0gZmFsc2VdIGB0cnVlYCB0byByZW1vdmUgdGhlIGBuZXh0YCByZWZlcmVuY2UsIHRoaXNcbiAgICAgKiAgICBpcyBjb25zaWRlcmVkIGEgaGFyZCBkZXN0cm95LiBTb2Z0IGRlc3Ryb3kgbWFpbnRhaW5zIHRoZSBuZXh0IHJlZmVyZW5jZS5cbiAgICAgKiBAcmV0dXJuIHtUaWNrZXJMaXN0ZW5lcn0gVGhlIGxpc3RlbmVyIHRvIHJlZGlyZWN0IHdoaWxlIGVtaXR0aW5nIG9yIHJlbW92aW5nLlxuICAgICAqL1xuICAgIGRlc3Ryb3koaGFyZCkge1xuICAgICAgICBpZiAoaGFyZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mbiA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIC8vIERpc2Nvbm5lY3QsIGhvb2sgdXAgbmV4dCBhbmQgcHJldmlvdXNcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQucHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZGlyZWN0IHRvIHRoZSBuZXh0IGl0ZW1cbiAgICAgICAgdmFyIHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlc1xuICAgICAgICB0aGlzLm5leHQgPSBoYXJkID8gbnVsbCA6IHJlZGlyZWN0O1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgbGlzdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VGlja2VyTGlzdGVuZXJ9IHByZXZpb3VzIC0gSW5wdXQgbm9kZSwgcHJldmlvdXMgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBjb25uZWN0KHByZXZpb3VzKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgaWYgKHByZXZpb3VzLm5leHQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQucHJldmlvdXMgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCA9IHByZXZpb3VzLm5leHQ7XG4gICAgICAgIHByZXZpb3VzLm5leHQgPSB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIGNvbXBhcmUgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiBhIGZ1bmN0aW9uIGFuZCBjb250ZXh0IG1hdGNoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGxpc3RlbmVyIG1hdGNoIHRoZSBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBtYXRjaChmbiwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5mbiA9PT0gZm4gJiYgdGhpcy5jb250ZXh0ID09PSBjb250ZXh0O1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlRpY2tlckxpc3RlbmVyID0gVGlja2VyTGlzdGVuZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4vU3ByaXRlXCIpO1xuY29uc3QgVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi9UcmFuc2Zvcm1cIik7XG5jb25zdCBUZXh0dXJlTWF0cml4XzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlTWF0cml4XCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcbmNsYXNzIFRpbGluZ1Nwcml0ZSBleHRlbmRzIFNwcml0ZV8xLlNwcml0ZSB7XG4gICAgY29uc3RydWN0b3IodGV4dHVyZSwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCkge1xuICAgICAgICBzdXBlcih0ZXh0dXJlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy51dk1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXZNYXRyaXgudGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHdpZHRoID0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaWxlIHRyYW5zZm9ybVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGlsZVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1fMS5UcmFuc2Zvcm0oKTtcbiAgICAgICAgLy8gLy8vIHByaXZhdGVcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aXRoIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbnZhcyBwYXR0ZXJuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtDYW52YXNQYXR0ZXJufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2FudmFzUGF0dGVybiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXRyaXggdGhhdCBpcyBhcHBsaWVkIHRvIFVWIHRvIGdldCB0aGUgY29vcmRzIGluIFRleHR1cmUgbm9ybWFsaXplZCBzcGFjZSB0byBjb29yZHMgaW4gQmFzZVRleHR1cmUgc3BhY2VcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlTWF0cml4fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51dk1hdHJpeCA9IHRleHR1cmUudXZNYXRyaXggfHwgbmV3IFRleHR1cmVNYXRyaXhfMS5UZXh0dXJlTWF0cml4KHRleHR1cmUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGx1Z2luIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqIEFsbG93cyB0byBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBwcm9jZXNzIHdpdGhvdXQgb3ZlcnJpZGluZyAnX3JlbmRlcicgbWV0aG9kLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICd0aWxpbmdTcHJpdGUnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsdWdpbk5hbWUgPSAndGlsaW5nU3ByaXRlJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IGFuY2hvciBhZmZlY3RzIHV2c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51dlJlc3BlY3RBbmNob3IgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBmcmFtZSBjbGFtcGluZyBpbiBjb3JyZXNwb25kaW5nIHRleHR1cmVUcmFuc2Zvcm0sIHNob3J0Y3V0XG4gICAgICogQ2hhbmdlIHRvIC0wLjUgdG8gYWRkIGEgcGl4ZWwgdG8gdGhlIGVkZ2UsIHJlY29tbWVuZGVkIGZvciB0cmFuc3BhcmVudCB0cmltbWVkIHRleHR1cmVzIGluIGF0bGFzXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAwLjVcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGNsYW1wTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51dk1hdHJpeC5jbGFtcE1hcmdpbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBjbGFtcE1hcmdpbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnV2TWF0cml4LmNsYW1wTWFyZ2luID0gdmFsdWU7XG4gICAgICAgIHRoaXMudXZNYXRyaXgudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHNjYWxpbmcgb2YgdGhlIGltYWdlIHRoYXQgaXMgYmVpbmcgdGlsZWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAqL1xuICAgIGdldCB0aWxlU2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVUcmFuc2Zvcm0uc2NhbGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGlsZVNjYWxlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGlsZVRyYW5zZm9ybS5zY2FsZS5jb3B5RnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgb2Zmc2V0IG9mIHRoZSBpbWFnZSB0aGF0IGlzIGJlaW5nIHRpbGVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgKi9cbiAgICBnZXQgdGlsZVBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWxlVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRpbGVQb3NpdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRpbGVUcmFuc2Zvcm0ucG9zaXRpb24uY29weUZyb20odmFsdWUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIHR3ZWFrIG91ciB0ZXh0dXJlIHRlbXBvcmFyaWx5Li5cbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgICAgICBpZiAoIXRleHR1cmUgfHwgIXRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbGVUcmFuc2Zvcm0udXBkYXRlTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy51dk1hdHJpeC51cGRhdGUoKTtcbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdKTtcbiAgICAgICAgcmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdLnJlbmRlcih0aGlzKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgdGlsaW5nIHNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgICAgICB2YXIgbWluWCA9IHRoaXMuX3dpZHRoICogLXRoaXMuX2FuY2hvci5feDtcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzLl9oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLl95O1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMuX3dpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xuICAgICAgICB2YXIgbWF4WSA9IHRoaXMuX2hlaWdodCAqICgxIC0gdGhpcy5fYW5jaG9yLl95KTtcbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgc3ByaXRlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3QgLSBUaGUgb3V0cHV0IHJlY3RhbmdsZS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIGJvdW5kcy5cbiAgICAgKi9cbiAgICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgICAgIC8vIHdlIGNhbiBkbyBhIGZhc3QgbG9jYWwgYm91bmRzIGlmIHRoZSBzcHJpdGUgaGFzIG5vIGNoaWxkcmVuIVxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5taW5YID0gdGhpcy5fd2lkdGggKiAtdGhpcy5fYW5jaG9yLl94O1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblkgPSB0aGlzLl9oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLl95O1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1heFggPSB0aGlzLl93aWR0aCAqICgxIC0gdGhpcy5fYW5jaG9yLl94KTtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5tYXhZID0gdGhpcy5faGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IuX3kpO1xuICAgICAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNwcml0ZV8xLlNwcml0ZS5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZHMuY2FsbCh0aGlzLCByZWN0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHRpbGluZyBzcHJpdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gdGhlIHBvaW50IHRvIGNoZWNrXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIHNwcml0ZSBjb250YWlucyB0aGUgcG9pbnQuXG4gICAgICovXG4gICAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgVGlsaW5nU3ByaXRlLnRlbXBQb2ludCQxKTtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIHZhciB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLl94O1xuICAgICAgICBpZiAoVGlsaW5nU3ByaXRlLnRlbXBQb2ludCQxLnggPj0geDEgJiYgVGlsaW5nU3ByaXRlLnRlbXBQb2ludCQxLnggPCB4MSArIHdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IuX3k7XG4gICAgICAgICAgICBpZiAoVGlsaW5nU3ByaXRlLnRlbXBQb2ludCQxLnkgPj0geTEgJiYgVGlsaW5nU3ByaXRlLnRlbXBQb2ludCQxLnkgPCB5MSArIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgc3ByaXRlIGFuZCBvcHRpb25hbGx5IGl0cyB0ZXh0dXJlIGFuZCBjaGlsZHJlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XG4gICAgICogICAgICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGlsZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgICAgIHRoaXMudXZNYXRyaXggPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyB0aWxpbmcgc3ByaXRlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAgICogVGhlIHNvdXJjZSBjYW4gYmUgLSBmcmFtZSBpZCwgaW1hZ2UgdXJsLCB2aWRlbyB1cmwsIGNhbnZhcyBlbGVtZW50LCB2aWRlbyBlbGVtZW50LCBiYXNlIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8UElYSS5UZXh0dXJlfEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHNvdXJjZSAtIFNvdXJjZSB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRpbGluZ1Nwcml0ZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuICAgIC8vIHN0YXRpYyBmcm9tICAoc291cmNlLCB3aWR0aCwgaGVpZ2h0KVxuICAgIC8vIHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBUaWxpbmdTcHJpdGUoVGV4dHVyZS5mcm9tKHNvdXJjZSksIHdpZHRoLCBoZWlnaHQpO1xuICAgIC8vIH07XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHRpbGluZyBzcHJpdGUgdGhhdCB3aWxsIHVzZSBhIHRleHR1cmUgZnJvbSB0aGUgVGV4dHVyZUNhY2hlIGJhc2VkIG9uIHRoZSBmcmFtZUlkXG4gICAgICogVGhlIGZyYW1lIGlkcyBhcmUgY3JlYXRlZCB3aGVuIGEgVGV4dHVyZSBwYWNrZXIgZmlsZSBoYXMgYmVlbiBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnJhbWVJZCAtIFRoZSBmcmFtZSBJZCBvZiB0aGUgdGV4dHVyZSBpbiB0aGUgY2FjaGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqIEByZXR1cm4ge1BJWEkuVGlsaW5nU3ByaXRlfSBBIG5ldyBUaWxpbmdTcHJpdGUgdXNpbmcgYSB0ZXh0dXJlIGZyb20gdGhlIHRleHR1cmUgY2FjaGUgbWF0Y2hpbmcgdGhlIGZyYW1lSWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUZyYW1lKGZyYW1lSWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbZnJhbWVJZF07XG4gICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlRoZSBmcmFtZUlkIFxcXCJcIiArIGZyYW1lSWQgKyBcIlxcXCIgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgXCIgKyAodGhpcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbGluZ1Nwcml0ZSh0ZXh0dXJlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBzcHJpdGUgdGhhdCB3aWxsIGNvbnRhaW4gYSB0ZXh0dXJlIGJhc2VkIG9uIGFuIGltYWdlIHVybFxuICAgICAqIElmIHRoZSBpbWFnZSBpcyBub3QgaW4gdGhlIHRleHR1cmUgY2FjaGUgaXQgd2lsbCBiZSBsb2FkZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VJZCAtIFRoZSBpbWFnZSB1cmwgb2YgdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7UElYSS5UaWxpbmdTcHJpdGV9IEEgbmV3IFRpbGluZ1Nwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgaW1hZ2UgaWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUltYWdlKGltYWdlSWQsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgc3VwcG9ydCBmb3IgY3Jvc3NvcmlnaW4sIHNjYWxlTW9kZSBwYXJhbWV0ZXJzXG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6IGFyZ3VtZW50c1s0XSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZU9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgY3Jvc3NvcmlnaW46IGFyZ3VtZW50c1szXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbGluZ1Nwcml0ZShUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKGltYWdlSWQsIG9wdGlvbnMpLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUaWxpbmdTcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbn1cblRpbGluZ1Nwcml0ZS50ZW1wUG9pbnQkMSA9IG5ldyBQb2ludF8xLlBvaW50KCk7XG5leHBvcnRzLlRpbGluZ1Nwcml0ZSA9IFRpbGluZ1Nwcml0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgT2JqZWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL09iamVjdFJlbmRlcmVyXCIpO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XG5jb25zdCBRdWFkVXZfMSA9IHJlcXVpcmUoXCIuL1F1YWRVdlwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcbmNsYXNzIFRpbGluZ1Nwcml0ZVJlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXJfMS5PYmplY3RSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7IGdsb2JhbHM6IHRoaXMucmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMgfTtcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBTaGFkZXJfMS5TaGFkZXIuZnJvbShUaWxpbmdTcHJpdGVSZW5kZXJlci52ZXJ0ZXgkMywgVGlsaW5nU3ByaXRlUmVuZGVyZXIuZnJhZ21lbnQkMiwgdW5pZm9ybXMpO1xuICAgICAgICB0aGlzLnNpbXBsZVNoYWRlciA9IFNoYWRlcl8xLlNoYWRlci5mcm9tKFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnZlcnRleCQzLCBUaWxpbmdTcHJpdGVSZW5kZXJlci5mcmFnbWVudFNpbXBsZSwgdW5pZm9ybXMpO1xuICAgICAgICB0aGlzLnF1YWQgPSBuZXcgUXVhZFV2XzEuUXVhZFV2KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlRpbGluZ1Nwcml0ZX0gdHMgdGlsaW5nU3ByaXRlIHRvIGJlIHJlbmRlcmVkXG4gICAgICovXG4gICAgcmVuZGVyKHRzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBxdWFkID0gdGhpcy5xdWFkO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBxdWFkLnZlcnRpY2VzO1xuICAgICAgICB2ZXJ0aWNlc1swXSA9IHZlcnRpY2VzWzZdID0gKHRzLl93aWR0aCkgKiAtdHMuYW5jaG9yLng7XG4gICAgICAgIHZlcnRpY2VzWzFdID0gdmVydGljZXNbM10gPSB0cy5faGVpZ2h0ICogLXRzLmFuY2hvci55O1xuICAgICAgICB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzRdID0gKHRzLl93aWR0aCkgKiAoMS4wIC0gdHMuYW5jaG9yLngpO1xuICAgICAgICB2ZXJ0aWNlc1s1XSA9IHZlcnRpY2VzWzddID0gdHMuX2hlaWdodCAqICgxLjAgLSB0cy5hbmNob3IueSk7XG4gICAgICAgIGlmICh0cy51dlJlc3BlY3RBbmNob3IpIHtcbiAgICAgICAgICAgIHZlcnRpY2VzID0gcXVhZC51dnM7XG4gICAgICAgICAgICB2ZXJ0aWNlc1swXSA9IHZlcnRpY2VzWzZdID0gLXRzLmFuY2hvci54O1xuICAgICAgICAgICAgdmVydGljZXNbMV0gPSB2ZXJ0aWNlc1szXSA9IC10cy5hbmNob3IueTtcbiAgICAgICAgICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbNF0gPSAxLjAgLSB0cy5hbmNob3IueDtcbiAgICAgICAgICAgIHZlcnRpY2VzWzVdID0gdmVydGljZXNbN10gPSAxLjAgLSB0cy5hbmNob3IueTtcbiAgICAgICAgfVxuICAgICAgICBxdWFkLmludmFsaWRhdGUoKTtcbiAgICAgICAgdmFyIHRleCA9IHRzLl90ZXh0dXJlO1xuICAgICAgICB2YXIgYmFzZVRleCA9IHRleC5iYXNlVGV4dHVyZTtcbiAgICAgICAgdmFyIGx0ID0gdHMudGlsZVRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIHV2ID0gdHMudXZNYXRyaXg7XG4gICAgICAgIHZhciBpc1NpbXBsZSA9IGJhc2VUZXguaXNQb3dlck9mVHdvXG4gICAgICAgICAgICAmJiB0ZXguZnJhbWUud2lkdGggPT09IGJhc2VUZXgud2lkdGggJiYgdGV4LmZyYW1lLmhlaWdodCA9PT0gYmFzZVRleC5oZWlnaHQ7XG4gICAgICAgIC8vIGF1dG8sIGZvcmNlIHJlcGVhdCB3cmFwTW9kZSBmb3IgYmlnIHRpbGluZyB0ZXh0dXJlc1xuICAgICAgICBpZiAoaXNTaW1wbGUpIHtcbiAgICAgICAgICAgIGlmICghYmFzZVRleC5fZ2xUZXh0dXJlc1tyZW5kZXJlci5DT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVRleC53cmFwTW9kZSA9PT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFUy5DTEFNUCkge1xuICAgICAgICAgICAgICAgICAgICBiYXNlVGV4LndyYXBNb2RlID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFUy5SRVBFQVQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNTaW1wbGUgPSBiYXNlVGV4LndyYXBNb2RlICE9PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5XUkFQX01PREVTLkNMQU1QO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkZXIgPSBpc1NpbXBsZSA/IHRoaXMuc2ltcGxlU2hhZGVyIDogdGhpcy5zaGFkZXI7XG4gICAgICAgIHZhciB3ID0gdGV4LndpZHRoO1xuICAgICAgICB2YXIgaCA9IHRleC5oZWlnaHQ7XG4gICAgICAgIHZhciBXID0gdHMuX3dpZHRoO1xuICAgICAgICB2YXIgSCA9IHRzLl9oZWlnaHQ7XG4gICAgICAgIFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnRlbXBNYXQkMS5zZXQobHQuYSAqIHcgLyBXLCBsdC5iICogdyAvIEgsIGx0LmMgKiBoIC8gVywgbHQuZCAqIGggLyBILCBsdC50eCAvIFcsIGx0LnR5IC8gSCk7XG4gICAgICAgIC8vIHRoYXQgcGFydCBpcyB0aGUgc2FtZSBhcyBhYm92ZTpcbiAgICAgICAgLy8gdGVtcE1hdC5pZGVudGl0eSgpO1xuICAgICAgICAvLyB0ZW1wTWF0LnNjYWxlKHRleC53aWR0aCwgdGV4LmhlaWdodCk7XG4gICAgICAgIC8vIHRlbXBNYXQucHJlcGVuZChsdCk7XG4gICAgICAgIC8vIHRlbXBNYXQuc2NhbGUoMS4wIC8gdHMuX3dpZHRoLCAxLjAgLyB0cy5faGVpZ2h0KTtcbiAgICAgICAgVGlsaW5nU3ByaXRlUmVuZGVyZXIudGVtcE1hdCQxLmludmVydCgpO1xuICAgICAgICBpZiAoaXNTaW1wbGUpIHtcbiAgICAgICAgICAgIFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnRlbXBNYXQkMS5wcmVwZW5kKHV2Lm1hcENvb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy51TWFwQ29vcmQgPSB1di5tYXBDb29yZC50b0FycmF5KHRydWUpO1xuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVDbGFtcEZyYW1lID0gdXYudUNsYW1wRnJhbWU7XG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMudUNsYW1wT2Zmc2V0ID0gdXYudUNsYW1wT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy51VHJhbnNmb3JtID0gVGlsaW5nU3ByaXRlUmVuZGVyZXIudGVtcE1hdCQxLnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy51Q29sb3IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5wcmVtdWx0aXBseVRpbnRUb1JnYmEodHMudGludCwgdHMud29ybGRBbHBoYSwgc2hhZGVyLnVuaWZvcm1zLnVDb2xvciwgYmFzZVRleC5wcmVtdWx0aXBseUFscGhhKTtcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdHMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy51U2FtcGxlciA9IHRleDtcbiAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKTtcbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChxdWFkKTsgLy8gLCByZW5kZXJlci5zaGFkZXIuZ2V0R0xTaGFkZXIoKSk7XG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLnNldEJsZW5kTW9kZShCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuY29ycmVjdEJsZW5kTW9kZSh0cy5ibGVuZE1vZGUsIGJhc2VUZXgucHJlbXVsdGlwbHlBbHBoYSkpO1xuICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KHRoaXMucmVuZGVyZXIuZ2wuVFJJQU5HTEVTLCA2LCAwKTtcbiAgICB9XG4gICAgO1xufVxuVGlsaW5nU3ByaXRlUmVuZGVyZXIuZnJhZ21lbnRTaW1wbGUgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IHNhbXBsZSAqIHVDb2xvcjtcXHJcXG59XFxyXFxuXCI7XG5UaWxpbmdTcHJpdGVSZW5kZXJlci5mcmFnbWVudCQyID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcclxcbnVuaWZvcm0gbWF0MyB1TWFwQ29vcmQ7XFxyXFxudW5pZm9ybSB2ZWM0IHVDbGFtcEZyYW1lO1xcclxcbnVuaWZvcm0gdmVjMiB1Q2xhbXBPZmZzZXQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICB2ZWMyIGNvb3JkID0gbW9kKHZUZXh0dXJlQ29vcmQgLSB1Q2xhbXBPZmZzZXQsIHZlYzIoMS4wLCAxLjApKSArIHVDbGFtcE9mZnNldDtcXHJcXG4gICAgY29vcmQgPSAodU1hcENvb3JkICogdmVjMyhjb29yZCwgMS4wKSkueHk7XFxyXFxuICAgIGNvb3JkID0gY2xhbXAoY29vcmQsIHVDbGFtcEZyYW1lLnh5LCB1Q2xhbXBGcmFtZS56dyk7XFxyXFxuXFxyXFxuICAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZCk7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IHNhbXBsZSAqIHVDb2xvcjtcXHJcXG59XFxyXFxuXCI7XG5UaWxpbmdTcHJpdGVSZW5kZXJlci52ZXJ0ZXgkMyA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB1VHJhbnNmb3JtO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VHJhbnNmb3JtICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcXHJcXG59XFxyXFxuXCI7XG5UaWxpbmdTcHJpdGVSZW5kZXJlci50ZW1wTWF0JDEgPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XG5leHBvcnRzLlRpbGluZ1Nwcml0ZVJlbmRlcmVyID0gVGlsaW5nU3ByaXRlUmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgT2JzZXJ2YWJsZVBvaW50XzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlUG9pbnRcIik7XG5jbGFzcyBUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgZ2xvYmFsIG1hdHJpeCB0cmFuc2Zvcm0uIEl0IGNhbiBiZSBzd2FwcGVkIHRlbXBvcmFyaWx5IGJ5IHNvbWUgZnVuY3Rpb25zIGxpa2UgZ2V0TG9jYWxCb3VuZHMoKVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbG9jYWwgbWF0cml4IHRyYW5zZm9ybVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9jYWxUcmFuc2Zvcm0gPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgT2JzZXJ2YWJsZVBvaW50XzEuT2JzZXJ2YWJsZVBvaW50KHRoaXMub25DaGFuZ2UsIHRoaXMsIDAsIDApO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjYWxlIGZhY3RvciBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGUgPSBuZXcgT2JzZXJ2YWJsZVBvaW50XzEuT2JzZXJ2YWJsZVBvaW50KHRoaXMub25DaGFuZ2UsIHRoaXMsIDEsIDEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBpdm90IHBvaW50IG9mIHRoZSBkaXNwbGF5T2JqZWN0IHRoYXQgaXQgcm90YXRlcyBhcm91bmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5waXZvdCA9IG5ldyBPYnNlcnZhYmxlUG9pbnRfMS5PYnNlcnZhYmxlUG9pbnQodGhpcy5vbkNoYW5nZSwgdGhpcywgMCwgMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2tldyBhbW91bnQsIG9uIHRoZSB4IGFuZCB5IGF4aXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5za2V3ID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCh0aGlzLnVwZGF0ZVNrZXcsIHRoaXMsIDAsIDApO1xuICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuX2N4ID0gMTsgLy8gY29zIHJvdGF0aW9uICsgc2tld1k7XG4gICAgICAgIHRoaXMuX3N4ID0gMDsgLy8gc2luIHJvdGF0aW9uICsgc2tld1k7XG4gICAgICAgIHRoaXMuX2N5ID0gMDsgLy8gY29zIHJvdGF0aW9uICsgTWF0aC5QSS8yIC0gc2tld1g7XG4gICAgICAgIHRoaXMuX3N5ID0gMTsgLy8gc2luIHJvdGF0aW9uICsgTWF0aC5QSS8yIC0gc2tld1g7XG4gICAgICAgIHRoaXMuX2xvY2FsSUQgPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IDA7XG4gICAgICAgIHRoaXMuX3dvcmxkSUQgPSAwO1xuICAgICAgICB0aGlzLl9wYXJlbnRJRCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgdmFsdWUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHNrZXcgb3Igcm90YXRpb24gY2hhbmdlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVTa2V3KCkge1xuICAgICAgICB0aGlzLl9jeCA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3Ll95KTtcbiAgICAgICAgdGhpcy5fc3ggPSBNYXRoLnNpbih0aGlzLl9yb3RhdGlvbiArIHRoaXMuc2tldy5feSk7XG4gICAgICAgIHRoaXMuX2N5ID0gLU1hdGguc2luKHRoaXMuX3JvdGF0aW9uIC0gdGhpcy5za2V3Ll94KTsgLy8gY29zLCBhZGRlZCBQSS8yXG4gICAgICAgIHRoaXMuX3N5ID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24gLSB0aGlzLnNrZXcuX3gpOyAvLyBzaW4sIGFkZGVkIFBJLzJcbiAgICAgICAgdGhpcy5fbG9jYWxJRCsrO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBvbmx5IGxvY2FsIG1hdHJpeFxuICAgICAqL1xuICAgIHVwZGF0ZUxvY2FsVHJhbnNmb3JtKCkge1xuICAgICAgICB2YXIgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxJRCAhPT0gdGhpcy5fY3VycmVudExvY2FsSUQpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgbWF0cml4IHZhbHVlcyBvZiB0aGUgZGlzcGxheW9iamVjdCBiYXNlZCBvbiBpdHMgdHJhbnNmb3JtIHByb3BlcnRpZXMuLlxuICAgICAgICAgICAgbHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS5feDtcbiAgICAgICAgICAgIGx0LmIgPSB0aGlzLl9zeCAqIHRoaXMuc2NhbGUuX3g7XG4gICAgICAgICAgICBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLl95O1xuICAgICAgICAgICAgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS5feTtcbiAgICAgICAgICAgIGx0LnR4ID0gdGhpcy5wb3NpdGlvbi5feCAtICgodGhpcy5waXZvdC5feCAqIGx0LmEpICsgKHRoaXMucGl2b3QuX3kgKiBsdC5jKSk7XG4gICAgICAgICAgICBsdC50eSA9IHRoaXMucG9zaXRpb24uX3kgLSAoKHRoaXMucGl2b3QuX3ggKiBsdC5iKSArICh0aGlzLnBpdm90Ll95ICogbHQuZCkpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSB0aGlzLl9sb2NhbElEO1xuICAgICAgICAgICAgLy8gZm9yY2UgYW4gdXBkYXRlLi5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudElEID0gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0IGFuZCBhcHBsaWVzIHRoZSBwYXJlbnQncyB0cmFuc2Zvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSBwYXJlbnRUcmFuc2Zvcm0gLSBUaGUgdHJhbnNmb3JtIG9mIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3RcbiAgICAgKi9cbiAgICB1cGRhdGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtKSB7XG4gICAgICAgIHZhciBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG4gICAgICAgIGlmICh0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtYXRyaXggdmFsdWVzIG9mIHRoZSBkaXNwbGF5b2JqZWN0IGJhc2VkIG9uIGl0cyB0cmFuc2Zvcm0gcHJvcGVydGllcy4uXG4gICAgICAgICAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLl94O1xuICAgICAgICAgICAgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS5feDtcbiAgICAgICAgICAgIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUuX3k7XG4gICAgICAgICAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLl95O1xuICAgICAgICAgICAgbHQudHggPSB0aGlzLnBvc2l0aW9uLl94IC0gKCh0aGlzLnBpdm90Ll94ICogbHQuYSkgKyAodGhpcy5waXZvdC5feSAqIGx0LmMpKTtcbiAgICAgICAgICAgIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi5feSAtICgodGhpcy5waXZvdC5feCAqIGx0LmIpICsgKHRoaXMucGl2b3QuX3kgKiBsdC5kKSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IHRoaXMuX2xvY2FsSUQ7XG4gICAgICAgICAgICAvLyBmb3JjZSBhbiB1cGRhdGUuLlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50SUQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50SUQgIT09IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRCkge1xuICAgICAgICAgICAgLy8gY29uY2F0IHRoZSBwYXJlbnQgbWF0cml4IHdpdGggdGhlIG9iamVjdHMgdHJhbnNmb3JtLlxuICAgICAgICAgICAgdmFyIHB0ID0gcGFyZW50VHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgICAgIHd0LmEgPSAobHQuYSAqIHB0LmEpICsgKGx0LmIgKiBwdC5jKTtcbiAgICAgICAgICAgIHd0LmIgPSAobHQuYSAqIHB0LmIpICsgKGx0LmIgKiBwdC5kKTtcbiAgICAgICAgICAgIHd0LmMgPSAobHQuYyAqIHB0LmEpICsgKGx0LmQgKiBwdC5jKTtcbiAgICAgICAgICAgIHd0LmQgPSAobHQuYyAqIHB0LmIpICsgKGx0LmQgKiBwdC5kKTtcbiAgICAgICAgICAgIHd0LnR4ID0gKGx0LnR4ICogcHQuYSkgKyAobHQudHkgKiBwdC5jKSArIHB0LnR4O1xuICAgICAgICAgICAgd3QudHkgPSAobHQudHggKiBwdC5iKSArIChsdC50eSAqIHB0LmQpICsgcHQudHk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRJRCA9IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRDtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaWQgb2YgdGhlIHRyYW5zZm9ybS4uXG4gICAgICAgICAgICB0aGlzLl93b3JsZElEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlY29tcG9zZXMgYSBtYXRyaXggYW5kIHNldHMgdGhlIHRyYW5zZm9ybXMgcHJvcGVydGllcyBiYXNlZCBvbiBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gZGVjb21wb3NlXG4gICAgICovXG4gICAgc2V0RnJvbU1hdHJpeChtYXRyaXgpIHtcbiAgICAgICAgbWF0cml4LmRlY29tcG9zZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fbG9jYWxJRCsrO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTa2V3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xufVxuVHJhbnNmb3JtLklERU5USVRZID0gbmV3IFRyYW5zZm9ybSgpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IElPRXJyb3JFdmVudF8xID0gcmVxdWlyZShcIi4vSU9FcnJvckV2ZW50XCIpO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jbGFzcyBVUkxMb2FkZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9uSHR0cFJlc3BvbnNlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhID0gdGhpcy54bWxodHRwLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNPTVBMRVRFKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMueG1saHR0cC5zdGF0dXMgPT0gMCAmJiB0aGlzLnhtbGh0dHAucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHRoaXMueG1saHR0cC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DT01QTEVURSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy54bWxodHRwLnJlYWR5U3RhdGUgPT0gNCAmJiB0aGlzLnhtbGh0dHAuc3RhdHVzID09IDQwNCkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvcmV2ZW50ID0gbmV3IElPRXJyb3JFdmVudF8xLklPRXJyb3JFdmVudChJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQuSU9fRVJST1IpO1xuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQudGV4dCA9IFwiQ291bGQgbm90IGZpbmQgZmlsZSBcIiArIHRoaXMucmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC5lcnJvcklkID0gNDA0O1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvcmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyA9PSA0MDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JldmVudCA9IG5ldyBJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQoSU9FcnJvckV2ZW50XzEuSU9FcnJvckV2ZW50LklPX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBlcnJvcmV2ZW50LnRleHQgPSBcIkNyb3NzIE9yaWdpbiBFcnJvciBcIiArIHRoaXMucmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC5lcnJvcklkID0gNDAzO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvcmV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyAhPSAyMDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JldmVudCA9IG5ldyBJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQoSU9FcnJvckV2ZW50XzEuSU9FcnJvckV2ZW50LklPX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBlcnJvcmV2ZW50LnRleHQgPSBcIlVua293biBFcnJvciBcIiArIHRoaXMucmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC5lcnJvcklkID0gdGhpcy54bWxodHRwLnN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMueG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIGlmICh0aGlzLnhtbGh0dHApIHtcbiAgICAgICAgICAgIHRoaXMueG1saHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueG1saHR0cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QudXJsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICAgIHNldCBkYXRhKHZhbHVlKSB7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgIH1cbiAgICBsb2FkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHZhbHVlO1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucmVxdWVzdC51cmw7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QuZGF0YSkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucmVxdWVzdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zICs9IGtleSArIFwiPVwiICsgdGhpcy5yZXF1ZXN0LmRhdGFba2V5XSArIFwiJlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLnN1YnN0cigwLCBwYXJhbXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBwYXRoICs9IFwiP1wiICsgcGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueG1saHR0cC5vcGVuKHRoaXMucmVxdWVzdC5tZXRob2QsIHBhdGgsIHRydWUpO1xuICAgICAgICB0aGlzLnhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vbkh0dHBSZXNwb25zZTtcbiAgICAgICAgaWYgKHBhdGguaW5kZXhPZihcIi5qc29uXCIpIDwgMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdC5jb250ZW50VHlwZSAhPSAnanNvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnhtbGh0dHAuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQveG1sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdC5lbnZlbG9wKSB7XG4gICAgICAgICAgICB0aGlzLnhtbGh0dHAuc2VuZCh0aGlzLnJlcXVlc3QuZW52ZWxvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnhtbGh0dHAuc2VuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkYXRhRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2V0IGRhdGFGb3JtYXQodmFsdWUpIHtcbiAgICB9XG59XG5leHBvcnRzLlVSTExvYWRlciA9IFVSTExvYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVVJMUmVxdWVzdE1ldGhvZF8xID0gcmVxdWlyZShcIi4vVVJMUmVxdWVzdE1ldGhvZFwiKTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xuY2xhc3MgVVJMUmVxdWVzdCBleHRlbmRzIEZsYXNoQmFzZU9iamVjdF8xLkZsYXNoQmFzZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IocGF0aCA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdE1ldGFEYXRhID0gbmV3IFJlcXVlc3RNZXRhRGF0YSgpO1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gMDtcbiAgICAgICAgdGhpcy5fY3Jvc3NPcmlnaW4gPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0KHBhdGgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl91cmwgPSBudWxsO1xuICAgICAgICB0aGlzLl9tZXRob2QgPSBVUkxSZXF1ZXN0TWV0aG9kXzEuVVJMUmVxdWVzdE1ldGhvZC5QT1NUO1xuICAgICAgICBsZXQgaW5kZXggPSBVUkxSZXF1ZXN0LlVSTFJlcXVlc3RDYWNoZS5pbmRleE9mKHRoaXMpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBVUkxSZXF1ZXN0LlVSTFJlcXVlc3RDYWNoZS5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0KHBhdGggPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3VybCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX21ldGhvZCA9IFVSTFJlcXVlc3RNZXRob2RfMS5VUkxSZXF1ZXN0TWV0aG9kLlBPU1Q7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZW52ZWxvcCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VVJMUmVxdWVzdChwYXRoID0gbnVsbCkge1xuICAgICAgICBpZiAoVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgdXIgPSBVUkxSZXF1ZXN0LlVSTFJlcXVlc3RDYWNoZVtVUkxSZXF1ZXN0LlVSTFJlcXVlc3RDYWNoZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIFVSTFJlcXVlc3QuVVJMUmVxdWVzdENhY2hlLmxlbmd0aCAtPSAxO1xuICAgICAgICAgICAgdXIucmVzZXQocGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gdXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBVUkxSZXF1ZXN0KHBhdGgpO1xuICAgIH1cbiAgICBzZXQgcmVxdWVzdE1ldGFEYXRhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RNZXRhRGF0YSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcmVxdWVzdE1ldGFEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdE1ldGFEYXRhO1xuICAgIH1cbiAgICBzZXQgdGltZW91dCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB0aW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgICB9XG4gICAgc2V0IGNyb3NzT3JpZ2luKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Nyb3NzT3JpZ2luID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBjcm9zc09yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nyb3NzT3JpZ2luO1xuICAgIH1cbiAgICBzZXQgZW52ZWxvcCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9lbnZlbG9wID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBlbnZlbG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW52ZWxvcDtcbiAgICB9XG4gICAgZ2V0IHJlcXVlc3RIZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2V0IHJlcXVlc3RIZWFkZXJzKHZhbHVlKSB7XG4gICAgfVxuICAgIGdldCBjb250ZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRUeXBlO1xuICAgIH1cbiAgICBzZXQgY29udGVudFR5cGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9XG4gICAgc2V0IHVybCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl91cmwgPSB2YWx1ZTtcbiAgICB9XG4gICAgc2V0IGRhdGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxuICAgIGdldCBtZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRob2Q7XG4gICAgfVxuICAgIHNldCBtZXRob2QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gdmFsdWU7XG4gICAgfVxufVxuVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUgPSBbXTtcbmV4cG9ydHMuVVJMUmVxdWVzdCA9IFVSTFJlcXVlc3Q7XG5jbGFzcyBSZXF1ZXN0TWV0YURhdGEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1pbWVUeXBlID0gJyc7XG4gICAgICAgIHRoaXMuc2tpcFNvdXJjZSA9IGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdE1ldGFEYXRhID0gUmVxdWVzdE1ldGFEYXRhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBVUkxSZXF1ZXN0TWV0aG9kIHtcbn1cblVSTFJlcXVlc3RNZXRob2QuR0VUID0gXCJHRVRcIjtcblVSTFJlcXVlc3RNZXRob2QuUE9TVCA9IFwiUE9TVFwiO1xuZXhwb3J0cy5VUkxSZXF1ZXN0TWV0aG9kID0gVVJMUmVxdWVzdE1ldGhvZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVW5pZm9ybUdyb3VwIHtcbiAgICBjb25zdHJ1Y3Rvcih1bmlmb3JtcyA9IG51bGwsIF9zdGF0aWMgPSBudWxsKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdHMgYSBncm91cCBhbmQgbm90IGEgc2luZ2xlIHVuaWZvcm1zXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwID0gdHJ1ZTtcbiAgICAgICAgLy8gbGV0cyBnZW5lcmF0ZSB0aGlzIHdoZW4gdGhlIHNoYWRlciA/XG4gICAgICAgIHRoaXMuc3luY1VuaWZvcm1zID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXJ0eSB2ZXJzaW9uXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eUlkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuaXF1ZSBpZFxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBVbmlmb3JtR3JvdXAuVUlEJDIrKztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuaWZvcm1zIHdvbnQgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvblxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0aWMgPSAhIV9zdGF0aWM7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgfVxuICAgIDtcbiAgICBhZGQobmFtZSwgdW5pZm9ybXMsIF9zdGF0aWMpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtc1tuYW1lXSA9IG5ldyBVbmlmb3JtR3JvdXAodW5pZm9ybXMsIF9zdGF0aWMpO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGljIGZyb20odW5pZm9ybXMsIF9zdGF0aWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmlmb3JtR3JvdXAodW5pZm9ybXMsIF9zdGF0aWMpO1xuICAgIH1cbiAgICA7XG59XG5Vbmlmb3JtR3JvdXAuVUlEJDIgPSAwO1xuZXhwb3J0cy5Vbmlmb3JtR3JvdXAgPSBVbmlmb3JtR3JvdXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFV0aWxzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1V0aWxzU2V0dGluZ3NcIik7XG5jbGFzcyBVcmwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgICAgICAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzaCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLmhyZWYgPSBudWxsO1xuICAgIH1cbiAgICAvLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG4gICAgc3RhdGljIHVybEZvcm1hdChvYmopIHtcbiAgICAgICAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgICAgICAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgICAgICAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAgICAgICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICAgICAgICBpZiAoVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc1N0cmluZyhvYmopKSB7XG4gICAgICAgICAgICBvYmogPSBVcmwudXJsUGFyc2Uob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmouZm9ybWF0KCk7XG4gICAgfVxuICAgIHN0YXRpYyB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXJsLnVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xuICAgIH1cbiAgICBzdGF0aWMgdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gICAgICAgIHJldHVybiBVcmwudXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG4gICAgfVxuICAgIHJlc29sdmVPYmplY3QocmVsYXRpdmUpIHtcbiAgICAgICAgaWYgKFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgICAgICAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgICAgICAgICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZWxhdGl2ZSA9IHJlbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICAgICAgICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICAgICAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgICAgICAgICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgICAgICAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAgICAgICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgICAgICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuICAgICAgICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gICAgICAgIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICAgICAgICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICAgICAgICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgICAgICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgICAgICAgICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgICAgICAgICAgaWYgKFVybC5zbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgICAgICAgICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgICAgICAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgICAgICAgICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgICAgICAgICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgICAgICAgICAgaWYgKCFVcmwuc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIVVybC5ob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgICAgICAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgICAgICAgICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgICAgICAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksIGlzUmVsQWJzID0gKHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSwgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLCBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLCByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSwgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFVcmwuc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG4gICAgICAgIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgICAgICAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAgICAgICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gICAgICAgIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gICAgICAgIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICAgICAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgICAgICAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVsQWJzKSB7XG4gICAgICAgICAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAgICAgICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgICAgICAgICAgaWYgKCFzcmNQYXRoKSB7XG4gICAgICAgICAgICAgICAgc3JjUGF0aCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjUGF0aC5wb3AoKTtcbiAgICAgICAgICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgICAgICAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgICAgICAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgICAgICAgICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgICAgICAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgICAgICAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICAgICAgICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gICAgICAgIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAgICAgICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICAgICAgICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9ICgocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAgICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcbiAgICAgICAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAgICAgICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICAgICAgICB2YXIgdXAgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB1cCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXApIHtcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB1cC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgICAgICAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgICAgICAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgICAgICAgICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAgICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcbiAgICAgICAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgICAgICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAgICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICAgICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcbiAgICAgICAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICAgICAgICB9XG4gICAgICAgIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgICAgICAgaWYgKCFVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGljIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZyA9IG51bGwsIHNsYXNoZXNEZW5vdGVIb3N0ID0gbnVsbCkge1xuICAgICAgICBpZiAodXJsICYmIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHUgPSBuZXcgVXJsO1xuICAgICAgICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICAgICAgICByZXR1cm4gdTtcbiAgICB9XG4gICAgcmVzb2x2ZShyZWxhdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KFVybC51cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbiAgICB9XG4gICAgO1xuICAgIHBhcnNlSG9zdCgpIHtcbiAgICAgICAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gICAgICAgIHZhciBwb3J0ID0gVXJsLnBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gICAgICAgIGlmIChwb3J0KSB7XG4gICAgICAgICAgICBwb3J0ID0gcG9ydFswXTtcbiAgICAgICAgICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdCkge1xuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIHBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZyA9IG51bGwsIHNsYXNoZXNEZW5vdGVIb3N0ID0gbnVsbCkge1xuICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgICAgICAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gICAgICAgIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSwgc3BsaXR0ZXIgPSAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLCB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLCBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgICAgICAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgICAgICAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuICAgICAgICB2YXIgcmVzdCA9IHVybDtcbiAgICAgICAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICAgICAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICAgICAgICByZXN0ID0gcmVzdC50cmltKCk7XG4gICAgICAgIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgICAgICAgICAgdmFyIHNpbXBsZVBhdGggPSBVcmwuc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICAgICAgICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgICAgICAgICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgICAgICAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvdG8gPSBVcmwucHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgICAgIGlmIChwcm90bykge1xuICAgICAgICAgICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICAgICAgICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgICAgICAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAgICAgICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gICAgICAgIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICAgICAgICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICAgICAgICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgICAgICAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIFVybC5ob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVVybC5ob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFVcmwuc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG4gICAgICAgICAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgICAgICAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgICAgICAgICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGV4OlxuICAgICAgICAgICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcbiAgICAgICAgICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAgICAgICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgICAgICAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBVcmwuaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihVcmwuaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAgICAgICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgICAgICAgICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICAgICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICAgICAgICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICAgICAgICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgICAgICAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgICAgICAgICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICAgICAgICAgIGhvc3RFbmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVXJsLm5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoVXJsLm5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgICAgICAgICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuICAgICAgICAgICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICAgICAgICAgIHRoaXMucGFyc2VIb3N0KCk7XG4gICAgICAgICAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgICAgICAgICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgICAgICAgICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAgICAgICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgICAgICAgICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuICAgICAgICAgICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgICAgICAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKFVybC5ob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKFVybC5ob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChVcmwuaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gVXJsLmhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgICAgICAgICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgICAgICAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICAgICAgICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG4gICAgICAgICAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgICAgICAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgICAgICAgICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAgICAgICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gICAgICAgIGlmICghVXJsLnVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgICAgICAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IFVybC5hdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhZSA9IFVybC5hdXRvRXNjYXBlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICAgICAgICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICAgICAgICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICAgICAgICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gICAgICAgIGlmIChxbSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXJsLnNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgICAgICAgfVxuICAgICAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcCArIHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gICAgICAgIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG4gKiBBU0NJSS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcbiAqIFVuaWNvZGUgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICogZW1haWwgYWRkcmVzcy5cbiAqL1xuICAgIHRvQVNDSUkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gVXJsLnJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG4gICAgICAgICAgICAgICAgPyAneG4tLScgKyB0aGlzLmVuY29kZShzdHJpbmcpXG4gICAgICAgICAgICAgICAgOiBzdHJpbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpbmdpZnlQcmltaXRpdmUodikge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZW5jb2RlKG9iaiwgc2VwID0gbnVsbCwgZXEgPSBudWxsLCBuYW1lID0gbnVsbCkge1xuICAgICAgICBzZXAgPSBzZXAgfHwgJyYnO1xuICAgICAgICBlcSA9IGVxIHx8ICc9JztcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAgICAgKiBhZGRyZXNzZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuICAgICAqIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG4gICAgICAgICAgICAvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuICAgICAgICAgICAgcmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG4gICAgICAgICAgICBzdHJpbmcgPSBwYXJ0c1sxXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKFVybC5yZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuICAgICAgICB2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBlbmNvZGVkID0gdGhpcy5tYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICAgICAqIGl0ZW0uXG4gICAgICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIG1hcChhcnJheSwgZm4pIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZm9ybWF0KCkge1xuICAgICAgICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgICAgICAgaWYgKGF1dGgpIHtcbiAgICAgICAgICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgICAgICAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICAgICAgICAgIGF1dGggKz0gJ0AnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJywgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJywgaG9zdCA9IGZhbHNlLCBxdWVyeSA9ICcnO1xuICAgICAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgICAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAgICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgICAgICAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5lbmNvZGUodGhpcy5xdWVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcbiAgICAgICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6Jykge1xuICAgICAgICAgICAgcHJvdG9jb2wgKz0gJzonO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAgICAgICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICAgICAgICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAgICAgICAoIXByb3RvY29sIHx8IFVybC5zbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgICAgICAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICBob3N0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgICAgICAgICAgaGFzaCA9ICcjJyArIGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHtcbiAgICAgICAgICAgIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcbiAgICAgICAgfVxuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuICAgIH1cbiAgICA7XG59XG5VcmwucmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZztcblVybC5wb3J0UGF0dGVybiA9IC86WzAtOV0qJC87XG5Vcmwuc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvO1xuVXJsLnByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2k7XG5VcmwucmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS87XG5VcmwuaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxufTtcblVybC5zbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgJ2h0dHAnOiB0cnVlLFxuICAgICdodHRwcyc6IHRydWUsXG4gICAgJ2Z0cCc6IHRydWUsXG4gICAgJ2dvcGhlcic6IHRydWUsXG4gICAgJ2ZpbGUnOiB0cnVlLFxuICAgICdodHRwOic6IHRydWUsXG4gICAgJ2h0dHBzOic6IHRydWUsXG4gICAgJ2Z0cDonOiB0cnVlLFxuICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAnZmlsZTonOiB0cnVlXG59O1xuVXJsLmhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXTtcblVybC5kZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXTtcblVybC51bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KFVybC5kZWxpbXMpO1xuVXJsLmF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdChVcmwudW53aXNlKTtcblVybC5ub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChVcmwuYXV0b0VzY2FwZSk7XG5VcmwuaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLztcblVybC5ob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLztcblVybC5ob3N0bmFtZU1heExlbiA9IDI1NTtcblVybC51bnNhZmVQcm90b2NvbCA9IHtcbiAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxufTtcbmV4cG9ydHMuVXJsID0gVXJsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBVdGlsc1NldHRpbmdzIHtcbiAgICBzdGF0aWMgcmVtb3ZlSXRlbXMoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAoc3RhcnRJZHggPj0gbGVuZ3RoIHx8IHJlbW92ZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ291bnQgPSAoc3RhcnRJZHggKyByZW1vdmVDb3VudCA+IGxlbmd0aCA/IGxlbmd0aCAtIHN0YXJ0SWR4IDogcmVtb3ZlQ291bnQpO1xuICAgICAgICB2YXIgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnQ7XG4gICAgICAgIGZvciAoaSA9IHN0YXJ0SWR4OyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIGFycltpXSA9IGFycltpICsgcmVtb3ZlQ291bnRdO1xuICAgICAgICB9XG4gICAgICAgIGFyci5sZW5ndGggPSBsZW47XG4gICAgfVxuICAgIHN0YXRpYyBkZWVwQ29weVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UsIHByb3BlcnR5T2JqKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gcHJvcGVydHlPYmopIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF0uc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYXJlQXJyYXlzRXF1YWwoYXJyYXkxLCBhcnJheTIpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5MSkgfHwgIUFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheTEubGVuZ3RoICE9PSBhcnJheTIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIHVuc2FmZUV2YWxTdXBwb3J0ZWQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgVXRpbHNTZXR0aW5ncy51bnNhZmVFdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlsc1NldHRpbmdzLnVuc2FmZUV2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uKCdwYXJhbTEnLCAncGFyYW0yJywgJ3BhcmFtMycsICdyZXR1cm4gcGFyYW0xW3BhcmFtMl0gPT09IHBhcmFtMzsnKTtcbiAgICAgICAgICAgIFV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbCA9IGZ1bmMoeyBhOiAnYicgfSwgJ2EnLCAnYicpID09PSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBVdGlsc1NldHRpbmdzLnVuc2FmZUV2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXRpbHNTZXR0aW5ncy51bnNhZmVFdmFsO1xuICAgIH1cbiAgICBzdGF0aWMgaXNXZWJHTFN1cHBvcnRlZCgpIHtcbiAgICAgICAgdmFyIGNvbnRleHRPcHRpb25zID0geyBzdGVuY2lsOiB0cnVlLCBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvd1snV2ViR0xSZW5kZXJpbmdDb250ZXh0J10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBjb250ZXh0T3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gISEoZ2wgJiYgZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKS5zdGVuY2lsKTtcbiAgICAgICAgICAgIGlmIChnbCkge1xuICAgICAgICAgICAgICAgIHZhciBsb3NlQ29udGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvc2VDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvc2VDb250ZXh0Lmxvc2VDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblV0aWxzU2V0dGluZ3MudXRpbCA9IHtcbiAgICBpc1N0cmluZzogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIChhcmcpID09PSAnc3RyaW5nJztcbiAgICB9LFxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgICB9LFxuICAgIGlzTnVsbDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICAgIH0sXG4gICAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLlV0aWxzU2V0dGluZ3MgPSBVdGlsc1NldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQmFzZUltYWdlUmVzb3VyY2VcIik7XG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY2xhc3MgVmlkZW9SZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlXzEuQmFzZUltYWdlUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgLy8gdGhyb3cgXCJzdG9wXCJcbiAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHZhciB2aWRlb0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnd2Via2l0LXBsYXlzaW5saW5lJywgJycpO1xuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAnJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEJhc2VJbWFnZVJlc291cmNlXzEuQmFzZUltYWdlUmVzb3VyY2UuY3Jvc3NPcmlnaW4odmlkZW9FbGVtZW50LCAoc291cmNlWzBdLnNyYyB8fCBzb3VyY2VbMF0pLCBvcHRpb25zLmNyb3Nzb3JpZ2luKTtcbiAgICAgICAgICAgIC8vIGFycmF5IG9mIG9iamVjdHMgb3Igc3RyaW5nc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpO1xuICAgICAgICAgICAgICAgIHZhciByZWYgPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IHJlZi5zcmM7XG4gICAgICAgICAgICAgICAgdmFyIG1pbWUgPSByZWYubWltZTtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMgfHwgc291cmNlW2ldO1xuICAgICAgICAgICAgICAgIHZhciBiYXNlU3JjID0gc3JjLnNwbGl0KCc/Jykuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHZhciBleHQgPSBiYXNlU3JjLnN1YnN0cihiYXNlU3JjLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgICAgICAgICBtaW1lID0gbWltZSB8fCAoXCJ2aWRlby9cIiArIGV4dCk7XG4gICAgICAgICAgICAgICAgc291cmNlRWxlbWVudC5zcmMgPSBzcmM7XG4gICAgICAgICAgICAgICAgc291cmNlRWxlbWVudC50eXBlID0gbWltZTtcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuYXBwZW5kQ2hpbGQoc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdmVycmlkZSB0aGUgc291cmNlXG4gICAgICAgICAgICBzb3VyY2UgPSB2aWRlb0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc291cmNlKTtcbiAgICAgICAgdGhpcy5jYW5VcGxvYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUZQUyA9IG9wdGlvbnMudXBkYXRlRlBTIHx8IDA7XG4gICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIHRydWUgd2lsbCBhdXRvbWF0aWNhbGx5IHBsYXkgdmlkZW9zIHVzZWQgYnkgdGhpcyB0ZXh0dXJlIG9uY2VcbiAgICAgICAgICogdGhleSBhcmUgbG9hZGVkLiBJZiBmYWxzZSwgaXQgd2lsbCBub3QgbW9kaWZ5IHRoZSBwbGF5aW5nIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9QbGF5ID0gb3B0aW9ucy5hdXRvUGxheSAhPT0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9taXNlIHdoZW4gbG9hZGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtQcm9taXNlPHZvaWQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHdoZW4gY29tcGxldGVkIHdpdGggbG9hZC5cbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgLy8gQmluZCBmb3IgbGlzdGVuZXJzXG4gICAgICAgIHRoaXMuX29uQ2FuUGxheSA9IHRoaXMuX29uQ2FuUGxheS5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgdXBkYXRpbmcgb2YgdGhlIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsdGFUaW1lPTBdIC0gdGltZSBkZWx0YSBzaW5jZSBsYXN0IHRpY2tcbiAgICAgKi9cbiAgICB1cGRhdGUoZGVsdGFUaW1lID0gMCkge1xuICAgICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciBpZiB2aWRlbyBoYXMgaGFkIGl0cyBwbGF5YmFja1JhdGUgY2hhbmdlZFxuICAgICAgICAgICAgdmFyIGVsYXBzZWRNUyA9IFRpY2tlcl8xLlRpY2tlci5zaGFyZWQuZWxhcHNlZE1TICogdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlO1xuICAgICAgICAgICAgLy8gdHJhY2UoXCJlbGFwc2VkOiBcIiArIGVsYXBzZWRNUylcbiAgICAgICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gTWF0aC5mbG9vcih0aGlzLl9tc1RvTmV4dFVwZGF0ZSAtIGVsYXBzZWRNUyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZUZQUyB8fCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJhY2UoXCJzdXBlciB1cGRhdGU6IFwiICsgZGVsdGFUaW1lKVxuICAgICAgICAgICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gdGhpcy5fdXBkYXRlRlBTID8gTWF0aC5mbG9vcigxMDAwIC8gdGhpcy5fdXBkYXRlRlBTKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IHByZWxvYWRpbmcgdGhlIHZpZGVvIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICBMb2dnZXJfMS50cmFjZShcImxvYWRpbmcgdmlkZW9cIik7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoKHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9FTk9VR0hfREFUQSB8fCBzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRlVUVVJFX0RBVEEpXG4gICAgICAgICAgICAmJiBzb3VyY2Uud2lkdGggJiYgc291cmNlLmhlaWdodCkge1xuICAgICAgICAgICAgc291cmNlLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncGxheScsIHRoaXMuX29uUGxheVN0YXJ0LmJpbmQodGhpcykpO1xuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCB0aGlzLl9vblBsYXlTdG9wLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAoIXRoaXMuX2lzU291cmNlUmVhZHkoKSkge1xuICAgICAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgICAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2FuUGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMkMS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgc291cmNlLmxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyBwbGF5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHBsYXlpbmcuXG4gICAgICovXG4gICAgX2lzU291cmNlUGxheWluZygpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICByZXR1cm4gKHNvdXJjZS5jdXJyZW50VGltZSA+IDAgJiYgc291cmNlLnBhdXNlZCA9PT0gZmFsc2UgJiYgc291cmNlLmVuZGVkID09PSBmYWxzZSAmJiBzb3VyY2UucmVhZHlTdGF0ZSA+IDIpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyByZWFkeSBmb3IgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiByZWFkeS5cbiAgICAgKi9cbiAgICBfaXNTb3VyY2VSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnJlYWR5U3RhdGUgPT09IDMgfHwgdGhpcy5zb3VyY2UucmVhZHlTdGF0ZSA9PT0gNDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIHVwZGF0ZSBsb29wIHdoZW4gdGhlIHZpZGVvIGlzIHJlYWR5IHRvIHBsYXlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uUGxheVN0YXJ0KCkge1xuICAgICAgICAvLyBKdXN0IGluIGNhc2UgdGhlIHZpZGVvIGhhcyBub3QgcmVjZWl2ZWQgaXRzIGNhbiBwbGF5IGV2ZW4geWV0Li5cbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNhblBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzQXV0b1VwZGF0aW5nICYmIHRoaXMuYXV0b1VwZGF0ZSkge1xuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgcGF1c2UgZXZlbnQgaXMgdHJpZ2dlcmVkLCBzdG9wcyB0aGUgdXBkYXRlIGxvb3BcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uUGxheVN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0F1dG9VcGRhdGluZykge1xuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgbG9hZGVkIGFuZCByZWFkeSB0byBwbGF5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkNhblBsYXkoKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgc291cmNlID0gcmVmLnNvdXJjZTtcbiAgICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLl9vbkNhblBsYXkpO1xuICAgICAgICB2YXIgdmFsaWQgPSB0aGlzLnZhbGlkO1xuICAgICAgICB0aGlzLnJlc2l6ZShzb3VyY2UudmlkZW9XaWR0aCwgc291cmNlLnZpZGVvSGVpZ2h0KTtcbiAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBsb2FkZWQgZGlzcGF0Y2hlcy4uXG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhpcy5fcmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc1NvdXJjZVBsYXlpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5fb25QbGF5U3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmF1dG9QbGF5KSB7XG4gICAgICAgICAgICBzb3VyY2UucGxheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5faXNBdXRvVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5zcmMgPSAnJztcbiAgICAgICAgICAgIHRoaXMuc291cmNlLmxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTaG91bGQgdGhlIGJhc2UgdGV4dHVyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZSBpdHNlbGYsIHNldCB0byB0cnVlIGJ5IGRlZmF1bHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGF1dG9VcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvVXBkYXRlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGF1dG9VcGRhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRvVXBkYXRlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2F1dG9VcGRhdGUgJiYgdGhpcy5faXNBdXRvVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F1dG9VcGRhdGUgJiYgIXRoaXMuX2lzQXV0b1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSG93IG1hbnkgdGltZXMgYSBzZWNvbmQgdG8gdXBkYXRlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIHZpZGVvLiBMZWF2ZSBhdCAwIHRvIHVwZGF0ZSBhdCBldmVyeSByZW5kZXIuXG4gICAgICogQSBsb3dlciBmcHMgY2FuIGhlbHAgcGVyZm9ybWFuY2UsIGFzIHVwZGF0aW5nIHRoZSB0ZXh0dXJlIGF0IDYwZnBzIG9uIGEgMzBwcyB2aWRlbyBtYXkgbm90IGJlIGVmZmljaWVudC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgdXBkYXRlRlBTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlRlBTO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHVwZGF0ZUZQUyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3VwZGF0ZUZQUykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRlBTID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gYXV0by1kZXRlY3QgdGhlIHR5cGUgb2YgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb24gLSBUaGUgZXh0ZW5zaW9uIG9mIHNvdXJjZSwgaWYgc2V0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHZpZGVvIHNvdXJjZVxuICAgICAqL1xuICAgIHN0YXRpYyB0ZXN0KHNvdXJjZSwgZXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiAoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudClcbiAgICAgICAgICAgIHx8IFZpZGVvUmVzb3VyY2UuVFlQRVMuaW5kZXhPZihleHRlbnNpb24pID4gLTE7XG4gICAgfVxuICAgIDtcbn1cblZpZGVvUmVzb3VyY2UuVFlQRVMgPSBbJ21wNCcsICdtNHYnLCAnd2VibScsICdvZ2cnLCAnb2d2JywgJ2gyNjQnLCAnYXZpJywgJ21vdiddO1xuZXhwb3J0cy5WaWRlb1Jlc291cmNlID0gVmlkZW9SZXNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4vUHJvZ3JhbVwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XG5jb25zdCBDYWNoZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9DYWNoZVNldHRpbmdzXCIpO1xuY29uc3QgVW5pZm9ybUdyb3VwXzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtR3JvdXBcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIFdlYkdMU2V0dGluZ3Mge1xuICAgIHN0YXRpYyBjcmVhdGVJbmRpY2VzRm9yUXVhZHMoc2l6ZSkge1xuICAgICAgICB2YXIgdG90YWxJbmRpY2VzID0gc2l6ZSAqIDY7XG4gICAgICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHRvdGFsSW5kaWNlcyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsSW5kaWNlczsgaSArPSA2LCBqICs9IDQpIHtcbiAgICAgICAgICAgIGluZGljZXNbaSArIDBdID0gaiArIDA7XG4gICAgICAgICAgICBpbmRpY2VzW2kgKyAxXSA9IGogKyAxO1xuICAgICAgICAgICAgaW5kaWNlc1tpICsgMl0gPSBqICsgMjtcbiAgICAgICAgICAgIGluZGljZXNbaSArIDNdID0gaiArIDA7XG4gICAgICAgICAgICBpbmRpY2VzW2kgKyA0XSA9IGogKyAyO1xuICAgICAgICAgICAgaW5kaWNlc1tpICsgNV0gPSBqICsgMztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kaWNlcztcbiAgICB9XG4gICAgc3RhdGljIGNhblVwbG9hZFNhbWVCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXIoZ2wsIG1heFRleHR1cmVzKSB7XG4gICAgICAgIGlmICghQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MucHJvZ3JhbUNhY2hlW21heFRleHR1cmVzXSkge1xuICAgICAgICAgICAgdmFyIHNhbXBsZVZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KG1heFRleHR1cmVzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5kZWZhdWx0R3JvdXBDYWNoZVttYXhUZXh0dXJlc10gPSBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sIHRydWUpO1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50U3JjID0gV2ViR0xTZXR0aW5ncy5mcmFnVGVtcGxhdGUkMTtcbiAgICAgICAgICAgIGZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMucmVwbGFjZSgvJWNvdW50JS9naSwgbWF4VGV4dHVyZXMpO1xuICAgICAgICAgICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIFdlYkdMU2V0dGluZ3MuZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpKTtcbiAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLnByb2dyYW1DYWNoZVttYXhUZXh0dXJlc10gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0oV2ViR0xTZXR0aW5ncy52ZXJ0ZXgkMSwgZnJhZ21lbnRTcmMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgIHRpbnQ6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgTWF0cml4XzEuTWF0cml4KCksXG4gICAgICAgICAgICBkZWZhdWx0OiBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5kZWZhdWx0R3JvdXBDYWNoZVttYXhUZXh0dXJlc10sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzaGFkZXIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLnByb2dyYW1DYWNoZVttYXhUZXh0dXJlc10sIHVuaWZvcm1zKTtcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSB7XG4gICAgICAgIHZhciBzcmMgPSAnJztcbiAgICAgICAgc3JjICs9ICdcXG4nO1xuICAgICAgICBzcmMgKz0gJ1xcbic7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3JjICs9ICdcXG5lbHNlICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IG1heFRleHR1cmVzIC0gMSkge1xuICAgICAgICAgICAgICAgIHNyYyArPSBcImlmKHZUZXh0dXJlSWQgPCBcIiArIGkgKyBcIi41KVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3JjICs9ICdcXG57JztcbiAgICAgICAgICAgIHNyYyArPSBcIlxcblxcdGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyc1tcIiArIGkgKyBcIl0sIHZUZXh0dXJlQ29vcmQpO1wiO1xuICAgICAgICAgICAgc3JjICs9ICdcXG59JztcbiAgICAgICAgfVxuICAgICAgICBzcmMgKz0gJ1xcbic7XG4gICAgICAgIHNyYyArPSAnXFxuJztcbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgc3RhdGljIGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIobWF4SWZzLCBnbCkge1xuICAgICAgICBpZiAobWF4SWZzID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgYDBgIHBhc3NlZCB0byBgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcmAnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgICAgIHdoaWxlICh0cnVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50U3JjID0gV2ViR0xTZXR0aW5ncy5mcmFnVGVtcGxhdGUucmVwbGFjZSgvJWZvcmxvb3AlL2dpLCBXZWJHTFNldHRpbmdzLmdlbmVyYXRlSWZUZXN0U3JjKG1heElmcykpO1xuICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgZnJhZ21lbnRTcmMpO1xuICAgICAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgICAgICAgICBtYXhJZnMgPSAobWF4SWZzIC8gMikgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdmFsaWQhXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heElmcztcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlSWZUZXN0U3JjKG1heElmcykge1xuICAgICAgICB2YXIgc3JjID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4SWZzOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHNyYyArPSAnXFxuZWxzZSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCBtYXhJZnMgLSAxKSB7XG4gICAgICAgICAgICAgICAgc3JjICs9IFwiaWYodGVzdCA9PSBcIiArIGkgKyBcIi4wKXt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgc3RhdGljIG1heFJlY29tbWVuZGVkVGV4dHVyZXMobWF4KSB7XG4gICAgICAgIHZhciBhbGxvd01heCA9IHRydWU7XG4gICAgICAgIHZhciBtYXRjaCA9IChuYXZpZ2F0b3IudXNlckFnZW50KS5tYXRjaCgvT1MgKFxcZCspXyhcXGQrKT8vKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICAgIGlmIChtYWpvclZlcnNpb24gPj0gMTEpIHtcbiAgICAgICAgICAgICAgICBhbGxvd01heCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoJDEgPSAobmF2aWdhdG9yLnVzZXJBZ2VudCkubWF0Y2goL0FuZHJvaWRcXHMoWzAtOS5dKikvKTtcbiAgICAgICAgaWYgKG1hdGNoJDEpIHtcbiAgICAgICAgICAgIHZhciBtYWpvclZlcnNpb24kMSA9IHBhcnNlSW50KG1hdGNoJDFbMV0sIDEwKTtcbiAgICAgICAgICAgIGlmIChtYWpvclZlcnNpb24kMSA+PSA3KSB7XG4gICAgICAgICAgICAgICAgYWxsb3dNYXggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxvd01heCA/IG1heCA6IDQ7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRQcmVjaXNpb24oc3JjLCBwcmVjaXNpb24pIHtcbiAgICAgICAgaWYgKHNyYy5zdWJzdHJpbmcoMCwgOSkgIT09ICdwcmVjaXNpb24nKSAvLyAmJiBzcmMuc3Vic3RyaW5nKDAsIDEpICE9PSAnIycpXG4gICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gKFwicHJlY2lzaW9uIFwiICsgcHJlY2lzaW9uICsgXCIgZmxvYXQ7XFxuXCIgKyBzcmMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUZXN0Q29udGV4dCgpIHtcbiAgICAgICAgaWYgKCFXZWJHTFNldHRpbmdzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHZhciBnbDtcbiAgICAgICAgICAgIGlmIChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUFJFRkVSX0VOViA+PSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuRU5WLldFQkdMMikge1xuICAgICAgICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHt9KVxuICAgICAgICAgICAgICAgICAgICB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywge30pO1xuICAgICAgICAgICAgICAgIGlmICghZ2wpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbCwgbm90IGFibGUgdG8gZ2V0IGEgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHNoYWRlciB0ZXN0aW5nLi5cbiAgICAgICAgICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBXZWJHTFNldHRpbmdzLmNvbnRleHQgPSBnbDtcbiAgICAgICAgICAgIHJldHVybiBnbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5jb250ZXh0O1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFZhbHVlKHR5cGUsIHNpemUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlICd2ZWMyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgyICogc2l6ZSk7XG4gICAgICAgICAgICBjYXNlICd2ZWMzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgzICogc2l6ZSk7XG4gICAgICAgICAgICBjYXNlICd2ZWM0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgICAgICAgICBjYXNlICdpbnQnOlxuICAgICAgICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXIyREFycmF5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgJ2l2ZWMyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMiAqIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAnaXZlYzMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgzICogc2l6ZSk7XG4gICAgICAgICAgICBjYXNlICdpdmVjNCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDQgKiBzaXplKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ2J2ZWMyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5ib29sZWFuQXJyYXkoMiAqIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAnYnZlYzMnOlxuICAgICAgICAgICAgICAgIHJldHVybiBXZWJHTFNldHRpbmdzLmJvb2xlYW5BcnJheSgzICogc2l6ZSk7XG4gICAgICAgICAgICBjYXNlICdidmVjNCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFdlYkdMU2V0dGluZ3MuYm9vbGVhbkFycmF5KDQgKiBzaXplKTtcbiAgICAgICAgICAgIGNhc2UgJ21hdDInOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAxXSk7XG4gICAgICAgICAgICBjYXNlICdtYXQzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgMCwgMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgMCwgMCwgMV0pO1xuICAgICAgICAgICAgY2FzZSAnbWF0NCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGJvb2xlYW5BcnJheShzaXplKSB7XG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShzaXplKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHN0YXRpYyBtYXBUeXBlKGdsLCB0eXBlKSB7XG4gICAgICAgIGlmICghV2ViR0xTZXR0aW5ncy5HTF9UQUJMRSkge1xuICAgICAgICAgICAgdmFyIHR5cGVOYW1lcyA9IE9iamVjdC5rZXlzKFdlYkdMU2V0dGluZ3MuR0xfVE9fR0xTTF9UWVBFUyk7XG4gICAgICAgICAgICBXZWJHTFNldHRpbmdzLkdMX1RBQkxFID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciB0biA9IHR5cGVOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBXZWJHTFNldHRpbmdzLkdMX1RBQkxFW2dsW3RuXV0gPSBXZWJHTFNldHRpbmdzLkdMX1RPX0dMU0xfVFlQRVNbdG5dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBXZWJHTFNldHRpbmdzLkdMX1RBQkxFW3R5cGVdO1xuICAgIH1cbiAgICBzdGF0aWMgbWFwU2l6ZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiBXZWJHTFNldHRpbmdzLkdMU0xfVE9fU0laRVt0eXBlXTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlVW5pZm9ybXNTeW5jKGdyb3VwLCB1bmlmb3JtRGF0YSkge1xuICAgICAgICB2YXIgdGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgdmFyIGZ1bmMgPSBcInZhciB2ID0gbnVsbDtcXG4gICAgdmFyIGN2ID0gbnVsbFxcbiAgICB2YXIgZ2wgPSByZW5kZXJlci5nbFwiO1xuICAgICAgICBmb3IgKHZhciBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVuaWZvcm1EYXRhW2ldO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5zeW5jVW5pZm9ybUdyb3VwKHV2LlwiICsgaSArIFwiKTtcXG4gICAgICAgICAgICAgICAgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETyAmJiB1bmlmb3JtRGF0YVtpXS52YWx1ZSAhPT0gMCA8LS0gZG8gd2Ugc3RpbGwgbmVlZCB0aGlzP1xuICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ2Zsb2F0JyAmJiBkYXRhLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgaWYodXYuXCIgKyBpICsgXCIgIT09IHVkLlwiICsgaSArIFwiLnZhbHVlKVxcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgdWQuXCIgKyBpICsgXCIudmFsdWUgPSB1di5cIiArIGkgKyBcIlxcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIHV2LlwiICsgaSArIFwiKVxcbiAgICAgICAgICAgIH1cXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgIGVsc2UgaWYgKChkYXRhLnR5cGUgPT09ICdzYW1wbGVyMkQnIHx8IGRhdGEudHlwZSA9PT0gJ3NhbXBsZXJDdWJlJyB8fCBkYXRhLnR5cGUgPT09ICdzYW1wbGVyMkRBcnJheScpICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5KSBcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgcmVuZGVyZXIudGV4dHVyZS5iaW5kKHV2LlwiICsgaSArIFwiLCBcIiArIHRleHR1cmVDb3VudCArIFwiKTtcXG5cXG4gICAgICAgICAgICBpZih1ZC5cIiArIGkgKyBcIi52YWx1ZSAhPT0gXCIgKyB0ZXh0dXJlQ291bnQgKyBcIilcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgIHVkLlwiICsgaSArIFwiLnZhbHVlID0gXCIgKyB0ZXh0dXJlQ291bnQgKyBcIjtcXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCBcIiArIHRleHR1cmVDb3VudCArIFwiKTtcXG47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxcbiAgICAgICAgICAgIH1cXG5cIjtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ21hdDMnICYmIGRhdGEuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cC51bmlmb3Jtc1tpXS5hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBhbmQgc29tZSBzbWFydCBjYWNoaW5nIGRpcnR5IGlkcyBoZXJlIVxuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIGZhbHNlLCB1di5cIiArIGkgKyBcIi50b0FycmF5KHRydWUpKTtcXG4gICAgICAgICAgICAgICAgXFxuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIGZhbHNlLCB1di5cIiArIGkgKyBcIik7XFxuICAgICAgICAgICAgICAgIFxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3ZlYzInICYmIGRhdGEuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBkbyB3ZSBuZWVkIGJvdGggaGVyZT9cbiAgICAgICAgICAgICAgICAvLyBtYXliZSB3ZSBjYW4gZ2V0IGF3YXkgd2l0aCBvbmx5IHVzaW5nIHBvaW50cz9cbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbaV0ueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC5cIiArIGkgKyBcIi52YWx1ZTtcXG4gICAgICAgICAgICAgICAgdiA9IHV2LlwiICsgaSArIFwiO1xcblxcbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi54IHx8IGN2WzFdICE9PSB2LnkpXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2Lnk7XFxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIHYueCwgdi55KTtcXG4gICAgICAgICAgICAgICAgfVxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBjdiA9IHVkLlwiICsgaSArIFwiLnZhbHVlO1xcbiAgICAgICAgICAgICAgICB2ID0gdXYuXCIgKyBpICsgXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHZbMF07XFxuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHZbMV07XFxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIHZbMF0sIHZbMV0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3ZlYzQnICYmIGRhdGEuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBkbyB3ZSBuZWVkIGJvdGggaGVyZT9cbiAgICAgICAgICAgICAgICAvLyBtYXliZSB3ZSBjYW4gZ2V0IGF3YXkgd2l0aCBvbmx5IHVzaW5nIHBvaW50cz9cbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbaV0ud2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgIGN2ID0gdWQuXCIgKyBpICsgXCIudmFsdWU7XFxuICAgICAgICAgICAgICAgIHYgPSB1di5cIiArIGkgKyBcIjtcXG5cXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYueCB8fCBjdlsxXSAhPT0gdi55IHx8IGN2WzJdICE9PSB2LndpZHRoIHx8IGN2WzNdICE9PSB2LmhlaWdodClcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2Lng7XFxuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYueTtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdi53aWR0aDtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzNdID0gdi5oZWlnaHQ7XFxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtNGYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIHYueCwgdi55LCB2LndpZHRoLCB2LmhlaWdodClcXG4gICAgICAgICAgICAgICAgfVxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBjdiA9IHVkLlwiICsgaSArIFwiLnZhbHVlO1xcbiAgICAgICAgICAgICAgICB2ID0gdXYuXCIgKyBpICsgXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdIHx8IGN2WzNdICE9PSB2WzNdKVxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHZbMF07XFxuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHZbMV07XFxuICAgICAgICAgICAgICAgICAgICBjdlsyXSA9IHZbMl07XFxuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHZbM107XFxuXFxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtNGYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXFxuXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVHlwZSA9IChkYXRhLnNpemUgPT09IDEpID8gV2ViR0xTZXR0aW5ncy5HTFNMX1RPX1NJTkdMRV9TRVRURVJTX0NBQ0hFRCA6IFdlYkdMU2V0dGluZ3MuR0xTTF9UT19BUlJBWV9TRVRURVJTO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRlbXBsYXRlVHlwZVtkYXRhLnR5cGVdLnJlcGxhY2UoJ2xvY2F0aW9uJywgKFwidWQuXCIgKyBpICsgXCIubG9jYXRpb25cIikpO1xuICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICBjdiA9IHVkLlwiICsgaSArIFwiLnZhbHVlO1xcbiAgICAgICAgICAgIHYgPSB1di5cIiArIGkgKyBcIjtcXG4gICAgICAgICAgICBcIiArIHRlbXBsYXRlICsgXCI7XFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbigndWQnLCAndXYnLCAncmVuZGVyZXInLCBmdW5jKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xuICAgIH1cbn1cbldlYkdMU2V0dGluZ3MuVVBMT0FEU19QRVJfRlJBTUUgPSA0O1xuV2ViR0xTZXR0aW5ncy5HTFNMX1RPX0FSUkFZX1NFVFRFUlMgPSB7XG4gICAgZmxvYXQ6IFwiZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdilcIixcbiAgICB2ZWMyOiBcImdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHYpXCIsXG4gICAgdmVjMzogXCJnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2KVwiLFxuICAgIHZlYzQ6ICdnbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2KScsXG4gICAgbWF0NDogJ2dsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXG4gICAgbWF0MzogJ2dsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXG4gICAgbWF0MjogJ2dsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXG4gICAgaW50OiAnZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdiknLFxuICAgIGl2ZWMyOiAnZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdiknLFxuICAgIGl2ZWMzOiAnZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdiknLFxuICAgIGl2ZWM0OiAnZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdiknLFxuICAgIGJvb2w6ICdnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KScsXG4gICAgYnZlYzI6ICdnbC51bmlmb3JtMml2KGxvY2F0aW9uLCB2KScsXG4gICAgYnZlYzM6ICdnbC51bmlmb3JtM2l2KGxvY2F0aW9uLCB2KScsXG4gICAgYnZlYzQ6ICdnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KScsXG4gICAgc2FtcGxlcjJEOiAnZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdiknLFxuICAgIHNhbXBsZXJDdWJlOiAnZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdiknLFxuICAgIHNhbXBsZXIyREFycmF5OiAnZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdiknLFxufTtcbldlYkdMU2V0dGluZ3MuR0xTTF9UT19TSU5HTEVfU0VUVEVSU19DQUNIRUQgPSB7XG4gICAgZmxvYXQ6IFwiXFxuICAgIGlmKGN2ICE9PSB2KVxcbiAgICB7XFxuICAgICAgICBjdi52ID0gdjtcXG4gICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdilcXG4gICAgfVwiLFxuICAgIHZlYzI6IFwiXFxuICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxcbiAgICB7XFxuICAgICAgICBjdlswXSA9IHZbMF07XFxuICAgICAgICBjdlsxXSA9IHZbMV07XFxuICAgICAgICBnbC51bmlmb3JtMmYobG9jYXRpb24sIHZbMF0sIHZbMV0pXFxuICAgIH1cIixcbiAgICB2ZWMzOiBcIlxcbiAgICBpZihjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSlcXG4gICAge1xcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xcbiAgICAgICAgY3ZbMl0gPSB2WzJdO1xcblxcbiAgICAgICAgZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKVxcbiAgICB9XCIsXG4gICAgdmVjNDogJ2dsLnVuaWZvcm00Zihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSknLFxuICAgIGludDogJ2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdiknLFxuICAgIGl2ZWMyOiAnZ2wudW5pZm9ybTJpKGxvY2F0aW9uLCB2WzBdLCB2WzFdKScsXG4gICAgaXZlYzM6ICdnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pJyxcbiAgICBpdmVjNDogJ2dsLnVuaWZvcm00aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSknLFxuICAgIGJvb2w6ICdnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpJyxcbiAgICBidmVjMjogJ2dsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSknLFxuICAgIGJ2ZWMzOiAnZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKScsXG4gICAgYnZlYzQ6ICdnbC51bmlmb3JtNGkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pJyxcbiAgICBtYXQyOiAnZ2wudW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgZmFsc2UsIHYpJyxcbiAgICBtYXQzOiAnZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpJyxcbiAgICBtYXQ0OiAnZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpJyxcbiAgICBzYW1wbGVyMkQ6ICdnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpJyxcbiAgICBzYW1wbGVyQ3ViZTogJ2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdiknLFxuICAgIHNhbXBsZXIyREFycmF5OiAnZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KScsXG59O1xuV2ViR0xTZXR0aW5ncy5HTFNMX1RPX1NJWkUgPSB7XG4gICAgZmxvYXQ6IDEsXG4gICAgdmVjMjogMixcbiAgICB2ZWMzOiAzLFxuICAgIHZlYzQ6IDQsXG4gICAgaW50OiAxLFxuICAgIGl2ZWMyOiAyLFxuICAgIGl2ZWMzOiAzLFxuICAgIGl2ZWM0OiA0LFxuICAgIGJvb2w6IDEsXG4gICAgYnZlYzI6IDIsXG4gICAgYnZlYzM6IDMsXG4gICAgYnZlYzQ6IDQsXG4gICAgbWF0MjogNCxcbiAgICBtYXQzOiA5LFxuICAgIG1hdDQ6IDE2LFxuICAgIHNhbXBsZXIyRDogMSxcbn07XG5XZWJHTFNldHRpbmdzLkdMX1RPX0dMU0xfVFlQRVMgPSB7XG4gICAgRkxPQVQ6ICdmbG9hdCcsXG4gICAgRkxPQVRfVkVDMjogJ3ZlYzInLFxuICAgIEZMT0FUX1ZFQzM6ICd2ZWMzJyxcbiAgICBGTE9BVF9WRUM0OiAndmVjNCcsXG4gICAgSU5UOiAnaW50JyxcbiAgICBJTlRfVkVDMjogJ2l2ZWMyJyxcbiAgICBJTlRfVkVDMzogJ2l2ZWMzJyxcbiAgICBJTlRfVkVDNDogJ2l2ZWM0JyxcbiAgICBCT09MOiAnYm9vbCcsXG4gICAgQk9PTF9WRUMyOiAnYnZlYzInLFxuICAgIEJPT0xfVkVDMzogJ2J2ZWMzJyxcbiAgICBCT09MX1ZFQzQ6ICdidmVjNCcsXG4gICAgRkxPQVRfTUFUMjogJ21hdDInLFxuICAgIEZMT0FUX01BVDM6ICdtYXQzJyxcbiAgICBGTE9BVF9NQVQ0OiAnbWF0NCcsXG4gICAgU0FNUExFUl8yRDogJ3NhbXBsZXIyRCcsXG4gICAgU0FNUExFUl9DVUJFOiAnc2FtcGxlckN1YmUnLFxuICAgIFNBTVBMRVJfMkRfQVJSQVk6ICdzYW1wbGVyMkRBcnJheScsXG59O1xuV2ViR0xTZXR0aW5ncy5HTF9UQUJMRSA9IG51bGw7XG5XZWJHTFNldHRpbmdzLmNvbnRleHQgPSBudWxsO1xuV2ViR0xTZXR0aW5ncy5QUkVDSVNJT05fRlJBR01FTlQgPSAnaGlnaHAnO1xuV2ViR0xTZXR0aW5ncy5QUkVDSVNJT05fVkVSVEVYID0gJ2hpZ2hwJztcbldlYkdMU2V0dGluZ3MuZnJhZ1RlbXBsYXRlID0gW1xuICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICd2b2lkIG1haW4odm9pZCl7JyxcbiAgICAnZmxvYXQgdGVzdCA9IDAuMTsnLFxuICAgICclZm9ybG9vcCUnLFxuICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7JyxcbiAgICAnfSdcbl0uam9pbignXFxuJyk7XG5XZWJHTFNldHRpbmdzLnZlcnRleCQxID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxyXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcclxcbmF0dHJpYnV0ZSBmbG9hdCBhVGV4dHVyZUlkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIHZlYzQgdGludDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcbnZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcbiAgICB2VGV4dHVyZUlkID0gYVRleHR1cmVJZDtcXHJcXG4gICAgdkNvbG9yID0gYUNvbG9yICogdGludDtcXHJcXG59XFxyXFxuXCI7XG5XZWJHTFNldHRpbmdzLmZyYWdUZW1wbGF0ZSQxID0gW1xuICAgICd2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDsnLFxuICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXG4gICAgJ3ZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDsnLFxuICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcnNbJWNvdW50JV07JyxcbiAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgJ3ZlYzQgY29sb3I7JyxcbiAgICAnJWZvcmxvb3AlJyxcbiAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiB2Q29sb3I7JyxcbiAgICAnfSdcbl0uam9pbignXFxuJyk7XG5XZWJHTFNldHRpbmdzLk1JUE1BUF9URVhUVVJFUyA9IDE7XG5XZWJHTFNldHRpbmdzLldSQVBfTU9ERSA9IDMzMDcxO1xuV2ViR0xTZXR0aW5ncy5UQVJHRVRTID0ge1xuICAgIFRFWFRVUkVfMkQ6IDM1NTMsXG4gICAgVEVYVFVSRV9DVUJFX01BUDogMzQwNjcsXG4gICAgVEVYVFVSRV8yRF9BUlJBWTogMzU4NjYsXG4gICAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YOiAzNDA2OSxcbiAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1g6IDM0MDcwLFxuICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWTogMzQwNzEsXG4gICAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZOiAzNDA3MixcbiAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1o6IDM0MDczLFxuICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWjogMzQwNzQsXG59O1xuV2ViR0xTZXR0aW5ncy5GT1JNQVRTID0ge1xuICAgIFJHQkE6IDY0MDgsXG4gICAgUkdCOiA2NDA3LFxuICAgIEFMUEhBOiA2NDA2LFxuICAgIExVTUlOQU5DRTogNjQwOSxcbiAgICBMVU1JTkFOQ0VfQUxQSEE6IDY0MTAsXG4gICAgREVQVEhfQ09NUE9ORU5UOiA2NDAyLFxuICAgIERFUFRIX1NURU5DSUw6IDM0MDQxLFxufTtcbldlYkdMU2V0dGluZ3MuVFlQRVMgPSB7XG4gICAgVU5TSUdORURfQllURTogNTEyMSxcbiAgICBVTlNJR05FRF9TSE9SVDogNTEyMyxcbiAgICBVTlNJR05FRF9TSE9SVF81XzZfNTogMzM2MzUsXG4gICAgVU5TSUdORURfU0hPUlRfNF80XzRfNDogMzI4MTksXG4gICAgVU5TSUdORURfU0hPUlRfNV81XzVfMTogMzI4MjAsXG4gICAgRkxPQVQ6IDUxMjYsXG4gICAgSEFMRl9GTE9BVDogMzYxOTMsXG59O1xuV2ViR0xTZXR0aW5ncy5NSVBNQVBfTU9ERVMgPSB7XG4gICAgT0ZGOiAwLFxuICAgIFBPVzI6IDEsXG4gICAgT046IDIsXG59O1xuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUyA9IHtcbiAgICBMSU5FQVI6IDEsXG4gICAgTkVBUkVTVDogMCxcbn07XG5XZWJHTFNldHRpbmdzLldSQVBfTU9ERVMgPSB7XG4gICAgQ0xBTVA6IDMzMDcxLFxuICAgIFJFUEVBVDogMTA0OTcsXG4gICAgTUlSUk9SRURfUkVQRUFUOiAzMzY0OCxcbn07XG5XZWJHTFNldHRpbmdzLmRlZmF1bHRCdWZmZXJPcHRpb25zID0ge1xuICAgIHNjYWxlTW9kZTogV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5ORUFSRVNULFxuICAgIGZvcm1hdDogV2ViR0xTZXR0aW5ncy5GT1JNQVRTLlJHQkEsXG4gICAgcHJlbXVsdGlwbHlBbHBoYTogZmFsc2UsXG59O1xuV2ViR0xTZXR0aW5ncy5DQU5fVVBMT0FEX1NBTUVfQlVGRkVSID0gV2ViR0xTZXR0aW5ncy5jYW5VcGxvYWRTYW1lQnVmZmVyKCk7XG5XZWJHTFNldHRpbmdzLlNQUklURV9NQVhfVEVYVFVSRVMgPSBXZWJHTFNldHRpbmdzLm1heFJlY29tbWVuZGVkVGV4dHVyZXMoMzIpO1xuZXhwb3J0cy5XZWJHTFNldHRpbmdzID0gV2ViR0xTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgWE1MUGFyc2VyIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcodmFsdWUsIFwidGV4dC94bWxcIik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5YTUxQYXJzZXIgPSBYTUxQYXJzZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIHNldHRpbmdzIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gICAgICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gICAgICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcbiAgICAgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcbiAgICAgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICAgICAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG4gICAgICovXG4gICAgc3RhdGljIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuICAgICAgICAvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuICAgICAgICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbiAgICAgICAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgc3RhdGljIGVycm9yKHR5cGUpIHtcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcihzZXR0aW5ncy5lcnJvcnNbdHlwZV0pO1xuICAgIH1cbiAgICAvKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gKi9cbiAgICBzdGF0aWMgZW5jb2RlKGlucHV0KSB7XG4gICAgICAgIHZhciBuLCBkZWx0YSwgaGFuZGxlZENQQ291bnQsIGJhc2ljTGVuZ3RoLCBiaWFzLCBqLCBtLCBxLCBrLCB0LCBjdXJyZW50VmFsdWUsIG91dHB1dCA9IFtdLCBcbiAgICAgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cbiAgICAgICAgaW5wdXRMZW5ndGgsIFxuICAgICAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cbiAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLCBiYXNlTWludXNULCBxTWludXNUO1xuICAgICAgICAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG4gICAgICAgIGlucHV0ID0gc2V0dGluZ3MudWNzMmRlY29kZShpbnB1dCk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBsZW5ndGhcbiAgICAgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG4gICAgICAgIG4gPSBzZXR0aW5ncy5pbml0aWFsTjtcbiAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICBiaWFzID0gc2V0dGluZ3MuaW5pdGlhbEJpYXM7XG4gICAgICAgIC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzZXR0aW5ncy5zdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICAgIC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuICAgICAgICAvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG4gICAgICAgIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuICAgICAgICBpZiAoYmFzaWNMZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHNldHRpbmdzLmRlbGltaXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFpbiBlbmNvZGluZyBsb29wOlxuICAgICAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gbGFyZ2VyIG9uZTpcbiAgICAgICAgICAgIGZvciAobSA9IHNldHRpbmdzLm1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG4gICAgICAgICAgICAvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuICAgICAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuICAgICAgICAgICAgaWYgKG0gLSBuID4gc2V0dGluZ3MuZmxvb3IoKHNldHRpbmdzLm1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5lcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgICAgICAgICBuID0gbTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IHNldHRpbmdzLm1heEludCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5lcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocSA9IGRlbHRhLCBrID0gc2V0dGluZ3MuYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IHNldHRpbmdzLmJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBrIDw9IGJpYXMgPyBzZXR0aW5ncy50TWluIDogKGsgPj0gYmlhcyArIHNldHRpbmdzLnRNYXggPyBzZXR0aW5ncy50TWF4IDogayAtIGJpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPCB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlTWludXNUID0gc2V0dGluZ3MuYmFzZSAtIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzZXR0aW5ncy5zdHJpbmdGcm9tQ2hhckNvZGUoc2V0dGluZ3MuZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBzZXR0aW5ncy5mbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2V0dGluZ3Muc3RyaW5nRnJvbUNoYXJDb2RlKHNldHRpbmdzLmRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuICAgICAgICAgICAgICAgICAgICBiaWFzID0gc2V0dGluZ3MuYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICsraGFuZGxlZENQQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytkZWx0YTtcbiAgICAgICAgICAgICsrbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cbiogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuKiBAcHJpdmF0ZVxuKi9cbiAgICBzdGF0aWMgYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG4gICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgZGVsdGEgPSBmaXJzdFRpbWUgPyBzZXR0aW5ncy5mbG9vcihkZWx0YSAvIHNldHRpbmdzLmRhbXApIDogZGVsdGEgPj4gMTtcbiAgICAgICAgZGVsdGEgKz0gc2V0dGluZ3MuZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuICAgICAgICBmb3IgKCAvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBzZXR0aW5ncy5iYXNlTWludXNUTWluICogc2V0dGluZ3MudE1heCA+PiAxOyBrICs9IHNldHRpbmdzLmJhc2UpIHtcbiAgICAgICAgICAgIGRlbHRhID0gc2V0dGluZ3MuZmxvb3IoZGVsdGEgLyBzZXR0aW5ncy5iYXNlTWludXNUTWluKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGluZ3MuZmxvb3IoayArIChzZXR0aW5ncy5iYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNldHRpbmdzLnNrZXcpKTtcbiAgICB9XG4gICAgLyoqXG4qIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiogbWF0Y2hpbmcgVVRGLTE2LlxuKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4qIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4qIEBuYW1lIGRlY29kZVxuKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4qL1xuICAgIHN0YXRpYyB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gW10sIGNvdW50ZXIgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLCB2YWx1ZSwgZXh0cmE7XG4gICAgICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICogVHlwZWRlZiBmb3IgZGVjb21wb3NlRGF0YVVyaSByZXR1cm4gb2JqZWN0LlxuICpcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBEZWNvbXBvc2VkRGF0YVVyaVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lZGlhVHlwZSBNZWRpYSB0eXBlLCBlZy4gYGltYWdlYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN1YlR5cGUgU3ViIHR5cGUsIGVnLiBgcG5nYFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVuY29kaW5nIERhdGEgZW5jb2RpbmcsIGVnLiBgYmFzZTY0YFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRhdGEgVGhlIGFjdHVhbCBkYXRhXG4gKi9cbiAgICAvKipcbiAgICAgKiBTcGxpdCBhIGRhdGEgVVJJIGludG8gY29tcG9uZW50cy4gUmV0dXJucyB1bmRlZmluZWQgaWZcbiAgICAgKiBwYXJhbWV0ZXIgYGRhdGFVcmlgIGlzIG5vdCBhIHZhbGlkIGRhdGEgVVJJLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiAgICAgKiBAZnVuY3Rpb24gZGVjb21wb3NlRGF0YVVyaVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVXJpIC0gdGhlIGRhdGEgVVJJIHRvIGNoZWNrXG4gICAgICogQHJldHVybiB7UElYSS51dGlscy5EZWNvbXBvc2VkRGF0YVVyaXx1bmRlZmluZWR9IFRoZSBkZWNvbXBvc2VkIGRhdGEgdXJpIG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIHN0YXRpYyBkZWNvbXBvc2VEYXRhVXJpKGRhdGFVcmkpIHtcbiAgICAgICAgdmFyIGRhdGFVcmlNYXRjaCA9IHNldHRpbmdzLkRBVEFfVVJJLmV4ZWMoZGF0YVVyaSk7XG4gICAgICAgIGlmIChkYXRhVXJpTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBkYXRhVXJpTWF0Y2hbMV0gPyBkYXRhVXJpTWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzdWJUeXBlOiBkYXRhVXJpTWF0Y2hbMl0gPyBkYXRhVXJpTWF0Y2hbMl0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjaGFyc2V0OiBkYXRhVXJpTWF0Y2hbM10gPyBkYXRhVXJpTWF0Y2hbM10udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogZGF0YVVyaU1hdGNoWzRdID8gZGF0YVVyaU1hdGNoWzRdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVVyaU1hdGNoWzVdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogVGFyZ2V0IGZyYW1lcyBwZXIgbWlsbGlzZWNvbmQuXG4gKlxuICogQHN0YXRpY1xuICogQG5hbWUgVEFSR0VUX0ZQTVNcbiAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgMC4wNlxuICovXG5zZXR0aW5ncy5UQVJHRVRfRlBNUyA9IDAuMDY7XG4vKipcbiAqIERlZmF1bHQgZmlsdGVyIHJlc29sdXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG5hbWUgRklMVEVSX1JFU09MVVRJT05cbiAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgMVxuICovXG5zZXR0aW5ncy5GSUxURVJfUkVTT0xVVElPTiA9IDE7XG4vLyBUT0RPOiBtYXliZSBjaGFuZ2UgdG8gU1BSSVRFLkJBVENIX1NJWkU6IDIwMDBcbi8vIFRPRE86IG1heWJlIGFkZCBQQVJUSUNMRS5CQVRDSF9TSVpFOiAxNTAwMFxuLyoqXG4gKiBUaGUgZGVmYXVsdCBzcHJpdGUgYmF0Y2ggc2l6ZS5cbiAqXG4gKiBUaGUgZGVmYXVsdCBhaW1zIHRvIGJhbGFuY2UgZGVza3RvcCBhbmQgbW9iaWxlIGRldmljZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG5hbWUgU1BSSVRFX0JBVENIX1NJWkVcbiAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgNDA5NlxuICovXG5zZXR0aW5ncy5TUFJJVEVfQkFUQ0hfU0laRSA9IDQwOTY7XG4vKipcbiAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1vZGUuXG4gKlxuICogQHN0YXRpY1xuICogQG5hbWUgR0NfTU9ERVxuICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAqIEB0eXBlIHtQSVhJLkdDX01PREVTfVxuICogQGRlZmF1bHQgUElYSS5HQ19NT0RFUy5BVVRPXG4gKi9cbnNldHRpbmdzLkdDX01PREUgPSAwO1xuLyoqXG4gKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtYXggaWRsZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbmFtZSBHQ19NQVhfSURMRVxuICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdCAzNjAwXG4gKi9cbnNldHRpbmdzLkdDX01BWF9JRExFID0gNjAgKiA2MDtcbi8qKlxuICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbWF4aW11bSBjaGVjayBjb3VudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbmFtZSBHQ19NQVhfQ0hFQ0tfQ09VTlRcbiAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgNjAwXG4gKi9cbnNldHRpbmdzLkdDX01BWF9DSEVDS19DT1VOVCA9IDYwICogMTA7XG4vKipcbiogVGhlIGdjIG1vZGVzIHRoYXQgYXJlIHN1cHBvcnRlZCBieSBwaXhpLlxuKlxuKiBUaGUge0BsaW5rIFBJWEkuc2V0dGluZ3MuR0NfTU9ERX0gR2FyYmFnZSBDb2xsZWN0aW9uIG1vZGUgZm9yIFBpeGlKUyB0ZXh0dXJlcyBpcyBBVVRPXG4qIElmIHNldCB0byBHQ19NT0RFLCB0aGUgcmVuZGVyZXIgd2lsbCBvY2Nhc2lvbmFsbHkgY2hlY2sgdGV4dHVyZXMgdXNhZ2UuIElmIHRoZXkgYXJlIG5vdFxuKiB1c2VkIGZvciBhIHNwZWNpZmllZCBwZXJpb2Qgb2YgdGltZSB0aGV5IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBHUFUuIFRoZXkgd2lsbCBvZiBjb3Vyc2VcbiogYmUgdXBsb2FkZWQgYWdhaW4gd2hlbiB0aGV5IGFyZSByZXF1aXJlZC4gVGhpcyBpcyBhIHNpbGVudCBiZWhpbmQgdGhlIHNjZW5lcyBwcm9jZXNzIHRoYXRcbiogc2hvdWxkIGVuc3VyZSB0aGF0IHRoZSBHUFUgZG9lcyBub3QgIGdldCBmaWxsZWQgdXAuXG4qXG4qIEhhbmR5IGZvciBtb2JpbGUgZGV2aWNlcyFcbiogVGhpcyBwcm9wZXJ0eSBvbmx5IGFmZmVjdHMgV2ViR0wuXG4qXG4qIEBuYW1lIEdDX01PREVTXG4qIEBlbnVtIHtudW1iZXJ9XG4qIEBzdGF0aWNcbiogQG1lbWJlcm9mIFBJWElcbiogQHByb3BlcnR5IHtudW1iZXJ9IEFVVE8gLSBHYXJiYWdlIGNvbGxlY3Rpb24gd2lsbCBoYXBwZW4gcGVyaW9kaWNhbGx5IGF1dG9tYXRpY2FsbHlcbiogQHByb3BlcnR5IHtudW1iZXJ9IE1BTlVBTCAtIEdhcmJhZ2UgY29sbGVjdGlvbiB3aWxsIG5lZWQgdG8gYmUgY2FsbGVkIG1hbnVhbGx5XG4qL1xuc2V0dGluZ3MuR0NfTU9ERVMgPSB7XG4gICAgQVVUTzogMCxcbiAgICBNQU5VQUw6IDEsXG59O1xuLyoqXG4gKiBDb25zdGFudHMgdGhhdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiBzaGFkZXJzLlxuICpcbiAqIEBuYW1lIFBSRUNJU0lPTlxuICogQG1lbWJlcm9mIFBJWElcbiAqIEBzdGF0aWNcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAY29uc3RhbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBMT1c9J2xvd3AnXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTUVESVVNPSdtZWRpdW1wJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IEhJR0g9J2hpZ2hwJ1xuICovXG5zZXR0aW5ncy5QUkVDSVNJT04gPSB7XG4gICAgTE9XOiAnbG93cCcsXG4gICAgTUVESVVNOiAnbWVkaXVtcCcsXG4gICAgSElHSDogJ2hpZ2hwJyxcbn07XG4vKipcbiogR3JhcGhpY3MgY3VydmVzIHJlc29sdXRpb24gc2V0dGluZ3MuIElmIGBhZGFwdGl2ZWAgZmxhZyBpcyBzZXQgdG8gYHRydWVgLFxuKiB0aGUgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBjdXJ2ZSdzIGxlbmd0aCB0byBlbnN1cmUgYmV0dGVyIHZpc3VhbCBxdWFsaXR5LlxuKiBBZGFwdGl2ZSBkcmF3IHdvcmtzIHdpdGggYGJlemllckN1cnZlVG9gIGFuZCBgcXVhZHJhdGljQ3VydmVUb2AuXG4qXG4qIEBzdGF0aWNcbiogQGNvbnN0YW50XG4qIEBtZW1iZXJvZiBQSVhJXG4qIEBuYW1lIEdSQVBISUNTX0NVUlZFU1xuKiBAdHlwZSB7b2JqZWN0fVxuKiBAcHJvcGVydHkge2Jvb2xlYW59IGFkYXB0aXZlPWZhbHNlIC0gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSByZXNvbHV0aW9uIHNob3VsZCBiZSBhZGFwdGl2ZVxuKiBAcHJvcGVydHkge251bWJlcn0gbWF4TGVuZ3RoPTEwIC0gbWF4aW1hbCBsZW5ndGggb2YgYSBzaW5nbGUgc2VnbWVudCBvZiB0aGUgY3VydmUgKGlmIGFkYXB0aXZlID0gZmFsc2UsIGlnbm9yZWQpXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5TZWdtZW50cz04IC0gbWluaW1hbCBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdGhlIGN1cnZlIChpZiBhZGFwdGl2ZSA9IGZhbHNlLCBpZ25vcmVkKVxuKiBAcHJvcGVydHkge251bWJlcn0gbWF4U2VnbWVudHM9MjA0OCAtIG1heGltYWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoZSBjdXJ2ZSAoaWYgYWRhcHRpdmUgPSBmYWxzZSwgaWdub3JlZClcbiovXG5zZXR0aW5ncy5HUkFQSElDU19DVVJWRVMgPSB7XG4gICAgYWRhcHRpdmU6IHRydWUsXG4gICAgbWF4TGVuZ3RoOiAxMCxcbiAgICBtaW5TZWdtZW50czogOCxcbiAgICBtYXhTZWdtZW50czogMjA0OCxcbiAgICBfc2VnbWVudHNDb3VudDogZnVuY3Rpb24gX3NlZ21lbnRzQ291bnQobGVuZ3RoLCBkZWZhdWx0U2VnbWVudHMgPSBudWxsKSB7XG4gICAgICAgIGlmIChkZWZhdWx0U2VnbWVudHMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZGVmYXVsdFNlZ21lbnRzID0gMjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmFkYXB0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNlZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBNYXRoLmNlaWwobGVuZ3RoIC8gdGhpcy5tYXhMZW5ndGgpO1xuICAgICAgICBpZiAocmVzdWx0IDwgdGhpcy5taW5TZWdtZW50cykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5taW5TZWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgPiB0aGlzLm1heFNlZ21lbnRzKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heFNlZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbn07XG5zZXR0aW5ncy5pbml0aWFsTiA9IDEyODtcbnNldHRpbmdzLmluaXRpYWxCaWFzID0gNzI7XG5zZXR0aW5ncy5zdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuc2V0dGluZ3MuZGVsaW1pdGVyID0gJy0nO1xuc2V0dGluZ3MubWF4SW50ID0gMjE0NzQ4MzY0NztcbnNldHRpbmdzLmZsb29yID0gTWF0aC5mbG9vcjtcbnNldHRpbmdzLmJhc2UgPSAzNjtcbnNldHRpbmdzLnRNaW4gPSAxO1xuc2V0dGluZ3MudE1heCA9IDI2O1xuLyoqIEVycm9yIG1lc3NhZ2VzICovXG5zZXR0aW5ncy5lcnJvcnMgPSB7XG4gICAgJ292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcbiAgICAnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuICAgICdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG59O1xuc2V0dGluZ3MuZGFtcCA9IDcwMDtcbnNldHRpbmdzLmJhc2VNaW51c1RNaW4gPSBzZXR0aW5ncy5iYXNlIC0gc2V0dGluZ3MudE1pbjtcbnNldHRpbmdzLnNrZXcgPSAzODtcbi8qKlxuKiBSZWdleHAgZm9yIGRhdGEgVVJJLlxuKiBCYXNlZCBvbjoge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWdpbmd3aW5kL2RhdGEtdXJpLXJlZ2V4fVxuKlxuKiBAc3RhdGljXG4qIEBjb25zdGFudCB7UmVnRXhwfHN0cmluZ30gREFUQV9VUklcbiogQG1lbWJlcm9mIFBJWElcbiogQGV4YW1wbGUgZGF0YTppbWFnZS9wbmc7YmFzZTY0XG4qL1xuc2V0dGluZ3MuREFUQV9VUkkgPSAvXlxccypkYXRhOig/OihbXFx3LV0rKVxcLyhbXFx3Ky4tXSspKT8oPzo7Y2hhcnNldD0oW1xcdy1dKykpPyg/OjsoYmFzZTY0KSk/LCguKikvaTtcbi8vIFRha2VuIGZyb20gdGhlIGJpdC10d2lkZGxlIHBhY2thZ2VcbnNldHRpbmdzLmRlZmF1bHRWZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcbn1cIjtcbnNldHRpbmdzLmRlZmF1bHRGaWx0ZXJWZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xcclxcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXHJcXG5cXHJcXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXHJcXG57XFxyXFxuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcclxcblxcclxcbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxufVxcclxcblxcclxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXHJcXG57XFxyXFxuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXHJcXG4gICAgdlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xcclxcbn1cXHJcXG5cIjtcbmV4cG9ydHMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiJdLCJzb3VyY2VSb290IjoiIn0=